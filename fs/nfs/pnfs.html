<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › pnfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>pnfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  pNFS functions to call and manage layout drivers.</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2002 [year of first publication]</span>
<span class="cm"> *  The Regents of the University of Michigan</span>
<span class="cm"> *  All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> *  Dean Hildebrand &lt;dhildebz@umich.edu&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Permission is granted to use, copy, create derivative works, and</span>
<span class="cm"> *  redistribute this software and such derivative works for any purpose,</span>
<span class="cm"> *  so long as the name of the University of Michigan is not used in</span>
<span class="cm"> *  any advertising or publicity pertaining to the use or distribution</span>
<span class="cm"> *  of this software without specific, written prior authorization. If</span>
<span class="cm"> *  the above copyright notice or any other identification of the</span>
<span class="cm"> *  University of Michigan is included in any copy of any portion of</span>
<span class="cm"> *  this software, then the disclaimer below must also be included.</span>
<span class="cm"> *</span>
<span class="cm"> *  This software is provided as is, without representation or warranty</span>
<span class="cm"> *  of any kind either express or implied, including without limitation</span>
<span class="cm"> *  the implied warranties of merchantability, fitness for a particular</span>
<span class="cm"> *  purpose, or noninfringement.  The Regents of the University of</span>
<span class="cm"> *  Michigan shall not be liable for any damages, including special,</span>
<span class="cm"> *  indirect, incidental, or consequential damages, with respect to any</span>
<span class="cm"> *  claim arising out of or in connection with the use of the software,</span>
<span class="cm"> *  even if it has been or is hereafter advised of the possibility of</span>
<span class="cm"> *  such damages.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_page.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>
<span class="cp">#include &quot;pnfs.h&quot;</span>
<span class="cp">#include &quot;iostat.h&quot;</span>

<span class="cp">#define NFSDBG_FACILITY		NFSDBG_PNFS</span>

<span class="cm">/* Locking:</span>
<span class="cm"> *</span>
<span class="cm"> * pnfs_spinlock:</span>
<span class="cm"> *      protects pnfs_modules_tbl.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">pnfs_spinlock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * pnfs_modules_tbl holds all pnfs modules</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">pnfs_modules_tbl</span><span class="p">);</span>

<span class="cm">/* Return the registered pnfs layout driver module matching given id */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span>
<span class="nf">find_pnfs_driver_locked</span><span class="p">(</span><span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnfs_modules_tbl</span><span class="p">,</span> <span class="n">pnfs_tblid</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="n">id</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">local</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: Searching for id %u, found %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">local</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">local</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span>
<span class="nf">find_pnfs_driver</span><span class="p">(</span><span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">local</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnfs_spinlock</span><span class="p">);</span>
	<span class="n">local</span> <span class="o">=</span> <span class="n">find_pnfs_driver_locked</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">local</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">try_module_get</span><span class="p">(</span><span class="n">local</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: Could not grab reference on module</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">local</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnfs_spinlock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">local</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">unset_pnfs_layoutdriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">nfss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">clear_layoutdriver</span><span class="p">)</span>
			<span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">clear_layoutdriver</span><span class="p">(</span><span class="n">nfss</span><span class="p">);</span>
		<span class="cm">/* Decrement the MDS count. Purge the deviceid cache if zero */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfss</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_mds_count</span><span class="p">))</span>
			<span class="n">nfs4_deviceid_purge_client</span><span class="p">(</span><span class="n">nfss</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to set the server&#39;s pnfs module to the pnfs layout type specified by id.</span>
<span class="cm"> * Currently only one pNFS layout driver per filesystem is supported.</span>
<span class="cm"> *</span>
<span class="cm"> * @id layout type. Zero (illegal layout type) indicates pNFS not in use.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">set_pnfs_layoutdriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">mntfh</span><span class="p">,</span>
		      <span class="n">u32</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">ld_type</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_no_driver</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_exchange_flags</span> <span class="o">&amp;</span>
		 <span class="p">(</span><span class="n">EXCHGID4_FLAG_USE_NON_PNFS</span> <span class="o">|</span> <span class="n">EXCHGID4_FLAG_USE_PNFS_MDS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NFS: %s: id %u cl_exchange_flags 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_exchange_flags</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_driver</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ld_type</span> <span class="o">=</span> <span class="n">find_pnfs_driver</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ld_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">request_module</span><span class="p">(</span><span class="s">&quot;%s-%u&quot;</span><span class="p">,</span> <span class="n">LAYOUT_NFSV4_1_MODULE_PREFIX</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="n">ld_type</span> <span class="o">=</span> <span class="n">find_pnfs_driver</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ld_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: No pNFS module found for %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_no_driver</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span> <span class="o">=</span> <span class="n">ld_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">set_layoutdriver</span>
	    <span class="o">&amp;&amp;</span> <span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">set_layoutdriver</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">mntfh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NFS: %s: Error initializing pNFS layout &quot;</span>
			<span class="s">&quot;driver %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
		<span class="n">module_put</span><span class="p">(</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">owner</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_driver</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Bump the MDS count */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_mds_count</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: pNFS module for %u set</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">out_no_driver:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: Using NFSv4 I/O</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pnfs_register_layoutdriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">ld_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NFS: %s id 0 is reserved</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">alloc_lseg</span> <span class="o">||</span> <span class="o">!</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">free_lseg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NFS: %s Layout driver must provide &quot;</span>
		       <span class="s">&quot;alloc_lseg and free_lseg.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnfs_spinlock</span><span class="p">);</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">find_pnfs_driver_locked</span><span class="p">(</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">pnfs_tblid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pnfs_modules_tbl</span><span class="p">);</span>
		<span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s Registering id:%u name:%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">,</span>
			<span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NFS: %s Module with id %d already loaded!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnfs_spinlock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_register_layoutdriver</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">pnfs_unregister_layoutdriver</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">ld_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s Deregistering id:%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnfs_spinlock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ld_type</span><span class="o">-&gt;</span><span class="n">pnfs_tblid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pnfs_spinlock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_unregister_layoutdriver</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * pNFS client layout cache</span>
<span class="cm"> */</span>

<span class="cm">/* Need to hold i_lock if caller does not already hold reference */</span>
<span class="kt">void</span>
<span class="nf">get_layout_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span>
<span class="nf">pnfs_alloc_layout_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">alloc_layout_hdr</span> <span class="o">?</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">alloc_layout_hdr</span><span class="p">(</span><span class="n">ino</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">)</span> <span class="o">:</span>
		<span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span><span class="p">),</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pnfs_free_layout_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="p">;</span>
	<span class="n">put_rpccred</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_lc_cred</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">alloc_layout_hdr</span> <span class="o">?</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">free_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="o">:</span> <span class="n">kfree</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">destroy_layout_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: freeing layout cache %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">lo</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_layouts</span><span class="p">));</span>
	<span class="n">NFS_I</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">layout</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pnfs_free_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">put_layout_hdr_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_refcount</span><span class="p">))</span>
		<span class="n">destroy_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">put_layout_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_refcount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">destroy_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">init_lseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_lc_list</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_LSEG_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">);</span>
	<span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_lseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">;</span>

	<span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">free_lseg</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
	<span class="cm">/* Matched by get_layout_hdr in pnfs_insert_layout */</span>
	<span class="n">put_layout_hdr</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">put_lseg_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LSEG_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">));</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_DESTROYED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">);</span>
		<span class="cm">/* Matched by initial refcount set in alloc_init_layout_hdr */</span>
		<span class="n">put_layout_hdr_locked</span><span class="p">(</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rpc_wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">roc_rpcwaitq</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">put_lseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lseg</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: lseg %p ref %d valid %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">lseg</span><span class="p">,</span>
		<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_refcount</span><span class="p">),</span>
		<span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LSEG_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">));</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_refcount</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">free_me</span><span class="p">);</span>

		<span class="n">put_lseg_common</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">free_me</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">pnfs_free_lseg_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">free_me</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">put_lseg</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span>
<span class="nf">end_offset</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">?</span> <span class="n">end</span> <span class="o">:</span> <span class="n">NFS4_MAX_UINT64</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* last octet in a range */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span>
<span class="nf">last_byte_offset</span><span class="p">(</span><span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">?</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">:</span> <span class="n">NFS4_MAX_UINT64</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is l2 fully contained in l1?</span>
<span class="cm"> *   start1                             end1</span>
<span class="cm"> *   [----------------------------------)</span>
<span class="cm"> *           start2           end2</span>
<span class="cm"> *           [----------------)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lo_seg_contained</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">l2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">end_offset</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">end_offset</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">start1</span> <span class="o">&lt;=</span> <span class="n">start2</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">end1</span> <span class="o">&gt;=</span> <span class="n">end2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * is l1 and l2 intersecting?</span>
<span class="cm"> *   start1                             end1</span>
<span class="cm"> *   [----------------------------------)</span>
<span class="cm"> *                              start2           end2</span>
<span class="cm"> *                              [----------------)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span>
<span class="nf">lo_seg_intersecting</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">l2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">start1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end1</span> <span class="o">=</span> <span class="n">end_offset</span><span class="p">(</span><span class="n">start1</span><span class="p">,</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">start2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end2</span> <span class="o">=</span> <span class="n">end_offset</span><span class="p">(</span><span class="n">start2</span><span class="p">,</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">end1</span> <span class="o">==</span> <span class="n">NFS4_MAX_UINT64</span> <span class="o">||</span> <span class="n">end1</span> <span class="o">&gt;</span> <span class="n">start2</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">end2</span> <span class="o">==</span> <span class="n">NFS4_MAX_UINT64</span> <span class="o">||</span> <span class="n">end2</span> <span class="o">&gt;</span> <span class="n">start1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">should_free_lseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">lseg_range</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">recall_range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">recall_range</span><span class="o">-&gt;</span><span class="n">iomode</span> <span class="o">==</span> <span class="n">IOMODE_ANY</span> <span class="o">||</span>
		<span class="n">lseg_range</span><span class="o">-&gt;</span><span class="n">iomode</span> <span class="o">==</span> <span class="n">recall_range</span><span class="o">-&gt;</span><span class="n">iomode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	       <span class="n">lo_seg_intersecting</span><span class="p">(</span><span class="n">lseg_range</span><span class="p">,</span> <span class="n">recall_range</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Returns 1 if lseg is removed from list, 0 otherwise */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">mark_lseg_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NFS_LSEG_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Remove the reference keeping the lseg in the</span>
<span class="cm">		 * list.  It will now be removed when all</span>
<span class="cm">		 * outstanding io is finished.</span>
<span class="cm">		 */</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: lseg %p ref %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">lseg</span><span class="p">,</span>
			<span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_refcount</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_refcount</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">put_lseg_common</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">,</span> <span class="n">tmp_list</span><span class="p">);</span>
			<span class="n">rv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rv</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Returns count of number of matching invalid lsegs remaining in list</span>
<span class="cm"> * after call.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">mark_matching_lsegs_invalid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp_list</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">recall_range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">invalid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">removed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s:Begin lo %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">lo</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Reset MDS Threshold I/O counters */</span>
		<span class="n">NFS_I</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">write_io</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">NFS_I</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">read_io</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_DESTROYED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">))</span>
			<span class="n">put_layout_hdr_locked</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">,</span> <span class="n">pls_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">recall_range</span> <span class="o">||</span>
		    <span class="n">should_free_lseg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">,</span> <span class="n">recall_range</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: freeing lseg %p iomode %d &quot;</span>
				<span class="s">&quot;offset %llu length %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">lseg</span><span class="p">,</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">iomode</span><span class="p">,</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
				<span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
			<span class="n">invalid</span><span class="o">++</span><span class="p">;</span>
			<span class="n">removed</span> <span class="o">+=</span> <span class="n">mark_lseg_invalid</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">tmp_list</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s:Return %i</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">invalid</span> <span class="o">-</span> <span class="n">removed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">invalid</span> <span class="o">-</span> <span class="n">removed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* note free_me must contain lsegs from a single layout_hdr */</span>
<span class="kt">void</span>
<span class="nf">pnfs_free_lseg_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">free_me</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">free_me</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lo</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">free_me</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_layout_segment</span><span class="p">,</span>
			      <span class="n">pls_list</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_DESTROYED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">;</span>

		<span class="n">clp</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_layouts</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">free_me</span><span class="p">,</span> <span class="n">pls_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">);</span>
		<span class="n">free_lseg</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">pnfs_destroy_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_block_lgets</span><span class="o">++</span><span class="p">;</span> <span class="cm">/* permanently block new LAYOUTGETs */</span>
		<span class="n">mark_matching_lsegs_invalid</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">pnfs_free_lseg_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_destroy_layout</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Called by the state manger to remove all layouts established under an</span>
<span class="cm"> * expired lease.</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">pnfs_destroy_all_layouts</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>

	<span class="n">nfs4_deviceid_mark_client_invalid</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>
	<span class="n">nfs4_deviceid_purge_client</span><span class="p">(</span><span class="n">clp</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_superblocks</span><span class="p">,</span> <span class="n">client_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">layouts</span><span class="p">))</span>
			<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">layouts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">lo</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_layout_hdr</span><span class="p">,</span>
				<span class="n">plh_layouts</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s freeing layout for inode %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_layouts</span><span class="p">);</span>
		<span class="n">pnfs_destroy_layout</span><span class="p">(</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* update lo-&gt;plh_stateid with new if is more recent */</span>
<span class="kt">void</span>
<span class="nf">pnfs_set_layout_stateid</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="k">const</span> <span class="n">nfs4_stateid</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
			<span class="n">bool</span> <span class="n">update_barrier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">oldseq</span><span class="p">,</span> <span class="n">newseq</span><span class="p">;</span>

	<span class="n">oldseq</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_stateid</span><span class="p">.</span><span class="n">seqid</span><span class="p">);</span>
	<span class="n">newseq</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">seqid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">newseq</span> <span class="o">-</span> <span class="n">oldseq</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs4_stateid_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_stateid</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">update_barrier</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">new_barrier</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">seqid</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">new_barrier</span> <span class="o">-</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_barrier</span><span class="p">))</span>
				<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_barrier</span> <span class="o">=</span> <span class="n">new_barrier</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Because of wraparound, we want to keep the barrier</span>
<span class="cm">			 * &quot;close&quot; to the current seqids.  It needs to be</span>
<span class="cm">			 * within 2**31 to count as &quot;behind&quot;, so if it</span>
<span class="cm">			 * gets too near that limit, give us a litle leeway</span>
<span class="cm">			 * and bring it to within 2**30.</span>
<span class="cm">			 * NOTE - and yes, this is all unsigned arithmetic.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">newseq</span> <span class="o">-</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_barrier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">3</span> <span class="o">&lt;&lt;</span> <span class="mi">29</span><span class="p">)))</span>
				<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_barrier</span> <span class="o">=</span> <span class="n">newseq</span> <span class="o">-</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">30</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* lget is set to 1 if called from inside send_layoutget call chain */</span>
<span class="k">static</span> <span class="n">bool</span>
<span class="nf">pnfs_layoutgets_blocked</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span> <span class="n">nfs4_stateid</span> <span class="o">*</span><span class="n">stateid</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">lget</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">stateid</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_barrier</span> <span class="o">-</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">stateid</span><span class="o">-&gt;</span><span class="n">seqid</span><span class="p">))</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_block_lgets</span> <span class="o">||</span>
		<span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_DESTROYED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_BULK_RECALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">)</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		 <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_outstanding</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">lget</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pnfs_choose_layoutget_stateid</span><span class="p">(</span><span class="n">nfs4_stateid</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nfs4_state</span> <span class="o">*</span><span class="n">open_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;--&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pnfs_layoutgets_blocked</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">open_state</span><span class="o">-&gt;</span><span class="n">seqlock</span><span class="p">);</span>
			<span class="n">nfs4_stateid_copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">open_state</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">open_state</span><span class="o">-&gt;</span><span class="n">seqlock</span><span class="p">,</span> <span class="n">seq</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">nfs4_stateid_copy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_stateid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;&lt;-- %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">* Get layout from server.</span>
<span class="cm">*    for now, assume that whole file layouts are requested.</span>
<span class="cm">*    arg-&gt;offset: 0</span>
<span class="cm">*    arg-&gt;length: all ones</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span>
<span class="nf">send_layoutget</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span>
	   <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs4_layoutget</span> <span class="o">*</span><span class="n">lgp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">max_resp_sz</span><span class="p">,</span> <span class="n">max_pages</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;--&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ctx</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">lgp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lgp</span><span class="p">),</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lgp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* allocate pages for xdr post processing */</span>
	<span class="n">max_resp_sz</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="o">-&gt;</span><span class="n">cl_session</span><span class="o">-&gt;</span><span class="n">fc_attrs</span><span class="p">.</span><span class="n">max_resp_sz</span><span class="p">;</span>
	<span class="n">max_pages</span> <span class="o">=</span> <span class="n">nfs_page_array_len</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_resp_sz</span><span class="p">);</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">max_pages</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_err_free</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">gfp_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">out_err_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">minlength</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">minlength</span> <span class="o">&gt;</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
		<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">minlength</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">maxcount</span> <span class="o">=</span> <span class="n">PNFS_LAYOUT_MAXSIZE</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">range</span> <span class="o">=</span> <span class="o">*</span><span class="n">range</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">ctx</span> <span class="o">=</span> <span class="n">get_nfs_open_context</span><span class="p">(</span><span class="n">ctx</span><span class="p">);</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">layout</span><span class="p">.</span><span class="n">pglen</span> <span class="o">=</span> <span class="n">max_pages</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">lsegpp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="p">;</span>
	<span class="n">lgp</span><span class="o">-&gt;</span><span class="n">gfp_flags</span> <span class="o">=</span> <span class="n">gfp_flags</span><span class="p">;</span>

	<span class="cm">/* Synchronously retrieve layout information from server and</span>
<span class="cm">	 * store in lseg.</span>
<span class="cm">	 */</span>
	<span class="n">nfs4_proc_layoutget</span><span class="p">(</span><span class="n">lgp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lseg</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* remember that LAYOUTGET failed and suspend trying */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">lo_fail_bit</span><span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">iomode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* free xdr pages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">__free_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">lseg</span><span class="p">;</span>

<span class="nl">out_err_free:</span>
	<span class="cm">/* free any allocated xdr pages, lgp as it&#39;s not used */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">max_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">lgp</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Initiates a LAYOUTRETURN(FILE) */</span>
<span class="kt">int</span>
<span class="nf">_pnfs_return_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs4_layoutreturn</span> <span class="o">*</span><span class="n">lrp</span><span class="p">;</span>
	<span class="n">nfs4_stateid</span> <span class="n">stateid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;--&gt; %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lo</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: no layout to return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">stateid</span> <span class="o">=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_stateid</span><span class="p">;</span>
	<span class="cm">/* Reference matched in nfs4_layoutreturn_release */</span>
	<span class="n">get_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">mark_matching_lsegs_invalid</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_block_lgets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">pnfs_free_lseg_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>

	<span class="n">lrp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lrp</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">lrp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_RW_FAILED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_RO_FAILED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">);</span>
		<span class="n">put_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lrp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">stateid</span> <span class="o">=</span> <span class="n">stateid</span><span class="p">;</span>
	<span class="n">lrp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">layout_type</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
	<span class="n">lrp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">lrp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">layout</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">lrp</span><span class="o">-&gt;</span><span class="n">clp</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">;</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs4_proc_layoutreturn</span><span class="p">(</span><span class="n">lrp</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;&lt;-- %s status: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">_pnfs_return_layout</span><span class="p">);</span>

<span class="n">bool</span> <span class="nf">pnfs_roc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lo</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_ROC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_BULK_RECALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_nolayout</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">,</span> <span class="n">pls_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LSEG_ROC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mark_lseg_invalid</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>
			<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nolayout</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_block_lgets</span><span class="o">++</span><span class="p">;</span>
	<span class="n">get_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span> <span class="cm">/* matched in pnfs_roc_release */</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">pnfs_free_lseg_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_list</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="nl">out_nolayout:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pnfs_roc_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_block_lgets</span><span class="o">--</span><span class="p">;</span>
	<span class="n">put_layout_hdr_locked</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pnfs_roc_set_barrier</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span> <span class="n">u32</span> <span class="n">barrier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">barrier</span> <span class="o">-</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_barrier</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_barrier</span> <span class="o">=</span> <span class="n">barrier</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">bool</span> <span class="nf">pnfs_roc_drain</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">barrier</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">,</span> <span class="n">pls_list</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LSEG_ROC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">current_seqid</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_stateid</span><span class="p">.</span><span class="n">seqid</span><span class="p">);</span>

		<span class="cm">/* Since close does not return a layout stateid for use as</span>
<span class="cm">		 * a barrier, we choose the worst-case barrier.</span>
<span class="cm">		 */</span>
		<span class="o">*</span><span class="n">barrier</span> <span class="o">=</span> <span class="n">current_seqid</span> <span class="o">+</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_outstanding</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Compare two layout segments for sorting into layout cache.</span>
<span class="cm"> * We want to preferentially return RW over RO layouts, so ensure those</span>
<span class="cm"> * are seen first.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">s64</span>
<span class="nf">cmp_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span>
	   <span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">l2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s64</span> <span class="n">d</span><span class="p">;</span>

	<span class="cm">/* high offset &gt; low offset */</span>
	<span class="n">d</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d</span><span class="p">;</span>

	<span class="cm">/* short length &gt; long length */</span>
	<span class="n">d</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">d</span><span class="p">;</span>

	<span class="cm">/* read &gt; read/write */</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">iomode</span> <span class="o">==</span> <span class="n">IOMODE_READ</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">l2</span><span class="o">-&gt;</span><span class="n">iomode</span> <span class="o">==</span> <span class="n">IOMODE_READ</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pnfs_insert_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lp</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s:Begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">,</span> <span class="n">pls_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmp_layout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lp</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: inserted lseg %p &quot;</span>
			<span class="s">&quot;iomode %d offset %llu length %llu before &quot;</span>
			<span class="s">&quot;lp %p iomode %d offset %llu length %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">lseg</span><span class="p">,</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">iomode</span><span class="p">,</span>
			<span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">length</span><span class="p">,</span>
			<span class="n">lp</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">iomode</span><span class="p">,</span> <span class="n">lp</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
			<span class="n">lp</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: inserted lseg %p &quot;</span>
		<span class="s">&quot;iomode %d offset %llu length %llu at tail</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">lseg</span><span class="p">,</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">iomode</span><span class="p">,</span>
		<span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">get_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s:Return</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span>
<span class="nf">alloc_init_layout_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		      <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>

	<span class="n">lo</span> <span class="o">=</span> <span class="n">pnfs_alloc_layout_hdr</span><span class="p">(</span><span class="n">ino</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lo</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_refcount</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_layouts</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_bulk_recall</span><span class="p">);</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_lc_cred</span> <span class="o">=</span> <span class="n">get_rpccred</span><span class="p">(</span><span class="n">ctx</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">owner</span><span class="o">-&gt;</span><span class="n">so_cred</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lo</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span>
<span class="nf">pnfs_find_alloc_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		       <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s Begin ino=%p layout=%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">);</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_DESTROYED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">alloc_init_layout_hdr</span><span class="p">(</span><span class="n">ino</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>	<span class="cm">/* Won the race? */</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pnfs_free_layout_hdr</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * iomode matching rules:</span>
<span class="cm"> * iomode	lseg	match</span>
<span class="cm"> * -----	-----	-----</span>
<span class="cm"> * ANY		READ	true</span>
<span class="cm"> * ANY		RW	true</span>
<span class="cm"> * RW		READ	false</span>
<span class="cm"> * RW		RW	true</span>
<span class="cm"> * READ		READ	true</span>
<span class="cm"> * READ		RW	true</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">is_matching_lseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">ls_range</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="n">range1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">iomode</span> <span class="o">==</span> <span class="n">IOMODE_RW</span> <span class="o">&amp;&amp;</span>
	     <span class="n">ls_range</span><span class="o">-&gt;</span><span class="n">iomode</span> <span class="o">!=</span> <span class="n">IOMODE_RW</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">lo_seg_intersecting</span><span class="p">(</span><span class="n">ls_range</span><span class="p">,</span> <span class="n">range</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* range1 covers only the first byte in the range */</span>
	<span class="n">range1</span> <span class="o">=</span> <span class="o">*</span><span class="n">range</span><span class="p">;</span>
	<span class="n">range1</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">lo_seg_contained</span><span class="p">(</span><span class="n">ls_range</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lookup range in layout</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span>
<span class="nf">pnfs_find_lseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="o">*</span><span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s:Begin</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>

	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">,</span> <span class="n">pls_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LSEG_VALID</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">is_matching_lseg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">,</span> <span class="n">range</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">get_lseg</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s:Return lseg %p ref %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ret</span> <span class="o">?</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">pls_refcount</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Use mdsthreshold hints set at each OPEN to determine if I/O should go</span>
<span class="cm"> * to the MDS or over pNFS</span>
<span class="cm"> *</span>
<span class="cm"> * The nfs_inode read_io and write_io fields are cumulative counters reset</span>
<span class="cm"> * when there are no layout segments. Note that in pnfs_update_layout iomode</span>
<span class="cm"> * is set to IOMODE_READ for a READ request, and set to IOMODE_RW for a</span>
<span class="cm"> * WRITE request.</span>
<span class="cm"> *</span>
<span class="cm"> * A return of true means use MDS I/O.</span>
<span class="cm"> *</span>
<span class="cm"> * From rfc 5661:</span>
<span class="cm"> * If a file&#39;s size is smaller than the file size threshold, data accesses</span>
<span class="cm"> * SHOULD be sent to the metadata server.  If an I/O request has a length that</span>
<span class="cm"> * is below the I/O size threshold, the I/O SHOULD be sent to the metadata</span>
<span class="cm"> * server.  If both file size and I/O size are provided, the client SHOULD</span>
<span class="cm"> * reach or exceed  both thresholds before sending its read or write</span>
<span class="cm"> * requests to the data server.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">pnfs_within_mdsthreshold</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iomode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_threshold</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">ctx</span><span class="o">-&gt;</span><span class="n">mdsthreshold</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">fsize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">size</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">size_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">io</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">io_set</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s bm=0x%x rd_sz=%llu wr_sz=%llu rd_io=%llu wr_io=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">bm</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rd_sz</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">wr_sz</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rd_io_sz</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">wr_io_sz</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">iomode</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">IOMODE_READ</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bm</span> <span class="o">&amp;</span> <span class="n">THRESHOLD_RD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s fsize %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">fsize</span><span class="p">);</span>
			<span class="n">size_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fsize</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rd_sz</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bm</span> <span class="o">&amp;</span> <span class="n">THRESHOLD_RD_IO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s nfsi-&gt;read_io %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_io</span><span class="p">);</span>
			<span class="n">io_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">read_io</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">rd_io_sz</span><span class="p">)</span>
				<span class="n">io</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">IOMODE_RW</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bm</span> <span class="o">&amp;</span> <span class="n">THRESHOLD_WR</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s fsize %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">fsize</span><span class="p">);</span>
			<span class="n">size_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fsize</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">wr_sz</span><span class="p">)</span>
				<span class="n">size</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">bm</span> <span class="o">&amp;</span> <span class="n">THRESHOLD_WR_IO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s nfsi-&gt;write_io %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">write_io</span><span class="p">);</span>
			<span class="n">io_set</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">write_io</span> <span class="o">&lt;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">wr_io_sz</span><span class="p">)</span>
				<span class="n">io</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size_set</span> <span class="o">&amp;&amp;</span> <span class="n">io_set</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">io</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">||</span> <span class="n">io</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;&lt;-- %s size %d io %d ret %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">io</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Layout segment is retreived from the server if not cached.</span>
<span class="cm"> * The appropriate layout segment is referenced and returned to the caller.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span>
<span class="nf">pnfs_update_layout</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">nfs_open_context</span> <span class="o">*</span><span class="n">ctx</span><span class="p">,</span>
		   <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span>
		   <span class="n">u64</span> <span class="n">count</span><span class="p">,</span>
		   <span class="k">enum</span> <span class="n">pnfs_iomode</span> <span class="n">iomode</span><span class="p">,</span>
		   <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_range</span> <span class="n">arg</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">iomode</span> <span class="o">=</span> <span class="n">iomode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span><span class="p">,</span>
		<span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">count</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="n">pg_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nfs_client</span> <span class="o">*</span><span class="n">clp</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">nfs_client</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pnfs_enabled_sb</span><span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">)))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnfs_within_mdsthreshold</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">iomode</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lo</span> <span class="o">=</span> <span class="n">pnfs_find_alloc_layout</span><span class="p">(</span><span class="n">ino</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s ERROR: can&#39;t get pnfs_layout_hdr</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do we even need to bother with this? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_BULK_RECALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s matches recall, use MDS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if LAYOUTGET already failed once we don&#39;t try again */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">lo_fail_bit</span><span class="p">(</span><span class="n">iomode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* Check to see if the layout for the given range already exists */</span>
	<span class="n">lseg</span> <span class="o">=</span> <span class="n">pnfs_find_lseg</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lseg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnfs_layoutgets_blocked</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_outstanding</span><span class="p">);</span>

	<span class="n">get_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">))</span>
		<span class="n">first</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* The lo must be on the clp list if there is any</span>
<span class="cm">		 * chance of a CB_LAYOUTRECALL(FILE) coming in.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_layouts</span><span class="p">));</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_layouts</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">layouts</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">pg_offset</span> <span class="o">=</span> <span class="n">arg</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pg_offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">arg</span><span class="p">.</span><span class="n">offset</span> <span class="o">-=</span> <span class="n">pg_offset</span><span class="p">;</span>
		<span class="n">arg</span><span class="p">.</span><span class="n">length</span> <span class="o">+=</span> <span class="n">pg_offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">length</span> <span class="o">!=</span> <span class="n">NFS4_MAX_UINT64</span><span class="p">)</span>
		<span class="n">arg</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">PAGE_CACHE_ALIGN</span><span class="p">(</span><span class="n">arg</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>

	<span class="n">lseg</span> <span class="o">=</span> <span class="n">send_layoutget</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">arg</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lseg</span> <span class="o">&amp;&amp;</span> <span class="n">first</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_layouts</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">clp</span><span class="o">-&gt;</span><span class="n">cl_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_outstanding</span><span class="p">);</span>
	<span class="n">put_layout_hdr</span><span class="p">(</span><span class="n">lo</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s end, state 0x%lx lseg %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span> <span class="o">?</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_flags</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">lseg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lseg</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_update_layout</span><span class="p">);</span>

<span class="kt">int</span>
<span class="nf">pnfs_layout_process</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_layoutget</span> <span class="o">*</span><span class="n">lgp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_hdr</span> <span class="o">*</span><span class="n">lo</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">lgp</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">layout</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs4_layoutget_res</span> <span class="o">*</span><span class="n">res</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lgp</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ino</span> <span class="o">=</span> <span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Inject layout blob into I/O device driver */</span>
	<span class="n">lseg</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">alloc_lseg</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">res</span><span class="p">,</span> <span class="n">lgp</span><span class="o">-&gt;</span><span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lseg</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">lseg</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lseg</span><span class="p">)</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">status</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: Could not allocate layout: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_BULK_RECALL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s forget reply due to recall</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_forget_reply</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pnfs_layoutgets_blocked</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s forget reply due to state</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_forget_reply</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">init_lseg</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">lseg</span><span class="p">);</span>
	<span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span> <span class="o">=</span> <span class="n">res</span><span class="o">-&gt;</span><span class="n">range</span><span class="p">;</span>
	<span class="o">*</span><span class="n">lgp</span><span class="o">-&gt;</span><span class="n">lsegpp</span> <span class="o">=</span> <span class="n">get_lseg</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
	<span class="n">pnfs_insert_layout</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="n">lseg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">return_on_close</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_LSEG_ROC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NFS_LAYOUT_ROC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lo</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Done processing layoutget. Set the layout stateid */</span>
	<span class="n">pnfs_set_layout_stateid</span><span class="p">(</span><span class="n">lo</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">res</span><span class="o">-&gt;</span><span class="n">stateid</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>

<span class="nl">out_forget_reply:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ino</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span> <span class="o">=</span> <span class="n">lo</span><span class="p">;</span>
	<span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">ino</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">free_lseg</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">pnfs_generic_pg_init_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">pgio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_page</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_offset</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_pgbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_pageio_reset_read_mds</span><span class="p">(</span><span class="n">pgio</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="n">pnfs_update_layout</span><span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_inode</span><span class="p">,</span>
					   <span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_context</span><span class="p">,</span>
					   <span class="n">req_offset</span><span class="p">(</span><span class="n">req</span><span class="p">),</span>
					   <span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_bytes</span><span class="p">,</span>
					   <span class="n">IOMODE_READ</span><span class="p">,</span>
					   <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="cm">/* If no lseg, fall back to read through mds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">nfs_pageio_reset_read_mds</span><span class="p">(</span><span class="n">pgio</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_generic_pg_init_read</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">pnfs_generic_pg_init_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">pgio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_page</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_offset</span> <span class="o">!=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_pgbase</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nfs_pageio_reset_write_mds</span><span class="p">(</span><span class="n">pgio</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="n">pnfs_update_layout</span><span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_inode</span><span class="p">,</span>
					   <span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_context</span><span class="p">,</span>
					   <span class="n">req_offset</span><span class="p">(</span><span class="n">req</span><span class="p">),</span>
					   <span class="n">req</span><span class="o">-&gt;</span><span class="n">wb_bytes</span><span class="p">,</span>
					   <span class="n">IOMODE_RW</span><span class="p">,</span>
					   <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="cm">/* If no lseg, fall back to write through mds */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">nfs_pageio_reset_write_mds</span><span class="p">(</span><span class="n">pgio</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_generic_pg_init_write</span><span class="p">);</span>

<span class="n">bool</span>
<span class="nf">pnfs_pageio_init_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">pgio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_pgio_completion_ops</span> <span class="o">*</span><span class="n">compl_ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">nfs_pageio_init</span><span class="p">(</span><span class="n">pgio</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">pg_read_ops</span><span class="p">,</span> <span class="n">compl_ops</span><span class="p">,</span>
			<span class="n">server</span><span class="o">-&gt;</span><span class="n">rsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span>
<span class="nf">pnfs_pageio_init_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">pgio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">ioflags</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_pgio_completion_ops</span> <span class="o">*</span><span class="n">compl_ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">pnfs_layoutdriver_type</span> <span class="o">*</span><span class="n">ld</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ld</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">nfs_pageio_init</span><span class="p">(</span><span class="n">pgio</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ld</span><span class="o">-&gt;</span><span class="n">pg_write_ops</span><span class="p">,</span> <span class="n">compl_ops</span><span class="p">,</span>
			<span class="n">server</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">,</span> <span class="n">ioflags</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span>
<span class="nf">pnfs_generic_pg_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">pgio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_page</span> <span class="o">*</span><span class="n">prev</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">nfs_page</span> <span class="o">*</span><span class="n">req</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nfs_generic_pg_test</span><span class="p">(</span><span class="n">pgio</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">req</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Test if a nfs_page is fully contained in the pnfs_layout_range.</span>
<span class="cm">	 * Note that this test makes several assumptions:</span>
<span class="cm">	 * - that the previous nfs_page in the struct nfs_pageio_descriptor</span>
<span class="cm">	 *   is known to lie within the range.</span>
<span class="cm">	 *   - that the nfs_page being tested is known to be contiguous with the</span>
<span class="cm">	 *   previous nfs_page.</span>
<span class="cm">	 *   - Layout ranges are page aligned, so we only have to test the</span>
<span class="cm">	 *   start offset of the request.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Please also note that &#39;end_offset&#39; is actually the offset of the</span>
<span class="cm">	 * first byte that lies outside the pnfs_layout_range. FIXME?</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">req_offset</span><span class="p">(</span><span class="n">req</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_offset</span><span class="p">(</span><span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
					 <span class="n">pgio</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">length</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_generic_pg_test</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pnfs_write_done_resend_to_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_pgio_completion_ops</span> <span class="o">*</span><span class="n">compl_ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="n">pgio</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">failed</span><span class="p">);</span>

	<span class="cm">/* Resend all requests through the MDS */</span>
	<span class="n">nfs_pageio_init_write_mds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgio</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">FLUSH_STABLE</span><span class="p">,</span> <span class="n">compl_ops</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nfs_page</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">nfs_list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

		<span class="n">nfs_list_remove_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_pageio_add_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgio</span><span class="p">,</span> <span class="n">req</span><span class="p">))</span>
			<span class="n">nfs_list_add_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">failed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nfs_pageio_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">failed</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* For some reason our attempt to resend pages. Mark the</span>
<span class="cm">		 * overall send request as having failed, and let</span>
<span class="cm">		 * nfs_writeback_release_full deal with the error.</span>
<span class="cm">		 */</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">failed</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_write_done_resend_to_mds</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pnfs_ld_handle_write_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_write_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;pnfs write error = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pnfs_error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
	    <span class="n">PNFS_LAYOUTRET_ON_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">pnfs_return_layout</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_IOHDR_REDO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">.</span><span class="n">tk_status</span> <span class="o">=</span> <span class="n">pnfs_write_done_resend_to_mds</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span>
							<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">completion_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by non rpc-based layout drivers</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pnfs_ld_write_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_write_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pnfs_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pnfs_set_layoutcommit</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mds_ops</span><span class="o">-&gt;</span><span class="n">rpc_call_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pnfs_ld_handle_write_error</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mds_ops</span><span class="o">-&gt;</span><span class="n">rpc_release</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_ld_write_done</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pnfs_write_through_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nfs_write_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_IOHDR_REDO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_list</span><span class="p">);</span>
		<span class="n">nfs_pageio_reset_write_mds</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_recoalesce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfs_writedata_release</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">enum</span> <span class="n">pnfs_try_status</span>
<span class="nf">pnfs_try_to_write_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_write_data</span> <span class="o">*</span><span class="n">wdata</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="n">call_ops</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">pnfs_try_status</span> <span class="n">trypnfs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">nfss</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mds_ops</span> <span class="o">=</span> <span class="n">call_ops</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: Writing ino:%lu %u@%llu (how %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">how</span><span class="p">);</span>
	<span class="n">trypnfs</span> <span class="o">=</span> <span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">write_pagelist</span><span class="p">(</span><span class="n">wdata</span><span class="p">,</span> <span class="n">how</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trypnfs</span> <span class="o">!=</span> <span class="n">PNFS_NOT_ATTEMPTED</span><span class="p">)</span>
		<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_PNFS_WRITE</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s End (trypnfs:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trypnfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">trypnfs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pnfs_do_multiple_writes</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">how</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_write_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="n">call_ops</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_rpc_callops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">pnfs_try_status</span> <span class="n">trypnfs</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_write_data</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">trypnfs</span> <span class="o">=</span> <span class="n">pnfs_try_to_write_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">call_ops</span><span class="p">,</span> <span class="n">lseg</span><span class="p">,</span> <span class="n">how</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trypnfs</span> <span class="o">==</span> <span class="n">PNFS_NOT_ATTEMPTED</span><span class="p">)</span>
			<span class="n">pnfs_write_through_mds</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_lseg</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pnfs_writehdr_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_lseg</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lseg</span><span class="p">);</span>
	<span class="n">nfs_writehdr_free</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pnfs_generic_pg_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_write_header</span> <span class="o">*</span><span class="n">whdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">whdr</span> <span class="o">=</span> <span class="n">nfs_writehdr_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">whdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_completion_ops</span><span class="o">-&gt;</span><span class="n">error_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_list</span><span class="p">);</span>
		<span class="n">put_lseg</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">whdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="n">nfs_pgheader_init</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">pnfs_writehdr_free</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lseg</span> <span class="o">=</span> <span class="n">get_lseg</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs_generic_flush</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_lseg</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pnfs_do_multiple_writes</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rpc_list</span><span class="p">,</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_ioflags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">completion_ops</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_generic_pg_writepages</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">pnfs_read_done_resend_to_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				<span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_pgio_completion_ops</span> <span class="o">*</span><span class="n">compl_ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="n">pgio</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">failed</span><span class="p">);</span>

	<span class="cm">/* Resend all requests through the MDS */</span>
	<span class="n">nfs_pageio_init_read_mds</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgio</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">compl_ops</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nfs_page</span> <span class="o">*</span><span class="n">req</span> <span class="o">=</span> <span class="n">nfs_list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>

		<span class="n">nfs_list_remove_request</span><span class="p">(</span><span class="n">req</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfs_pageio_add_request</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgio</span><span class="p">,</span> <span class="n">req</span><span class="p">))</span>
			<span class="n">nfs_list_add_request</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">failed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nfs_pageio_complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pgio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">failed</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">failed</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_read_done_resend_to_mds</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pnfs_ld_handle_read_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_read_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;pnfs read error = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pnfs_error</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
	    <span class="n">PNFS_LAYOUTRET_ON_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">pnfs_return_layout</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_IOHDR_REDO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">.</span><span class="n">tk_status</span> <span class="o">=</span> <span class="n">pnfs_read_done_resend_to_mds</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span>
							<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">completion_ops</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called by non rpc-based layout drivers</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">pnfs_ld_read_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_read_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pnfs_error</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">__nfs4_read_done_cb</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mds_ops</span><span class="o">-&gt;</span><span class="n">rpc_call_done</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pnfs_ld_handle_read_error</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mds_ops</span><span class="o">-&gt;</span><span class="n">rpc_release</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_ld_read_done</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pnfs_read_through_mds</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nfs_read_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_IOHDR_REDO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_list</span><span class="p">);</span>
		<span class="n">nfs_pageio_reset_read_mds</span><span class="p">(</span><span class="n">desc</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_recoalesce</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nfs_readdata_release</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Call the appropriate parallel I/O subsystem read function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">enum</span> <span class="n">pnfs_try_status</span>
<span class="nf">pnfs_try_to_read_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_read_data</span> <span class="o">*</span><span class="n">rdata</span><span class="p">,</span>
		       <span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="n">call_ops</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">nfss</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">enum</span> <span class="n">pnfs_try_status</span> <span class="n">trypnfs</span><span class="p">;</span>

	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">mds_ops</span> <span class="o">=</span> <span class="n">call_ops</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: Reading ino:%lu %u@%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">count</span><span class="p">,</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">trypnfs</span> <span class="o">=</span> <span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">read_pagelist</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trypnfs</span> <span class="o">!=</span> <span class="n">PNFS_NOT_ATTEMPTED</span><span class="p">)</span>
		<span class="n">nfs_inc_stats</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">NFSIOS_PNFS_READ</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s End (trypnfs:%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">trypnfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">trypnfs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">pnfs_do_multiple_reads</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_read_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_call_ops</span> <span class="o">*</span><span class="n">call_ops</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_rpc_callops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span> <span class="o">=</span> <span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">;</span>

	<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">enum</span> <span class="n">pnfs_try_status</span> <span class="n">trypnfs</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_read_data</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">trypnfs</span> <span class="o">=</span> <span class="n">pnfs_try_to_read_data</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">call_ops</span><span class="p">,</span> <span class="n">lseg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trypnfs</span> <span class="o">==</span> <span class="n">PNFS_NOT_ATTEMPTED</span><span class="p">)</span>
			<span class="n">pnfs_read_through_mds</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">put_lseg</span><span class="p">(</span><span class="n">lseg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">pnfs_readhdr_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">put_lseg</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lseg</span><span class="p">);</span>
	<span class="n">nfs_readhdr_free</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">pnfs_generic_pg_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_pageio_descriptor</span> <span class="o">*</span><span class="n">desc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_read_header</span> <span class="o">*</span><span class="n">rhdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rhdr</span> <span class="o">=</span> <span class="n">nfs_readhdr_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rhdr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_completion_ops</span><span class="o">-&gt;</span><span class="n">error_cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_list</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">put_lseg</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">hdr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rhdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="n">nfs_pgheader_init</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">,</span> <span class="n">pnfs_readhdr_free</span><span class="p">);</span>
	<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lseg</span> <span class="o">=</span> <span class="n">get_lseg</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nfs_generic_pagein</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="n">hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_lseg</span><span class="p">(</span><span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span><span class="p">);</span>
		<span class="n">desc</span><span class="o">-&gt;</span><span class="n">pg_lseg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pnfs_do_multiple_reads</span><span class="p">(</span><span class="n">desc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">rpc_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">refcnt</span><span class="p">))</span>
		<span class="n">hdr</span><span class="o">-&gt;</span><span class="n">completion_ops</span><span class="o">-&gt;</span><span class="n">completion</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_generic_pg_readpages</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * There can be multiple RW segments.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">pnfs_list_write_lseg</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">listp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">lseg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_segs</span><span class="p">,</span> <span class="n">pls_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">iomode</span> <span class="o">==</span> <span class="n">IOMODE_RW</span> <span class="o">&amp;&amp;</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_LSEG_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">))</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_lc_list</span><span class="p">,</span> <span class="n">listp</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">pnfs_set_lo_fail</span><span class="p">(</span><span class="k">struct</span> <span class="n">pnfs_layout_segment</span> <span class="o">*</span><span class="n">lseg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_range</span><span class="p">.</span><span class="n">iomode</span> <span class="o">==</span> <span class="n">IOMODE_RW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s Setting layout IOMODE_RW fail bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">lo_fail_bit</span><span class="p">(</span><span class="n">IOMODE_RW</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s Setting layout IOMODE_READ fail bit</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">lo_fail_bit</span><span class="p">(</span><span class="n">IOMODE_READ</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_layout</span><span class="o">-&gt;</span><span class="n">plh_flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_set_lo_fail</span><span class="p">);</span>

<span class="kt">void</span>
<span class="nf">pnfs_set_layoutcommit</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs_write_data</span> <span class="o">*</span><span class="n">wdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_pgio_header</span> <span class="o">*</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">end_pos</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">mds_offset</span> <span class="o">+</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">.</span><span class="n">count</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">mark_as_dirty</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mark_as_dirty</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: Set layoutcommit for inode %lu &quot;</span><span class="p">,</span>
			<span class="n">__func__</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_LSEG_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lseg</span><span class="o">-&gt;</span><span class="n">pls_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* references matched in nfs4_layoutcommit_release */</span>
		<span class="n">get_lseg</span><span class="p">(</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lseg</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_pos</span> <span class="o">&gt;</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_lwb</span><span class="p">)</span>
		<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_lwb</span> <span class="o">=</span> <span class="n">end_pos</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s: lseg %p end_pos %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">__func__</span><span class="p">,</span> <span class="n">hdr</span><span class="o">-&gt;</span><span class="n">lseg</span><span class="p">,</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_lwb</span><span class="p">);</span>

	<span class="cm">/* if pnfs_layoutcommit_inode() runs between inode locks, the next one</span>
<span class="cm">	 * will be a noop because NFS_INO_LAYOUTCOMMIT will not be set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mark_as_dirty</span><span class="p">)</span>
		<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">pnfs_set_layoutcommit</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">pnfs_cleanup_layoutcommit</span><span class="p">(</span><span class="k">struct</span> <span class="n">nfs4_layoutcommit_data</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs_server</span> <span class="o">*</span><span class="n">nfss</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">cleanup_layoutcommit</span><span class="p">)</span>
		<span class="n">nfss</span><span class="o">-&gt;</span><span class="n">pnfs_curr_ld</span><span class="o">-&gt;</span><span class="n">cleanup_layoutcommit</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * For the LAYOUT4_NFSV4_1_FILES layout type, NFS_DATA_SYNC WRITEs and</span>
<span class="cm"> * NFS_UNSTABLE WRITEs with a COMMIT to data servers must store enough</span>
<span class="cm"> * data to disk to allow the server to recover the data if it crashes.</span>
<span class="cm"> * LAYOUTCOMMIT is only needed when the NFL4_UFLG_COMMIT_THRU_MDS flag</span>
<span class="cm"> * is off, and a COMMIT is sent to a data server, or</span>
<span class="cm"> * if WRITEs to a data server return NFS_DATA_SYNC.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">pnfs_layoutcommit_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">bool</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_layoutcommit_data</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nfs_inode</span> <span class="o">*</span><span class="n">nfsi</span> <span class="o">=</span> <span class="n">NFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">end_pos</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;--&gt; %s inode %lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Note kzalloc ensures data-&gt;res.seq_res.sr_slot == NULL */</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMITTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">status</span> <span class="o">=</span> <span class="n">wait_on_bit_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">NFS_INO_LAYOUTCOMMITTING</span><span class="p">,</span>
					<span class="n">nfs_wait_bit_killable</span><span class="p">,</span> <span class="n">TASK_KILLABLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">lseg_list</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMIT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NFS_INO_LAYOUTCOMMITTING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">NFS_INO_LAYOUTCOMMITTING</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pnfs_list_write_lseg</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">lseg_list</span><span class="p">);</span>

	<span class="n">end_pos</span> <span class="o">=</span> <span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_lwb</span><span class="p">;</span>
	<span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_lwb</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nfs4_stateid_copy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">stateid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_stateid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">cred</span> <span class="o">=</span> <span class="n">get_rpccred</span><span class="p">(</span><span class="n">nfsi</span><span class="o">-&gt;</span><span class="n">layout</span><span class="o">-&gt;</span><span class="n">plh_lc_cred</span><span class="p">);</span>
	<span class="n">nfs_fattr_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">bitmask</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">cache_consistency_bitmask</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">.</span><span class="n">fattr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">args</span><span class="p">.</span><span class="n">lastbytewritten</span> <span class="o">=</span> <span class="n">end_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">res</span><span class="p">.</span><span class="n">server</span> <span class="o">=</span> <span class="n">NFS_SERVER</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">status</span> <span class="o">=</span> <span class="n">nfs4_proc_layoutcommit</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sync</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span><span class="p">)</span>
		<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;&lt;-- %s status %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nfs4_threshold</span> <span class="o">*</span><span class="nf">pnfs_mdsthreshold_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nfs4_threshold</span> <span class="o">*</span><span class="n">thp</span><span class="p">;</span>

	<span class="n">thp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">thp</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">thp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;%s mdsthreshold allocation failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">thp</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
