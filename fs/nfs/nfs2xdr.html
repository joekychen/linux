<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › nfs2xdr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nfs2xdr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/nfs/nfs2xdr.c</span>
<span class="cm"> *</span>
<span class="cm"> * XDR functions to encode/decode NFS RPC arguments and results.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994  Rick Sladkey</span>
<span class="cm"> * Copyright (C) 1996 Olaf Kirch</span>
<span class="cm"> * 04 Aug 1998  Ion Badulescu &lt;ionut@cs.columbia.edu&gt;</span>
<span class="cm"> * 		FIFO&#39;s need special handling in NFSv2</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/param.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/sunrpc/clnt.h&gt;</span>
<span class="cp">#include &lt;linux/nfs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs2.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define NFSDBG_FACILITY		NFSDBG_XDR</span>

<span class="cm">/* Mapping from NFS error code to &quot;errno&quot; error code. */</span>
<span class="cp">#define errno_NFSERR_IO		EIO</span>

<span class="cm">/*</span>
<span class="cm"> * Declare the space requirements for NFS arguments and replies as</span>
<span class="cm"> * number of 32bit-words</span>
<span class="cm"> */</span>
<span class="cp">#define NFS_fhandle_sz		(8)</span>
<span class="cp">#define NFS_sattr_sz		(8)</span>
<span class="cp">#define NFS_filename_sz		(1+(NFS2_MAXNAMLEN&gt;&gt;2))</span>
<span class="cp">#define NFS_path_sz		(1+(NFS2_MAXPATHLEN&gt;&gt;2))</span>
<span class="cp">#define NFS_fattr_sz		(17)</span>
<span class="cp">#define NFS_info_sz		(5)</span>
<span class="cp">#define NFS_entry_sz		(NFS_filename_sz+3)</span>

<span class="cp">#define NFS_diropargs_sz	(NFS_fhandle_sz+NFS_filename_sz)</span>
<span class="cp">#define NFS_removeargs_sz	(NFS_fhandle_sz+NFS_filename_sz)</span>
<span class="cp">#define NFS_sattrargs_sz	(NFS_fhandle_sz+NFS_sattr_sz)</span>
<span class="cp">#define NFS_readlinkargs_sz	(NFS_fhandle_sz)</span>
<span class="cp">#define NFS_readargs_sz		(NFS_fhandle_sz+3)</span>
<span class="cp">#define NFS_writeargs_sz	(NFS_fhandle_sz+4)</span>
<span class="cp">#define NFS_createargs_sz	(NFS_diropargs_sz+NFS_sattr_sz)</span>
<span class="cp">#define NFS_renameargs_sz	(NFS_diropargs_sz+NFS_diropargs_sz)</span>
<span class="cp">#define NFS_linkargs_sz		(NFS_fhandle_sz+NFS_diropargs_sz)</span>
<span class="cp">#define NFS_symlinkargs_sz	(NFS_diropargs_sz+1+NFS_sattr_sz)</span>
<span class="cp">#define NFS_readdirargs_sz	(NFS_fhandle_sz+2)</span>

<span class="cp">#define NFS_attrstat_sz		(1+NFS_fattr_sz)</span>
<span class="cp">#define NFS_diropres_sz		(1+NFS_fhandle_sz+NFS_fattr_sz)</span>
<span class="cp">#define NFS_readlinkres_sz	(2)</span>
<span class="cp">#define NFS_readres_sz		(1+NFS_fattr_sz+1)</span>
<span class="cp">#define NFS_writeres_sz         (NFS_attrstat_sz)</span>
<span class="cp">#define NFS_stat_sz		(1)</span>
<span class="cp">#define NFS_readdirres_sz	(1)</span>
<span class="cp">#define NFS_statfsres_sz	(1+NFS_info_sz)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="k">enum</span> <span class="n">nfs_stat</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * While encoding arguments, set up the reply buffer in advance to</span>
<span class="cm"> * receive reply data directly into the page cache.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">prepare_reply_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
				 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bufsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rpc_auth</span>	<span class="o">*</span><span class="n">auth</span> <span class="o">=</span> <span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_cred</span><span class="o">-&gt;</span><span class="n">cr_auth</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">replen</span><span class="p">;</span>

	<span class="n">replen</span> <span class="o">=</span> <span class="n">RPC_REPHDRSIZE</span> <span class="o">+</span> <span class="n">auth</span><span class="o">-&gt;</span><span class="n">au_rslack</span> <span class="o">+</span> <span class="n">bufsize</span><span class="p">;</span>
	<span class="n">xdr_inline_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">,</span> <span class="n">replen</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle decode buffer overflows out-of-line.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">print_overflow_msg</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">func</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: %s prematurely hit the end of our receive buffer. &quot;</span>
		<span class="s">&quot;Remaining buffer length is %tu words.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">func</span><span class="p">,</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Encode/decode NFSv2 basic data types</span>
<span class="cm"> *</span>
<span class="cm"> * Basic NFSv2 data types are defined in section 2.3 of RFC 1094:</span>
<span class="cm"> * &quot;NFS: Network File System Protocol Specification&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Not all basic data types have their own encoding and decoding</span>
<span class="cm"> * functions.  For run-time efficiency, some data types are encoded</span>
<span class="cm"> * or decoded inline.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> *	typedef opaque	nfsdata&lt;&gt;;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_nfsdata</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_readres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">recvd</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">recvd</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">recvd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cheating</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">xdr_read_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* NFSv2 does not pass EOF flag on the wire. */</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="nl">out_cheating:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: server cheating in read result: &quot;</span>
		<span class="s">&quot;count %u &gt; recvd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">recvd</span><span class="p">);</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">recvd</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *	enum stat {</span>
<span class="cm"> *		NFS_OK = 0,</span>
<span class="cm"> *		NFSERR_PERM = 1,</span>
<span class="cm"> *		NFSERR_NOENT = 2,</span>
<span class="cm"> *		NFSERR_IO = 5,</span>
<span class="cm"> *		NFSERR_NXIO = 6,</span>
<span class="cm"> *		NFSERR_ACCES = 13,</span>
<span class="cm"> *		NFSERR_EXIST = 17,</span>
<span class="cm"> *		NFSERR_NODEV = 19,</span>
<span class="cm"> *		NFSERR_NOTDIR = 20,</span>
<span class="cm"> *		NFSERR_ISDIR = 21,</span>
<span class="cm"> *		NFSERR_FBIG = 27,</span>
<span class="cm"> *		NFSERR_NOSPC = 28,</span>
<span class="cm"> *		NFSERR_ROFS = 30,</span>
<span class="cm"> *		NFSERR_NAMETOOLONG = 63,</span>
<span class="cm"> *		NFSERR_NOTEMPTY = 66,</span>
<span class="cm"> *		NFSERR_DQUOT = 69,</span>
<span class="cm"> *		NFSERR_STALE = 70,</span>
<span class="cm"> *		NFSERR_WFLUSH = 99</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">enum</span> <span class="n">nfs_stat</span> <span class="o">*</span><span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="o">*</span><span class="n">status</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.2.  ftype</span>
<span class="cm"> *</span>
<span class="cm"> *	enum ftype {</span>
<span class="cm"> *		NFNON = 0,</span>
<span class="cm"> *		NFREG = 1,</span>
<span class="cm"> *		NFDIR = 2,</span>
<span class="cm"> *		NFBLK = 3,</span>
<span class="cm"> *		NFCHR = 4,</span>
<span class="cm"> *		NFLNK = 5</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_decode_ftype</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">*</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">NF2FIFO</span><span class="p">))</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">NFBAD</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.3.  fhandle</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef opaque fhandle[FHSIZE];</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_fhandle</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">!=</span> <span class="n">NFS2_FHSIZE</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS2_FHSIZE</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">fh</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">NFS2_FHSIZE</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_fhandle</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS2_FHSIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">fh</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">NFS2_FHSIZE</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">fh</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">NFS2_FHSIZE</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.4.  timeval</span>
<span class="cm"> *</span>
<span class="cm"> *	struct timeval {</span>
<span class="cm"> *		unsigned int seconds;</span>
<span class="cm"> *		unsigned int useconds;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_encode_time</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Passing the invalid value useconds=1000000 is a Sun convention for</span>
<span class="cm"> * &quot;set to current server time&quot;.  It&#39;s needed to make permissions checks</span>
<span class="cm"> * for the &quot;touch&quot; program across v2 mounts to Solaris and Irix servers</span>
<span class="cm"> * work correctly.  See description of sattr in section 6.1 of &quot;NFS</span>
<span class="cm"> * Illustrated&quot; by Brent Callaghan, Addison-Wesley, ISBN 0-201-32750-5.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_encode_current_server_time</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					      <span class="k">const</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="mi">1000000</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_decode_time</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">timep</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">timep</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">)</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.5.  fattr</span>
<span class="cm"> *</span>
<span class="cm"> *	struct fattr {</span>
<span class="cm"> *		ftype		type;</span>
<span class="cm"> *		unsigned int	mode;</span>
<span class="cm"> *		unsigned int	nlink;</span>
<span class="cm"> *		unsigned int	uid;</span>
<span class="cm"> *		unsigned int	gid;</span>
<span class="cm"> *		unsigned int	size;</span>
<span class="cm"> *		unsigned int	blocksize;</span>
<span class="cm"> *		unsigned int	rdev;</span>
<span class="cm"> *		unsigned int	blocks;</span>
<span class="cm"> *		unsigned int	fsid;</span>
<span class="cm"> *		unsigned int	fileid;</span>
<span class="cm"> *		timeval		atime;</span>
<span class="cm"> *		timeval		mtime;</span>
<span class="cm"> *		timeval		ctime;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_fattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">fattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">rdev</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS_fattr_sz</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>

	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">valid</span> <span class="o">|=</span> <span class="n">NFS_ATTR_FATTR_V2</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_ftype</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>

	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">du</span><span class="p">.</span><span class="n">nfs2</span><span class="p">.</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>

	<span class="n">rdev</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">rdev</span> <span class="o">=</span> <span class="n">new_decode_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">NFCHR</span> <span class="o">&amp;&amp;</span> <span class="n">rdev</span> <span class="o">==</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">NFS2_FIFO_DEV</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">S_IFMT</span><span class="p">)</span> <span class="o">|</span> <span class="n">S_IFIFO</span><span class="p">;</span>
		<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">du</span><span class="p">.</span><span class="n">nfs2</span><span class="p">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">.</span><span class="n">major</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">.</span><span class="n">minor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">fileid</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">atime</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_decode_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">mtime</span><span class="p">);</span>
	<span class="n">xdr_decode_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">);</span>
	<span class="n">fattr</span><span class="o">-&gt;</span><span class="n">change_attr</span> <span class="o">=</span> <span class="n">nfs_timespec_to_change_attr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fattr</span><span class="o">-&gt;</span><span class="n">ctime</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.6.  sattr</span>
<span class="cm"> *</span>
<span class="cm"> *	struct sattr {</span>
<span class="cm"> *		unsigned int	mode;</span>
<span class="cm"> *		unsigned int	uid;</span>
<span class="cm"> *		unsigned int	gid;</span>
<span class="cm"> *		unsigned int	size;</span>
<span class="cm"> *		timeval		atime;</span>
<span class="cm"> *		timeval		mtime;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>

<span class="cp">#define NFS2_SATTR_NOT_SET	(0xffffffff)</span>

<span class="k">static</span> <span class="n">__be32</span> <span class="o">*</span><span class="nf">xdr_time_not_set</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NFS2_SATTR_NOT_SET</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NFS2_SATTR_NOT_SET</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_sattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS_sattr_sz</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NFS2_SATTR_NOT_SET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_UID</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_uid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NFS2_SATTR_NOT_SET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_GID</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_gid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NFS2_SATTR_NOT_SET</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">NFS2_SATTR_NOT_SET</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME_SET</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_ATIME</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_encode_current_server_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_atime</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_time_not_set</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME_SET</span><span class="p">)</span>
		<span class="n">xdr_encode_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MTIME</span><span class="p">)</span>
		<span class="n">xdr_encode_current_server_time</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_mtime</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">xdr_time_not_set</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.7.  filename</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef string filename&lt;MAXNAMLEN&gt;;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_filename</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">NFS2_MAXNAMLEN</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">xdr_encode_opaque</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_filename_inline</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="kt">char</span> <span class="o">**</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">&gt;</span> <span class="n">NFS3_MAXNAMLEN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nametoolong</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">;</span>
	<span class="o">*</span><span class="n">length</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_nametoolong:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: returned filename too long: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.8.  path</span>
<span class="cm"> *</span>
<span class="cm"> *	typedef string path&lt;MAXPATHLEN&gt;;</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">NFS2_MAXPATHLEN</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">length</span><span class="p">);</span>
	<span class="n">xdr_write_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">length</span><span class="p">,</span> <span class="n">recvd</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page_len</span> <span class="o">||</span> <span class="n">length</span> <span class="o">&gt;</span> <span class="n">NFS_MAXPATHLEN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_size</span><span class="p">;</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">recvd</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="n">recvd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cheating</span><span class="p">;</span>

	<span class="n">xdr_read_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="n">xdr_terminate_string</span><span class="p">(</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_size:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: returned pathname too long: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
<span class="nl">out_cheating:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: server cheating in pathname result: &quot;</span>
		<span class="s">&quot;length %u &gt; received %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">recvd</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.9.  attrstat</span>
<span class="cm"> *</span>
<span class="cm"> *	union attrstat switch (stat status) {</span>
<span class="cm"> *	case NFS_OK:</span>
<span class="cm"> *		fattr attributes;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_attrstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_stat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fattr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.10.  diropargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct diropargs {</span>
<span class="cm"> *		fhandle  dir;</span>
<span class="cm"> *		filename name;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_diropargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">,</span>
			     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="n">u32</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
	<span class="n">encode_filename</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.3.11.  diropres</span>
<span class="cm"> *</span>
<span class="cm"> *	union diropres switch (stat status) {</span>
<span class="cm"> *	case NFS_OK:</span>
<span class="cm"> *		struct {</span>
<span class="cm"> *			fhandle file;</span>
<span class="cm"> *			fattr   attributes;</span>
<span class="cm"> *		} diropok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_diropok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_diropok</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fattr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_diropres</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_diropok</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_stat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_diropok</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * NFSv2 XDR encode functions</span>
<span class="cm"> *</span>
<span class="cm"> * NFSv2 argument types are defined in section 2.2 of RFC 1094:</span>
<span class="cm"> * &quot;NFS: Network File System Protocol Specification&quot;.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_fhandle</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_fh</span> <span class="o">*</span><span class="n">fh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">fh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.3.  sattrargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct sattrargs {</span>
<span class="cm"> *		fhandle file;</span>
<span class="cm"> *		sattr attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_sattrargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_sattrargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">encode_sattr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_diropargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_diropargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_readlinkargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				      <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_readlinkargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>
	<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pgbase</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">pglen</span><span class="p">,</span> <span class="n">NFS_readlinkres_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.7.  readargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct readargs {</span>
<span class="cm"> *		fhandle file;</span>
<span class="cm"> *		unsigned offset;</span>
<span class="cm"> *		unsigned count;</span>
<span class="cm"> *		unsigned totalcount;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_readargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_readargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_readargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_readargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_readargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pgbase</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">NFS_readres_sz</span><span class="p">);</span>
	<span class="n">req</span><span class="o">-&gt;</span><span class="n">rq_rcv_buf</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XDRBUF_READ</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.9.  writeargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct writeargs {</span>
<span class="cm"> *		fhandle file;</span>
<span class="cm"> *		unsigned beginoffset;</span>
<span class="cm"> *		unsigned offset;</span>
<span class="cm"> *		unsigned totalcount;</span>
<span class="cm"> *		nfsdata data;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_writeargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_writeargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">count</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>

	<span class="cm">/* nfsdata */</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">count</span><span class="p">);</span>
	<span class="n">xdr_write_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pgbase</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_writeargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_writeargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_writeargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">XDRBUF_WRITE</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.10.  createargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct createargs {</span>
<span class="cm"> *		diropargs where;</span>
<span class="cm"> *		sattr attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_createargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_createargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">encode_sattr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_removeargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_removeargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.12.  renameargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct renameargs {</span>
<span class="cm"> *		diropargs from;</span>
<span class="cm"> *		diropargs to;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_renameargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_renameargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">old</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">old_name</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">new_name</span><span class="p">;</span>

	<span class="n">encode_diropargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">old_dir</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">encode_diropargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.13.  linkargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct linkargs {</span>
<span class="cm"> *		fhandle from;</span>
<span class="cm"> *		diropargs to;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_linkargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_linkargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromfh</span><span class="p">);</span>
	<span class="n">encode_diropargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tofh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">toname</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">tolen</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.14.  symlinkargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct symlinkargs {</span>
<span class="cm"> *		diropargs from;</span>
<span class="cm"> *		path to;</span>
<span class="cm"> *		sattr attributes;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_symlinkargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_symlinkargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_diropargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromfh</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromname</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fromlen</span><span class="p">);</span>
	<span class="n">encode_path</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pathlen</span><span class="p">);</span>
	<span class="n">encode_sattr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">sattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.17.  readdirargs</span>
<span class="cm"> *</span>
<span class="cm"> *	struct readdirargs {</span>
<span class="cm"> *		fhandle dir;</span>
<span class="cm"> *		nfscookie cookie;</span>
<span class="cm"> *		unsigned count;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">encode_readdirargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			       <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_readdirargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">encode_fhandle</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">fh</span><span class="p">);</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_reserve_space</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="mi">4</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">);</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nfs2_xdr_enc_readdirargs</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">nfs_readdirargs</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">encode_readdirargs</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="n">prepare_reply_buffer</span><span class="p">(</span><span class="n">req</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">NFS_readdirres_sz</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * NFSv2 XDR decode functions</span>
<span class="cm"> *</span>
<span class="cm"> * NFSv2 result types are defined in section 2.2 of RFC 1094:</span>
<span class="cm"> * &quot;NFS: Network File System Protocol Specification&quot;.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_stat</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
			     <span class="kt">void</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_stat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_attrstat</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nfs_fattr</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">decode_attrstat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_diropres</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nfs_diropok</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">decode_diropres</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.6.  readlinkres</span>
<span class="cm"> *</span>
<span class="cm"> *	union readlinkres switch (stat status) {</span>
<span class="cm"> *	case NFS_OK:</span>
<span class="cm"> *		path data;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_readlinkres</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_stat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_path</span><span class="p">(</span><span class="n">xdr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.7.  readres</span>
<span class="cm"> *</span>
<span class="cm"> *	union readres switch (stat status) {</span>
<span class="cm"> *	case NFS_OK:</span>
<span class="cm"> *		fattr attributes;</span>
<span class="cm"> *		nfsdata data;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_readres</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">nfs_readres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_stat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_fattr</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_nfsdata</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_writeres</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nfs_writeres</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* All NFSv2 writes are &quot;file sync&quot; writes */</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">verf</span><span class="o">-&gt;</span><span class="n">committed</span> <span class="o">=</span> <span class="n">NFS_FILE_SYNC</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">decode_attrstat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="o">-&gt;</span><span class="n">fattr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs2_decode_dirent - Decode a single NFSv2 directory entry stored in</span>
<span class="cm"> *                      the local page cache.</span>
<span class="cm"> * @xdr: XDR stream where entry resides</span>
<span class="cm"> * @entry: buffer to fill in with entry data</span>
<span class="cm"> * @plus: boolean indicating whether this should be a readdirplus entry</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero if successful, otherwise a negative errno value is</span>
<span class="cm"> * returned.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is not invoked during READDIR reply decoding, but</span>
<span class="cm"> * rather whenever an application invokes the getdents(2) system call</span>
<span class="cm"> * on a directory already in our cache.</span>
<span class="cm"> *</span>
<span class="cm"> * 2.2.17.  entry</span>
<span class="cm"> *</span>
<span class="cm"> *	struct entry {</span>
<span class="cm"> *		unsigned	fileid;</span>
<span class="cm"> *		filename	name;</span>
<span class="cm"> *		nfscookie	cookie;</span>
<span class="cm"> *		entry		*nextentry;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nfs2_decode_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">plus</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">==</span> <span class="n">xdr_zero</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">==</span> <span class="n">xdr_zero</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">entry</span><span class="o">-&gt;</span><span class="n">eof</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADCOOKIE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_filename_inline</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The type (size and byte order) of nfscookie isn&#39;t defined in</span>
<span class="cm">	 * RFC 1094.  This implementation assumes that it&#39;s an XDR uint32.</span>
<span class="cm">	 */</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">prev_cookie</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">cookie</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">cookie</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">d_type</span> <span class="o">=</span> <span class="n">DT_UNKNOWN</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.17.  readdirres</span>
<span class="cm"> *</span>
<span class="cm"> *	union readdirres switch (stat status) {</span>
<span class="cm"> *	case NFS_OK:</span>
<span class="cm"> *		struct {</span>
<span class="cm"> *			entry *entries;</span>
<span class="cm"> *			bool eof;</span>
<span class="cm"> *		} readdirok;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> *</span>
<span class="cm"> * Read the directory contents into the page cache, but don&#39;t</span>
<span class="cm"> * touch them.  The actual decoding is done by nfs2_decode_dirent()</span>
<span class="cm"> * during subsequent nfs_readdir() calls.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_readdirok</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">recvd</span><span class="p">,</span> <span class="n">pglen</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">hdrlen</span><span class="p">;</span>

	<span class="n">pglen</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">page_len</span><span class="p">;</span>
	<span class="n">hdrlen</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="p">(</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">xdr</span><span class="o">-&gt;</span><span class="n">iov</span><span class="o">-&gt;</span><span class="n">iov_base</span><span class="p">;</span>
	<span class="n">recvd</span> <span class="o">=</span> <span class="n">xdr</span><span class="o">-&gt;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="n">hdrlen</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">pglen</span> <span class="o">&gt;</span> <span class="n">recvd</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_cheating</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">xdr_read_pages</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">pglen</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">pglen</span><span class="p">;</span>
<span class="nl">out_cheating:</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: server cheating in readdir result: &quot;</span>
		<span class="s">&quot;pglen %u &gt; recvd %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pglen</span><span class="p">,</span> <span class="n">recvd</span><span class="p">);</span>
	<span class="n">pglen</span> <span class="o">=</span> <span class="n">recvd</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_readdirres</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_stat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_readdirok</span><span class="p">(</span><span class="n">xdr</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * 2.2.18.  statfsres</span>
<span class="cm"> *</span>
<span class="cm"> *	union statfsres (stat status) {</span>
<span class="cm"> *	case NFS_OK:</span>
<span class="cm"> *		struct {</span>
<span class="cm"> *			unsigned tsize;</span>
<span class="cm"> *			unsigned bsize;</span>
<span class="cm"> *			unsigned blocks;</span>
<span class="cm"> *			unsigned bfree;</span>
<span class="cm"> *			unsigned bavail;</span>
<span class="cm"> *		} info;</span>
<span class="cm"> *	default:</span>
<span class="cm"> *		void;</span>
<span class="cm"> *	};</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">decode_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nfs2_fsstat</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__be32</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">xdr_inline_decode</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">NFS_info_sz</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">p</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_overflow</span><span class="p">;</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">tsize</span>  <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">bsize</span>  <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">bfree</span>  <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="o">++</span><span class="p">);</span>
	<span class="n">result</span><span class="o">-&gt;</span><span class="n">bavail</span> <span class="o">=</span> <span class="n">be32_to_cpup</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_overflow:</span>
	<span class="n">print_overflow_msg</span><span class="p">(</span><span class="n">__func__</span><span class="p">,</span> <span class="n">xdr</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs2_xdr_dec_statfsres</span><span class="p">(</span><span class="k">struct</span> <span class="n">rpc_rqst</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">xdr_stream</span> <span class="o">*</span><span class="n">xdr</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">nfs2_fsstat</span> <span class="o">*</span><span class="n">result</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_stat</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">status</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">status</span> <span class="o">!=</span> <span class="n">NFS_OK</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_default</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">decode_info</span><span class="p">(</span><span class="n">xdr</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="nl">out_default:</span>
	<span class="k">return</span> <span class="n">nfs_stat_to_errno</span><span class="p">(</span><span class="n">status</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * We need to translate between nfs status return values and</span>
<span class="cm"> * the local errno values which may not be the same.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">stat</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">errno</span><span class="p">;</span>
<span class="p">}</span> <span class="n">nfs_errtbl</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span> <span class="n">NFS_OK</span><span class="p">,</span>		<span class="mi">0</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_PERM</span><span class="p">,</span>		<span class="o">-</span><span class="n">EPERM</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOENT</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENOENT</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_IO</span><span class="p">,</span>		<span class="o">-</span><span class="n">errno_NFSERR_IO</span><span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NXIO</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENXIO</span>		<span class="p">},</span>
<span class="cm">/*	{ NFSERR_EAGAIN,	-EAGAIN		}, */</span>
	<span class="p">{</span> <span class="n">NFSERR_ACCES</span><span class="p">,</span>		<span class="o">-</span><span class="n">EACCES</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_EXIST</span><span class="p">,</span>		<span class="o">-</span><span class="n">EEXIST</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_XDEV</span><span class="p">,</span>		<span class="o">-</span><span class="n">EXDEV</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NODEV</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENODEV</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOTDIR</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTDIR</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_ISDIR</span><span class="p">,</span>		<span class="o">-</span><span class="n">EISDIR</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_INVAL</span><span class="p">,</span>		<span class="o">-</span><span class="n">EINVAL</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_FBIG</span><span class="p">,</span>		<span class="o">-</span><span class="n">EFBIG</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOSPC</span><span class="p">,</span>		<span class="o">-</span><span class="n">ENOSPC</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_ROFS</span><span class="p">,</span>		<span class="o">-</span><span class="n">EROFS</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_MLINK</span><span class="p">,</span>		<span class="o">-</span><span class="n">EMLINK</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NAMETOOLONG</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENAMETOOLONG</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOTEMPTY</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTEMPTY</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_DQUOT</span><span class="p">,</span>		<span class="o">-</span><span class="n">EDQUOT</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_STALE</span><span class="p">,</span>		<span class="o">-</span><span class="n">ESTALE</span>		<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_REMOTE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EREMOTE</span>	<span class="p">},</span>
<span class="cp">#ifdef EWFLUSH</span>
	<span class="p">{</span> <span class="n">NFSERR_WFLUSH</span><span class="p">,</span>	<span class="o">-</span><span class="n">EWFLUSH</span>	<span class="p">},</span>
<span class="cp">#endif</span>
	<span class="p">{</span> <span class="n">NFSERR_BADHANDLE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADHANDLE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOT_SYNC</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTSYNC</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_BAD_COOKIE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADCOOKIE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_NOTSUPP</span><span class="p">,</span>	<span class="o">-</span><span class="n">ENOTSUPP</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_TOOSMALL</span><span class="p">,</span>	<span class="o">-</span><span class="n">ETOOSMALL</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_SERVERFAULT</span><span class="p">,</span>	<span class="o">-</span><span class="n">EREMOTEIO</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_BADTYPE</span><span class="p">,</span>	<span class="o">-</span><span class="n">EBADTYPE</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="n">NFSERR_JUKEBOX</span><span class="p">,</span>	<span class="o">-</span><span class="n">EJUKEBOX</span>	<span class="p">},</span>
	<span class="p">{</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>			<span class="o">-</span><span class="n">EIO</span>		<span class="p">}</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_stat_to_errno - convert an NFS status code to a local errno</span>
<span class="cm"> * @status: NFS status code to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Returns a local errno value, or -EIO if the NFS status code is</span>
<span class="cm"> * not recognized.  This function is used jointly by NFSv2 and NFSv3.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nfs_stat_to_errno</span><span class="p">(</span><span class="k">enum</span> <span class="n">nfs_stat</span> <span class="n">status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stat</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">stat</span> <span class="o">==</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">status</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">errno</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;NFS: Unrecognized nfs status value: %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">status</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nfs_errtbl</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">errno</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define PROC(proc, argtype, restype, timer)				\</span>
<span class="cp">[NFSPROC_##proc] = {							\</span>
<span class="cp">	.p_proc	    =  NFSPROC_##proc,					\</span>
<span class="cp">	.p_encode   =  (kxdreproc_t)nfs2_xdr_enc_##argtype,		\</span>
<span class="cp">	.p_decode   =  (kxdrdproc_t)nfs2_xdr_dec_##restype,		\</span>
<span class="cp">	.p_arglen   =  NFS_##argtype##_sz,				\</span>
<span class="cp">	.p_replen   =  NFS_##restype##_sz,				\</span>
<span class="cp">	.p_timer    =  timer,						\</span>
<span class="cp">	.p_statidx  =  NFSPROC_##proc,					\</span>
<span class="cp">	.p_name     =  #proc,						\</span>
<span class="cp">	}</span>
<span class="k">struct</span> <span class="n">rpc_procinfo</span>	<span class="n">nfs_procedures</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">GETATTR</span><span class="p">,</span>	<span class="n">fhandle</span><span class="p">,</span>	<span class="n">attrstat</span><span class="p">,</span>	<span class="mi">1</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">SETATTR</span><span class="p">,</span>	<span class="n">sattrargs</span><span class="p">,</span>	<span class="n">attrstat</span><span class="p">,</span>	<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">LOOKUP</span><span class="p">,</span>	<span class="n">diropargs</span><span class="p">,</span>	<span class="n">diropres</span><span class="p">,</span>	<span class="mi">2</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">READLINK</span><span class="p">,</span>	<span class="n">readlinkargs</span><span class="p">,</span>	<span class="n">readlinkres</span><span class="p">,</span>	<span class="mi">3</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span>	<span class="n">readargs</span><span class="p">,</span>	<span class="n">readres</span><span class="p">,</span>	<span class="mi">3</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span>	<span class="n">writeargs</span><span class="p">,</span>	<span class="n">writeres</span><span class="p">,</span>	<span class="mi">4</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">CREATE</span><span class="p">,</span>	<span class="n">createargs</span><span class="p">,</span>	<span class="n">diropres</span><span class="p">,</span>	<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">REMOVE</span><span class="p">,</span>	<span class="n">removeargs</span><span class="p">,</span>	<span class="n">stat</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">RENAME</span><span class="p">,</span>	<span class="n">renameargs</span><span class="p">,</span>	<span class="n">stat</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">LINK</span><span class="p">,</span>	<span class="n">linkargs</span><span class="p">,</span>	<span class="n">stat</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">SYMLINK</span><span class="p">,</span>	<span class="n">symlinkargs</span><span class="p">,</span>	<span class="n">stat</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">MKDIR</span><span class="p">,</span>	<span class="n">createargs</span><span class="p">,</span>	<span class="n">diropres</span><span class="p">,</span>	<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">RMDIR</span><span class="p">,</span>	<span class="n">diropargs</span><span class="p">,</span>	<span class="n">stat</span><span class="p">,</span>		<span class="mi">0</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">READDIR</span><span class="p">,</span>	<span class="n">readdirargs</span><span class="p">,</span>	<span class="n">readdirres</span><span class="p">,</span>	<span class="mi">3</span><span class="p">),</span>
	<span class="n">PROC</span><span class="p">(</span><span class="n">STATFS</span><span class="p">,</span>	<span class="n">fhandle</span><span class="p">,</span>	<span class="n">statfsres</span><span class="p">,</span>	<span class="mi">0</span><span class="p">),</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">rpc_version</span> <span class="n">nfs_version2</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">number</span>			<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="p">.</span><span class="n">nrprocs</span>		<span class="o">=</span> <span class="n">ARRAY_SIZE</span><span class="p">(</span><span class="n">nfs_procedures</span><span class="p">),</span>
	<span class="p">.</span><span class="n">procs</span>			<span class="o">=</span> <span class="n">nfs_procedures</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
