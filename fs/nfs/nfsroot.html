<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nfs › nfsroot.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nfsroot.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  Copyright (C) 1995, 1996  Gero Kuhlmann &lt;gero@gkminix.han.de&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  Allow an NFS filesystem to be mounted as root. The way this works is:</span>
<span class="cm"> *     (1) Use the IP autoconfig mechanism to set local IP addresses and routes.</span>
<span class="cm"> *     (2) Construct the device string and the options string using DHCP</span>
<span class="cm"> *         option 17 and/or kernel command line options.</span>
<span class="cm"> *     (3) When mount_root() sets up the root file system, pass these strings</span>
<span class="cm"> *         to the NFS client&#39;s regular mount interface via sys_mount().</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> *	Changes:</span>
<span class="cm"> *</span>
<span class="cm"> *	Alan Cox	:	Removed get_address name clash with FPU.</span>
<span class="cm"> *	Alan Cox	:	Reformatted a bit.</span>
<span class="cm"> *	Gero Kuhlmann	:	Code cleanup</span>
<span class="cm"> *	Michael Rausch  :	Fixed recognition of an incoming RARP answer.</span>
<span class="cm"> *	Martin Mares	: (2.0)	Auto-configuration via BOOTP supported.</span>
<span class="cm"> *	Martin Mares	:	Manual selection of interface &amp; BOOTP/RARP.</span>
<span class="cm"> *	Martin Mares	:	Using network routes instead of host routes,</span>
<span class="cm"> *				allowing the default configuration to be used</span>
<span class="cm"> *				for normal operation of the host.</span>
<span class="cm"> *	Martin Mares	:	Randomized timer with exponential backoff</span>
<span class="cm"> *				installed to minimize network congestion.</span>
<span class="cm"> *	Martin Mares	:	Code cleanup.</span>
<span class="cm"> *	Martin Mares	: (2.1)	BOOTP and RARP made configuration options.</span>
<span class="cm"> *	Martin Mares	:	Server hostname generation fixed.</span>
<span class="cm"> *	Gerd Knorr	:	Fixed wired inode handling</span>
<span class="cm"> *	Martin Mares	: (2.2)	&quot;0.0.0.0&quot; addresses from command line ignored.</span>
<span class="cm"> *	Martin Mares	:	RARP replies not tested for server address.</span>
<span class="cm"> *	Gero Kuhlmann	: (2.3) Some bug fixes and code cleanup again (please</span>
<span class="cm"> *				send me your new patches _before_ bothering</span>
<span class="cm"> *				Linus so that I don&#39; always have to cleanup</span>
<span class="cm"> *				_afterwards_ - thanks)</span>
<span class="cm"> *	Gero Kuhlmann	:	Last changes of Martin Mares undone.</span>
<span class="cm"> *	Gero Kuhlmann	: 	RARP replies are tested for specified server</span>
<span class="cm"> *				again. However, it&#39;s now possible to have</span>
<span class="cm"> *				different RARP and NFS servers.</span>
<span class="cm"> *	Gero Kuhlmann	:	&quot;0.0.0.0&quot; addresses from command line are</span>
<span class="cm"> *				now mapped to INADDR_NONE.</span>
<span class="cm"> *	Gero Kuhlmann	:	Fixed a bug which prevented BOOTP path name</span>
<span class="cm"> *				from being used (thanks to Leo Spiekman)</span>
<span class="cm"> *	Andy Walker	:	Allow to specify the NFS server in nfs_root</span>
<span class="cm"> *				without giving a path name</span>
<span class="cm"> *	Swen Thümmler	:	Allow to specify the NFS options in nfs_root</span>
<span class="cm"> *				without giving a path name. Fix BOOTP request</span>
<span class="cm"> *				for domainname (domainname is NIS domain, not</span>
<span class="cm"> *				DNS domain!). Skip dummy devices for BOOTP.</span>
<span class="cm"> *	Jacek Zapala	:	Fixed a bug which prevented server-ip address</span>
<span class="cm"> *				from nfsroot parameter from being used.</span>
<span class="cm"> *	Olaf Kirch	:	Adapted to new NFS code.</span>
<span class="cm"> *	Jakub Jelinek	:	Free used code segment.</span>
<span class="cm"> *	Marko Kohtala	:	Fixed some bugs.</span>
<span class="cm"> *	Martin Mares	:	Debug message cleanup</span>
<span class="cm"> *	Martin Mares	:	Changed to use the new generic IP layer autoconfig</span>
<span class="cm"> *				code. BOOTP and RARP moved there.</span>
<span class="cm"> *	Martin Mares	:	Default path now contains host name instead of</span>
<span class="cm"> *				host IP address (but host name defaults to IP</span>
<span class="cm"> *				address anyway).</span>
<span class="cm"> *	Martin Mares	:	Use root_server_addr appropriately during setup.</span>
<span class="cm"> *	Martin Mares	:	Rewrote parameter parsing, now hopefully giving</span>
<span class="cm"> *				correct overriding.</span>
<span class="cm"> *	Trond Myklebust :	Add in preliminary support for NFSv3 and TCP.</span>
<span class="cm"> *				Fix bug in root_nfs_addr(). nfs_data.namlen</span>
<span class="cm"> *				is NOT for the length of the hostname.</span>
<span class="cm"> *	Hua Qin		:	Support for mounting root file system via</span>
<span class="cm"> *				NFS over TCP.</span>
<span class="cm"> *	Fabian Frederick:	Option parser rebuilt (using parser lib)</span>
<span class="cm"> *	Chuck Lever	:	Use super.c&#39;s text-based mount option parsing</span>
<span class="cm"> *	Chuck Lever	:	Add &quot;nfsrootdebug&quot;.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/nfs.h&gt;</span>
<span class="cp">#include &lt;linux/nfs_fs.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/root_dev.h&gt;</span>
<span class="cp">#include &lt;net/ipconfig.h&gt;</span>

<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define NFSDBG_FACILITY NFSDBG_ROOT</span>

<span class="cm">/* Default path we try to mount. &quot;%s&quot; gets replaced by our IP address */</span>
<span class="cp">#define NFS_ROOT		&quot;/tftpboot/%s&quot;</span>

<span class="cm">/* Default NFSROOT mount options. */</span>
<span class="cp">#define NFS_DEF_OPTIONS		&quot;vers=2,udp,rsize=4096,wsize=4096&quot;</span>

<span class="cm">/* Parameters passed from the kernel command line */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">nfs_root_parms</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="cm">/* Text-based mount options passed to super.c */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">nfs_root_options</span><span class="p">[</span><span class="mi">256</span><span class="p">]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="n">NFS_DEF_OPTIONS</span><span class="p">;</span>

<span class="cm">/* Address of NFS server */</span>
<span class="k">static</span> <span class="n">__be32</span> <span class="n">servaddr</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_NONE</span><span class="p">);</span>

<span class="cm">/* Name of directory to mount */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">nfs_export_path</span><span class="p">[</span><span class="n">NFS_MAXPATHLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="cm">/* server:export path string passed to super.c */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">nfs_root_device</span><span class="p">[</span><span class="n">NFS_MAXPATHLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="n">__initdata</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

<span class="cp">#ifdef NFS_DEBUG</span>
<span class="cm">/*</span>
<span class="cm"> * When the &quot;nfsrootdebug&quot; kernel command line option is specified,</span>
<span class="cm"> * enable debugging messages for NFSROOT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nfs_root_debug</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">__unused</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nfs_debug</span> <span class="o">|=</span> <span class="n">NFSDBG_ROOT</span> <span class="o">|</span> <span class="n">NFSDBG_MOUNT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nfsrootdebug&quot;</span><span class="p">,</span> <span class="n">nfs_root_debug</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> *  Parse NFS server and directory information passed on the kernel</span>
<span class="cm"> *  command line.</span>
<span class="cm"> *</span>
<span class="cm"> *  nfsroot=[&lt;server-ip&gt;:]&lt;root-dir&gt;[,&lt;nfs-options&gt;]</span>
<span class="cm"> *</span>
<span class="cm"> *  If there is a &quot;%s&quot; token in the &lt;root-dir&gt; string, it is replaced</span>
<span class="cm"> *  by the ASCII-representation of the client&#39;s IP address.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nfs_root_setup</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">line</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ROOT_DEV</span> <span class="o">=</span> <span class="n">Root_NFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span> <span class="o">||</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;,&#39;</span> <span class="o">||</span> <span class="p">(</span><span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">line</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">nfs_root_parms</span><span class="p">,</span> <span class="n">line</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_root_parms</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">line</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NFS_ROOT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_root_parms</span><span class="p">))</span>
			<span class="n">line</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_root_parms</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">NFS_ROOT</span><span class="p">)</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">sprintf</span><span class="p">(</span><span class="n">nfs_root_parms</span><span class="p">,</span> <span class="n">NFS_ROOT</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Extract the IP address of the NFS server containing our</span>
<span class="cm">	 * root file system, if one was specified.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note: root_nfs_parse_addr() removes the server-ip from</span>
<span class="cm">	 *	 nfs_root_parms, if it exists.</span>
<span class="cm">	 */</span>
	<span class="n">root_server_addr</span> <span class="o">=</span> <span class="n">root_nfs_parse_addr</span><span class="p">(</span><span class="n">nfs_root_parms</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">__setup</span><span class="p">(</span><span class="s">&quot;nfsroot=&quot;</span><span class="p">,</span> <span class="n">nfs_root_setup</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">root_nfs_copy</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">size_t</span> <span class="n">destlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strlcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">destlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">destlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">root_nfs_cat</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
			       <span class="k">const</span> <span class="kt">size_t</span> <span class="n">destlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">dest</span><span class="p">[</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;,&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">strlcat</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">,</span> <span class="n">destlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">destlen</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strlcat</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">destlen</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">destlen</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Parse out root export path and mount options from</span>
<span class="cm"> * passed-in string @incoming.</span>
<span class="cm"> *</span>
<span class="cm"> * Copy the export path into @exppath.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">root_nfs_parse_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">incoming</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">exppath</span><span class="p">,</span>
					 <span class="k">const</span> <span class="kt">size_t</span> <span class="n">exppathlen</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the NFS remote path</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">incoming</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="s">&quot;default&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root_nfs_copy</span><span class="p">(</span><span class="n">exppath</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">exppathlen</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * @incoming now points to the rest of the string; if it</span>
<span class="cm">	 * contains something, append it to our root options buffer</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">incoming</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">incoming</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root_nfs_cat</span><span class="p">(</span><span class="n">nfs_root_options</span><span class="p">,</span> <span class="n">incoming</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_root_options</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *  Decode the export directory path name and NFS options from</span>
<span class="cm"> *  the kernel command line.  This has to be done late in order to</span>
<span class="cm"> *  use a dynamically acquired client IP address for the remote</span>
<span class="cm"> *  root directory path.</span>
<span class="cm"> *</span>
<span class="cm"> *  Returns zero if successful; otherwise -1 is returned.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">root_nfs_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">cmdline</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">mand_options</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="s">&quot;nolock,addr=&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="n">INET_ADDRSTRLEN</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">tmplen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_export_path</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">tmplen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nomem</span><span class="p">;</span>
	<span class="n">strcpy</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">NFS_ROOT</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_server_path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;Root-NFS: DHCPv4 option 17: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">root_server_path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root_nfs_parse_options</span><span class="p">(</span><span class="n">root_server_path</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmplen</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_optionstoolong</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmdline</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dprintk</span><span class="p">(</span><span class="s">&quot;Root-NFS: nfsroot=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cmdline</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root_nfs_parse_options</span><span class="p">(</span><span class="n">cmdline</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tmplen</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_optionstoolong</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Append mandatory options for nfsroot so they override</span>
<span class="cm">	 * what has come before</span>
<span class="cm">	 */</span>
	<span class="n">snprintf</span><span class="p">(</span><span class="n">mand_options</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">mand_options</span><span class="p">),</span> <span class="s">&quot;nolock,addr=%pI4&quot;</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">servaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root_nfs_cat</span><span class="p">(</span><span class="n">nfs_root_options</span><span class="p">,</span> <span class="n">mand_options</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_root_options</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_optionstoolong</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up nfs_root_device.  For NFS mounts, this looks like</span>
<span class="cm">	 *</span>
<span class="cm">	 *	server:/path</span>
<span class="cm">	 *</span>
<span class="cm">	 * At this point, utsname()-&gt;nodename contains our local</span>
<span class="cm">	 * IP address or hostname, set by ipconfig.  If &quot;%s&quot; exists</span>
<span class="cm">	 * in tmp, substitute the nodename, then shovel the whole</span>
<span class="cm">	 * mess into nfs_root_device.</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">nfs_export_path</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_export_path</span><span class="p">),</span>
				<span class="n">tmp</span><span class="p">,</span> <span class="n">utsname</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">nodename</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_export_path</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_devnametoolong</span><span class="p">;</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">nfs_root_device</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_root_device</span><span class="p">),</span>
				<span class="s">&quot;%pI4:%s&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">servaddr</span><span class="p">,</span> <span class="n">nfs_export_path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="k">sizeof</span><span class="p">(</span><span class="n">nfs_root_device</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_devnametoolong</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="nl">out_nomem:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Root-NFS: could not allocate memory</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">out_optionstoolong:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Root-NFS: mount options string too long</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">out_devnametoolong:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Root-NFS: root device name too long.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nfs_root_data - Return prepared &#39;data&#39; for NFSROOT mount</span>
<span class="cm"> * @root_device: OUT: address of string containing NFSROOT device</span>
<span class="cm"> * @root_data: OUT: address of string containing NFSROOT mount options</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero and sets @root_device and @root_data if successful,</span>
<span class="cm"> * otherwise -1 is returned.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">__init</span> <span class="nf">nfs_root_data</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">root_device</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">root_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">servaddr</span> <span class="o">=</span> <span class="n">root_server_addr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">servaddr</span> <span class="o">==</span> <span class="n">htonl</span><span class="p">(</span><span class="n">INADDR_NONE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Root-NFS: no NFS server address</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_nfs_data</span><span class="p">(</span><span class="n">nfs_root_parms</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">root_device</span> <span class="o">=</span> <span class="n">nfs_root_device</span><span class="p">;</span>
	<span class="o">*</span><span class="n">root_data</span> <span class="o">=</span> <span class="n">nfs_root_options</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
