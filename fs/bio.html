<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › bio.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>bio.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2001 Jens Axboe &lt;axboe@kernel.dk&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License version 2 as</span>
<span class="cm"> * published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public Licens</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/iocontext.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/cgroup.h&gt;</span>
<span class="cp">#include &lt;scsi/sg.h&gt;		</span><span class="cm">/* for struct sg_iovec */</span><span class="cp"></span>

<span class="cp">#include &lt;trace/events/block.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Test patch to inline a certain number of bi_io_vec&#39;s inside the bio</span>
<span class="cm"> * itself, to shrink a bio data allocation from two mempool calls to one</span>
<span class="cm"> */</span>
<span class="cp">#define BIO_INLINE_VECS		4</span>

<span class="k">static</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">bio_split_pool</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * if you change this list, also change bvec_alloc or things will</span>
<span class="cm"> * break badly! cannot be bigger than what you can fit into an</span>
<span class="cm"> * unsigned short</span>
<span class="cm"> */</span>
<span class="cp">#define BV(x) { .nr_vecs = x, .name = &quot;biovec-&quot;__stringify(x) }</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">biovec_slab</span> <span class="n">bvec_slabs</span><span class="p">[</span><span class="n">BIOVEC_NR_POOLS</span><span class="p">]</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">BV</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">BV</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">BV</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">BV</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">BV</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">BV</span><span class="p">(</span><span class="n">BIO_MAX_PAGES</span><span class="p">),</span>
<span class="p">};</span>
<span class="cp">#undef BV</span>

<span class="cm">/*</span>
<span class="cm"> * fs_bio_set is the bio_set containing bio and iovec memory pools used by</span>
<span class="cm"> * IO code that does not need private memory pools.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">fs_bio_set</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * Our slab pool management</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_slab</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slab_ref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">slab_size</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">static</span> <span class="n">DEFINE_MUTEX</span><span class="p">(</span><span class="n">bio_slab_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bio_slab</span> <span class="o">*</span><span class="n">bio_slabs</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bio_slab_nr</span><span class="p">,</span> <span class="n">bio_slab_max</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="nf">bio_find_or_create_slab</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">extra_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span><span class="p">)</span> <span class="o">+</span> <span class="n">extra_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_slab</span> <span class="o">*</span><span class="n">bslab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">entry</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_slab_lock</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">bio_slab_nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bslab</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bio_slabs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab_size</span> <span class="o">==</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">slab</span> <span class="o">=</span> <span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">;</span>
			<span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab_ref</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slab</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_slab_nr</span> <span class="o">==</span> <span class="n">bio_slab_max</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio_slab_max</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">bio_slabs</span> <span class="o">=</span> <span class="n">krealloc</span><span class="p">(</span><span class="n">bio_slabs</span><span class="p">,</span>
				     <span class="n">bio_slab_max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_slab</span><span class="p">),</span>
				     <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio_slabs</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">bio_slab_nr</span><span class="o">++</span><span class="p">;</span>

	<span class="n">bslab</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bio_slabs</span><span class="p">[</span><span class="n">entry</span><span class="p">];</span>

	<span class="n">snprintf</span><span class="p">(</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span> <span class="s">&quot;bio-%d&quot;</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="n">slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slab</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;bio: create slab &lt;%s&gt; at %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bslab</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
	<span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">slab</span><span class="p">;</span>
	<span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab_size</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_slab_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">slab</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_put_slab</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_slab</span> <span class="o">*</span><span class="n">bslab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_slab_lock</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bio_slab_nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_slab</span> <span class="o">==</span> <span class="n">bio_slabs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slab</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bslab</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bio_slabs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">bslab</span><span class="p">,</span> <span class="n">KERN_ERR</span> <span class="s">&quot;bio: unable to find slab!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab_ref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab_ref</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
	<span class="n">bslab</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_slab_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bvec_nr_vecs</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bvec_slabs</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">nr_vecs</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bvec_free_bs</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BIO_BUG_ON</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;=</span> <span class="n">BIOVEC_NR_POOLS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">BIOVEC_MAX_IDX</span><span class="p">)</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bvec_pool</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">biovec_slab</span> <span class="o">*</span><span class="n">bvs</span> <span class="o">=</span> <span class="n">bvec_slabs</span> <span class="o">+</span> <span class="n">idx</span><span class="p">;</span>

		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">bvs</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">bv</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="nf">bvec_alloc_bs</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">idx</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * see comment near bvec_array define!</span>
<span class="cm">	 */</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span> <span class="p">...</span> <span class="mi">4</span>:
		<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span> <span class="p">...</span> <span class="mi">16</span>:
		<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">17</span> <span class="p">...</span> <span class="mi">64</span>:
		<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">65</span> <span class="p">...</span> <span class="mi">128</span>:
		<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">129</span> <span class="p">...</span> <span class="n">BIO_MAX_PAGES</span>:
		<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * idx now points to the pool we want to allocate from. only the</span>
<span class="cm">	 * 1-vec entry pool is mempool backed.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">idx</span> <span class="o">==</span> <span class="n">BIOVEC_MAX_IDX</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">fallback:</span>
		<span class="n">bvl</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bvec_pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">biovec_slab</span> <span class="o">*</span><span class="n">bvs</span> <span class="o">=</span> <span class="n">bvec_slabs</span> <span class="o">+</span> <span class="o">*</span><span class="n">idx</span><span class="p">;</span>
		<span class="n">gfp_t</span> <span class="n">__gfp_mask</span> <span class="o">=</span> <span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">__GFP_WAIT</span> <span class="o">|</span> <span class="n">__GFP_IO</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Make this allocation restricted and don&#39;t dump info on</span>
<span class="cm">		 * allocation failures, since we&#39;ll fallback to the mempool</span>
<span class="cm">		 * in case of failure.</span>
<span class="cm">		 */</span>
		<span class="n">__gfp_mask</span> <span class="o">|=</span> <span class="n">__GFP_NOMEMALLOC</span> <span class="o">|</span> <span class="n">__GFP_NORETRY</span> <span class="o">|</span> <span class="n">__GFP_NOWARN</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try a slab allocation. If this fails and __GFP_WAIT</span>
<span class="cm">		 * is set, retry with the 1-entry mempool</span>
<span class="cm">		 */</span>
		<span class="n">bvl</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">bvs</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">,</span> <span class="n">__gfp_mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bvl</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">gfp_mask</span> <span class="o">&amp;</span> <span class="n">__GFP_WAIT</span><span class="p">)))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">idx</span> <span class="o">=</span> <span class="n">BIOVEC_MAX_IDX</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fallback</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">bvl</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bio_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_has_allocated_vec</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="n">bvec_free_bs</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">,</span> <span class="n">BIO_POOL_IDX</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="n">bio_integrity_free</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bs</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have front padding, adjust the bio pointer before freeing</span>
<span class="cm">	 */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">front_pad</span><span class="p">)</span>
		<span class="n">p</span> <span class="o">-=</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">front_pad</span><span class="p">;</span>

	<span class="n">mempool_free</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_pool</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_free</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bio_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bio</span><span class="p">));</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIO_UPTODATE</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_cnt</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_init</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_alloc_bioset - allocate a bio for I/O</span>
<span class="cm"> * @gfp_mask:   the GFP_ mask given to the slab allocator</span>
<span class="cm"> * @nr_iovecs:	number of iovecs to pre-allocate</span>
<span class="cm"> * @bs:		the bio_set to allocate from.</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   bio_alloc_bioset will try its own mempool to satisfy the allocation.</span>
<span class="cm"> *   If %__GFP_WAIT is set then we will block on the internal pool waiting</span>
<span class="cm"> *   for a &amp;struct bio to become free.</span>
<span class="cm"> *</span>
<span class="cm"> *   Note that the caller must set -&gt;bi_destructor on successful return</span>
<span class="cm"> *   of a bio, to do the appropriate freeing of the bio once the reference</span>
<span class="cm"> *   count drops to zero.</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_alloc_bioset</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_iovecs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">BIO_POOL_NONE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">front_pad</span><span class="p">;</span>

	<span class="n">bio_init</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">nr_iovecs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_set</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_iovecs</span> <span class="o">&lt;=</span> <span class="n">BIO_INLINE_VECS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bvl</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_inline_vecs</span><span class="p">;</span>
		<span class="n">nr_iovecs</span> <span class="o">=</span> <span class="n">BIO_INLINE_VECS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bvl</span> <span class="o">=</span> <span class="n">bvec_alloc_bs</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nr_iovecs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">idx</span><span class="p">,</span> <span class="n">bs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bvl</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err_free</span><span class="p">;</span>

		<span class="n">nr_iovecs</span> <span class="o">=</span> <span class="n">bvec_nr_vecs</span><span class="p">(</span><span class="n">idx</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_set:</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">|=</span> <span class="n">idx</span> <span class="o">&lt;&lt;</span> <span class="n">BIO_POOL_OFFSET</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_max_vecs</span> <span class="o">=</span> <span class="n">nr_iovecs</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">=</span> <span class="n">bvl</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>

<span class="nl">err_free:</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_pool</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_alloc_bioset</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_fs_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio_free</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">fs_bio_set</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_alloc - allocate a new bio, memory pool backed</span>
<span class="cm"> *	@gfp_mask: allocation mask to use</span>
<span class="cm"> *	@nr_iovecs: number of iovecs</span>
<span class="cm"> *</span>
<span class="cm"> *	bio_alloc will allocate a bio and associated bio_vec array that can hold</span>
<span class="cm"> *	at least @nr_iovecs entries. Allocations will be done from the</span>
<span class="cm"> *	fs_bio_set. Also see @bio_alloc_bioset and @bio_kmalloc.</span>
<span class="cm"> *</span>
<span class="cm"> *	If %__GFP_WAIT is set, then bio_alloc will always be able to allocate</span>
<span class="cm"> *	a bio. This is due to the mempool guarantees. To make this work, callers</span>
<span class="cm"> *	must never allocate more than 1 bio at a time from this pool. Callers</span>
<span class="cm"> *	that need to allocate more than 1 bio must always submit the previously</span>
<span class="cm"> *	allocated bio for IO before attempting to allocate a new one. Failure to</span>
<span class="cm"> *	do so can cause livelocks under memory pressure.</span>
<span class="cm"> *</span>
<span class="cm"> *	RETURNS:</span>
<span class="cm"> *	Pointer to new bio on success, NULL on failure.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_alloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_iovecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc_bioset</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nr_iovecs</span><span class="p">,</span> <span class="n">fs_bio_set</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_destructor</span> <span class="o">=</span> <span class="n">bio_fs_destructor</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_alloc</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_kmalloc_destructor</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="n">bio_integrity_free</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">fs_bio_set</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_kmalloc - allocate a bio for I/O using kmalloc()</span>
<span class="cm"> * @gfp_mask:   the GFP_ mask given to the slab allocator</span>
<span class="cm"> * @nr_iovecs:	number of iovecs to pre-allocate</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Allocate a new bio with @nr_iovecs bvecs.  If @gfp_mask contains</span>
<span class="cm"> *   %__GFP_WAIT, the allocation is guaranteed to succeed.</span>
<span class="cm"> *</span>
<span class="cm"> **/</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_kmalloc</span><span class="p">(</span><span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_iovecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_iovecs</span> <span class="o">&gt;</span> <span class="n">UIO_MAXIOV</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span><span class="p">)</span> <span class="o">+</span> <span class="n">nr_iovecs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">),</span>
		      <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bio_init</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">|=</span> <span class="n">BIO_POOL_NONE</span> <span class="o">&lt;&lt;</span> <span class="n">BIO_POOL_OFFSET</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_max_vecs</span> <span class="o">=</span> <span class="n">nr_iovecs</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_inline_vecs</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_destructor</span> <span class="o">=</span> <span class="n">bio_kmalloc_destructor</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_kmalloc</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">zero_fill_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">bvec_kmap_irq</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="n">bvec_kunmap_irq</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">zero_fill_bio</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_put - release a reference to a bio</span>
<span class="cm"> * @bio:   bio to release reference to</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   Put a reference to a &amp;struct bio, either one you have gotten with</span>
<span class="cm"> *   bio_alloc, bio_get or bio_clone. The last put of a bio will free it.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">bio_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BIO_BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_cnt</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * last put frees it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bio_disassociate_task</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_destructor</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_put</span><span class="p">);</span>

<span class="kr">inline</span> <span class="kt">int</span> <span class="nf">bio_phys_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_SEG_VALID</span><span class="p">)))</span>
		<span class="n">blk_recount_segments</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_phys_segments</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_phys_segments</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * 	__bio_clone	-	clone a bio</span>
<span class="cm"> * 	@bio: destination bio</span>
<span class="cm"> * 	@bio_src: bio to clone</span>
<span class="cm"> *</span>
<span class="cm"> *	Clone a &amp;bio. Caller will own the returned bio, but not</span>
<span class="cm"> *	the actual data it points to. Reference count of returned</span>
<span class="cm"> * 	bio will be one.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__bio_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">,</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">,</span>
		<span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_max_vecs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * most users will be overriding -&gt;bi_bdev with a new target,</span>
<span class="cm">	 * so we don&#39;t set nor calculate new physical/hw segment counts here</span>
<span class="cm">	 */</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIO_CLONED</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">=</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_rw</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">=</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">=</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_idx</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__bio_clone</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_clone	-	clone a bio</span>
<span class="cm"> *	@bio: bio to clone</span>
<span class="cm"> *	@gfp_mask: allocation priority</span>
<span class="cm"> *</span>
<span class="cm"> * 	Like __bio_clone, only also allocates the returned bio</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="n">bio_alloc_bioset</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_max_vecs</span><span class="p">,</span> <span class="n">fs_bio_set</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">b</span><span class="o">-&gt;</span><span class="n">bi_destructor</span> <span class="o">=</span> <span class="n">bio_fs_destructor</span><span class="p">;</span>
	<span class="n">__bio_clone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_integrity_clone</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">fs_bio_set</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bio_put</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_clone</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_get_nr_vecs		- return approx number of vecs</span>
<span class="cm"> *	@bdev:  I/O target</span>
<span class="cm"> *</span>
<span class="cm"> *	Return the approximate number of pages we can send to this target.</span>
<span class="cm"> *	There&#39;s no guarantee that you will be able to fit this number of pages</span>
<span class="cm"> *	into a bio, it does not account for dynamic restrictions that vary</span>
<span class="cm"> *	on offset.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_get_nr_vecs</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span>
		     <span class="n">queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">),</span>
		     <span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">BIO_MAX_PAGES</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_get_nr_vecs</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__bio_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span>
			  <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">max_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">retried_segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * cloned bio must not modify vec list</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_CLONED</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_sectors</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * For filesystems with a blocksize smaller than the pagesize</span>
<span class="cm">	 * we will often be called with the same page as last time and</span>
<span class="cm">	 * a consecutive offset.  Optimize this special case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">==</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">bv_page</span> <span class="o">&amp;&amp;</span>
		    <span class="n">offset</span> <span class="o">==</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">+</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">prev_bv_len</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="n">bvm</span> <span class="o">=</span> <span class="p">{</span>
					<span class="cm">/* prev_bvec is already charged in</span>
<span class="cm">					   bi_size, discharge it in order to</span>
<span class="cm">					   simulate merging updated prev_bvec</span>
<span class="cm">					   as new bvec. */</span>
					<span class="p">.</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span>
					<span class="p">.</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">,</span>
					<span class="p">.</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">-</span> <span class="n">prev_bv_len</span><span class="p">,</span>
					<span class="p">.</span><span class="n">bi_rw</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span><span class="p">,</span>
				<span class="p">};</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bvm</span><span class="p">,</span> <span class="n">prev</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">prev</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
					<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">&gt;=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_max_vecs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we might lose a segment or two here, but rather that than</span>
<span class="cm">	 * make this too complex.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_phys_segments</span> <span class="o">&gt;=</span> <span class="n">queue_max_segments</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retried_segments</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">retried_segments</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">blk_recount_segments</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * setup the new entry, we might clear it again later if we</span>
<span class="cm">	 * cannot add the page</span>
<span class="cm">	 */</span>
	<span class="n">bvec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">];</span>
	<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if queue has other restrictions (eg varying max sector size</span>
<span class="cm">	 * depending on offset), it can specify a merge_bvec_fn in the</span>
<span class="cm">	 * queue to get further control</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bvec_merge_data</span> <span class="n">bvm</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span>
			<span class="p">.</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">,</span>
			<span class="p">.</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">,</span>
			<span class="p">.</span><span class="n">bi_rw</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="cm">/*</span>
<span class="cm">		 * merge_bvec_fn() returns number of bytes it can accept</span>
<span class="cm">		 * at this offset</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">merge_bvec_fn</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bvm</span><span class="p">,</span> <span class="n">bvec</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If we may be able to merge these biovecs, force a recount */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">BIOVEC_PHYS_MERGEABLE</span><span class="p">(</span><span class="n">bvec</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">bvec</span><span class="p">)))</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIO_SEG_VALID</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="o">++</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_phys_segments</span><span class="o">++</span><span class="p">;</span>
 <span class="nl">done:</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_add_pc_page	-	attempt to add page to bio</span>
<span class="cm"> *	@q: the target queue</span>
<span class="cm"> *	@bio: destination bio</span>
<span class="cm"> *	@page: page to add</span>
<span class="cm"> *	@len: vec entry length</span>
<span class="cm"> *	@offset: vec entry offset</span>
<span class="cm"> *</span>
<span class="cm"> *	Attempt to add a page to the bio_vec maplist. This can fail for a</span>
<span class="cm"> *	number of reasons, such as the bio being full or target block device</span>
<span class="cm"> *	limitations. The target block device must allow bio&#39;s up to PAGE_SIZE,</span>
<span class="cm"> *	so it is always possible to add a single page to an empty bio.</span>
<span class="cm"> *</span>
<span class="cm"> *	This should only be used by REQ_PC bios.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_add_pc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__bio_add_page</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			      <span class="n">queue_max_hw_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_add_pc_page</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_add_page	-	attempt to add page to bio</span>
<span class="cm"> *	@bio: destination bio</span>
<span class="cm"> *	@page: page to add</span>
<span class="cm"> *	@len: vec entry length</span>
<span class="cm"> *	@offset: vec entry offset</span>
<span class="cm"> *</span>
<span class="cm"> *	Attempt to add a page to the bio_vec maplist. This can fail for a</span>
<span class="cm"> *	number of reasons, such as the bio being full or target block device</span>
<span class="cm"> *	limitations. The target block device must allow bio&#39;s up to PAGE_SIZE,</span>
<span class="cm"> *	so it is always possible to add a single page to an empty bio.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__bio_add_page</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">queue_max_sectors</span><span class="p">(</span><span class="n">q</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_add_page</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">bio_map_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">iovecs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="n">sgvecs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_sgvecs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_our_pages</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_set_map_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_map_data</span> <span class="o">*</span><span class="n">bmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iov_count</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">is_our_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bmd</span><span class="o">-&gt;</span><span class="n">iovecs</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">)</span> <span class="o">*</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">bmd</span><span class="o">-&gt;</span><span class="n">sgvecs</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_iovec</span><span class="p">)</span> <span class="o">*</span> <span class="n">iov_count</span><span class="p">);</span>
	<span class="n">bmd</span><span class="o">-&gt;</span><span class="n">nr_sgvecs</span> <span class="o">=</span> <span class="n">iov_count</span><span class="p">;</span>
	<span class="n">bmd</span><span class="o">-&gt;</span><span class="n">is_our_pages</span> <span class="o">=</span> <span class="n">is_our_pages</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">bmd</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_free_map_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_map_data</span> <span class="o">*</span><span class="n">bmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bmd</span><span class="o">-&gt;</span><span class="n">iovecs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bmd</span><span class="o">-&gt;</span><span class="n">sgvecs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bmd</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bio_map_data</span> <span class="o">*</span><span class="nf">bio_alloc_map_data</span><span class="p">(</span><span class="kt">int</span> <span class="n">nr_segs</span><span class="p">,</span>
					       <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iov_count</span><span class="p">,</span>
					       <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_map_data</span> <span class="o">*</span><span class="n">bmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iov_count</span> <span class="o">&gt;</span> <span class="n">UIO_MAXIOV</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bmd</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bmd</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bmd</span><span class="o">-&gt;</span><span class="n">iovecs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bmd</span><span class="o">-&gt;</span><span class="n">iovecs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bmd</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bmd</span><span class="o">-&gt;</span><span class="n">sgvecs</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sg_iovec</span><span class="p">)</span> <span class="o">*</span> <span class="n">iov_count</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bmd</span><span class="o">-&gt;</span><span class="n">sgvecs</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bmd</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bmd</span><span class="o">-&gt;</span><span class="n">iovecs</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__bio_copy_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">iovecs</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iov_count</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">to_user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from_user</span><span class="p">,</span> <span class="kt">int</span> <span class="n">do_free_page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iov_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iov_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">__bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">bv_addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bv_len</span> <span class="o">=</span> <span class="n">iovecs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_len</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">bv_len</span> <span class="o">&amp;&amp;</span> <span class="n">iov_idx</span> <span class="o">&lt;</span> <span class="n">iov_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">iov_addr</span><span class="p">;</span>

			<span class="n">bytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
				      <span class="n">iov</span><span class="p">[</span><span class="n">iov_idx</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">-</span> <span class="n">iov_off</span><span class="p">,</span> <span class="n">bv_len</span><span class="p">);</span>
			<span class="n">iov_addr</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">iov_idx</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">iov_off</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">to_user</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">iov_addr</span><span class="p">,</span> <span class="n">bv_addr</span><span class="p">,</span>
							   <span class="n">bytes</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">from_user</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_from_user</span><span class="p">(</span><span class="n">bv_addr</span><span class="p">,</span> <span class="n">iov_addr</span><span class="p">,</span>
							     <span class="n">bytes</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bv_len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">bv_addr</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">iov_addr</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">iov_off</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="p">[</span><span class="n">iov_idx</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">==</span> <span class="n">iov_off</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">iov_idx</span><span class="o">++</span><span class="p">;</span>
				<span class="n">iov_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_free_page</span><span class="p">)</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_uncopy_user	-	finish previously mapped bio</span>
<span class="cm"> *	@bio: bio being terminated</span>
<span class="cm"> *</span>
<span class="cm"> *	Free pages allocated from bio_copy_user() and write back data</span>
<span class="cm"> *	to user space in case of a read.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_uncopy_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_map_data</span> <span class="o">*</span><span class="n">bmd</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_NULL_MAPPED</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__bio_copy_iov</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bmd</span><span class="o">-&gt;</span><span class="n">iovecs</span><span class="p">,</span> <span class="n">bmd</span><span class="o">-&gt;</span><span class="n">sgvecs</span><span class="p">,</span>
				     <span class="n">bmd</span><span class="o">-&gt;</span><span class="n">nr_sgvecs</span><span class="p">,</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">,</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="n">bmd</span><span class="o">-&gt;</span><span class="n">is_our_pages</span><span class="p">);</span>
	<span class="n">bio_free_map_data</span><span class="p">(</span><span class="n">bmd</span><span class="p">);</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_uncopy_user</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_copy_user_iov	-	copy user data to bio</span>
<span class="cm"> *	@q: destination block queue</span>
<span class="cm"> *	@map_data: pointer to the rq_map_data holding pages (if necessary)</span>
<span class="cm"> *	@iov:	the iovec.</span>
<span class="cm"> *	@iov_count: number of elements in the iovec</span>
<span class="cm"> *	@write_to_vm: bool indicating writing to pages or not</span>
<span class="cm"> *	@gfp_mask: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Prepares and returns a bio for indirect user io, bouncing data</span>
<span class="cm"> *	to/from kernel pages as necessary. Must be paired with</span>
<span class="cm"> *	call bio_uncopy_user() on io completion.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_copy_user_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">rq_map_data</span> <span class="o">*</span><span class="n">map_data</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iov_count</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">write_to_vm</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_map_data</span> <span class="o">*</span><span class="n">bmd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">map_data</span> <span class="o">?</span> <span class="n">map_data</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iov_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">;</span>

		<span class="n">uaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">+</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Overflow, abort</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

		<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">+=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span>
		<span class="n">nr_pages</span><span class="o">++</span><span class="p">;</span>

	<span class="n">bmd</span> <span class="o">=</span> <span class="n">bio_alloc_map_data</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">iov_count</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bmd</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_kmalloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bmd</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_to_vm</span><span class="p">)</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">|=</span> <span class="n">REQ_WRITE</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">map_data</span><span class="o">-&gt;</span><span class="n">page_order</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">map_data</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">/</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>

		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">map_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">map_data</span><span class="o">-&gt;</span><span class="n">nr_entries</span> <span class="o">*</span> <span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">page</span> <span class="o">=</span> <span class="n">map_data</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span> <span class="o">/</span> <span class="n">nr_pages</span><span class="p">];</span>
			<span class="n">page</span> <span class="o">+=</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="n">nr_pages</span><span class="p">);</span>

			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">bounce_gfp</span> <span class="o">|</span> <span class="n">gfp_mask</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_add_pc_page</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * success</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">write_to_vm</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">map_data</span> <span class="o">||</span> <span class="o">!</span><span class="n">map_data</span><span class="o">-&gt;</span><span class="n">null_mapped</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">map_data</span> <span class="o">&amp;&amp;</span> <span class="n">map_data</span><span class="o">-&gt;</span><span class="n">from_user</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__bio_copy_iov</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">iov_count</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bio_set_map_data</span><span class="p">(</span><span class="n">bmd</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">iov_count</span><span class="p">,</span> <span class="n">map_data</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="nl">cleanup:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map_data</span><span class="p">)</span>
		<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">__free_page</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>

	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="nl">out_bmd:</span>
	<span class="n">bio_free_map_data</span><span class="p">(</span><span class="n">bmd</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_copy_user	-	copy user data to bio</span>
<span class="cm"> *	@q: destination block queue</span>
<span class="cm"> *	@map_data: pointer to the rq_map_data holding pages (if necessary)</span>
<span class="cm"> *	@uaddr: start of user address</span>
<span class="cm"> *	@len: length in bytes</span>
<span class="cm"> *	@write_to_vm: bool indicating writing to pages or not</span>
<span class="cm"> *	@gfp_mask: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Prepares and returns a bio for indirect user io, bouncing data</span>
<span class="cm"> *	to/from kernel pages as necessary. Must be paired with</span>
<span class="cm"> *	call bio_uncopy_user() on io completion.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_copy_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rq_map_data</span> <span class="o">*</span><span class="n">map_data</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">write_to_vm</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_iovec</span> <span class="n">iov</span><span class="p">;</span>

	<span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio_copy_user_iov</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">map_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">write_to_vm</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_copy_user</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">__bio_map_user_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iov_count</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">write_to_vm</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cur_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iov_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Overflow, abort</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

		<span class="n">nr_pages</span> <span class="o">+=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * buffer must be aligned to at least hardsector size for now</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">&amp;</span> <span class="n">queue_dma_alignment</span><span class="p">(</span><span class="n">q</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_kmalloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">iov_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">uaddr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">local_nr_pages</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">page_limit</span> <span class="o">=</span> <span class="n">cur_page</span> <span class="o">+</span> <span class="n">local_nr_pages</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_user_pages_fast</span><span class="p">(</span><span class="n">uaddr</span><span class="p">,</span> <span class="n">local_nr_pages</span><span class="p">,</span>
				<span class="n">write_to_vm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pages</span><span class="p">[</span><span class="n">cur_page</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">local_nr_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unmap</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">uaddr</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">cur_page</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">page_limit</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">bytes</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * sorry...</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bio_add_pc_page</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">pages</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;</span>
					    <span class="n">bytes</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cur_page</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * release the pages we didn&#39;t map into the bio, if any</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">j</span> <span class="o">&lt;</span> <span class="n">page_limit</span><span class="p">)</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">j</span><span class="o">++</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * set data direction, and check if mapped pages need bouncing</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_to_vm</span><span class="p">)</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span> <span class="o">|=</span> <span class="n">REQ_WRITE</span><span class="p">;</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">bdev</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIO_USER_MAPPED</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>

 <span class="nl">out_unmap:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_map_user	-	map user address into bio</span>
<span class="cm"> *	@q: the struct request_queue for the bio</span>
<span class="cm"> *	@bdev: destination block device</span>
<span class="cm"> *	@uaddr: start of user address</span>
<span class="cm"> *	@len: length in bytes</span>
<span class="cm"> *	@write_to_vm: bool indicating writing to pages or not</span>
<span class="cm"> *	@gfp_mask: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Map the user space address into a bio suitable for io to a block</span>
<span class="cm"> *	device. Returns an error pointer in case of error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_map_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uaddr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write_to_vm</span><span class="p">,</span>
			 <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sg_iovec</span> <span class="n">iov</span><span class="p">;</span>

	<span class="n">iov</span><span class="p">.</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">uaddr</span><span class="p">;</span>
	<span class="n">iov</span><span class="p">.</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio_map_user_iov</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">write_to_vm</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_map_user</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_map_user_iov - map user sg_iovec table into bio</span>
<span class="cm"> *	@q: the struct request_queue for the bio</span>
<span class="cm"> *	@bdev: destination block device</span>
<span class="cm"> *	@iov:	the iovec.</span>
<span class="cm"> *	@iov_count: number of elements in the iovec</span>
<span class="cm"> *	@write_to_vm: bool indicating writing to pages or not</span>
<span class="cm"> *	@gfp_mask: memory allocation flags</span>
<span class="cm"> *</span>
<span class="cm"> *	Map the user space address into a bio suitable for io to a block</span>
<span class="cm"> *	device. Returns an error pointer in case of error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_map_user_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">sg_iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="kt">int</span> <span class="n">iov_count</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">write_to_vm</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">__bio_map_user_iov</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bdev</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">iov_count</span><span class="p">,</span> <span class="n">write_to_vm</span><span class="p">,</span>
				 <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * subtle -- if __bio_map_user() ended up bouncing a bio,</span>
<span class="cm">	 * it would normally disappear when its bi_end_io is run.</span>
<span class="cm">	 * however, we need it for the unmap, so grab an extra</span>
<span class="cm">	 * reference to it</span>
<span class="cm">	 */</span>
	<span class="n">bio_get</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__bio_unmap_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure we dirty pages we wrote to</span>
<span class="cm">	 */</span>
	<span class="n">__bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span>
			<span class="n">set_page_dirty_lock</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_unmap_user	-	unmap a bio</span>
<span class="cm"> *	@bio:		the bio being unmapped</span>
<span class="cm"> *</span>
<span class="cm"> *	Unmap a bio previously mapped by bio_map_user(). Must be called with</span>
<span class="cm"> *	a process context.</span>
<span class="cm"> *</span>
<span class="cm"> *	bio_unmap_user() may sleep.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_unmap_user</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__bio_unmap_user</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_unmap_user</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_map_kern_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">__bio_map_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span>
				  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">kaddr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span> <span class="o">=</span> <span class="n">kaddr</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_kmalloc</span><span class="p">(</span><span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_add_pc_page</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="n">bytes</span><span class="p">,</span>
				    <span class="n">offset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">data</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bio_map_kern_endio</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_map_kern	-	map kernel address into bio</span>
<span class="cm"> *	@q: the struct request_queue for the bio</span>
<span class="cm"> *	@data: pointer to buffer to map</span>
<span class="cm"> *	@len: length in bytes</span>
<span class="cm"> *	@gfp_mask: allocation flags for bio allocation</span>
<span class="cm"> *</span>
<span class="cm"> *	Map the kernel address into a bio suitable for io to a block</span>
<span class="cm"> *	device. Returns an error pointer in case of error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_map_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			 <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">__bio_map_kern</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t support partial mappings.</span>
<span class="cm">	 */</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EINVAL</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_map_kern</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_copy_kern_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">read</span> <span class="o">=</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_map_data</span> <span class="o">*</span><span class="n">bmd</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">bmd</span><span class="o">-&gt;</span><span class="n">sgvecs</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>

	<span class="n">__bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bmd</span><span class="o">-&gt;</span><span class="n">iovecs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">read</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">__free_page</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bio_free_map_data</span><span class="p">(</span><span class="n">bmd</span><span class="p">);</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	bio_copy_kern	-	copy kernel address into bio</span>
<span class="cm"> *	@q: the struct request_queue for the bio</span>
<span class="cm"> *	@data: pointer to buffer to copy</span>
<span class="cm"> *	@len: length in bytes</span>
<span class="cm"> *	@gfp_mask: allocation flags for bio and page allocation</span>
<span class="cm"> *	@reading: data direction is READ</span>
<span class="cm"> *</span>
<span class="cm"> *	copy the kernel address into a bio suitable for io to a block</span>
<span class="cm"> *	device. Returns an error pointer in case of error.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">bio_copy_kern</span><span class="p">(</span><span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span>
			  <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reading</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_copy_user</span><span class="p">(</span><span class="n">q</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">reading</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>

		<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">addr</span> <span class="o">=</span> <span class="n">page_address</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">);</span>
			<span class="n">p</span> <span class="o">+=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bio_copy_kern_endio</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bio</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_copy_kern</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * bio_set_pages_dirty() and bio_check_pages_dirty() are support functions</span>
<span class="cm"> * for performing direct-IO in BIOs.</span>
<span class="cm"> *</span>
<span class="cm"> * The problem is that we cannot run set_page_dirty() from interrupt context</span>
<span class="cm"> * because the required locks are not interrupt-safe.  So what we can do is to</span>
<span class="cm"> * mark the pages dirty _before_ performing IO.  And in interrupt context,</span>
<span class="cm"> * check that the pages are still dirty.   If so, fine.  If not, redirty them</span>
<span class="cm"> * in process context.</span>
<span class="cm"> *</span>
<span class="cm"> * We special-case compound pages here: normally this means reads into hugetlb</span>
<span class="cm"> * pages.  The logic in here doesn&#39;t really work right for compound pages</span>
<span class="cm"> * because the VM does not uniformly chase down the head page in all cases.</span>
<span class="cm"> * But dirtiness of compound pages is pretty meaningless anyway: the VM doesn&#39;t</span>
<span class="cm"> * handle them at all.  So we skip compound pages here at an early stage.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this code is very hard to test under normal circumstances because</span>
<span class="cm"> * direct-io pins the pages with get_user_pages().  This makes</span>
<span class="cm"> * is_page_cache_freeable return false, and the VM will not clean the pages.</span>
<span class="cm"> * But other code (eg, pdflush) could clean the pages if they are mapped</span>
<span class="cm"> * pagecache.</span>
<span class="cm"> *</span>
<span class="cm"> * Simply disabling the call to bio_set_pages_dirty() is a good way to test the</span>
<span class="cm"> * deferred bio dirtying paths.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * bio_set_pages_dirty() will mark all the bio&#39;s pages as dirty.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_set_pages_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">set_page_dirty_lock</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_release_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * bio_check_pages_dirty() will check that all the BIO&#39;s pages are still dirty.</span>
<span class="cm"> * If they are, then fine.  If, however, some pages are clean then they must</span>
<span class="cm"> * have been written out during the direct-IO read.  So we take another ref on</span>
<span class="cm"> * the BIO and the offending pages and re-dirty the pages in process context.</span>
<span class="cm"> *</span>
<span class="cm"> * It is expected that bio_check_pages_dirty() will wholly own the BIO from</span>
<span class="cm"> * here on.  It will run one page_cache_release() against each page and will</span>
<span class="cm"> * run one bio_put() against the BIO.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">bio_dirty_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">static</span> <span class="n">DECLARE_WORK</span><span class="p">(</span><span class="n">bio_dirty_work</span><span class="p">,</span> <span class="n">bio_dirty_fn</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">bio_dirty_lock</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_dirty_list</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This runs in process context</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_dirty_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_dirty_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_dirty_list</span><span class="p">;</span>
	<span class="n">bio_dirty_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_dirty_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

		<span class="n">bio_set_pages_dirty</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">bio_release_pages</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bio_check_pages_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_clean_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bvec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageCompound</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">bvec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nr_clean_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_clean_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_dirty_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">bio_dirty_list</span><span class="p">;</span>
		<span class="n">bio_dirty_list</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
		<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_dirty_lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bio_dirty_work</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE</span>
<span class="kt">void</span> <span class="nf">bio_flush_dcache_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span><span class="p">;</span>

	<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bvec</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_flush_dcache_pages</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> * bio_endio - end I/O on a bio</span>
<span class="cm"> * @bio:	bio</span>
<span class="cm"> * @error:	error, if any</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   bio_endio() will end I/O on the whole bio. bio_endio() is the</span>
<span class="cm"> *   preferred way to end I/O on a bio, it takes care of clearing</span>
<span class="cm"> *   BIO_UPTODATE on error. @error is 0 on success, and and one of the</span>
<span class="cm"> *   established -Exxxx (-EIO, for instance) error values in case</span>
<span class="cm"> *   something went wrong. No one should call bi_end_io() directly on a</span>
<span class="cm"> *   bio unless they own it and thus know that it has an end_io</span>
<span class="cm"> *   function.</span>
<span class="cm"> **/</span>
<span class="kt">void</span> <span class="nf">bio_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">)</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_endio</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bio_pair_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">bp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">master</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span><span class="p">.</span><span class="n">bi_private</span><span class="p">;</span>

		<span class="n">bio_endio</span><span class="p">(</span><span class="n">master</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">);</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_private</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_pair_release</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_pair_end_1</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_pair</span><span class="p">,</span> <span class="n">bio1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">bio_pair_release</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_pair_end_2</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_pair</span><span class="p">,</span> <span class="n">bio2</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">bp</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">bio_pair_release</span><span class="p">(</span><span class="n">bp</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * split a bio - only worry about a bio with a single page in its iovec</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="nf">bio_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span> <span class="kt">int</span> <span class="n">first_sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">bio_split_pool</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bp</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>

	<span class="n">trace_block_split</span><span class="p">(</span><span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">),</span> <span class="n">bi</span><span class="p">,</span>
				<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">+</span> <span class="n">first_sectors</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">cnt</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span> <span class="o">=</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span> <span class="o">=</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_sector</span> <span class="o">+=</span> <span class="n">first_sectors</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_size</span> <span class="o">-=</span> <span class="n">first_sectors</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span><span class="p">.</span><span class="n">bi_size</span> <span class="o">=</span> <span class="n">first_sectors</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bv1</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bv2</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bv2</span><span class="p">.</span><span class="n">bv_offset</span> <span class="o">+=</span> <span class="n">first_sectors</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bv2</span><span class="p">.</span><span class="n">bv_len</span> <span class="o">-=</span> <span class="n">first_sectors</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bv1</span><span class="p">.</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">first_sectors</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span><span class="p">.</span><span class="n">bi_io_vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bv1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_io_vec</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bv2</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span><span class="p">.</span><span class="n">bi_max_vecs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_max_vecs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span><span class="p">.</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bio_pair_end_1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bio_pair_end_2</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span><span class="p">.</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">bi</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">bio_split_pool</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bi</span><span class="p">))</span>
		<span class="n">bio_integrity_split</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">bp</span><span class="p">,</span> <span class="n">first_sectors</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bp</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_split</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *      bio_sector_offset - Find hardware sector offset in bio</span>
<span class="cm"> *      @bio:           bio to inspect</span>
<span class="cm"> *      @index:         bio_vec index</span>
<span class="cm"> *      @offset:        offset in bv_page</span>
<span class="cm"> *</span>
<span class="cm"> *      Return the number of hardware sectors between beginning of bio</span>
<span class="cm"> *      and an end point indicated by a bio_vec index and an offset</span>
<span class="cm"> *      within that vector&#39;s page.</span>
<span class="cm"> */</span>
<span class="n">sector_t</span> <span class="nf">bio_sector_offset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">index</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sector_sz</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sectors</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">sector_sz</span> <span class="o">=</span> <span class="n">queue_logical_block_size</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">queue</span><span class="p">);</span>
	<span class="n">sectors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">__bio_for_each_segment</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">)</span>
				<span class="n">sectors</span> <span class="o">+=</span> <span class="p">(</span><span class="n">offset</span> <span class="o">-</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">)</span> <span class="o">/</span> <span class="n">sector_sz</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sectors</span> <span class="o">+=</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">/</span> <span class="n">sector_sz</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sectors</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_sector_offset</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * create memory pools for biovec&#39;s in a bio_set.</span>
<span class="cm"> * use the global biovec slabs created for general use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">biovec_create_pools</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_entries</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">biovec_slab</span> <span class="o">*</span><span class="n">bp</span> <span class="o">=</span> <span class="n">bvec_slabs</span> <span class="o">+</span> <span class="n">BIOVEC_MAX_IDX</span><span class="p">;</span>

	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bvec_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">pool_entries</span><span class="p">,</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">slab</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bvec_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">biovec_free_pools</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bvec_pool</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bioset_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_pool</span><span class="p">)</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_pool</span><span class="p">);</span>

	<span class="n">bioset_integrity_free</span><span class="p">(</span><span class="n">bs</span><span class="p">);</span>
	<span class="n">biovec_free_pools</span><span class="p">(</span><span class="n">bs</span><span class="p">);</span>
	<span class="n">bio_put_slab</span><span class="p">(</span><span class="n">bs</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bs</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bioset_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bioset_create  - Create a bio_set</span>
<span class="cm"> * @pool_size:	Number of bio and bio_vecs to cache in the mempool</span>
<span class="cm"> * @front_pad:	Number of bytes to allocate in front of the returned bio</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *    Set up a bio_set to be used with @bio_alloc_bioset. Allows the caller</span>
<span class="cm"> *    to ask for a number of bytes to be allocated in front of the bio.</span>
<span class="cm"> *    Front pad allocation is useful for embedding the bio inside</span>
<span class="cm"> *    another structure, to avoid allocating extra data to go with the bio.</span>
<span class="cm"> *    Note that the bio must be embedded at the END of that structure always,</span>
<span class="cm"> *    or things will break badly.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="nf">bioset_create</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">pool_size</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">front_pad</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">back_pad</span> <span class="o">=</span> <span class="n">BIO_INLINE_VECS</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">;</span>

	<span class="n">bs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bs</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">front_pad</span> <span class="o">=</span> <span class="n">front_pad</span><span class="p">;</span>

	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_slab</span> <span class="o">=</span> <span class="n">bio_find_or_create_slab</span><span class="p">(</span><span class="n">front_pad</span> <span class="o">+</span> <span class="n">back_pad</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_slab</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bs</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_pool</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">pool_size</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_slab</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_pool</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">bad</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">biovec_create_pools</span><span class="p">(</span><span class="n">bs</span><span class="p">,</span> <span class="n">pool_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">bs</span><span class="p">;</span>

<span class="nl">bad:</span>
	<span class="n">bioset_free</span><span class="p">(</span><span class="n">bs</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bioset_create</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_BLK_CGROUP</span>
<span class="cm">/**</span>
<span class="cm"> * bio_associate_current - associate a bio with %current</span>
<span class="cm"> * @bio: target bio</span>
<span class="cm"> *</span>
<span class="cm"> * Associate @bio with %current if it hasn&#39;t been associated yet.  Block</span>
<span class="cm"> * layer will treat @bio as if it were issued by %current no matter which</span>
<span class="cm"> * task actually issues it.</span>
<span class="cm"> *</span>
<span class="cm"> * This function takes an extra reference of @task&#39;s io_context and blkcg</span>
<span class="cm"> * which will be put when @bio is released.  The caller must own @bio,</span>
<span class="cm"> * ensure %current-&gt;io_context exists, and is responsible for synchronizing</span>
<span class="cm"> * calls to this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_associate_current</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">io_context</span> <span class="o">*</span><span class="n">ioc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">css</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>

	<span class="n">ioc</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">io_context</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ioc</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="cm">/* acquire active ref on @ioc and associate */</span>
	<span class="n">get_io_context_active</span><span class="p">(</span><span class="n">ioc</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_ioc</span> <span class="o">=</span> <span class="n">ioc</span><span class="p">;</span>

	<span class="cm">/* associate blkcg if exists */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">css</span> <span class="o">=</span> <span class="n">task_subsys_state</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">blkio_subsys_id</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">css</span> <span class="o">&amp;&amp;</span> <span class="n">css_tryget</span><span class="p">(</span><span class="n">css</span><span class="p">))</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_css</span> <span class="o">=</span> <span class="n">css</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_disassociate_task - undo bio_associate_current()</span>
<span class="cm"> * @bio: target bio</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_disassociate_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_ioc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_io_context</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_ioc</span><span class="p">);</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_ioc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_css</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">css_put</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_css</span><span class="p">);</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_css</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* CONFIG_BLK_CGROUP */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__init</span> <span class="nf">biovec_init_slabs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BIOVEC_NR_POOLS</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">biovec_slab</span> <span class="o">*</span><span class="n">bvs</span> <span class="o">=</span> <span class="n">bvec_slabs</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bvs</span><span class="o">-&gt;</span><span class="n">nr_vecs</span> <span class="o">&lt;=</span> <span class="n">BIO_INLINE_VECS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bvs</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">bvs</span><span class="o">-&gt;</span><span class="n">nr_vecs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">);</span>
		<span class="n">bvs</span><span class="o">-&gt;</span><span class="n">slab</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">bvs</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                <span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_bio</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bio_slab_max</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">bio_slab_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bio_slabs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">bio_slab_max</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_slab</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio_slabs</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;bio: can&#39;t allocate bios</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">bio_integrity_init</span><span class="p">();</span>
	<span class="n">biovec_init_slabs</span><span class="p">();</span>

	<span class="n">fs_bio_set</span> <span class="o">=</span> <span class="n">bioset_create</span><span class="p">(</span><span class="n">BIO_POOL_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fs_bio_set</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;bio: can&#39;t allocate bios</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bioset_integrity_create</span><span class="p">(</span><span class="n">fs_bio_set</span><span class="p">,</span> <span class="n">BIO_POOL_SIZE</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;bio: can&#39;t create integrity pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">bio_split_pool</span> <span class="o">=</span> <span class="n">mempool_create_kmalloc_pool</span><span class="p">(</span><span class="n">BIO_SPLIT_ENTRIES</span><span class="p">,</span>
						     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_pair</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio_split_pool</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;bio: can&#39;t create split pool</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">subsys_initcall</span><span class="p">(</span><span class="n">init_bio</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
