<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › fuse › fuse_i.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>fuse_i.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  FUSE: Filesystem in Userspace</span>
<span class="cm">  Copyright (C) 2001-2008  Miklos Szeredi &lt;miklos@szeredi.hu&gt;</span>

<span class="cm">  This program can be distributed under the terms of the GNU GPL.</span>
<span class="cm">  See the file COPYING.</span>
<span class="cm">*/</span>

<span class="cp">#ifndef _FS_FUSE_I_H</span>
<span class="cp">#define _FS_FUSE_I_H</span>

<span class="cp">#include &lt;linux/fuse.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/wait.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/rwsem.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>

<span class="cm">/** Max number of pages that can be used in a single read request */</span>
<span class="cp">#define FUSE_MAX_PAGES_PER_REQ 32</span>

<span class="cm">/** Bias for fi-&gt;writectr, meaning new writepages must not be sent */</span>
<span class="cp">#define FUSE_NOWRITE INT_MIN</span>

<span class="cm">/** It could be as large as PATH_MAX, but would that have any uses? */</span>
<span class="cp">#define FUSE_NAME_MAX 1024</span>

<span class="cm">/** Number of dentries for each connection in the control filesystem */</span>
<span class="cp">#define FUSE_CTL_NUM_DENTRIES 5</span>

<span class="cm">/** If the FUSE_DEFAULT_PERMISSIONS flag is given, the filesystem</span>
<span class="cm">    module will check permissions based on the file mode.  Otherwise no</span>
<span class="cm">    permission checking is done in the kernel */</span>
<span class="cp">#define FUSE_DEFAULT_PERMISSIONS (1 &lt;&lt; 0)</span>

<span class="cm">/** If the FUSE_ALLOW_OTHER flag is given, then not only the user</span>
<span class="cm">    doing the mount will be allowed to access the filesystem */</span>
<span class="cp">#define FUSE_ALLOW_OTHER         (1 &lt;&lt; 1)</span>

<span class="cm">/** List of active connections */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">fuse_conn_list</span><span class="p">;</span>

<span class="cm">/** Global mutex protecting fuse_conn_list and the control filesystem */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">fuse_mutex</span><span class="p">;</span>

<span class="cm">/** Module parameters */</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">max_user_bgreq</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="n">max_user_congthresh</span><span class="p">;</span>

<span class="cm">/* One forget request */</span>
<span class="k">struct</span> <span class="n">fuse_forget_link</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">fuse_forget_one</span> <span class="n">forget_one</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fuse_forget_link</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** FUSE inode */</span>
<span class="k">struct</span> <span class="n">fuse_inode</span> <span class="p">{</span>
	<span class="cm">/** Inode data */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">inode</span><span class="p">;</span>

	<span class="cm">/** Unique ID, which identifies the inode between userspace</span>
<span class="cm">	 * and kernel */</span>
	<span class="n">u64</span> <span class="n">nodeid</span><span class="p">;</span>

	<span class="cm">/** Number of lookups on this inode */</span>
	<span class="n">u64</span> <span class="n">nlookup</span><span class="p">;</span>

	<span class="cm">/** The request used for sending the FORGET message */</span>
	<span class="k">struct</span> <span class="n">fuse_forget_link</span> <span class="o">*</span><span class="n">forget</span><span class="p">;</span>

	<span class="cm">/** Time in jiffies until the file attributes are valid */</span>
	<span class="n">u64</span> <span class="n">i_time</span><span class="p">;</span>

	<span class="cm">/** The sticky bit in inode-&gt;i_mode may have been removed, so</span>
<span class="cm">	    preserve the original mode */</span>
	<span class="n">umode_t</span> <span class="n">orig_i_mode</span><span class="p">;</span>

	<span class="cm">/** 64 bit inode number */</span>
	<span class="n">u64</span> <span class="n">orig_ino</span><span class="p">;</span>

	<span class="cm">/** Version of last attribute change */</span>
	<span class="n">u64</span> <span class="n">attr_version</span><span class="p">;</span>

	<span class="cm">/** Files usable in writepage.  Protected by fc-&gt;lock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">write_files</span><span class="p">;</span>

	<span class="cm">/** Writepages pending on truncate or fsync */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">queued_writes</span><span class="p">;</span>

	<span class="cm">/** Number of sent writes, a negative bias (FUSE_NOWRITE)</span>
<span class="cm">	 * means more writes are blocked */</span>
	<span class="kt">int</span> <span class="n">writectr</span><span class="p">;</span>

	<span class="cm">/** Waitq for writepage completion */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">page_waitq</span><span class="p">;</span>

	<span class="cm">/** List of writepage requestst (pending or sent) */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">writepages</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">fuse_conn</span><span class="p">;</span>

<span class="cm">/** FUSE specific file data */</span>
<span class="k">struct</span> <span class="n">fuse_file</span> <span class="p">{</span>
	<span class="cm">/** Fuse connection for this file */</span>
	<span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">;</span>

	<span class="cm">/** Request reserved for flush and release */</span>
	<span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">reserved_req</span><span class="p">;</span>

	<span class="cm">/** Kernel file handle guaranteed to be unique */</span>
	<span class="n">u64</span> <span class="n">kh</span><span class="p">;</span>

	<span class="cm">/** File handle used by userspace */</span>
	<span class="n">u64</span> <span class="n">fh</span><span class="p">;</span>

	<span class="cm">/** Node id of this file */</span>
	<span class="n">u64</span> <span class="n">nodeid</span><span class="p">;</span>

	<span class="cm">/** Refcount */</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/** FOPEN_* flags returned by open */</span>
	<span class="n">u32</span> <span class="n">open_flags</span><span class="p">;</span>

	<span class="cm">/** Entry on inode&#39;s write_files list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">write_entry</span><span class="p">;</span>

	<span class="cm">/** RB node to be linked on fuse_conn-&gt;polled_files */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">polled_node</span><span class="p">;</span>

	<span class="cm">/** Wait queue head for poll */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">poll_wait</span><span class="p">;</span>

	<span class="cm">/** Has flock been performed on this file? */</span>
	<span class="n">bool</span> <span class="n">flock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** One input argument of a request */</span>
<span class="k">struct</span> <span class="n">fuse_in_arg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** The request input */</span>
<span class="k">struct</span> <span class="n">fuse_in</span> <span class="p">{</span>
	<span class="cm">/** The request header */</span>
	<span class="k">struct</span> <span class="n">fuse_in_header</span> <span class="n">h</span><span class="p">;</span>

	<span class="cm">/** True if the data for the last argument is in req-&gt;pages */</span>
	<span class="kt">unsigned</span> <span class="n">argpages</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Number of arguments */</span>
	<span class="kt">unsigned</span> <span class="n">numargs</span><span class="p">;</span>

	<span class="cm">/** Array of arguments */</span>
	<span class="k">struct</span> <span class="n">fuse_in_arg</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/** One output argument of a request */</span>
<span class="k">struct</span> <span class="n">fuse_arg</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/** The request output */</span>
<span class="k">struct</span> <span class="n">fuse_out</span> <span class="p">{</span>
	<span class="cm">/** Header returned from userspace */</span>
	<span class="k">struct</span> <span class="n">fuse_out_header</span> <span class="n">h</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following bitfields are not changed during the request</span>
<span class="cm">	 * processing</span>
<span class="cm">	 */</span>

	<span class="cm">/** Last argument is variable length (can be shorter than</span>
<span class="cm">	    arg-&gt;size) */</span>
	<span class="kt">unsigned</span> <span class="n">argvar</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Last argument is a list of pages to copy data to */</span>
	<span class="kt">unsigned</span> <span class="n">argpages</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Zero partially or not copied pages */</span>
	<span class="kt">unsigned</span> <span class="n">page_zeroing</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Pages may be replaced with new ones */</span>
	<span class="kt">unsigned</span> <span class="n">page_replace</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Number or arguments */</span>
	<span class="kt">unsigned</span> <span class="n">numargs</span><span class="p">;</span>

	<span class="cm">/** Array of arguments */</span>
	<span class="k">struct</span> <span class="n">fuse_arg</span> <span class="n">args</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/** The request state */</span>
<span class="k">enum</span> <span class="n">fuse_req_state</span> <span class="p">{</span>
	<span class="n">FUSE_REQ_INIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">FUSE_REQ_PENDING</span><span class="p">,</span>
	<span class="n">FUSE_REQ_READING</span><span class="p">,</span>
	<span class="n">FUSE_REQ_SENT</span><span class="p">,</span>
	<span class="n">FUSE_REQ_WRITING</span><span class="p">,</span>
	<span class="n">FUSE_REQ_FINISHED</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * A request to the client</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fuse_req</span> <span class="p">{</span>
	<span class="cm">/** This can be on either pending processing or io lists in</span>
<span class="cm">	    fuse_conn */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>

	<span class="cm">/** Entry on the interrupts list  */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">intr_entry</span><span class="p">;</span>

	<span class="cm">/** refcount */</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/** Unique ID for the interrupt request */</span>
	<span class="n">u64</span> <span class="n">intr_unique</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following bitfields are either set once before the</span>
<span class="cm">	 * request is queued or setting/clearing them is protected by</span>
<span class="cm">	 * fuse_conn-&gt;lock</span>
<span class="cm">	 */</span>

	<span class="cm">/** True if the request has reply */</span>
	<span class="kt">unsigned</span> <span class="n">isreply</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Force sending of the request even if interrupted */</span>
	<span class="kt">unsigned</span> <span class="n">force</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** The request was aborted */</span>
	<span class="kt">unsigned</span> <span class="n">aborted</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Request is sent in the background */</span>
	<span class="kt">unsigned</span> <span class="n">background</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** The request has been interrupted */</span>
	<span class="kt">unsigned</span> <span class="n">interrupted</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Data is being copied to/from the request */</span>
	<span class="kt">unsigned</span> <span class="n">locked</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Request is counted as &quot;waiting&quot; */</span>
	<span class="kt">unsigned</span> <span class="n">waiting</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** State of the request */</span>
	<span class="k">enum</span> <span class="n">fuse_req_state</span> <span class="n">state</span><span class="p">;</span>

	<span class="cm">/** The request input */</span>
	<span class="k">struct</span> <span class="n">fuse_in</span> <span class="n">in</span><span class="p">;</span>

	<span class="cm">/** The request output */</span>
	<span class="k">struct</span> <span class="n">fuse_out</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/** Used to wake up the task waiting for completion of request*/</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitq</span><span class="p">;</span>

	<span class="cm">/** Data for asynchronous requests */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">union</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">fuse_release_in</span> <span class="n">in</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">work</span><span class="p">;</span>
			<span class="p">};</span>
			<span class="k">struct</span> <span class="n">path</span> <span class="n">path</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">release</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fuse_init_in</span> <span class="n">init_in</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fuse_init_out</span> <span class="n">init_out</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cuse_init_in</span> <span class="n">cuse_init_in</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fuse_read_in</span> <span class="n">in</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">attr_ver</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">read</span><span class="p">;</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">fuse_write_in</span> <span class="n">in</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">fuse_write_out</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">write</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fuse_notify_retrieve_in</span> <span class="n">retrieve_in</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">fuse_lk_in</span> <span class="n">lk_in</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">misc</span><span class="p">;</span>

	<span class="cm">/** page vector */</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">pages</span><span class="p">[</span><span class="n">FUSE_MAX_PAGES_PER_REQ</span><span class="p">];</span>

	<span class="cm">/** number of pages in vector */</span>
	<span class="kt">unsigned</span> <span class="n">num_pages</span><span class="p">;</span>

	<span class="cm">/** offset of data on first page */</span>
	<span class="kt">unsigned</span> <span class="n">page_offset</span><span class="p">;</span>

	<span class="cm">/** File used in the request (or NULL) */</span>
	<span class="k">struct</span> <span class="n">fuse_file</span> <span class="o">*</span><span class="n">ff</span><span class="p">;</span>

	<span class="cm">/** Inode used in the request or NULL */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="cm">/** Link on fi-&gt;writepages */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">writepages_entry</span><span class="p">;</span>

	<span class="cm">/** Request completion callback */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/** Request is stolen from fuse_file-&gt;reserved_req */</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">stolen_file</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * A Fuse connection.</span>
<span class="cm"> *</span>
<span class="cm"> * This structure is created, when the filesystem is mounted, and is</span>
<span class="cm"> * destroyed, when the client device is closed and the filesystem is</span>
<span class="cm"> * unmounted.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fuse_conn</span> <span class="p">{</span>
	<span class="cm">/** Lock protecting accessess to  members of this structure */</span>
	<span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/** Mutex protecting against directory alias creation */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">inst_mutex</span><span class="p">;</span>

	<span class="cm">/** Refcount */</span>
	<span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>

	<span class="cm">/** The user id for this mount */</span>
	<span class="n">uid_t</span> <span class="n">user_id</span><span class="p">;</span>

	<span class="cm">/** The group id for this mount */</span>
	<span class="n">gid_t</span> <span class="n">group_id</span><span class="p">;</span>

	<span class="cm">/** The fuse mount flags for this mount */</span>
	<span class="kt">unsigned</span> <span class="n">flags</span><span class="p">;</span>

	<span class="cm">/** Maximum read size */</span>
	<span class="kt">unsigned</span> <span class="n">max_read</span><span class="p">;</span>

	<span class="cm">/** Maximum write size */</span>
	<span class="kt">unsigned</span> <span class="n">max_write</span><span class="p">;</span>

	<span class="cm">/** Readers of the connection are waiting on this */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">waitq</span><span class="p">;</span>

	<span class="cm">/** The list of pending requests */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pending</span><span class="p">;</span>

	<span class="cm">/** The list of requests being processed */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">processing</span><span class="p">;</span>

	<span class="cm">/** The list of requests under I/O */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">io</span><span class="p">;</span>

	<span class="cm">/** The next unique kernel file handle */</span>
	<span class="n">u64</span> <span class="n">khctr</span><span class="p">;</span>

	<span class="cm">/** rbtree of fuse_files waiting for poll events indexed by ph */</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">polled_files</span><span class="p">;</span>

	<span class="cm">/** Maximum number of outstanding background requests */</span>
	<span class="kt">unsigned</span> <span class="n">max_background</span><span class="p">;</span>

	<span class="cm">/** Number of background requests at which congestion starts */</span>
	<span class="kt">unsigned</span> <span class="n">congestion_threshold</span><span class="p">;</span>

	<span class="cm">/** Number of requests currently in the background */</span>
	<span class="kt">unsigned</span> <span class="n">num_background</span><span class="p">;</span>

	<span class="cm">/** Number of background requests currently queued for userspace */</span>
	<span class="kt">unsigned</span> <span class="n">active_background</span><span class="p">;</span>

	<span class="cm">/** The list of background requests set aside for later queuing */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">bg_queue</span><span class="p">;</span>

	<span class="cm">/** Pending interrupts */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">interrupts</span><span class="p">;</span>

	<span class="cm">/** Queue of pending forgets */</span>
	<span class="k">struct</span> <span class="n">fuse_forget_link</span> <span class="n">forget_list_head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fuse_forget_link</span> <span class="o">*</span><span class="n">forget_list_tail</span><span class="p">;</span>

	<span class="cm">/** Batching of FORGET requests (positive indicates FORGET batch) */</span>
	<span class="kt">int</span> <span class="n">forget_batch</span><span class="p">;</span>

	<span class="cm">/** Flag indicating if connection is blocked.  This will be</span>
<span class="cm">	    the case before the INIT reply is received, and if there</span>
<span class="cm">	    are too many outstading backgrounds requests */</span>
	<span class="kt">int</span> <span class="n">blocked</span><span class="p">;</span>

	<span class="cm">/** waitq for blocked connection */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">blocked_waitq</span><span class="p">;</span>

	<span class="cm">/** waitq for reserved requests */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">reserved_req_waitq</span><span class="p">;</span>

	<span class="cm">/** The next unique request id */</span>
	<span class="n">u64</span> <span class="n">reqctr</span><span class="p">;</span>

	<span class="cm">/** Connection established, cleared on umount, connection</span>
<span class="cm">	    abort and device release */</span>
	<span class="kt">unsigned</span> <span class="n">connected</span><span class="p">;</span>

	<span class="cm">/** Connection failed (version mismatch).  Cannot race with</span>
<span class="cm">	    setting other bitfields since it is only set once in INIT</span>
<span class="cm">	    reply, before any other request, and never cleared */</span>
	<span class="kt">unsigned</span> <span class="n">conn_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Connection successful.  Only set in INIT */</span>
	<span class="kt">unsigned</span> <span class="n">conn_init</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Do readpages asynchronously?  Only set in INIT */</span>
	<span class="kt">unsigned</span> <span class="n">async_read</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Do not send separate SETATTR request before open(O_TRUNC)  */</span>
	<span class="kt">unsigned</span> <span class="n">atomic_o_trunc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Filesystem supports NFS exporting.  Only set in INIT */</span>
	<span class="kt">unsigned</span> <span class="n">export_support</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Set if bdi is valid */</span>
	<span class="kt">unsigned</span> <span class="n">bdi_initialized</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The following bitfields are only for optimization purposes</span>
<span class="cm">	 * and hence races in setting them will not cause malfunction</span>
<span class="cm">	 */</span>

	<span class="cm">/** Is fsync not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_fsync</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is fsyncdir not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_fsyncdir</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is flush not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_flush</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is setxattr not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_setxattr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is getxattr not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_getxattr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is listxattr not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_listxattr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is removexattr not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_removexattr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Are posix file locking primitives not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_lock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is access not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_access</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is create not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_create</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is interrupt not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_interrupt</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is bmap not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_bmap</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is poll not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_poll</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Do multi-page cached writes */</span>
	<span class="kt">unsigned</span> <span class="n">big_writes</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Don&#39;t apply umask to creation modes */</span>
	<span class="kt">unsigned</span> <span class="n">dont_mask</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Are BSD file locking primitives not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_flock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** Is fallocate not implemented by fs? */</span>
	<span class="kt">unsigned</span> <span class="n">no_fallocate</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/** The number of requests waiting for completion */</span>
	<span class="n">atomic_t</span> <span class="n">num_waiting</span><span class="p">;</span>

	<span class="cm">/** Negotiated minor version */</span>
	<span class="kt">unsigned</span> <span class="n">minor</span><span class="p">;</span>

	<span class="cm">/** Backing dev info */</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="n">bdi</span><span class="p">;</span>

	<span class="cm">/** Entry on the fuse_conn_list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">entry</span><span class="p">;</span>

	<span class="cm">/** Device ID from super block */</span>
	<span class="n">dev_t</span> <span class="n">dev</span><span class="p">;</span>

	<span class="cm">/** Dentries in the control filesystem */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ctl_dentry</span><span class="p">[</span><span class="n">FUSE_CTL_NUM_DENTRIES</span><span class="p">];</span>

	<span class="cm">/** number of dentries used in the above array */</span>
	<span class="kt">int</span> <span class="n">ctl_ndents</span><span class="p">;</span>

	<span class="cm">/** O_ASYNC requests */</span>
	<span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">fasync</span><span class="p">;</span>

	<span class="cm">/** Key for lock owner ID scrambling */</span>
	<span class="n">u32</span> <span class="n">scramble_key</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>

	<span class="cm">/** Reserved request for the DESTROY message */</span>
	<span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">destroy_req</span><span class="p">;</span>

	<span class="cm">/** Version counter for attribute changes */</span>
	<span class="n">u64</span> <span class="n">attr_version</span><span class="p">;</span>

	<span class="cm">/** Called on final put */</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">release</span><span class="p">)(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="p">);</span>

	<span class="cm">/** Super block for this connection. */</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>

	<span class="cm">/** Read/write semaphore to hold when accessing sb. */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span> <span class="n">killsb</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="nf">get_fuse_conn_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="nf">get_fuse_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_fuse_conn_super</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">fuse_inode</span> <span class="o">*</span><span class="nf">get_fuse_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_inode</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u64</span> <span class="nf">get_node_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">get_fuse_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/** Device operations */</span>
<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">fuse_dev_operations</span><span class="p">;</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">fuse_dentry_operations</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * Inode to nodeid comparison.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_inode_eq</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_nodeidp</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Get a filled in inode</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">fuse_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nodeid</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">generation</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">attr_valid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">attr_version</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">fuse_lookup_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nodeid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">fuse_entry_out</span> <span class="o">*</span><span class="n">outarg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">**</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Send FORGET command</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_queue_forget</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_forget_link</span> <span class="o">*</span><span class="n">forget</span><span class="p">,</span>
		       <span class="n">u64</span> <span class="n">nodeid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nlookup</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">fuse_forget_link</span> <span class="o">*</span><span class="n">fuse_alloc_forget</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize READ or READDIR request</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_read_fill</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">req</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		    <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Send OPEN or OPENDIR request</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_open_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">bool</span> <span class="n">isdir</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">fuse_file</span> <span class="o">*</span><span class="n">fuse_file_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">fuse_file</span> <span class="o">*</span><span class="n">fuse_file_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_file</span> <span class="o">*</span><span class="n">ff</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fuse_file_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_file</span> <span class="o">*</span><span class="n">ff</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fuse_finish_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_sync_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_file</span> <span class="o">*</span><span class="n">ff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Send RELEASE or RELEASEDIR request</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_release_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opcode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Send FSYNC or FSYNCDIR request</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_fsync_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">datasync</span><span class="p">,</span> <span class="kt">int</span> <span class="n">isdir</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Notify poll wakeup</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_notify_poll_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">fuse_notify_poll_wakeup_out</span> <span class="o">*</span><span class="n">outarg</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize file operations on a regular file</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_init_file_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize inode operations on regular files and special files</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_init_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize inode and file operations on a directory</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_init_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize inode operations on a symlink</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_init_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Change attributes of an inode</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_change_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">attr_valid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">attr_version</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_change_attributes_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_attr</span> <span class="o">*</span><span class="n">attr</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">attr_valid</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize the client device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_dev_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Cleanup the client device</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_dev_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">fuse_ctl_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fuse_ctl_cleanup</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Allocate a request</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">fuse_request_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">fuse_request_alloc_nofs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Free a request</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_request_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Get a request, may fail with -ENOMEM</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">fuse_get_req</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Gets a requests for a file operation, always succeeds</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">fuse_get_req_nofail</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Decrement reference count of a request.  If count goes to zero free</span>
<span class="cm"> * the request.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_put_request</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Send a request (synchronous)</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_request_send</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Send a request in the background</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_request_send_background</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_request_send_background_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">fuse_req</span> <span class="o">*</span><span class="n">req</span><span class="p">);</span>

<span class="cm">/* Abort all requests */</span>
<span class="kt">void</span> <span class="n">fuse_abort_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Invalidate inode attributes</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_invalidate_attr</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_invalidate_entry_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">entry</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Acquire reference to fuse_conn</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fuse_conn_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_conn_kill</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Initialize fuse_conn</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_conn_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Release reference to fuse_conn</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_conn_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Add connection to control filesystem</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_ctl_add_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Remove connection from control filesystem</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="n">fuse_ctl_remove_conn</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Is file type valid?</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_valid_type</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * Is task allowed to perform filesystem operation?</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_allow_task</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">);</span>

<span class="n">u64</span> <span class="n">fuse_lock_owner_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">fuse_update_attributes</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">bool</span> <span class="o">*</span><span class="n">refreshed</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_flush_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_set_nowrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">fuse_release_nowrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="n">u64</span> <span class="n">fuse_get_attr_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * File-system tells the kernel to invalidate cache for the given node id.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_reverse_inval_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nodeid</span><span class="p">,</span>
			     <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">len</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * File-system tells the kernel to invalidate parent attributes and</span>
<span class="cm"> * the dentry matching parent/name.</span>
<span class="cm"> *</span>
<span class="cm"> * If the child_nodeid is non-zero and:</span>
<span class="cm"> *    - matches the inode number for the dentry matching parent/name,</span>
<span class="cm"> *    - is not a mount point</span>
<span class="cm"> *    - is a file or oan empty directory</span>
<span class="cm"> * then the dentry is unhashed (d_delete()).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">fuse_reverse_inval_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent_nodeid</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">child_nodeid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">);</span>

<span class="kt">int</span> <span class="n">fuse_do_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">fuse_conn</span> <span class="o">*</span><span class="n">fc</span><span class="p">,</span> <span class="n">u64</span> <span class="n">nodeid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		 <span class="n">bool</span> <span class="n">isdir</span><span class="p">);</span>
<span class="kt">ssize_t</span> <span class="n">fuse_direct_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		       <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">write</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">fuse_do_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span>
		   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">long</span> <span class="n">fuse_ioctl_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="n">fuse_file_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">fuse_dev_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">fuse_write_update_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">);</span>

<span class="cp">#endif </span><span class="cm">/* _FS_FUSE_I_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
