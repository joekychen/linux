<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › locks.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>locks.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  linux/fs/locks.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Provide support for fcntl()&#39;s F_GETLK, F_SETLK, and F_SETLKW calls.</span>
<span class="cm"> *  Doug Evans (dje@spiff.uucp), August 07, 1992</span>
<span class="cm"> *</span>
<span class="cm"> *  Deadlock detection added.</span>
<span class="cm"> *  FIXME: one thing isn&#39;t handled yet:</span>
<span class="cm"> *	- mandatory locks (requires lots of changes elsewhere)</span>
<span class="cm"> *  Kelly Carmichael (kelly@[142.24.8.65]), September 17, 1994.</span>
<span class="cm"> *</span>
<span class="cm"> *  Miscellaneous edits, and a total rewrite of posix_lock_file() code.</span>
<span class="cm"> *  Kai Petzke (wpp@marie.physik.tu-berlin.de), 1994</span>
<span class="cm"> *  </span>
<span class="cm"> *  Converted file_lock_table to a linked list from an array, which eliminates</span>
<span class="cm"> *  the limits on how many active file locks are open.</span>
<span class="cm"> *  Chad Page (pageone@netcom.com), November 27, 1994</span>
<span class="cm"> * </span>
<span class="cm"> *  Removed dependency on file descriptors. dup()&#39;ed file descriptors now</span>
<span class="cm"> *  get the same locks as the original file descriptors, and a close() on</span>
<span class="cm"> *  any file descriptor removes ALL the locks on the file for the current</span>
<span class="cm"> *  process. Since locks still depend on the process id, locks are inherited</span>
<span class="cm"> *  after an exec() but not after a fork(). This agrees with POSIX, and both</span>
<span class="cm"> *  BSD and SVR4 practice.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), February 14, 1995</span>
<span class="cm"> *</span>
<span class="cm"> *  Scrapped free list which is redundant now that we allocate locks</span>
<span class="cm"> *  dynamically with kmalloc()/kfree().</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), February 21, 1995</span>
<span class="cm"> *</span>
<span class="cm"> *  Implemented two lock personalities - FL_FLOCK and FL_POSIX.</span>
<span class="cm"> *</span>
<span class="cm"> *  FL_POSIX locks are created with calls to fcntl() and lockf() through the</span>
<span class="cm"> *  fcntl() system call. They have the semantics described above.</span>
<span class="cm"> *</span>
<span class="cm"> *  FL_FLOCK locks are created with calls to flock(), through the flock()</span>
<span class="cm"> *  system call, which is new. Old C libraries implement flock() via fcntl()</span>
<span class="cm"> *  and will continue to use the old, broken implementation.</span>
<span class="cm"> *</span>
<span class="cm"> *  FL_FLOCK locks follow the 4.4 BSD flock() semantics. They are associated</span>
<span class="cm"> *  with a file pointer (filp). As a result they can be shared by a parent</span>
<span class="cm"> *  process and its children after a fork(). They are removed when the last</span>
<span class="cm"> *  file descriptor referring to the file pointer is closed (unless explicitly</span>
<span class="cm"> *  unlocked). </span>
<span class="cm"> *</span>
<span class="cm"> *  FL_FLOCK locks never deadlock, an existing lock is always removed before</span>
<span class="cm"> *  upgrading from shared to exclusive (or vice versa). When this happens</span>
<span class="cm"> *  any processes blocked by the current lock are woken up and allowed to</span>
<span class="cm"> *  run before the new lock is applied.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), June 09, 1995</span>
<span class="cm"> *</span>
<span class="cm"> *  Removed some race conditions in flock_lock_file(), marked other possible</span>
<span class="cm"> *  races. Just grep for FIXME to see them. </span>
<span class="cm"> *  Dmitry Gorodchanin (pgmdsg@ibi.com), February 09, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Addressed Dmitry&#39;s concerns. Deadlock checking no longer recursive.</span>
<span class="cm"> *  Lock allocation changed to GFP_ATOMIC as we can&#39;t afford to sleep</span>
<span class="cm"> *  once we&#39;ve checked for blocking and deadlocking.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), April 03, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Initial implementation of mandatory locks. SunOS turned out to be</span>
<span class="cm"> *  a rotten model, so I implemented the &quot;obvious&quot; semantics.</span>
<span class="cm"> *  See &#39;Documentation/filesystems/mandatory-locking.txt&#39; for details.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), April 06, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Don&#39;t allow mandatory locks on mmap()&#39;ed files. Added simple functions to</span>
<span class="cm"> *  check if a file has mandatory locks, used by mmap(), open() and creat() to</span>
<span class="cm"> *  see if system call should be rejected. Ref. HP-UX/SunOS/Solaris Reference</span>
<span class="cm"> *  Manual, Section 2.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), April 09, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Tidied up block list handling. Added &#39;/proc/locks&#39; interface.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), April 24, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Fixed deadlock condition for pathological code that mixes calls to</span>
<span class="cm"> *  flock() and fcntl().</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), April 29, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Allow only one type of locking scheme (FL_POSIX or FL_FLOCK) to be in use</span>
<span class="cm"> *  for a given file at a time. Changed the CONFIG_LOCK_MANDATORY scheme to</span>
<span class="cm"> *  guarantee sensible behaviour in the case where file system modules might</span>
<span class="cm"> *  be compiled with different options than the kernel itself.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Added a couple of missing wake_up() calls. Thanks to Thomas Meckel</span>
<span class="cm"> *  (Thomas.Meckel@mni.fh-giessen.de) for spotting this.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), May 15, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Changed FL_POSIX locks to use the block list in the same way as FL_FLOCK</span>
<span class="cm"> *  locks. Changed process synchronisation to avoid dereferencing locks that</span>
<span class="cm"> *  have already been freed.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), Sep 21, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Made the block list a circular list to minimise searching in the list.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), Sep 25, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Made mandatory locking a mount option. Default is not to allow mandatory</span>
<span class="cm"> *  locking.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), Oct 04, 1996.</span>
<span class="cm"> *</span>
<span class="cm"> *  Some adaptations for NFS support.</span>
<span class="cm"> *  Olaf Kirch (okir@monad.swb.de), Dec 1996,</span>
<span class="cm"> *</span>
<span class="cm"> *  Fixed /proc/locks interface so that we can&#39;t overrun the buffer we are handed.</span>
<span class="cm"> *  Andy Walker (andy@lysaker.kvaerner.no), May 12, 1997.</span>
<span class="cm"> *</span>
<span class="cm"> *  Use slab allocator instead of kmalloc/kfree.</span>
<span class="cm"> *  Use generic list implementation from &lt;linux/list.h&gt;.</span>
<span class="cm"> *  Sped up posix_locks_deadlock by only considering blocked locks.</span>
<span class="cm"> *  Matthew Wilcox &lt;willy@debian.org&gt;, March, 2000.</span>
<span class="cm"> *</span>
<span class="cm"> *  Leases and LOCK_MAND</span>
<span class="cm"> *  Matthew Wilcox &lt;willy@debian.org&gt;, June, 2000.</span>
<span class="cm"> *  Stephen Rothwell &lt;sfr@canb.auug.org.au&gt;, June, 2000.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/capability.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/pid_namespace.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define IS_POSIX(fl)	(fl-&gt;fl_flags &amp; FL_POSIX)</span>
<span class="cp">#define IS_FLOCK(fl)	(fl-&gt;fl_flags &amp; FL_FLOCK)</span>
<span class="cp">#define IS_LEASE(fl)	(fl-&gt;fl_flags &amp; FL_LEASE)</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">lease_breaking</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FL_UNLOCK_PENDING</span> <span class="o">|</span> <span class="n">FL_DOWNGRADE_PENDING</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">target_leasetype</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_UNLOCK_PENDING</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">F_UNLCK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_DOWNGRADE_PENDING</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">F_RDLCK</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">leases_enable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">lease_break_time</span> <span class="o">=</span> <span class="mi">45</span><span class="p">;</span>

<span class="cp">#define for_each_lock(inode, lockp) \</span>
<span class="cp">	for (lockp = &amp;inode-&gt;i_flock; *lockp != NULL; lockp = &amp;(*lockp)-&gt;fl_next)</span>

<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">file_lock_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">blocked_list</span><span class="p">);</span>
<span class="k">static</span> <span class="n">DEFINE_SPINLOCK</span><span class="p">(</span><span class="n">file_lock_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Protects the two list heads above, plus the inode-&gt;i_flock list</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lock_flocks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_lock_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">lock_flocks</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">unlock_flocks</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_lock_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">unlock_flocks</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">filelock_cache</span> <span class="n">__read_mostly</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">locks_init_lock_heads</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_link</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Allocate an empty lock structure. */</span>
<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="nf">locks_alloc_lock</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">filelock_cache</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="p">)</span>
		<span class="n">locks_init_lock_heads</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">fl</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">locks_alloc_lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">locks_release_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_release_private</span><span class="p">)</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_release_private</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_release_private</span><span class="p">)</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_release_private</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">locks_release_private</span><span class="p">);</span>

<span class="cm">/* Free a lock which is not in use. */</span>
<span class="kt">void</span> <span class="nf">locks_free_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">));</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_link</span><span class="p">));</span>

	<span class="n">locks_release_private</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">filelock_cache</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">locks_free_lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">locks_init_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span><span class="p">));</span>
	<span class="n">locks_init_lock_heads</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">locks_init_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">locks_copy_private</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_copy_lock</span><span class="p">)</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_copy_lock</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize a new lock from an existing file_lock structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__locks_copy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_owner</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__locks_copy_lock</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">locks_copy_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">locks_release_private</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>

	<span class="n">__locks_copy_lock</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span><span class="p">;</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="p">;</span>

	<span class="n">locks_copy_private</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">locks_copy_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">flock_translate_cmd</span><span class="p">(</span><span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">cmd</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LOCK_MAND</span> <span class="o">|</span> <span class="n">LOCK_RW</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LOCK_SH</span>:
		<span class="k">return</span> <span class="n">F_RDLCK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOCK_EX</span>:
		<span class="k">return</span> <span class="n">F_WRLCK</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">LOCK_UN</span>:
		<span class="k">return</span> <span class="n">F_UNLCK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Fill in a file_lock structure with an appropriate FLOCK lock. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flock_make_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">lock</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">flock_translate_cmd</span><span class="p">(</span><span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
	
	<span class="n">fl</span> <span class="o">=</span> <span class="n">locks_alloc_lock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">FL_FLOCK</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">OFFSET_MAX</span><span class="p">;</span>
	
	<span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">assign_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">F_RDLCK</span>:
	<span class="k">case</span> <span class="n">F_WRLCK</span>:
	<span class="k">case</span> <span class="n">F_UNLCK</span>:
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Verify a &quot;struct flock&quot; and copy it to a &quot;struct file_lock&quot; as a POSIX</span>
<span class="cm"> * style lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flock_to_posix_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">flock</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">off_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_whence</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEEK_SET</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_CUR</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_END</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* POSIX-1996 leaves the case l-&gt;l_len &lt; 0 undefined;</span>
<span class="cm">	   POSIX-2001 defines it. */</span>
	<span class="n">start</span> <span class="o">+=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">OFFSET_MAX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>	<span class="cm">/* we record the absolute position */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&lt;</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">FL_POSIX</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">assign_type</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flock64_to_posix_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">flock64</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_whence</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEEK_SET</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_CUR</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_END</span>:
		<span class="n">start</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start</span> <span class="o">+=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">OFFSET_MAX</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>	<span class="cm">/* we record the absolute position */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&lt;</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">FL_POSIX</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">assign_type</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">l_type</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* default lease lock manager operations */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">lease_break_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kill_fasync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_fasync</span><span class="p">,</span> <span class="n">SIGIO</span><span class="p">,</span> <span class="n">POLL_MSG</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lease_release_private_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">f_delown</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">);</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="o">-&gt;</span><span class="n">f_owner</span><span class="p">.</span><span class="n">signum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">lock_manager_operations</span> <span class="n">lease_manager_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lm_break</span> <span class="o">=</span> <span class="n">lease_break_callback</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_release_private</span> <span class="o">=</span> <span class="n">lease_release_private_callback</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lm_change</span> <span class="o">=</span> <span class="n">lease_modify</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Initialize a lease, use the default lock manager operations</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">lease_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
 <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">assign_type</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">type</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">FL_LEASE</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">OFFSET_MAX</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">lease_manager_ops</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Allocate a file_lock initialised to this type of lease */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="nf">lease_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="n">locks_alloc_lock</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">lease_init</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">fl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check if two locks overlap each other.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">locks_overlap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">((</span><span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&gt;=</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&gt;=</span> <span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether two locks have the same owner.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_same_owner</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">&amp;&amp;</span> <span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_compare_owner</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">==</span> <span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">&amp;&amp;</span>
			<span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_compare_owner</span><span class="p">(</span><span class="n">fl1</span><span class="p">,</span> <span class="n">fl2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">fl1</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">==</span> <span class="n">fl2</span><span class="o">-&gt;</span><span class="n">fl_owner</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Remove waiter from blocker&#39;s block list.</span>
<span class="cm"> * When blocker ends up pointing to itself then the list is empty.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__locks_delete_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_link</span><span class="p">);</span>
	<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">locks_delete_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">__locks_delete_block</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">locks_delete_block</span><span class="p">);</span>

<span class="cm">/* Insert waiter into blocker&#39;s block list.</span>
<span class="cm"> * We use a circular list so that processes can be easily woken up in</span>
<span class="cm"> * the order they blocked. The documentation doesn&#39;t require this but</span>
<span class="cm"> * it seems like the reasonable thing to do.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">locks_insert_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">blocker</span><span class="p">,</span> 
			       <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">));</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocker</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">);</span>
	<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_next</span> <span class="o">=</span> <span class="n">blocker</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">blocker</span><span class="p">))</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocked_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Wake up processes blocked waiting for blocker.</span>
<span class="cm"> * If told to wait then schedule the processes until the block list</span>
<span class="cm"> * is empty, otherwise empty the block list ourselves.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">locks_wake_up_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">blocker</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocker</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">;</span>

		<span class="n">waiter</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">blocker</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">file_lock</span><span class="p">,</span> <span class="n">fl_block</span><span class="p">);</span>
		<span class="n">__locks_delete_block</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_lmops</span> <span class="o">&amp;&amp;</span> <span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_notify</span><span class="p">)</span>
			<span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_notify</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Insert file lock fl into an inode&#39;s lock list at the position indicated</span>
<span class="cm"> * by pos. At the same time add the lock to the global file lock list.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">locks_insert_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock_list</span><span class="p">);</span>

	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span> <span class="o">=</span> <span class="n">get_pid</span><span class="p">(</span><span class="n">task_tgid</span><span class="p">(</span><span class="n">current</span><span class="p">));</span>

	<span class="cm">/* insert into file&#39;s list */</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span> <span class="o">=</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Delete a lock and then free it.</span>
<span class="cm"> * Wake up processes that are blocked waiting for this lock,</span>
<span class="cm"> * notify the FS that the lock has been cleared and</span>
<span class="cm"> * finally free the lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">locks_delete_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">thisfl_p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">thisfl_p</span><span class="p">;</span>

	<span class="o">*</span><span class="n">thisfl_p</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">;</span>
	<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_link</span><span class="p">);</span>

	<span class="n">fasync_helper</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_fasync</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_fasync</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;locks_delete_lock: fasync == %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_fasync</span><span class="p">);</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_fasync</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_pid</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span><span class="p">);</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">locks_wake_up_blocks</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
	<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Determine if lock sys_fl blocks lock caller_fl. Common functionality</span>
<span class="cm"> * checks for shared/exclusive status of overlapping locks.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">locks_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">caller_fl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">sys_fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sys_fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_WRLCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">caller_fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_WRLCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Determine if lock sys_fl blocks lock caller_fl. POSIX specific</span>
<span class="cm"> * checking before calling the locks_conflict().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_locks_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">caller_fl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">sys_fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* POSIX locks owned by the same process do not conflict with</span>
<span class="cm">	 * each other.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">sys_fl</span><span class="p">)</span> <span class="o">||</span> <span class="n">posix_same_owner</span><span class="p">(</span><span class="n">caller_fl</span><span class="p">,</span> <span class="n">sys_fl</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Check whether they overlap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locks_overlap</span><span class="p">(</span><span class="n">caller_fl</span><span class="p">,</span> <span class="n">sys_fl</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">locks_conflict</span><span class="p">(</span><span class="n">caller_fl</span><span class="p">,</span> <span class="n">sys_fl</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Determine if lock sys_fl blocks lock caller_fl. FLOCK specific</span>
<span class="cm"> * checking before calling the locks_conflict().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flock_locks_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">caller_fl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">sys_fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* FLOCK locks referring to the same filp do not conflict with</span>
<span class="cm">	 * each other.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_FLOCK</span><span class="p">(</span><span class="n">sys_fl</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">caller_fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">==</span> <span class="n">sys_fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">caller_fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">sys_fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">locks_conflict</span><span class="p">(</span><span class="n">caller_fl</span><span class="p">,</span> <span class="n">sys_fl</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">posix_test_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">cfl</span><span class="p">;</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">cfl</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">cfl</span><span class="p">;</span> <span class="n">cfl</span> <span class="o">=</span> <span class="n">cfl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">cfl</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">posix_locks_conflict</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">cfl</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cfl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__locks_copy_lock</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">cfl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cfl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span><span class="p">)</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">pid_vnr</span><span class="p">(</span><span class="n">cfl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">posix_test_lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Deadlock detection:</span>
<span class="cm"> *</span>
<span class="cm"> * We attempt to detect deadlocks that are due purely to posix file</span>
<span class="cm"> * locks.</span>
<span class="cm"> *</span>
<span class="cm"> * We assume that a task can be waiting for at most one lock at a time.</span>
<span class="cm"> * So for any acquired lock, the process holding that lock may be</span>
<span class="cm"> * waiting on at most one other lock.  That lock in turns may be held by</span>
<span class="cm"> * someone waiting for at most one other lock.  Given a requested lock</span>
<span class="cm"> * caller_fl which is about to wait for a conflicting lock block_fl, we</span>
<span class="cm"> * follow this chain of waiters to ensure we are not about to create a</span>
<span class="cm"> * cycle.</span>
<span class="cm"> *</span>
<span class="cm"> * Since we do this before we ever put a process to sleep on a lock, we</span>
<span class="cm"> * are ensured that there is never a cycle; that is what guarantees that</span>
<span class="cm"> * the while() loop in posix_locks_deadlock() eventually completes.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: the above assumption may not be true when handling lock</span>
<span class="cm"> * requests from a broken NFS client. It may also fail in the presence</span>
<span class="cm"> * of tasks (such as posix threads) sharing the same open file table.</span>
<span class="cm"> *</span>
<span class="cm"> * To handle those cases, we just bail out after a few iterations.</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_DEADLK_ITERATIONS 10</span>

<span class="cm">/* Find a lock that the owner of the given block_fl is blocking on. */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="nf">what_owner_is_waiting_for</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">block_fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocked_list</span><span class="p">,</span> <span class="n">fl_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">posix_same_owner</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">block_fl</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_locks_deadlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">caller_fl</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">block_fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">block_fl</span> <span class="o">=</span> <span class="n">what_owner_is_waiting_for</span><span class="p">(</span><span class="n">block_fl</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="o">++</span> <span class="o">&gt;</span> <span class="n">MAX_DEADLK_ITERATIONS</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">posix_same_owner</span><span class="p">(</span><span class="n">caller_fl</span><span class="p">,</span> <span class="n">block_fl</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Try to create a FLOCK lock on filp. We always insert new FLOCK locks</span>
<span class="cm"> * after any leases, but before any posix locks.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if called with an FL_EXISTS argument, the caller may determine</span>
<span class="cm"> * whether or not a lock was successfully freed by testing the return</span>
<span class="cm"> * value for -ENOENT.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">flock_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">request</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new_fl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">before</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_ACCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">!=</span> <span class="n">F_UNLCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_fl</span> <span class="o">=</span> <span class="n">locks_alloc_lock</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fl</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_ACCESS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">find_conflict</span><span class="p">;</span>

	<span class="n">for_each_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">before</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">filp</span> <span class="o">!=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">locks_delete_lock</span><span class="p">(</span><span class="n">before</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_EXISTS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">found</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If a higher-priority process was blocked on the old file lock,</span>
<span class="cm">	 * give it the opportunity to lock the file.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_flocks</span><span class="p">();</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="p">}</span>

<span class="nl">find_conflict:</span>
	<span class="n">for_each_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">before</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">flock_locks_conflict</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">fl</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_SLEEP</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">FILE_LOCK_DEFERRED</span><span class="p">;</span>
		<span class="n">locks_insert_block</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_ACCESS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">locks_copy_lock</span><span class="p">(</span><span class="n">new_fl</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
	<span class="n">locks_insert_lock</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">);</span>
	<span class="n">new_fl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fl</span><span class="p">)</span>
		<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">new_fl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__posix_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">request</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">conflock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new_fl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new_fl2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">before</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We may need two file_lock structures for this operation,</span>
<span class="cm">	 * so we get them in advance to avoid races.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In some cases we can be sure, that no new locks will be needed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_ACCESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">!=</span> <span class="n">F_UNLCK</span> <span class="o">||</span>
	     <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">!=</span> <span class="n">OFFSET_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">new_fl</span> <span class="o">=</span> <span class="n">locks_alloc_lock</span><span class="p">();</span>
		<span class="n">new_fl2</span> <span class="o">=</span> <span class="n">locks_alloc_lock</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">!=</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">for_each_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">before</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">posix_locks_conflict</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">fl</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">conflock</span><span class="p">)</span>
				<span class="n">__locks_copy_lock</span><span class="p">(</span><span class="n">conflock</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_SLEEP</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EDEADLK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">posix_locks_deadlock</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">fl</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">FILE_LOCK_DEFERRED</span><span class="p">;</span>
			<span class="n">locks_insert_block</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
  		<span class="p">}</span>
  	<span class="p">}</span>

	<span class="cm">/* If we&#39;re just looking for a conflict, we&#39;re done. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_ACCESS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Find the first old lock with the same owner as the new lock.</span>
<span class="cm">	 */</span>
	
	<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span>

	<span class="cm">/* First skip locks owned by other processes.  */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span> <span class="o">||</span>
				  <span class="o">!</span><span class="n">posix_same_owner</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">fl</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Process locks with this owner.  */</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">posix_same_owner</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Detect adjacent or overlapping regions (if same lock type)</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* In all comparisons of start vs end, use</span>
<span class="cm">			 * &quot;start - 1&quot; rather than &quot;end + 1&quot;. If end</span>
<span class="cm">			 * is OFFSET_MAX, end + 1 will become negative.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&lt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next_lock</span><span class="p">;</span>
			<span class="cm">/* If the next lock in the list has entirely bigger</span>
<span class="cm">			 * addresses than the new one, insert the lock here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* If we come here, the new and old lock are of the</span>
<span class="cm">			 * same type and adjacent or overlapping. Make one</span>
<span class="cm">			 * lock yielding from the lower start address of both</span>
<span class="cm">			 * locks to the higher end address.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&gt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">)</span>
				<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&lt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">)</span>
				<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">added</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">locks_delete_lock</span><span class="p">(</span><span class="n">before</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">request</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
			<span class="n">added</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Processing for different lock types is a bit</span>
<span class="cm">			 * more complex.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&lt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next_lock</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&gt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span>
				<span class="n">added</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&lt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">)</span>
				<span class="n">left</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
			<span class="cm">/* If the next lock in the list has a higher end</span>
<span class="cm">			 * address than the new one, insert the new one here.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&gt;</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">right</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&gt;=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* The new lock completely replaces an old</span>
<span class="cm">				 * one (This may happen several times).</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">added</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">locks_delete_lock</span><span class="p">(</span><span class="n">before</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* Replace the old lock with the new one.</span>
<span class="cm">				 * Wake up anybody waiting for the old one,</span>
<span class="cm">				 * as the change in lock type might satisfy</span>
<span class="cm">				 * their needs.</span>
<span class="cm">				 */</span>
				<span class="n">locks_wake_up_blocks</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
				<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
				<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">;</span>
				<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">;</span>
				<span class="n">locks_release_private</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
				<span class="n">locks_copy_private</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
				<span class="n">request</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
				<span class="n">added</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* Go on to next lock.</span>
<span class="cm">		 */</span>
	<span class="nl">next_lock:</span>
		<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The above code only modifies existing locks in case of</span>
<span class="cm">	 * merging or replacing.  If new lock(s) need to be inserted</span>
<span class="cm">	 * all modifications are done bellow this, so it&#39;s safe yet to</span>
<span class="cm">	 * bail out.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span> <span class="cm">/* &quot;no luck&quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="n">left</span> <span class="o">==</span> <span class="n">right</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">new_fl2</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">added</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_EXISTS</span><span class="p">)</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">locks_copy_lock</span><span class="p">(</span><span class="n">new_fl</span><span class="p">,</span> <span class="n">request</span><span class="p">);</span>
		<span class="n">locks_insert_lock</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">);</span>
		<span class="n">new_fl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="n">right</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The new lock breaks the old one in two pieces,</span>
<span class="cm">			 * so we have to use the second new lock.</span>
<span class="cm">			 */</span>
			<span class="n">left</span> <span class="o">=</span> <span class="n">new_fl2</span><span class="p">;</span>
			<span class="n">new_fl2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">locks_copy_lock</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
			<span class="n">locks_insert_lock</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">right</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">locks_wake_up_blocks</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">left</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">request</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">locks_wake_up_blocks</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="cm">/*</span>
<span class="cm">	 * Free any unused locks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fl</span><span class="p">)</span>
		<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">new_fl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_fl2</span><span class="p">)</span>
		<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">new_fl2</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * posix_lock_file - Apply a POSIX-style lock to a file</span>
<span class="cm"> * @filp: The file to apply the lock to</span>
<span class="cm"> * @fl: The lock to be applied</span>
<span class="cm"> * @conflock: Place to return a copy of the conflicting lock, if found.</span>
<span class="cm"> *</span>
<span class="cm"> * Add a POSIX style lock to a file.</span>
<span class="cm"> * We merge adjacent &amp; overlapping locks whenever possible.</span>
<span class="cm"> * POSIX locks are sorted by owner task, then by starting address</span>
<span class="cm"> *</span>
<span class="cm"> * Note that if called with an FL_EXISTS argument, the caller may determine</span>
<span class="cm"> * whether or not a lock was successfully freed by testing the return</span>
<span class="cm"> * value for -ENOENT.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">posix_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">conflock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__posix_lock_file</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">conflock</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">posix_lock_file</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * posix_lock_file_wait - Apply a POSIX-style lock to a file</span>
<span class="cm"> * @filp: The file to apply the lock to</span>
<span class="cm"> * @fl: The lock to be applied</span>
<span class="cm"> *</span>
<span class="cm"> * Add a POSIX style lock to a file.</span>
<span class="cm"> * We merge adjacent &amp; overlapping locks whenever possible.</span>
<span class="cm"> * POSIX locks are sorted by owner task, then by starting address</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">posix_lock_file_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">might_sleep</span> <span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">posix_lock_file</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">FILE_LOCK_DEFERRED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">locks_delete_block</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">posix_lock_file_wait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * locks_mandatory_locked - Check for an active lock</span>
<span class="cm"> * @inode: the file to check</span>
<span class="cm"> *</span>
<span class="cm"> * Searches the inode&#39;s list of locks to find any POSIX locks which conflict.</span>
<span class="cm"> * This function is called from locks_verify_locked() only.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">locks_mandatory_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fl_owner_t</span> <span class="n">owner</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Search the lock list for this inode for any POSIX locks.</span>
<span class="cm">	 */</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">fl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">!=</span> <span class="n">owner</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">fl</span> <span class="o">?</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * locks_mandatory_area - Check for a conflicting lock</span>
<span class="cm"> * @read_write: %FLOCK_VERIFY_WRITE for exclusive access, %FLOCK_VERIFY_READ</span>
<span class="cm"> *		for shared</span>
<span class="cm"> * @inode:      the file to check</span>
<span class="cm"> * @filp:       how the file was opened (if it was)</span>
<span class="cm"> * @offset:     start of area to check</span>
<span class="cm"> * @count:      length of area to check</span>
<span class="cm"> *</span>
<span class="cm"> * Searches the inode&#39;s list of locks to find any POSIX locks which conflict.</span>
<span class="cm"> * This function is called from rw_verify_area() and</span>
<span class="cm"> * locks_verify_truncate().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">locks_mandatory_area</span><span class="p">(</span><span class="kt">int</span> <span class="n">read_write</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">fl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">locks_init_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="p">);</span>
	<span class="n">fl</span><span class="p">.</span><span class="n">fl_owner</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">;</span>
	<span class="n">fl</span><span class="p">.</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">fl</span><span class="p">.</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">fl</span><span class="p">.</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">FL_POSIX</span> <span class="o">|</span> <span class="n">FL_ACCESS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span>
		<span class="n">fl</span><span class="p">.</span><span class="n">fl_flags</span> <span class="o">|=</span> <span class="n">FL_SLEEP</span><span class="p">;</span>
	<span class="n">fl</span><span class="p">.</span><span class="n">fl_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">read_write</span> <span class="o">==</span> <span class="n">FLOCK_VERIFY_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="n">F_WRLCK</span> <span class="o">:</span> <span class="n">F_RDLCK</span><span class="p">;</span>
	<span class="n">fl</span><span class="p">.</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">fl</span><span class="p">.</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">__posix_lock_file</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">FILE_LOCK_DEFERRED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">fl</span><span class="p">.</span><span class="n">fl_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">fl</span><span class="p">.</span><span class="n">fl_next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;ve been sleeping someone might have</span>
<span class="cm">			 * changed the permissions behind our back.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__mandatory_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">locks_delete_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">locks_mandatory_area</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lease_clear_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">F_UNLCK</span>:
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FL_UNLOCK_PENDING</span><span class="p">;</span>
		<span class="cm">/* fall through: */</span>
	<span class="k">case</span> <span class="n">F_RDLCK</span>:
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FL_DOWNGRADE_PENDING</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* We already had a lease on this file; just change its type */</span>
<span class="kt">int</span> <span class="nf">lease_modify</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">before</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="n">assign_type</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">lease_clear_pending</span><span class="p">(</span><span class="n">fl</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="n">locks_wake_up_blocks</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span>
		<span class="n">locks_delete_lock</span><span class="p">(</span><span class="n">before</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lease_modify</span><span class="p">);</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">past_time</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">then</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">then</span><span class="p">)</span>
		<span class="cm">/* 0 is a special value meaning &quot;this never expires&quot;: */</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">then</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">time_out_leases</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">before</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>

	<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">lease_breaking</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">past_time</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_downgrade_time</span><span class="p">))</span>
			<span class="n">lease_modify</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">F_RDLCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">past_time</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_break_time</span><span class="p">))</span>
			<span class="n">lease_modify</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">F_UNLCK</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span> <span class="o">==</span> <span class="o">*</span><span class="n">before</span><span class="p">)</span>	<span class="cm">/* lease_modify may have freed fl */</span>
			<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__break_lease	-	revoke all outstanding leases on file</span>
<span class="cm"> *	@inode: the inode of the file to return</span>
<span class="cm"> *	@mode: the open mode (read or write)</span>
<span class="cm"> *</span>
<span class="cm"> *	break_lease (inlined for speed) has checked there already is at least</span>
<span class="cm"> *	some kind of lock (maybe a lease) on this file.  Leases are broken on</span>
<span class="cm"> *	a call to open() or truncate().  This function can sleep unless you</span>
<span class="cm"> *	specified %O_NONBLOCK to your open().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">__break_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">new_fl</span><span class="p">,</span> <span class="o">*</span><span class="n">flock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">break_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i_have_this_lease</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want_write</span> <span class="o">=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">O_RDONLY</span><span class="p">;</span>

	<span class="n">new_fl</span> <span class="o">=</span> <span class="n">lease_alloc</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">want_write</span> <span class="o">?</span> <span class="n">F_WRLCK</span> <span class="o">:</span> <span class="n">F_RDLCK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_fl</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fl</span><span class="p">);</span>

	<span class="n">lock_flocks</span><span class="p">();</span>

	<span class="n">time_out_leases</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">flock</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">IS_LEASE</span><span class="p">(</span><span class="n">flock</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locks_conflict</span><span class="p">(</span><span class="n">flock</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">flock</span><span class="p">;</span> <span class="n">fl</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_owner</span> <span class="o">==</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">)</span>
			<span class="n">i_have_this_lease</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">break_time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lease_break_time</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">break_time</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">lease_break_time</span> <span class="o">*</span> <span class="n">HZ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">break_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">break_time</span><span class="o">++</span><span class="p">;</span>	<span class="cm">/* so that 0 means no break time */</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">flock</span><span class="p">;</span> <span class="n">fl</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want_write</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_UNLOCK_PENDING</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">|=</span> <span class="n">FL_UNLOCK_PENDING</span><span class="p">;</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_break_time</span> <span class="o">=</span> <span class="n">break_time</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">lease_breaking</span><span class="p">(</span><span class="n">flock</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">|=</span> <span class="n">FL_DOWNGRADE_PENDING</span><span class="p">;</span>
			<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_downgrade_time</span> <span class="o">=</span> <span class="n">break_time</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_break</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_have_this_lease</span> <span class="o">||</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">O_NONBLOCK</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EWOULDBLOCK</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">restart:</span>
	<span class="n">break_time</span> <span class="o">=</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_break_time</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">break_time</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">break_time</span> <span class="o">-=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">break_time</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">break_time</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">locks_insert_block</span><span class="p">(</span><span class="n">flock</span><span class="p">,</span> <span class="n">new_fl</span><span class="p">);</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">wait_event_interruptible_timeout</span><span class="p">(</span><span class="n">new_fl</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">,</span>
						<span class="o">!</span><span class="n">new_fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">,</span> <span class="n">break_time</span><span class="p">);</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">__locks_delete_block</span><span class="p">(</span><span class="n">new_fl</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">time_out_leases</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Wait for the next conflicting lease that has not been</span>
<span class="cm">		 * broken yet</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">flock</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">flock</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">flock</span><span class="p">);</span>
				<span class="n">flock</span> <span class="o">=</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">locks_conflict</span><span class="p">(</span><span class="n">new_fl</span><span class="p">,</span> <span class="n">flock</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">new_fl</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__break_lease</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	lease_get_mtime - get the last modified time of an inode</span>
<span class="cm"> *	@inode: the inode</span>
<span class="cm"> *      @time:  pointer to a timespec which will contain the last modified time</span>
<span class="cm"> *</span>
<span class="cm"> * This is to force NFS clients to flush their caches for files with</span>
<span class="cm"> * exclusive leases.  The justification is that if someone has an</span>
<span class="cm"> * exclusive lease, then they could be modifying it.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">lease_get_mtime</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">flock</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">F_WRLCK</span><span class="p">))</span>
		<span class="o">*</span><span class="n">time</span> <span class="o">=</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="o">*</span><span class="n">time</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lease_get_mtime</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	fcntl_getlease - Enquire what lease is currently active</span>
<span class="cm"> *	@filp: the file</span>
<span class="cm"> *</span>
<span class="cm"> *	The value returned by this function will be one of</span>
<span class="cm"> *	(if no lease break is pending):</span>
<span class="cm"> *</span>
<span class="cm"> *	%F_RDLCK to indicate a shared lease is held.</span>
<span class="cm"> *</span>
<span class="cm"> *	%F_WRLCK to indicate an exclusive lease is held.</span>
<span class="cm"> *</span>
<span class="cm"> *	%F_UNLCK to indicate no lease is held.</span>
<span class="cm"> *</span>
<span class="cm"> *	(if a lease break is pending):</span>
<span class="cm"> *</span>
<span class="cm"> *	%F_RDLCK to indicate an exclusive lease needs to be</span>
<span class="cm"> *		changed to a shared lease (or removed).</span>
<span class="cm"> *</span>
<span class="cm"> *	%F_UNLCK to indicate the lease needs to be removed.</span>
<span class="cm"> *</span>
<span class="cm"> *	XXX: sfr &amp; willy disagree over whether F_INPROGRESS</span>
<span class="cm"> *	should be returned to userspace.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcntl_getlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">time_out_leases</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">fl</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
			<span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">==</span> <span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">target_leasetype</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">generic_add_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">flp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="o">**</span><span class="n">before</span><span class="p">,</span> <span class="o">**</span><span class="n">my_before</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">lease</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">lease</span> <span class="o">=</span> <span class="o">*</span><span class="n">flp</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">==</span> <span class="n">F_RDLCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_writecount</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">arg</span> <span class="o">==</span> <span class="n">F_WRLCK</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="p">((</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">||</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * At this point, we know that if there is an exclusive</span>
<span class="cm">	 * lease on this file, then we hold it on this filp</span>
<span class="cm">	 * (otherwise our open of this file would have blocked).</span>
<span class="cm">	 * And if we are trying to acquire an exclusive lease,</span>
<span class="cm">	 * then the file is not open by anyone (including us)</span>
<span class="cm">	 * except for this filp.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span>
			<span class="p">((</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
			<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">==</span> <span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">my_before</span> <span class="o">=</span> <span class="n">before</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * No exclusive leases if someone else has a lease on</span>
<span class="cm">		 * this file:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="n">F_WRLCK</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Modifying our existing lease is OK, but no getting a</span>
<span class="cm">		 * new lease if someone else is opening for write:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_UNLOCK_PENDING</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">my_before</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">lease</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_change</span><span class="p">(</span><span class="n">my_before</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="o">*</span><span class="n">flp</span> <span class="o">=</span> <span class="o">*</span><span class="n">my_before</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">leases_enable</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">locks_insert_lock</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">lease</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">generic_delete_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">flp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="o">**</span><span class="n">before</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span>
			<span class="p">((</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
			<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">!=</span> <span class="n">filp</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="n">flp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_change</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">F_UNLCK</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	generic_setlease	-	sets a lease on an open file</span>
<span class="cm"> *	@filp: file pointer</span>
<span class="cm"> *	@arg: type of lease to obtain</span>
<span class="cm"> *	@flp: input - file_lock to use, output - file_lock inserted</span>
<span class="cm"> *</span>
<span class="cm"> *	The (input) flp-&gt;fl_lmops-&gt;lm_break function is required</span>
<span class="cm"> *	by break_lease().</span>
<span class="cm"> *</span>
<span class="cm"> *	Called with file_lock_lock held.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">generic_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">flp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">uid_eq</span><span class="p">(</span><span class="n">current_fsuid</span><span class="p">(),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_LEASE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">security_file_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">time_out_leases</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">flp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fl_lmops</span><span class="o">-&gt;</span><span class="n">lm_break</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">F_UNLCK</span>:
		<span class="k">return</span> <span class="n">generic_delete_lease</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">flp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">F_RDLCK</span>:
	<span class="k">case</span> <span class="n">F_WRLCK</span>:
		<span class="k">return</span> <span class="n">generic_add_lease</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">flp</span><span class="p">);</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_setlease</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__vfs_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">lease</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">setlease</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">setlease</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">lease</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">generic_setlease</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">lease</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	vfs_setlease        -       sets a lease on an open file</span>
<span class="cm"> *	@filp: file pointer</span>
<span class="cm"> *	@arg: type of lease to obtain</span>
<span class="cm"> *	@lease: file_lock to use</span>
<span class="cm"> *</span>
<span class="cm"> *	Call this to establish a lease on the file.</span>
<span class="cm"> *	The (*lease)-&gt;fl_lmops-&gt;lm_break operation must be set; if not,</span>
<span class="cm"> *	break_lease will oops!</span>
<span class="cm"> *</span>
<span class="cm"> *	This will call the filesystem&#39;s setlease file method, if</span>
<span class="cm"> *	defined.  Note that there is no getlease method; instead, the</span>
<span class="cm"> *	filesystem setlease method should call back to setlease() to</span>
<span class="cm"> *	add a lease to the inode&#39;s lease list, where fcntl_getlease() can</span>
<span class="cm"> *	find it.  Since fcntl_getlease() only reports whether the current</span>
<span class="cm"> *	task holds a lease, a cluster filesystem need only do this for</span>
<span class="cm"> *	leases held by processes on this node.</span>
<span class="cm"> *</span>
<span class="cm"> *	There is also no break_lease method; filesystems that</span>
<span class="cm"> *	handle their own leases should break leases themselves from the</span>
<span class="cm"> *	filesystem&#39;s open, create, and (on truncate) setattr methods.</span>
<span class="cm"> *</span>
<span class="cm"> *	Warning: the only current setlease methods exist only to disable</span>
<span class="cm"> *	leases in certain cases.  More vfs changes may be required to</span>
<span class="cm"> *	allow a full filesystem lease implementation.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">vfs_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">lease</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">__vfs_setlease</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">lease</span><span class="p">);</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vfs_setlease</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_fcntl_delete_lease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">fl</span><span class="p">,</span> <span class="o">*</span><span class="n">flp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="p">;</span>

	<span class="n">lease_init</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">F_UNLCK</span><span class="p">,</span> <span class="n">flp</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">vfs_setlease</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">F_UNLCK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_fcntl_add_lease</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fasync_struct</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">fl</span> <span class="o">=</span> <span class="n">lease_alloc</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>

	<span class="n">new</span> <span class="o">=</span> <span class="n">fasync_alloc</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fl</span><span class="p">;</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">__vfs_setlease</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_flocks</span><span class="p">();</span>
		<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_fasync</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">fl</span><span class="p">)</span>
		<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * fasync_insert_entry() returns the old entry if any.</span>
<span class="cm">	 * If there was no old entry, then it used &#39;new&#39; and</span>
<span class="cm">	 * inserted it into the fasync list. Clear new so that</span>
<span class="cm">	 * we don&#39;t release it here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fasync_insert_entry</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">fl_fasync</span><span class="p">,</span> <span class="n">new</span><span class="p">))</span>
		<span class="n">new</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">__f_setown</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">task_pid</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">PIDTYPE_PID</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>

<span class="nl">out_free_fasync:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">fasync_free</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	fcntl_setlease	-	sets a lease on an open file</span>
<span class="cm"> *	@fd: open file descriptor</span>
<span class="cm"> *	@filp: file pointer</span>
<span class="cm"> *	@arg: type of lease to obtain</span>
<span class="cm"> *</span>
<span class="cm"> *	Call this fcntl to establish a lease on the file.</span>
<span class="cm"> *	Note that you also need to call %F_SETSIG to</span>
<span class="cm"> *	receive a signal when the lease is broken.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcntl_setlease</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">do_fcntl_delete_lease</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_fcntl_add_lease</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * flock_lock_file_wait - Apply a FLOCK-style lock to a file</span>
<span class="cm"> * @filp: The file to apply the lock to</span>
<span class="cm"> * @fl: The lock to be applied</span>
<span class="cm"> *</span>
<span class="cm"> * Add a FLOCK style lock to a file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">flock_lock_file_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">flock_lock_file</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">FILE_LOCK_DEFERRED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">locks_delete_block</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">flock_lock_file_wait</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	sys_flock: - flock() system call.</span>
<span class="cm"> *	@fd: the file descriptor to lock.</span>
<span class="cm"> *	@cmd: the type of lock to apply.</span>
<span class="cm"> *</span>
<span class="cm"> *	Apply a %FL_FLOCK style lock to an open file descriptor.</span>
<span class="cm"> *	The @cmd can be one of</span>
<span class="cm"> *</span>
<span class="cm"> *	%LOCK_SH -- a shared lock.</span>
<span class="cm"> *</span>
<span class="cm"> *	%LOCK_EX -- an exclusive lock.</span>
<span class="cm"> *</span>
<span class="cm"> *	%LOCK_UN -- remove an existing lock.</span>
<span class="cm"> *</span>
<span class="cm"> *	%LOCK_MAND -- a `mandatory&#39; flock.  This exists to emulate Windows Share Modes.</span>
<span class="cm"> *</span>
<span class="cm"> *	%LOCK_MAND can be combined with %LOCK_READ or %LOCK_WRITE to allow other</span>
<span class="cm"> *	processes read and write access respectively.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE2</span><span class="p">(</span><span class="n">flock</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">can_sleep</span><span class="p">,</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">filp</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">can_sleep</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">LOCK_NB</span><span class="p">);</span>
	<span class="n">cmd</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">LOCK_NB</span><span class="p">;</span>
	<span class="n">unlock</span> <span class="o">=</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">LOCK_UN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">unlock</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">cmd</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FMODE_READ</span><span class="o">|</span><span class="n">FMODE_WRITE</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">flock_make_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="n">cmd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_putf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">can_sleep</span><span class="p">)</span>
		<span class="n">lock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">|=</span> <span class="n">FL_SLEEP</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_file_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">flock</span><span class="p">)</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">flock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span>
					  <span class="p">(</span><span class="n">can_sleep</span><span class="p">)</span> <span class="o">?</span> <span class="n">F_SETLKW</span> <span class="o">:</span> <span class="n">F_SETLK</span><span class="p">,</span>
					  <span class="n">lock</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">flock_lock_file_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>

 <span class="nl">out_free:</span>
	<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>

 <span class="nl">out_putf:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_test_lock - test file byte range lock</span>
<span class="cm"> * @filp: The file to test lock for</span>
<span class="cm"> * @fl: The lock to test; also used to hold result</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -ERRNO on failure.  Indicates presence of conflicting lock by</span>
<span class="cm"> * setting conf-&gt;fl_type to something other than F_UNLCK.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">vfs_test_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">F_GETLK</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
	<span class="n">posix_test_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vfs_test_lock</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">posix_lock_to_flock</span><span class="p">(</span><span class="k">struct</span> <span class="n">flock</span> <span class="o">*</span><span class="n">flock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_pid</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span><span class="p">;</span>
<span class="cp">#if BITS_PER_LONG == 32</span>
	<span class="cm">/*</span>
<span class="cm">	 * Make sure we can represent the posix lock via</span>
<span class="cm">	 * legacy 32bit flock.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&gt;</span> <span class="n">OFFT_OFFSET_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">!=</span> <span class="n">OFFSET_MAX</span> <span class="o">&amp;&amp;</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&gt;</span> <span class="n">OFFT_OFFSET_MAX</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">==</span> <span class="n">OFFSET_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">-</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_whence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">posix_lock_to_flock64</span><span class="p">(</span><span class="k">struct</span> <span class="n">flock64</span> <span class="o">*</span><span class="n">flock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_pid</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span><span class="p">;</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_start</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_len</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">==</span> <span class="n">OFFSET_MAX</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span>
		<span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">-</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_whence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">flock</span><span class="o">-&gt;</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* Report the first existing lock that would conflict with l.</span>
<span class="cm"> * This implements the F_GETLK command of fcntl().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcntl_getlk</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock</span> <span class="n">__user</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">file_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flock</span> <span class="n">flock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flock</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">!=</span> <span class="n">F_RDLCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">!=</span> <span class="n">F_WRLCK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">flock_to_posix_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_test_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
 
	<span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">file_lock</span><span class="p">.</span><span class="n">fl_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file_lock</span><span class="p">.</span><span class="n">fl_type</span> <span class="o">!=</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">posix_lock_to_flock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flock</span><span class="p">)))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_lock_file - file byte range lock</span>
<span class="cm"> * @filp: The file to apply the lock to</span>
<span class="cm"> * @cmd: type of locking operation (F_SETLK, F_GETLK, etc.)</span>
<span class="cm"> * @fl: The lock to be applied</span>
<span class="cm"> * @conf: Place to return a copy of the conflicting lock, if found.</span>
<span class="cm"> *</span>
<span class="cm"> * A caller that doesn&#39;t care about the conflicting lock may pass NULL</span>
<span class="cm"> * as the final argument.</span>
<span class="cm"> *</span>
<span class="cm"> * If the filesystem defines a private -&gt;lock() method, then @conf will</span>
<span class="cm"> * be left unchanged; so a caller that cares should initialize it to</span>
<span class="cm"> * some acceptable default.</span>
<span class="cm"> *</span>
<span class="cm"> * To avoid blocking kernel daemons, such as lockd, that need to acquire POSIX</span>
<span class="cm"> * locks, the -&gt;lock() interface may return asynchronously, before the lock has</span>
<span class="cm"> * been granted or denied by the underlying filesystem, if (and only if)</span>
<span class="cm"> * lm_grant is set. Callers expecting -&gt;lock() to return asynchronously</span>
<span class="cm"> * will only use F_SETLK, not F_SETLKW; they will set FL_SLEEP if (and only if)</span>
<span class="cm"> * the request is for a blocking lock. When -&gt;lock() does return asynchronously,</span>
<span class="cm"> * it must return FILE_LOCK_DEFERRED, and call -&gt;lm_grant() when the lock</span>
<span class="cm"> * request completes.</span>
<span class="cm"> * If the request is for non-blocking lock the file system should return</span>
<span class="cm"> * FILE_LOCK_DEFERRED then try to get the lock and call the callback routine</span>
<span class="cm"> * with the result. If the request timed out the callback routine will return a</span>
<span class="cm"> * nonzero return code and the file system should release the lock. The file</span>
<span class="cm"> * system is also responsible to keep a corresponding posix lock when it</span>
<span class="cm"> * grants a lock so the VFS can find out which locks are locally held and do</span>
<span class="cm"> * the correct lock cleanup when required.</span>
<span class="cm"> * The underlying filesystem must not drop the kernel lock or call</span>
<span class="cm"> * -&gt;lm_grant() before returning to the caller with a FILE_LOCK_DEFERRED</span>
<span class="cm"> * return code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vfs_lock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">conf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">posix_lock_file</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="n">conf</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vfs_lock_file</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_lock_file_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">security_file_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_lock_file</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">FILE_LOCK_DEFERRED</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">locks_delete_block</span><span class="p">(</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Apply the lock described by l to an open file descriptor.</span>
<span class="cm"> * This implements both the F_SETLK and F_SETLKW commands of fcntl().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcntl_setlk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">flock</span> <span class="n">__user</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">file_lock</span> <span class="o">=</span> <span class="n">locks_alloc_lock</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">flock</span> <span class="n">flock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file_lock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This might block, so we do it before checking the inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flock</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allow mandatory locks on files that may be memory mapped</span>
<span class="cm">	 * and shared.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mandatory_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mapping_writably_mapped</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">again:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">flock_to_posix_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">file_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">F_SETLKW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file_lock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">|=</span> <span class="n">FL_SLEEP</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">flock</span><span class="p">.</span><span class="n">l_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">F_RDLCK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">F_WRLCK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">F_UNLCK</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_lock_file_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">file_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attempt to detect a close/fcntl race and recover by</span>
<span class="cm">	 * releasing the lock that was just acquired.</span>
<span class="cm">	 */</span>
	<span class="cm">/*</span>
<span class="cm">	 * we need that spin_lock here - it prevents reordering between</span>
<span class="cm">	 * update of inode-&gt;i_flock and check for it done in close().</span>
<span class="cm">	 * rcu_read_lock() wouldn&#39;t do.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">fcheck</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">filp</span> <span class="o">&amp;&amp;</span> <span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">!=</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if BITS_PER_LONG == 32</span>
<span class="cm">/* Report the first existing lock that would conflict with l.</span>
<span class="cm"> * This implements the F_GETLK command of fcntl().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcntl_getlk64</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">flock64</span> <span class="n">__user</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">file_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">flock64</span> <span class="n">flock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flock</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">!=</span> <span class="n">F_RDLCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">!=</span> <span class="n">F_WRLCK</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">flock64_to_posix_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">vfs_test_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">file_lock</span><span class="p">.</span><span class="n">fl_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file_lock</span><span class="p">.</span><span class="n">fl_type</span> <span class="o">!=</span> <span class="n">F_UNLCK</span><span class="p">)</span>
		<span class="n">posix_lock_to_flock64</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flock</span><span class="p">)))</span>
		<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Apply the lock described by l to an open file descriptor.</span>
<span class="cm"> * This implements both the F_SETLK and F_SETLKW commands of fcntl().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">fcntl_setlk64</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">flock64</span> <span class="n">__user</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">file_lock</span> <span class="o">=</span> <span class="n">locks_alloc_lock</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">flock64</span> <span class="n">flock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file_lock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOLCK</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This might block, so we do it before checking the inode.</span>
<span class="cm">	 */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flock</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flock</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/* Don&#39;t allow mandatory locks on files that may be memory mapped</span>
<span class="cm">	 * and shared.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mandatory_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">mapping_writably_mapped</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">again:</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">flock64_to_posix_lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">file_lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cmd</span> <span class="o">==</span> <span class="n">F_SETLKW64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file_lock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">|=</span> <span class="n">FL_SLEEP</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">flock</span><span class="p">.</span><span class="n">l_type</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">F_RDLCK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">F_WRLCK</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">F_UNLCK</span>:
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">do_lock_file_wait</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">file_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Attempt to detect a close/fcntl race and recover by</span>
<span class="cm">	 * releasing the lock that was just acquired.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="n">f</span> <span class="o">=</span> <span class="n">fcheck</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="o">-&gt;</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">f</span> <span class="o">!=</span> <span class="n">filp</span> <span class="o">&amp;&amp;</span> <span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">!=</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flock</span><span class="p">.</span><span class="n">l_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">locks_free_lock</span><span class="p">(</span><span class="n">file_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* BITS_PER_LONG == 32 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * This function is called when the file is being removed</span>
<span class="cm"> * from the task&#39;s fd array.  POSIX locks belonging to this task</span>
<span class="cm"> * are deleted at this time.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">locks_remove_posix</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">lock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there are no locks held on this file, we don&#39;t need to call</span>
<span class="cm">	 * posix_lock_file().  Another process could be setting a lock on this</span>
<span class="cm">	 * file at the same time, but we wouldn&#39;t remove that lock anyway.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lock</span><span class="p">.</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">FL_POSIX</span> <span class="o">|</span> <span class="n">FL_CLOSE</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">OFFSET_MAX</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_owner</span> <span class="o">=</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_ops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">lock</span><span class="p">.</span><span class="n">fl_lmops</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">vfs_lock_file</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">F_SETLK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">.</span><span class="n">fl_ops</span> <span class="o">&amp;&amp;</span> <span class="n">lock</span><span class="p">.</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_release_private</span><span class="p">)</span>
		<span class="n">lock</span><span class="p">.</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_release_private</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">locks_remove_posix</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This function is called on the last close of an open file.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">locks_remove_flock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span> <span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">before</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">flock</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">fl</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">,</span>
			<span class="p">.</span><span class="n">fl_file</span> <span class="o">=</span> <span class="n">filp</span><span class="p">,</span>
			<span class="p">.</span><span class="n">fl_flags</span> <span class="o">=</span> <span class="n">FL_FLOCK</span><span class="p">,</span>
			<span class="p">.</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">,</span>
			<span class="p">.</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">OFFSET_MAX</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">flock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">F_SETLKW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="p">.</span><span class="n">fl_ops</span> <span class="o">&amp;&amp;</span> <span class="n">fl</span><span class="p">.</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_release_private</span><span class="p">)</span>
			<span class="n">fl</span><span class="p">.</span><span class="n">fl_ops</span><span class="o">-&gt;</span><span class="n">fl_release_private</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">fl</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">==</span> <span class="n">filp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_FLOCK</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">locks_delete_lock</span><span class="p">(</span><span class="n">before</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">lease_modify</span><span class="p">(</span><span class="n">before</span><span class="p">,</span> <span class="n">F_UNLCK</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* What? */</span>
			<span class="n">BUG</span><span class="p">();</span>
 		<span class="p">}</span>
		<span class="n">before</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	posix_unblock_lock - stop waiting for a file lock</span>
<span class="cm"> *      @filp:   how the file was opened</span>
<span class="cm"> *	@waiter: the lock which was waiting</span>
<span class="cm"> *</span>
<span class="cm"> *	lockd needs to block waiting for locks.</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">posix_unblock_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">waiter</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waiter</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span>
		<span class="n">__locks_delete_block</span><span class="p">(</span><span class="n">waiter</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">status</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">status</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">posix_unblock_lock</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_cancel_lock - file byte range unblock lock</span>
<span class="cm"> * @filp: The file to apply the unblock to</span>
<span class="cm"> * @fl: The lock to be unblocked</span>
<span class="cm"> *</span>
<span class="cm"> * Used by lock managers to cancel blocked requests</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vfs_cancel_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">F_CANCELLK</span><span class="p">,</span> <span class="n">fl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">vfs_cancel_lock</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_PROC_FS</span>
<span class="cp">#include &lt;linux/proc_fs.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">lock_get_status</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span>
			    <span class="n">loff_t</span> <span class="n">id</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pfx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fl_pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span><span class="p">)</span>
		<span class="n">fl_pid</span> <span class="o">=</span> <span class="n">pid_vnr</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_nspid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">fl_pid</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%lld:%s &quot;</span><span class="p">,</span> <span class="n">id</span><span class="p">,</span> <span class="n">pfx</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%6s %s &quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_ACCESS</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;ACCESS&quot;</span> <span class="o">:</span> <span class="s">&quot;POSIX &quot;</span><span class="p">,</span>
			     <span class="p">(</span><span class="n">inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;*NOINODE*&quot;</span> <span class="o">:</span>
			     <span class="n">mandatory_lock</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;MANDATORY&quot;</span> <span class="o">:</span> <span class="s">&quot;ADVISORY &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_FLOCK</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;FLOCK  MSNFS     &quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;FLOCK  ADVISORY  &quot;</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_LEASE</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;LEASE  &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lease_breaking</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;BREAKING  &quot;</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_file</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;ACTIVE    &quot;</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;BREAKER   &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;UNKNOWN UNKNOWN  &quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_READ</span><span class="p">)</span>
			       <span class="o">?</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;RW   &quot;</span> <span class="o">:</span> <span class="s">&quot;READ &quot;</span>
			       <span class="o">:</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_WRITE</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;WRITE&quot;</span> <span class="o">:</span> <span class="s">&quot;NONE &quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%s &quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">lease_breaking</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span>
			       <span class="o">?</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;UNLCK&quot;</span> <span class="o">:</span> <span class="s">&quot;READ &quot;</span>
			       <span class="o">:</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">F_WRLCK</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;WRITE&quot;</span> <span class="o">:</span> <span class="s">&quot;READ &quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifdef WE_CAN_BREAK_LSLK_NOW</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%d %s:%ld &quot;</span><span class="p">,</span> <span class="n">fl_pid</span><span class="p">,</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="cp">#else</span>
		<span class="cm">/* userspace relies on this representation of dev_t ;-( */</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%d %02x:%02x:%ld &quot;</span><span class="p">,</span> <span class="n">fl_pid</span><span class="p">,</span>
				<span class="n">MAJOR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">),</span>
				<span class="n">MINOR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_dev</span><span class="p">),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%d &lt;none&gt;:0 &quot;</span><span class="p">,</span> <span class="n">fl_pid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">==</span> <span class="n">OFFSET_MAX</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%Ld EOF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;%Ld %Ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;0 EOF</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">locks_show</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">,</span> <span class="o">*</span><span class="n">bfl</span><span class="p">;</span>

	<span class="n">fl</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span><span class="p">,</span> <span class="n">fl_link</span><span class="p">);</span>

	<span class="n">lock_get_status</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">fl</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">),</span> <span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bfl</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_block</span><span class="p">,</span> <span class="n">fl_block</span><span class="p">)</span>
		<span class="n">lock_get_status</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">bfl</span><span class="p">,</span> <span class="o">*</span><span class="p">((</span><span class="n">loff_t</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">),</span> <span class="s">&quot; -&gt;&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">locks_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">pos</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">seq_list_start</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file_lock_list</span><span class="p">,</span> <span class="o">*</span><span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">locks_next</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="o">++*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">seq_list_next</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_lock_list</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">locks_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">seq_operations</span> <span class="n">locks_seq_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">start</span>	<span class="o">=</span> <span class="n">locks_start</span><span class="p">,</span>
	<span class="p">.</span><span class="n">next</span>	<span class="o">=</span> <span class="n">locks_next</span><span class="p">,</span>
	<span class="p">.</span><span class="n">stop</span>	<span class="o">=</span> <span class="n">locks_stop</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show</span>	<span class="o">=</span> <span class="n">locks_show</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">locks_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">seq_open_private</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locks_seq_operations</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">loff_t</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">proc_locks_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">locks_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">seq_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">seq_lseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">seq_release_private</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">proc_locks_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">proc_create</span><span class="p">(</span><span class="s">&quot;locks&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">proc_locks_operations</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">proc_locks_init</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/**</span>
<span class="cm"> *	lock_may_read - checks that the region is free of locks</span>
<span class="cm"> *	@inode: the inode that is being read</span>
<span class="cm"> *	@start: the first byte to read</span>
<span class="cm"> *	@len: the number of bytes to read</span>
<span class="cm"> *</span>
<span class="cm"> *	Emulates Windows locking requirements.  Whole-file</span>
<span class="cm"> *	mandatory locks (share modes) can prohibit a read and</span>
<span class="cm"> *	byte-range POSIX locks can prohibit a read if they overlap.</span>
<span class="cm"> *</span>
<span class="cm"> *	N.B. this function is only ever called</span>
<span class="cm"> *	from knfsd and ownership of locks is never checked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">lock_may_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">fl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_RDLCK</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_FLOCK</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_READ</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lock_may_read</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> *	lock_may_write - checks that the region is free of locks</span>
<span class="cm"> *	@inode: the inode that is being written</span>
<span class="cm"> *	@start: the first byte to write</span>
<span class="cm"> *	@len: the number of bytes to write</span>
<span class="cm"> *</span>
<span class="cm"> *	Emulates Windows locking requirements.  Whole-file</span>
<span class="cm"> *	mandatory locks (share modes) can prohibit a write and</span>
<span class="cm"> *	byte-range POSIX locks can prohibit a write if they overlap.</span>
<span class="cm"> *</span>
<span class="cm"> *	N.B. this function is only ever called</span>
<span class="cm"> *	from knfsd and ownership of locks is never checked.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">lock_may_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">fl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fl</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flock</span><span class="p">;</span> <span class="n">fl</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">fl</span> <span class="o">=</span> <span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_POSIX</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&gt;</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">IS_FLOCK</span><span class="p">(</span><span class="n">fl</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_MAND</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">fl</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">&amp;</span> <span class="n">LOCK_WRITE</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">lock_may_write</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">filelock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">filelock_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;file_lock_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">filelock_init</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
