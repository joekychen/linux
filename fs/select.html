<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › select.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>select.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This file contains the procedures for the handling of select and poll</span>
<span class="cm"> *</span>
<span class="cm"> * Created for Linux based loosely upon Mathius Lattner&#39;s minix</span>
<span class="cm"> * patches by Peter MacDonald. Heavily edited by Linus.</span>
<span class="cm"> *</span>
<span class="cm"> *  4 February 1994</span>
<span class="cm"> *     COFF/ELF binary emulation. If the process has the STICKY_TIMEOUTS</span>
<span class="cm"> *     flag set in its personality we do *not* modify the given timeout</span>
<span class="cm"> *     parameter to reflect time remaining.</span>
<span class="cm"> *</span>
<span class="cm"> *  24 January 2000</span>
<span class="cm"> *     Changed sys_poll()/do_poll() to use PAGE_SIZE chunk-based allocation </span>
<span class="cm"> *     of fds to overcome nfds &lt; 16390 descriptors limit (Tigran Aivazian).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/poll.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt; </span><span class="cm">/* for STICKY_TIMEOUTS */</span><span class="cp"></span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fdtable.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>

<span class="cp">#include &lt;asm/uaccess.h&gt;</span>


<span class="cm">/*</span>
<span class="cm"> * Estimate expected accuracy in ns from a timeval.</span>
<span class="cm"> *</span>
<span class="cm"> * After quite a bit of churning around, we&#39;ve settled on</span>
<span class="cm"> * a simple thing of taking 0.1% of the timeout as the</span>
<span class="cm"> * slack, with a cap of 100 msec.</span>
<span class="cm"> * &quot;nice&quot; tasks get a 0.5% slack instead.</span>
<span class="cm"> *</span>
<span class="cm"> * Consider this comment an open invitation to come up with even</span>
<span class="cm"> * better solutions..</span>
<span class="cm"> */</span>

<span class="cp">#define MAX_SLACK	(100 * NSEC_PER_MSEC)</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">__estimate_accuracy</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">slack</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">divfactor</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">task_nice</span><span class="p">(</span><span class="n">current</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">divfactor</span> <span class="o">=</span> <span class="n">divfactor</span> <span class="o">/</span> <span class="mi">5</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&gt;</span> <span class="n">MAX_SLACK</span> <span class="o">/</span> <span class="p">(</span><span class="n">NSEC_PER_SEC</span><span class="o">/</span><span class="n">divfactor</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">MAX_SLACK</span><span class="p">;</span>

	<span class="n">slack</span> <span class="o">=</span> <span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="n">divfactor</span><span class="p">;</span>
	<span class="n">slack</span> <span class="o">+=</span> <span class="n">tv</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">*</span> <span class="p">(</span><span class="n">NSEC_PER_SEC</span><span class="o">/</span><span class="n">divfactor</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slack</span> <span class="o">&gt;</span> <span class="n">MAX_SLACK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">MAX_SLACK</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">slack</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">select_estimate_accuracy</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">tv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">now</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Realtime tasks get a slack of 0 for obvious reasons.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rt_task</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="n">now</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="o">*</span><span class="n">tv</span><span class="p">,</span> <span class="n">now</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__estimate_accuracy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">now</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">timer_slack_ns</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">timer_slack_ns</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>



<span class="k">struct</span> <span class="n">poll_table_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_table_page</span> <span class="o">*</span> <span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">poll_table_entry</span> <span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">poll_table_entry</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define POLL_TABLE_FULL(table) \</span>
<span class="cp">	((unsigned long)((table)-&gt;entry+1) &gt; PAGE_SIZE + (unsigned long)(table))</span>

<span class="cm">/*</span>
<span class="cm"> * Ok, Peter made a complicated, but straightforward multiple_wait() function.</span>
<span class="cm"> * I have rewritten this, taking some shortcuts: This code may not be easy to</span>
<span class="cm"> * follow, but it should be free of race-conditions, and it&#39;s practical. If you</span>
<span class="cm"> * understand what I&#39;m doing here, then you understand how the linux</span>
<span class="cm"> * sleep/wakeup mechanism works.</span>
<span class="cm"> *</span>
<span class="cm"> * Two very simple procedures, poll_wait() and poll_freewait() make all the</span>
<span class="cm"> * work.  poll_wait() is an inline-function defined in &lt;linux/poll.h&gt;,</span>
<span class="cm"> * as all select/poll functions have to call it to add an entry to the</span>
<span class="cm"> * poll table.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__pollwait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wait_address</span><span class="p">,</span>
		       <span class="n">poll_table</span> <span class="o">*</span><span class="n">p</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">poll_initwait</span><span class="p">(</span><span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="o">*</span><span class="n">pwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">init_poll_funcptr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">,</span> <span class="n">__pollwait</span><span class="p">);</span>
	<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">polling_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">triggered</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">inline_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">poll_initwait</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_poll_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">poll_table_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">remove_wait_queue</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">filp</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">poll_freewait</span><span class="p">(</span><span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="o">*</span><span class="n">pwq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_table_page</span> <span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">pwq</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pwq</span><span class="o">-&gt;</span><span class="n">inline_index</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">free_poll_entry</span><span class="p">(</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">inline_entries</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">poll_table_entry</span> <span class="o">*</span> <span class="n">entry</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">poll_table_page</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>

		<span class="n">entry</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">entry</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">entry</span><span class="o">--</span><span class="p">;</span>
			<span class="n">free_poll_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">entry</span> <span class="o">&gt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">);</span>
		<span class="n">old</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">free_page</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">old</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">poll_freewait</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">poll_table_entry</span> <span class="o">*</span><span class="nf">poll_get_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_table_page</span> <span class="o">*</span><span class="n">table</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">table</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">inline_index</span> <span class="o">&lt;</span> <span class="n">N_INLINE_POLL_ENTRIES</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">inline_entries</span> <span class="o">+</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">inline_index</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">table</span> <span class="o">||</span> <span class="n">POLL_TABLE_FULL</span><span class="p">(</span><span class="n">table</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">poll_table_page</span> <span class="o">*</span><span class="n">new_table</span><span class="p">;</span>

		<span class="n">new_table</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">poll_table_page</span> <span class="o">*</span><span class="p">)</span> <span class="n">__get_free_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_table</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_table</span><span class="o">-&gt;</span><span class="n">entry</span> <span class="o">=</span> <span class="n">new_table</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="n">new_table</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">table</span><span class="p">;</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">=</span> <span class="n">new_table</span><span class="p">;</span>
		<span class="n">table</span> <span class="o">=</span> <span class="n">new_table</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">entry</span><span class="o">++</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__pollwake</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="o">*</span><span class="n">pwq</span> <span class="o">=</span> <span class="n">wait</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
	<span class="n">DECLARE_WAITQUEUE</span><span class="p">(</span><span class="n">dummy_wait</span><span class="p">,</span> <span class="n">pwq</span><span class="o">-&gt;</span><span class="n">polling_task</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Although this function is called under waitqueue lock, LOCK</span>
<span class="cm">	 * doesn&#39;t imply write barrier and the users expect write</span>
<span class="cm">	 * barrier semantics on wakeup functions.  The following</span>
<span class="cm">	 * smp_wmb() is equivalent to smp_wmb() in try_to_wake_up()</span>
<span class="cm">	 * and is paired with set_mb() in poll_schedule_timeout.</span>
<span class="cm">	 */</span>
	<span class="n">smp_wmb</span><span class="p">();</span>
	<span class="n">pwq</span><span class="o">-&gt;</span><span class="n">triggered</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Perform the default wake up operation using a dummy</span>
<span class="cm">	 * waitqueue.</span>
<span class="cm">	 *</span>
<span class="cm">	 * TODO: This is hacky but there currently is no interface to</span>
<span class="cm">	 * pass in @sync.  @sync is scheduled to be removed and once</span>
<span class="cm">	 * that happens, wake_up_process() can be used directly.</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">default_wake_function</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dummy_wait</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pollwake</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_table_entry</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_table_entry</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">key</span> <span class="o">&amp;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__pollwake</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Add a new entry */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__pollwait</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wait_address</span><span class="p">,</span>
				<span class="n">poll_table</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="o">*</span><span class="n">pwq</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">struct</span> <span class="n">poll_wqueues</span><span class="p">,</span> <span class="n">pt</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">poll_table_entry</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="n">poll_get_entry</span><span class="p">(</span><span class="n">pwq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">get_file</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">filp</span> <span class="o">=</span> <span class="n">filp</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait_address</span> <span class="o">=</span> <span class="n">wait_address</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">key</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">_key</span><span class="p">;</span>
	<span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">pollwake</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">pwq</span><span class="p">;</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="n">wait_address</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">poll_schedule_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="o">*</span><span class="n">pwq</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">,</span>
			  <span class="n">ktime_t</span> <span class="o">*</span><span class="n">expires</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slack</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="n">set_current_state</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">triggered</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">schedule_hrtimeout_range</span><span class="p">(</span><span class="n">expires</span><span class="p">,</span> <span class="n">slack</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
	<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prepare for the next iteration.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The following set_mb() serves two purposes.  First, it&#39;s</span>
<span class="cm">	 * the counterpart rmb of the wmb in pollwake() such that data</span>
<span class="cm">	 * written before wake up is always visible after wake up.</span>
<span class="cm">	 * Second, the full barrier guarantees that triggered clearing</span>
<span class="cm">	 * doesn&#39;t pass event check of the next iteration.  Note that</span>
<span class="cm">	 * this problem doesn&#39;t exist for the first iteration as</span>
<span class="cm">	 * add_wait_queue() has full barrier semantics.</span>
<span class="cm">	 */</span>
	<span class="n">set_mb</span><span class="p">(</span><span class="n">pwq</span><span class="o">-&gt;</span><span class="n">triggered</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">poll_schedule_timeout</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * poll_select_set_timeout - helper function to setup the timeout value</span>
<span class="cm"> * @to:		pointer to timespec variable for the final timeout</span>
<span class="cm"> * @sec:	seconds (from user space)</span>
<span class="cm"> * @nsec:	nanoseconds (from user space)</span>
<span class="cm"> *</span>
<span class="cm"> * Note, we do not use a timespec for the user space value here, That</span>
<span class="cm"> * way we can use the function for timeval and compat interfaces as well.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns -EINVAL if sec/nsec are not normalized. Otherwise 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">poll_select_set_timeout</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="kt">long</span> <span class="n">sec</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nsec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span> <span class="o">=</span> <span class="p">{.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">sec</span><span class="p">,</span> <span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">nsec</span><span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">timespec_valid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* Optimize for the zero timeout value here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sec</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nsec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">to</span><span class="o">-&gt;</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ktime_get_ts</span><span class="p">(</span><span class="n">to</span><span class="p">);</span>
		<span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="n">timespec_add_safe</span><span class="p">(</span><span class="o">*</span><span class="n">to</span><span class="p">,</span> <span class="n">ts</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">poll_select_copy_remaining</span><span class="p">(</span><span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">end_time</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">timeval</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">rts</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">rtv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">STICKY_TIMEOUTS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">sticky</span><span class="p">;</span>

	<span class="cm">/* No update for zero timeout */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">end_time</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">end_time</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ktime_get_ts</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rts</span><span class="p">);</span>
	<span class="n">rts</span> <span class="o">=</span> <span class="n">timespec_sub</span><span class="p">(</span><span class="o">*</span><span class="n">end_time</span><span class="p">,</span> <span class="n">rts</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">rts</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">rts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rtv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rtv</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rtv</span><span class="p">.</span><span class="n">tv_usec</span><span class="p">))</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rtv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rtv</span><span class="p">));</span>
		<span class="n">rtv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">rts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">rtv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="n">rts</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">/</span> <span class="n">NSEC_PER_USEC</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rtv</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rtv</span><span class="p">)))</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rts</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rts</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If an application puts its timeval in read-only memory, we</span>
<span class="cm">	 * don&#39;t want the Linux-specific update to the timeval to</span>
<span class="cm">	 * cause a fault after the select has completed</span>
<span class="cm">	 * successfully. However, because we&#39;re not updating the</span>
<span class="cm">	 * timeval, we can&#39;t restart the system call.</span>
<span class="cm">	 */</span>

<span class="nl">sticky:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define FDS_IN(fds, n)		(fds-&gt;in + n)</span>
<span class="cp">#define FDS_OUT(fds, n)		(fds-&gt;out + n)</span>
<span class="cp">#define FDS_EX(fds, n)		(fds-&gt;ex + n)</span>

<span class="cp">#define BITS(fds, n)	(*FDS_IN(fds, n)|*FDS_OUT(fds, n)|*FDS_EX(fds, n))</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">max_select_fd</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set_bits</span> <span class="o">*</span><span class="n">fds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">open_fds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">set</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>

	<span class="cm">/* handle last in-complete long-word first */</span>
	<span class="n">set</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="o">~</span><span class="mi">0UL</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">__NFDBITS</span><span class="o">-</span><span class="mi">1</span><span class="p">)));</span>
	<span class="n">n</span> <span class="o">/=</span> <span class="n">__NFDBITS</span><span class="p">;</span>
	<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
	<span class="n">open_fds</span> <span class="o">=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">open_fds</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set</span> <span class="o">&amp;=</span> <span class="n">BITS</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="o">~*</span><span class="n">open_fds</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">get_max</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">open_fds</span><span class="o">--</span><span class="p">;</span>
		<span class="n">n</span><span class="o">--</span><span class="p">;</span>
		<span class="n">set</span> <span class="o">=</span> <span class="n">BITS</span><span class="p">(</span><span class="n">fds</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">set</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">set</span> <span class="o">&amp;</span> <span class="o">~*</span><span class="n">open_fds</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
<span class="nl">get_max:</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">max</span><span class="o">++</span><span class="p">;</span>
			<span class="n">set</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">set</span><span class="p">);</span>
		<span class="n">max</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">__NFDBITS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">max</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define POLLIN_SET (POLLRDNORM | POLLRDBAND | POLLIN | POLLHUP | POLLERR)</span>
<span class="cp">#define POLLOUT_SET (POLLWRBAND | POLLWRNORM | POLLOUT | POLLERR)</span>
<span class="cp">#define POLLEX_SET (POLLPRI)</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">wait_key_set</span><span class="p">(</span><span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">in</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_key</span> <span class="o">=</span> <span class="n">POLLEX_SET</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">in</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span>
		<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_key</span> <span class="o">|=</span> <span class="n">POLLIN_SET</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">out</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span>
		<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_key</span> <span class="o">|=</span> <span class="n">POLLOUT_SET</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">do_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set_bits</span> <span class="o">*</span><span class="n">fds</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">end_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ktime_t</span> <span class="n">expire</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="n">table</span><span class="p">;</span>
	<span class="n">poll_table</span> <span class="o">*</span><span class="n">wait</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">max_select_fd</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fds</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>

	<span class="n">poll_initwait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
	<span class="n">wait</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">.</span><span class="n">pt</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">end_time</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">end_time</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timed_out</span><span class="p">)</span>
		<span class="n">slack</span> <span class="o">=</span> <span class="n">select_estimate_accuracy</span><span class="p">(</span><span class="n">end_time</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">rinp</span><span class="p">,</span> <span class="o">*</span><span class="n">routp</span><span class="p">,</span> <span class="o">*</span><span class="n">rexp</span><span class="p">,</span> <span class="o">*</span><span class="n">inp</span><span class="p">,</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>

		<span class="n">inp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">in</span><span class="p">;</span> <span class="n">outp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">out</span><span class="p">;</span> <span class="n">exp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">ex</span><span class="p">;</span>
		<span class="n">rinp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">res_in</span><span class="p">;</span> <span class="n">routp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">res_out</span><span class="p">;</span> <span class="n">rexp</span> <span class="o">=</span> <span class="n">fds</span><span class="o">-&gt;</span><span class="n">res_ex</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">rinp</span><span class="p">,</span> <span class="o">++</span><span class="n">routp</span><span class="p">,</span> <span class="o">++</span><span class="n">rexp</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">ex</span><span class="p">,</span> <span class="n">all_bits</span><span class="p">,</span> <span class="n">bit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">mask</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">res_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">res_ex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="o">*</span><span class="n">f_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">in</span> <span class="o">=</span> <span class="o">*</span><span class="n">inp</span><span class="o">++</span><span class="p">;</span> <span class="n">out</span> <span class="o">=</span> <span class="o">*</span><span class="n">outp</span><span class="o">++</span><span class="p">;</span> <span class="n">ex</span> <span class="o">=</span> <span class="o">*</span><span class="n">exp</span><span class="o">++</span><span class="p">;</span>
			<span class="n">all_bits</span> <span class="o">=</span> <span class="n">in</span> <span class="o">|</span> <span class="n">out</span> <span class="o">|</span> <span class="n">ex</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">all_bits</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">+=</span> <span class="n">__NFDBITS</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">__NFDBITS</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">,</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="n">bit</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">bit</span> <span class="o">&amp;</span> <span class="n">all_bits</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">f_op</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="p">;</span>
					<span class="n">mask</span> <span class="o">=</span> <span class="n">DEFAULT_POLLMASK</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">wait_key_set</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">in</span><span class="p">,</span> <span class="n">out</span><span class="p">,</span> <span class="n">bit</span><span class="p">);</span>
						<span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)(</span><span class="n">file</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">POLLIN_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">in</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">res_in</span> <span class="o">|=</span> <span class="n">bit</span><span class="p">;</span>
						<span class="n">retval</span><span class="o">++</span><span class="p">;</span>
						<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">POLLOUT_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">out</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">res_out</span> <span class="o">|=</span> <span class="n">bit</span><span class="p">;</span>
						<span class="n">retval</span><span class="o">++</span><span class="p">;</span>
						<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
					<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">POLLEX_SET</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ex</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">res_ex</span> <span class="o">|=</span> <span class="n">bit</span><span class="p">;</span>
						<span class="n">retval</span><span class="o">++</span><span class="p">;</span>
						<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_in</span><span class="p">)</span>
				<span class="o">*</span><span class="n">rinp</span> <span class="o">=</span> <span class="n">res_in</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_out</span><span class="p">)</span>
				<span class="o">*</span><span class="n">routp</span> <span class="o">=</span> <span class="n">res_out</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">res_ex</span><span class="p">)</span>
				<span class="o">*</span><span class="n">rexp</span> <span class="o">=</span> <span class="n">res_ex</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">wait</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">||</span> <span class="n">timed_out</span> <span class="o">||</span> <span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">table</span><span class="p">.</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">table</span><span class="p">.</span><span class="n">error</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this is the first loop and we have a timeout</span>
<span class="cm">		 * given, then we convert to ktime_t and set the to</span>
<span class="cm">		 * pointer to the expiry value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">expire</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="o">*</span><span class="n">end_time</span><span class="p">);</span>
			<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expire</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">poll_schedule_timeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span>
					   <span class="n">to</span><span class="p">,</span> <span class="n">slack</span><span class="p">))</span>
			<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">poll_freewait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We can actually return ERESTARTSYS instead of EINTR, but I&#39;d</span>
<span class="cm"> * like to be certain this leads to no problems. So I return</span>
<span class="cm"> * EINTR just for safety.</span>
<span class="cm"> *</span>
<span class="cm"> * Update: ERESTARTSYS breaks at least the xview clock binary, so</span>
<span class="cm"> * I&#39;m trying ERESTARTNOHAND which restart only when you want to.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">core_sys_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">inp</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span>
			   <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">exp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">end_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">fd_set_bits</span> <span class="n">fds</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">bits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">max_fds</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fdtable</span> <span class="o">*</span><span class="n">fdt</span><span class="p">;</span>
	<span class="cm">/* Allocate small arguments on the stack to save memory and be faster */</span>
	<span class="kt">long</span> <span class="n">stack_fds</span><span class="p">[</span><span class="n">SELECT_STACK_ALLOC</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)];</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_nofds</span><span class="p">;</span>

	<span class="cm">/* max_fds can increase, so grab it once to avoid race */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">fdt</span> <span class="o">=</span> <span class="n">files_fdtable</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">files</span><span class="p">);</span>
	<span class="n">max_fds</span> <span class="o">=</span> <span class="n">fdt</span><span class="o">-&gt;</span><span class="n">max_fds</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">max_fds</span><span class="p">)</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">max_fds</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need 6 bitmaps (in/out/ex for both incoming and outgoing),</span>
<span class="cm">	 * since we used fdset we need to allocate memory in units of</span>
<span class="cm">	 * long-words. </span>
<span class="cm">	 */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">FDS_BYTES</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
	<span class="n">bits</span> <span class="o">=</span> <span class="n">stack_fds</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">stack_fds</span><span class="p">)</span> <span class="o">/</span> <span class="mi">6</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Not enough space in on-stack array; must use kmalloc */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">bits</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bits</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_nofds</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">in</span>      <span class="o">=</span> <span class="n">bits</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">out</span>     <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span>   <span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">ex</span>      <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">res_in</span>  <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">3</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">res_out</span> <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">4</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
	<span class="n">fds</span><span class="p">.</span><span class="n">res_ex</span>  <span class="o">=</span> <span class="n">bits</span> <span class="o">+</span> <span class="mi">5</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">in</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">out</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">ret</span> <span class="o">=</span> <span class="n">get_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">ex</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">zero_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_in</span><span class="p">);</span>
	<span class="n">zero_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_out</span><span class="p">);</span>
	<span class="n">zero_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_ex</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_select</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fds</span><span class="p">,</span> <span class="n">end_time</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_in</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">set_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_out</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">set_fd_set</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">fds</span><span class="p">.</span><span class="n">res_ex</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">!=</span> <span class="n">stack_fds</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bits</span><span class="p">);</span>
<span class="nl">out_nofds:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">select</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span>
		<span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tvp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tvp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tv</span><span class="p">,</span> <span class="n">tvp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tv</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">end_time</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">poll_select_set_timeout</span><span class="p">(</span><span class="n">to</span><span class="p">,</span>
				<span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">+</span> <span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">/</span> <span class="n">USEC_PER_SEC</span><span class="p">),</span>
				<span class="p">(</span><span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">%</span> <span class="n">USEC_PER_SEC</span><span class="p">)</span> <span class="o">*</span> <span class="n">NSEC_PER_USEC</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">core_sys_select</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">poll_select_copy_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">,</span> <span class="n">tvp</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="n">do_pselect</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">inp</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span>
		       <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">exp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="n">tsp</span><span class="p">,</span>
		       <span class="k">const</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sigmask</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigsaved</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">end_time</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">poll_select_set_timeout</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX: Don&#39;t preclude handling different sized sigset_t&#39;s.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ksigmask</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span><span class="o">|</span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">core_sys_select</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">poll_select_copy_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t restore the signal mask yet. Let do_signal() deliver</span>
<span class="cm">		 * the signal on the way back to userspace, before the signal</span>
<span class="cm">		 * mask is restored.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">saved_sigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sigsaved</span><span class="p">));</span>
			<span class="n">set_restore_sigmask</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Most architectures can&#39;t handle 7-argument syscalls. So we provide a</span>
<span class="cm"> * 6-argument version where the sixth argument is a pointer to a structure</span>
<span class="cm"> * which has a pointer to the sigset_t itself followed by a size_t containing</span>
<span class="cm"> * the sigset size.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE6</span><span class="p">(</span><span class="n">pselect6</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span>
		<span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span>
		<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">sig</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">sigsetsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">up</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sig</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">access_ok</span><span class="p">(</span><span class="n">VERIFY_READ</span><span class="p">,</span> <span class="n">sig</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">size_t</span><span class="p">))</span>
		    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">up</span><span class="p">,</span> <span class="p">(</span><span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">sig</span><span class="p">)</span>
		    <span class="o">||</span> <span class="n">__get_user</span><span class="p">(</span><span class="n">sigsetsize</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">size_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)(</span><span class="n">sig</span><span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">))))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">do_pselect</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">inp</span><span class="p">,</span> <span class="n">outp</span><span class="p">,</span> <span class="n">exp</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="n">up</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef __ARCH_WANT_SYS_OLD_SELECT</span>
<span class="k">struct</span> <span class="n">sel_arg_struct</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">n</span><span class="p">;</span>
	<span class="n">fd_set</span> <span class="n">__user</span> <span class="o">*</span><span class="n">inp</span><span class="p">,</span> <span class="o">*</span><span class="n">outp</span><span class="p">,</span> <span class="o">*</span><span class="n">exp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timeval</span> <span class="n">__user</span> <span class="o">*</span><span class="n">tvp</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">old_select</span><span class="p">,</span> <span class="k">struct</span> <span class="n">sel_arg_struct</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sel_arg_struct</span> <span class="n">a</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sys_select</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">n</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">inp</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">outp</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">exp</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">tvp</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">struct</span> <span class="n">poll_list</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_list</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">entries</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define POLLFD_PER_PAGE  ((PAGE_SIZE-sizeof(struct poll_list)) / sizeof(struct pollfd))</span>

<span class="cm">/*</span>
<span class="cm"> * Fish for pollable events on the pollfd-&gt;fd file descriptor. We&#39;re only</span>
<span class="cm"> * interested in events matching the pollfd-&gt;events mask, and the result</span>
<span class="cm"> * matching that mask is both recorded in pollfd-&gt;revents and returned. The</span>
<span class="cm"> * pwait poll_table will be used by the fd-provided poll handler for waiting,</span>
<span class="cm"> * if pwait-&gt;_qproc is non-NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">do_pollfd</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">pollfd</span><span class="p">,</span> <span class="n">poll_table</span> <span class="o">*</span><span class="n">pwait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fd</span><span class="p">;</span>

	<span class="n">mask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">fd</span> <span class="o">=</span> <span class="n">pollfd</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span> <span class="n">file</span><span class="p">;</span>

		<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
		<span class="n">mask</span> <span class="o">=</span> <span class="n">POLLNVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mask</span> <span class="o">=</span> <span class="n">DEFAULT_POLLMASK</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">&amp;&amp;</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pwait</span><span class="o">-&gt;</span><span class="n">_key</span> <span class="o">=</span> <span class="n">pollfd</span><span class="o">-&gt;</span><span class="n">events</span><span class="o">|</span><span class="n">POLLERR</span><span class="o">|</span><span class="n">POLLHUP</span><span class="p">;</span>
				<span class="n">mask</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pwait</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="cm">/* Mask out unneeded events. */</span>
			<span class="n">mask</span> <span class="o">&amp;=</span> <span class="n">pollfd</span><span class="o">-&gt;</span><span class="n">events</span> <span class="o">|</span> <span class="n">POLLERR</span> <span class="o">|</span> <span class="n">POLLHUP</span><span class="p">;</span>
			<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">pollfd</span><span class="o">-&gt;</span><span class="n">revents</span> <span class="o">=</span> <span class="n">mask</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">mask</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_poll</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">poll_list</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">end_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">poll_table</span><span class="o">*</span> <span class="n">pt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">pt</span><span class="p">;</span>
	<span class="n">ktime_t</span> <span class="n">expire</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timed_out</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">slack</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Optimise the no-wait case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">end_time</span><span class="o">-&gt;</span><span class="n">tv_sec</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">end_time</span><span class="o">-&gt;</span><span class="n">tv_nsec</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pt</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">timed_out</span><span class="p">)</span>
		<span class="n">slack</span> <span class="o">=</span> <span class="n">select_estimate_accuracy</span><span class="p">(</span><span class="n">end_time</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">poll_list</span> <span class="o">*</span><span class="n">walk</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">walk</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span> <span class="n">walk</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">walk</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span> <span class="n">pfd</span><span class="p">,</span> <span class="o">*</span> <span class="n">pfd_end</span><span class="p">;</span>

			<span class="n">pfd</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
			<span class="n">pfd_end</span> <span class="o">=</span> <span class="n">pfd</span> <span class="o">+</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(;</span> <span class="n">pfd</span> <span class="o">!=</span> <span class="n">pfd_end</span><span class="p">;</span> <span class="n">pfd</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * Fish for events. If we found one, record it</span>
<span class="cm">				 * and kill poll_table-&gt;_qproc, so we don&#39;t</span>
<span class="cm">				 * needlessly register any other waiters after</span>
<span class="cm">				 * this. They&#39;ll get immediately deregistered</span>
<span class="cm">				 * when we break out and return.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">do_pollfd</span><span class="p">(</span><span class="n">pfd</span><span class="p">,</span> <span class="n">pt</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">count</span><span class="o">++</span><span class="p">;</span>
					<span class="n">pt</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * All waiters have already been registered, so don&#39;t provide</span>
<span class="cm">		 * a poll_table-&gt;_qproc to them on the next loop iteration.</span>
<span class="cm">		 */</span>
		<span class="n">pt</span><span class="o">-&gt;</span><span class="n">_qproc</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">count</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">wait</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span>
				<span class="n">count</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">||</span> <span class="n">timed_out</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If this is the first loop and we have a timeout</span>
<span class="cm">		 * given, then we convert to ktime_t and set the to</span>
<span class="cm">		 * pointer to the expiry value.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_time</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">to</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">expire</span> <span class="o">=</span> <span class="n">timespec_to_ktime</span><span class="p">(</span><span class="o">*</span><span class="n">end_time</span><span class="p">);</span>
			<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">expire</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">poll_schedule_timeout</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">slack</span><span class="p">))</span>
			<span class="n">timed_out</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define N_STACK_PPS ((sizeof(stack_pps) - sizeof(struct poll_list))  / \</span>
<span class="cp">			sizeof(struct pollfd))</span>

<span class="kt">int</span> <span class="nf">do_sys_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ufds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nfds</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">end_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">poll_wqueues</span> <span class="n">table</span><span class="p">;</span>
 	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">,</span> <span class="n">fdcount</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>
	<span class="cm">/* Allocate small arguments on the stack to save memory and be</span>
<span class="cm">	   faster - use long to make sure the buffer is aligned properly</span>
<span class="cm">	   on 64 bit archs to avoid unaligned access */</span>
	<span class="kt">long</span> <span class="n">stack_pps</span><span class="p">[</span><span class="n">POLL_STACK_ALLOC</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">long</span><span class="p">)];</span>
	<span class="k">struct</span> <span class="n">poll_list</span> <span class="o">*</span><span class="k">const</span> <span class="n">head</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">poll_list</span> <span class="o">*</span><span class="p">)</span><span class="n">stack_pps</span><span class="p">;</span>
 	<span class="k">struct</span> <span class="n">poll_list</span> <span class="o">*</span><span class="n">walk</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">todo</span> <span class="o">=</span> <span class="n">nfds</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nfds</span> <span class="o">&gt;</span> <span class="n">rlimit</span><span class="p">(</span><span class="n">RLIMIT_NOFILE</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">N_STACK_PPS</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">walk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">walk</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">walk</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">,</span> <span class="n">ufds</span> <span class="o">+</span> <span class="n">nfds</span><span class="o">-</span><span class="n">todo</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span><span class="p">)</span> <span class="o">*</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_fds</span><span class="p">;</span>

		<span class="n">todo</span> <span class="o">-=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">todo</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">todo</span><span class="p">,</span> <span class="n">POLLFD_PER_PAGE</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">poll_list</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">pollfd</span><span class="p">)</span> <span class="o">*</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">walk</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">walk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_fds</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">poll_initwait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>
	<span class="n">fdcount</span> <span class="o">=</span> <span class="n">do_poll</span><span class="p">(</span><span class="n">nfds</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">table</span><span class="p">,</span> <span class="n">end_time</span><span class="p">);</span>
	<span class="n">poll_freewait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">table</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">walk</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span> <span class="n">walk</span><span class="p">;</span> <span class="n">walk</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">pollfd</span> <span class="o">*</span><span class="n">fds</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">entries</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">j</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">,</span> <span class="n">ufds</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">fds</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">revents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ufds</span><span class="o">-&gt;</span><span class="n">revents</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_fds</span><span class="p">;</span>
  	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">fdcount</span><span class="p">;</span>
<span class="nl">out_fds:</span>
	<span class="n">walk</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">walk</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">poll_list</span> <span class="o">*</span><span class="n">pos</span> <span class="o">=</span> <span class="n">walk</span><span class="p">;</span>
		<span class="n">walk</span> <span class="o">=</span> <span class="n">walk</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">do_restart_poll</span><span class="p">(</span><span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">pollfd</span> <span class="n">__user</span> <span class="o">*</span><span class="n">ufds</span> <span class="o">=</span> <span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">ufds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nfds</span> <span class="o">=</span> <span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">nfds</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">end_time</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">has_timeout</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end_time</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
		<span class="n">end_time</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">end_time</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sys_poll</span><span class="p">(</span><span class="n">ufds</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">do_restart_poll</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">poll</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">ufds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span>
		<span class="kt">int</span><span class="p">,</span> <span class="n">timeout_msecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">end_time</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">timeout_msecs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">end_time</span><span class="p">;</span>
		<span class="n">poll_select_set_timeout</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">timeout_msecs</span> <span class="o">/</span> <span class="n">MSEC_PER_SEC</span><span class="p">,</span>
			<span class="n">NSEC_PER_MSEC</span> <span class="o">*</span> <span class="p">(</span><span class="n">timeout_msecs</span> <span class="o">%</span> <span class="n">MSEC_PER_SEC</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sys_poll</span><span class="p">(</span><span class="n">ufds</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">restart_block</span> <span class="o">*</span><span class="n">restart_block</span><span class="p">;</span>

		<span class="n">restart_block</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">current_thread_info</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">restart_block</span><span class="p">;</span>
		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">do_restart_poll</span><span class="p">;</span>
		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">ufds</span> <span class="o">=</span> <span class="n">ufds</span><span class="p">;</span>
		<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">nfds</span> <span class="o">=</span> <span class="n">nfds</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">timeout_msecs</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">end_time</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">;</span>
			<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">end_time</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">;</span>
			<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">has_timeout</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">restart_block</span><span class="o">-&gt;</span><span class="n">poll</span><span class="p">.</span><span class="n">has_timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTART_RESTARTBLOCK</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE5</span><span class="p">(</span><span class="n">ppoll</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pollfd</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">ufds</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">timespec</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="k">const</span> <span class="n">sigset_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">,</span>
		<span class="kt">size_t</span><span class="p">,</span> <span class="n">sigsetsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sigset_t</span> <span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigsaved</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ts</span><span class="p">,</span> <span class="n">end_time</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tsp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ts</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">to</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">end_time</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">poll_select_set_timeout</span><span class="p">(</span><span class="n">to</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* XXX: Don&#39;t preclude handling different sized sigset_t&#39;s.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sigsetsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sigset_t</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ksigmask</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

		<span class="n">sigdelsetmask</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="n">sigmask</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">)</span><span class="o">|</span><span class="n">sigmask</span><span class="p">(</span><span class="n">SIGSTOP</span><span class="p">));</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ksigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_sys_poll</span><span class="p">(</span><span class="n">ufds</span><span class="p">,</span> <span class="n">nfds</span><span class="p">,</span> <span class="n">to</span><span class="p">);</span>

	<span class="cm">/* We can restart this syscall, usually */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t restore the signal mask yet. Let do_signal() deliver</span>
<span class="cm">		 * the signal on the way back to userspace, before the signal</span>
<span class="cm">		 * mask is restored.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">saved_sigmask</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="n">sigsaved</span><span class="p">));</span>
			<span class="n">set_restore_sigmask</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTNOHAND</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sigmask</span><span class="p">)</span>
		<span class="n">sigprocmask</span><span class="p">(</span><span class="n">SIG_SETMASK</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sigsaved</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">poll_select_copy_remaining</span><span class="p">(</span><span class="o">&amp;</span><span class="n">end_time</span><span class="p">,</span> <span class="n">tsp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
