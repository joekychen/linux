<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jbd › checkpoint.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>checkpoint.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/jbd/checkpoint.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1999</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999 Red Hat Software --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Checkpoint routines for the generic filesystem journaling code.</span>
<span class="cm"> * Part of the ext2fs journaling system.</span>
<span class="cm"> *</span>
<span class="cm"> * Checkpointing is the process of ensuring that a section of the log is</span>
<span class="cm"> * committed fully to disk, so that that portion of the log can be</span>
<span class="cm"> * reused.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;trace/events/jbd.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a buffer from a transaction checkpoint list.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with j_list_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__buffer_unlink_first</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">;</span>

	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span><span class="o">-&gt;</span><span class="n">b_cpprev</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span><span class="o">-&gt;</span><span class="n">b_cpnext</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">==</span> <span class="n">jh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">==</span> <span class="n">jh</span><span class="p">)</span>
			<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Unlink a buffer from a transaction checkpoint(io) list.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with j_list_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__buffer_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">;</span>

	<span class="n">__buffer_unlink_first</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">==</span> <span class="n">jh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">==</span> <span class="n">jh</span><span class="p">)</span>
			<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move a buffer from the checkpoint list to the checkpoint io list</span>
<span class="cm"> *</span>
<span class="cm"> * Called with j_list_lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">__buffer_relink_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">;</span>

	<span class="n">__buffer_unlink_first</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span><span class="o">-&gt;</span><span class="n">b_cpprev</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span><span class="o">-&gt;</span><span class="n">b_cpnext</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span><span class="o">-&gt;</span><span class="n">b_cpprev</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to release a checkpointed buffer from its transaction.</span>
<span class="cm"> * Returns 1 if we released it and 2 if we also released the</span>
<span class="cm"> * whole transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Requires j_list_lock</span>
<span class="cm"> * Called under jbd_lock_bh_state(jh2bh(jh)), and drops it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__try_to_free_cp_buf</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_None</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Get our reference so that bh cannot be freed before</span>
<span class="cm">		 * we unlock it</span>
<span class="cm">		 */</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;remove from checkpoint list&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__journal_remove_checkpoint</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;release&quot;</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __log_wait_for_space: wait until there is space in the journal.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under j-state_lock *only*.  It will be unlocked if we have to wait</span>
<span class="cm"> * for a checkpoint to free up some space in the log.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__log_wait_for_space</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">space_left</span><span class="p">;</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">nblocks</span> <span class="o">=</span> <span class="n">jbd_space_needed</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">__log_space_left</span><span class="p">(</span><span class="n">journal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nblocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JFS_ABORT</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Test again, another process may have checkpointed while we</span>
<span class="cm">		 * were waiting for the checkpoint lock. If there are no</span>
<span class="cm">		 * transactions ready to be checkpointed, try to recover</span>
<span class="cm">		 * journal space by calling cleanup_journal_tail(), and if</span>
<span class="cm">		 * that doesn&#39;t work, by waiting for the currently committing</span>
<span class="cm">		 * transaction to complete.  If there is absolutely no way</span>
<span class="cm">		 * to make progress, this is either a BUG or corrupted</span>
<span class="cm">		 * filesystem, so abort the journal and leave a stack</span>
<span class="cm">		 * trace for forensic evidence.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">nblocks</span> <span class="o">=</span> <span class="n">jbd_space_needed</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="n">space_left</span> <span class="o">=</span> <span class="n">__log_space_left</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space_left</span> <span class="o">&lt;</span> <span class="n">nblocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">chkpt</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">tid_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span>
				<span class="n">tid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">chkpt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">log_do_checkpoint</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cleanup_journal_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We were able to recover space; yay! */</span>
				<span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">log_wait_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: needed %d blocks and &quot;</span>
				       <span class="s">&quot;only had %d space available</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">__func__</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">space_left</span><span class="p">);</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: no way to get more &quot;</span>
				       <span class="s">&quot;journal space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_mutex</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We were unable to perform jbd_trylock_bh_state() inside j_list_lock.</span>
<span class="cm"> * The caller must restart a list walk.  Wait for someone else to run</span>
<span class="cm"> * jbd_unlock_bh_state().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">jbd_sync_bh</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">put_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Clean up transaction&#39;s list of buffers submitted for io.</span>
<span class="cm"> * We wait for any pending IO to complete and remove any clean</span>
<span class="cm"> * buffers. Note that we take the buffers in the opposite ordering</span>
<span class="cm"> * from the one in which they were submitted for IO.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, and return &lt;0 if some buffers have failed</span>
<span class="cm"> * to be written out.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with j_list_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__wait_cp_io</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">this_tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">this_tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="cm">/* Did somebody clean up the transaction in the meanwhile? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">!=</span> <span class="n">transaction</span> <span class="o">||</span>
			<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span> <span class="o">!=</span> <span class="n">this_tid</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">released</span> <span class="o">&amp;&amp;</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd_trylock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jbd_sync_bh</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
			<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="cm">/* the journal_head may have gone by now */</span>
			<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;brelse&quot;</span><span class="p">);</span>
			<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Now in whatever state the buffer currently is, we know that</span>
<span class="cm">		 * it has been written out and so we can drop it from the list</span>
<span class="cm">		 */</span>
		<span class="n">released</span> <span class="o">=</span> <span class="n">__journal_remove_checkpoint</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define NR_BATCH	64</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__flush_batch</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bhs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">batch_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>

	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">batch_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">write_dirty_buffer</span><span class="p">(</span><span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">WRITE_SYNC</span><span class="p">);</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">batch_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bhs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">clear_buffer_jwrite</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;brelse&quot;</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">batch_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Try to flush one buffer from the checkpoint list to disk.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 1 if something happened which requires us to abort the current</span>
<span class="cm"> * scan of the checkpoint list.  Return &lt;0 if the buffer has failed to</span>
<span class="cm"> * be written out.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with j_list_lock held and drops it if 1 is returned</span>
<span class="cm"> * Called under jbd_lock_bh_state(jh2bh(jh)), and drops it</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__process_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bhs</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">batch_count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="cm">/* the journal_head may have gone by now */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;brelse&quot;</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction_t</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">;</span>
		<span class="n">tid_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
		<span class="n">log_wait_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buffer_write_io_error</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="o">!</span><span class="n">buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;remove from checkpoint&quot;</span><span class="p">);</span>
		<span class="n">__journal_remove_checkpoint</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Important: we are about to write the buffer, and</span>
<span class="cm">		 * possibly block, while still holding the journal lock.</span>
<span class="cm">		 * We cannot afford to let the transaction logic start</span>
<span class="cm">		 * messing around with this buffer before we write it to</span>
<span class="cm">		 * disk, as that would break recoverability.</span>
<span class="cm">		 */</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;queue&quot;</span><span class="p">);</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">!</span><span class="n">buffer_jwrite</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
		<span class="n">set_buffer_jwrite</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bhs</span><span class="p">[</span><span class="o">*</span><span class="n">batch_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">__buffer_relink_io</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">(</span><span class="o">*</span><span class="n">batch_count</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">batch_count</span> <span class="o">==</span> <span class="n">NR_BATCH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
			<span class="n">__flush_batch</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bhs</span><span class="p">,</span> <span class="n">batch_count</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Perform an actual checkpoint. We take the first transaction on the</span>
<span class="cm"> * list of transactions to be checkpointed and send all its buffers</span>
<span class="cm"> * to disk. We submit larger chunks of data at once.</span>
<span class="cm"> *</span>
<span class="cm"> * The journal should be locked before calling this function.</span>
<span class="cm"> * Called with j_checkpoint_mutex held.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">log_do_checkpoint</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="n">tid_t</span> <span class="n">this_tid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Start checkpoint</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * First thing: if there are any transactions in the log which</span>
<span class="cm">	 * don&#39;t need checkpointing, just eliminate them from the</span>
<span class="cm">	 * journal straight away.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="n">cleanup_journal_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">trace_jbd_checkpoint</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cleanup_journal_tail returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">result</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, we need to start writing disk blocks.  Take one transaction</span>
<span class="cm">	 * and write it.</span>
<span class="cm">	 */</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>
	<span class="n">this_tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
<span class="nl">restart:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If someone cleaned up this transaction while we slept, we&#39;re</span>
<span class="cm">	 * done (maybe it&#39;s a new transaction, but it fell at the same</span>
<span class="cm">	 * address).</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">==</span> <span class="n">transaction</span> <span class="o">&amp;&amp;</span>
			<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span> <span class="o">==</span> <span class="n">this_tid</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">batch_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bhs</span><span class="p">[</span><span class="n">NR_BATCH</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">retry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">retry</span> <span class="o">&amp;&amp;</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

			<span class="n">jh</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span><span class="p">;</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jbd_trylock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">jbd_sync_bh</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
				<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">retry</span> <span class="o">=</span> <span class="n">__process_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">jh</span><span class="p">,</span> <span class="n">bhs</span><span class="p">,</span><span class="o">&amp;</span><span class="n">batch_count</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retry</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">result</span><span class="p">)</span>
				<span class="n">result</span> <span class="o">=</span> <span class="n">retry</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retry</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">()</span> <span class="o">||</span>
				<span class="n">spin_needbreak</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
				<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">batch_count</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retry</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
				<span class="n">retry</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">__flush_batch</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bhs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">batch_count</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">restart</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now we have cleaned up the first transaction&#39;s checkpoint</span>
<span class="cm">		 * list. Let&#39;s clean up the second one</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__wait_cp_io</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
			<span class="n">result</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">journal_abort</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">result</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">result</span> <span class="o">=</span> <span class="n">cleanup_journal_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="n">result</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check the list of checkpoint transactions for the journal to see if</span>
<span class="cm"> * we have already got rid of any since the last update of the log tail</span>
<span class="cm"> * in the journal superblock.  If so, we can instantly roll the</span>
<span class="cm"> * superblock forward to remove those transactions from the log.</span>
<span class="cm"> *</span>
<span class="cm"> * Return &lt;0 on error, 0 on success, 1 if there was nothing to clean up.</span>
<span class="cm"> *</span>
<span class="cm"> * This is the only part of the journaling code which really needs to be</span>
<span class="cm"> * aware of transaction aborts.  Checkpointing involves writing to the</span>
<span class="cm"> * main filesystem area rather than to the journal, so it can proceed</span>
<span class="cm"> * even in abort state, but we must not update the super block if</span>
<span class="cm"> * checkpointing may have failed.  Otherwise, we would lose some metadata</span>
<span class="cm"> * buffers which should be written-back to the filesystem.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">cleanup_journal_tail</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span> <span class="n">transaction</span><span class="p">;</span>
	<span class="n">tid_t</span>		<span class="n">first_tid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">blocknr</span><span class="p">,</span> <span class="n">freed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * OK, work out the oldest transaction remaining in the log, and</span>
<span class="cm">	 * the log block it starts at.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If the log is now empty, we need to work out which is the</span>
<span class="cm">	 * next transaction ID we will write, and where it will</span>
<span class="cm">	 * start.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_log_start</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_log_start</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">first_tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">first_tid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span><span class="p">;</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_head</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">blocknr</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* If the oldest pinned transaction is at the tail of the log</span>
<span class="cm">           already then there&#39;s not much we can do right now. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span> <span class="o">==</span> <span class="n">first_tid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to make sure that any blocks that were recently written out</span>
<span class="cm">	 * --- perhaps by log_do_checkpoint() --- are flushed out before we</span>
<span class="cm">	 * drop the transactions from the journal. Similarly we need to be sure</span>
<span class="cm">	 * superblock makes it to disk before next transaction starts reusing</span>
<span class="cm">	 * freed space (otherwise we could replay some blocks of the new</span>
<span class="cm">	 * transaction thinking they belong to the old one). So we use</span>
<span class="cm">	 * WRITE_FLUSH_FUA. It&#39;s unlikely this will be necessary, especially</span>
<span class="cm">	 * with an appropriately sized journal, but we need this to guarantee</span>
<span class="cm">	 * correctness.  Fortunately cleanup_journal_tail() doesn&#39;t get called</span>
<span class="cm">	 * all that often.</span>
<span class="cm">	 */</span>
	<span class="n">journal_update_sb_log_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">first_tid</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span>
				   <span class="n">WRITE_FLUSH_FUA</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="cm">/* OK, update the superblock to recover the freed space.</span>
<span class="cm">	 * Physical blocks come first: have we wrapped beyond the end of</span>
<span class="cm">	 * the log?  */</span>
	<span class="n">freed</span> <span class="o">=</span> <span class="n">blocknr</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocknr</span> <span class="o">&lt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span><span class="p">)</span>
		<span class="n">freed</span> <span class="o">=</span> <span class="n">freed</span> <span class="o">+</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span> <span class="o">-</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_first</span><span class="p">;</span>

	<span class="n">trace_jbd_cleanup_journal_tail</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">first_tid</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
		  <span class="s">&quot;Cleaning journal tail from %d to %d (offset %u), &quot;</span>
		  <span class="s">&quot;freeing %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span><span class="p">,</span> <span class="n">first_tid</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">freed</span><span class="p">);</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_free</span> <span class="o">+=</span> <span class="n">freed</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail_sequence</span> <span class="o">=</span> <span class="n">first_tid</span><span class="p">;</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span> <span class="o">=</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Checkpoint list management */</span>

<span class="cm">/*</span>
<span class="cm"> * journal_clean_one_cp_list</span>
<span class="cm"> *</span>
<span class="cm"> * Find all the written-back checkpoint buffers in the given list and release</span>
<span class="cm"> * them.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with j_list_lock held.</span>
<span class="cm"> * Returns number of buffers reaped (for debug)</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_clean_one_cp_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">released</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">last_jh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">next_jh</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">freed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">released</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">last_jh</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">next_jh</span><span class="p">;</span>
		<span class="n">next_jh</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span><span class="p">;</span>
		<span class="cm">/* Use trylock because of the ranking */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jbd_trylock_bh_state</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__try_to_free_cp_buf</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">freed</span><span class="o">++</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">released</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * This function only frees up some memory</span>
<span class="cm">		 * if possible so we dont have an obligation</span>
<span class="cm">		 * to finish processing. Bail out if preemption</span>
<span class="cm">		 * requested:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">jh</span> <span class="o">!=</span> <span class="n">last_jh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">freed</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * journal_clean_checkpoint_list</span>
<span class="cm"> *</span>
<span class="cm"> * Find all the written-back checkpoint buffers in the journal and release them.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the journal locked.</span>
<span class="cm"> * Called with j_list_lock held.</span>
<span class="cm"> * Returns number of buffers reaped (for debug)</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__journal_clean_checkpoint_list</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span> <span class="o">*</span><span class="n">last_transaction</span><span class="p">,</span> <span class="o">*</span><span class="n">next_transaction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">released</span><span class="p">;</span>

	<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">last_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpprev</span><span class="p">;</span>
	<span class="n">next_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">transaction</span> <span class="o">=</span> <span class="n">next_transaction</span><span class="p">;</span>
		<span class="n">next_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">journal_clean_one_cp_list</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span>
				<span class="n">t_checkpoint_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">released</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * This function only frees up some memory if possible so we</span>
<span class="cm">		 * dont have an obligation to finish processing. Bail out if</span>
<span class="cm">		 * preemption requested:</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">released</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * It is essential that we are as careful as in the case of</span>
<span class="cm">		 * t_checkpoint_list with removing the buffer from the list as</span>
<span class="cm">		 * we can possibly see not yet submitted buffers on io_list</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">+=</span> <span class="n">journal_clean_one_cp_list</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span>
				<span class="n">t_checkpoint_io_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">released</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">())</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">transaction</span> <span class="o">!=</span> <span class="n">last_transaction</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * journal_remove_checkpoint: called after a buffer has been committed</span>
<span class="cm"> * to disk (either by being write-back flushed to disk, or being</span>
<span class="cm"> * committed to the log).</span>
<span class="cm"> *</span>
<span class="cm"> * We cannot safely clean a transaction out of the log until all of the</span>
<span class="cm"> * buffer updates committed in that transaction have safely been stored</span>
<span class="cm"> * elsewhere on disk.  To achieve this, all of the buffers in a</span>
<span class="cm"> * transaction need to be maintained on the transaction&#39;s checkpoint</span>
<span class="cm"> * lists until they have been rewritten, at which point this function is</span>
<span class="cm"> * called to remove the buffer from the existing transaction&#39;s</span>
<span class="cm"> * checkpoint lists.</span>
<span class="cm"> *</span>
<span class="cm"> * The function returns 1 if it frees the transaction, 0 otherwise.</span>
<span class="cm"> * The function can free jh and bh.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called with j_list_lock held.</span>
<span class="cm"> * This function is called with jbd_lock_bh_state(jh2bh(jh))</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">__journal_remove_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;not on transaction&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;removing from transaction&quot;</span><span class="p">);</span>
	<span class="n">__buffer_unlink</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
	    <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * There is one special case to worry about: if we have just pulled the</span>
<span class="cm">	 * buffer off a running or committing transaction&#39;s checkpoing list,</span>
<span class="cm">	 * then even if the checkpoint list is empty, the transaction obviously</span>
<span class="cm">	 * cannot be dropped!</span>
<span class="cm">	 *</span>
<span class="cm">	 * The locking here around t_state is a bit sleazy.</span>
<span class="cm">	 * See the comment at the end of journal_commit_transaction().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">!=</span> <span class="n">T_FINISHED</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* OK, that was the last buffer for the transaction: we can now</span>
<span class="cm">	   safely remove this transaction from the log */</span>

	<span class="n">__journal_drop_transaction</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>

	<span class="cm">/* Just in case anybody was waiting for more transactions to be</span>
<span class="cm">           checkpointed... */</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_logspace</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * journal_insert_checkpoint: put a committed buffer onto a checkpoint</span>
<span class="cm"> * list so that we know when it is safe to clean the transaction out of</span>
<span class="cm"> * the log.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the journal locked.</span>
<span class="cm"> * Called with j_list_lock held.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__journal_insert_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span>
			       <span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">))</span> <span class="o">||</span> <span class="n">buffer_jbddirty</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)));</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* Get reference for checkpointing transaction */</span>
	<span class="n">journal_grab_journal_head</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">));</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span><span class="o">-&gt;</span><span class="n">b_cpprev</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpprev</span><span class="o">-&gt;</span><span class="n">b_cpnext</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cpnext</span><span class="o">-&gt;</span><span class="n">b_cpprev</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We&#39;ve finished with this transaction structure: adios...</span>
<span class="cm"> *</span>
<span class="cm"> * The transaction must have no links except for the checkpoint by this</span>
<span class="cm"> * point.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with the journal locked.</span>
<span class="cm"> * Called with j_list_lock held.</span>
<span class="cm"> */</span>

<span class="kt">void</span> <span class="nf">__journal_drop_transaction</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="o">-&gt;</span><span class="n">t_cpprev</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpprev</span><span class="p">;</span>
		<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpprev</span><span class="o">-&gt;</span><span class="n">t_cpnext</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">==</span> <span class="n">transaction</span><span class="p">)</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">=</span>
				<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_cpnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">==</span> <span class="n">transaction</span><span class="p">)</span>
			<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_checkpoint_transactions</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">T_FINISHED</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_sync_datalist</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_forget</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_iobuf_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_shadow_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_log_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_checkpoint_io_list</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span> <span class="o">!=</span> <span class="n">transaction</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">!=</span> <span class="n">transaction</span><span class="p">);</span>

	<span class="n">trace_jbd_drop_transaction</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Dropping transaction %d, all done</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">transaction</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
