<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jbd › transaction.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>transaction.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/jbd/transaction.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1998</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1998 Red Hat corp --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Generic filesystem transaction handling code; part of the ext2fs</span>
<span class="cm"> * journaling system.</span>
<span class="cm"> *</span>
<span class="cm"> * This file manages transactions (compound commits managed by the</span>
<span class="cm"> * journaling code) and handles (individual atomic operations by the</span>
<span class="cm"> * filesystem).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/timer.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/hrtimer.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * get_transaction: obtain a new transaction_t object.</span>
<span class="cm"> *</span>
<span class="cm"> * Simply allocate and initialise a new transaction.  Create it in</span>
<span class="cm"> * RUNNING state and add it to the current journal (which should not</span>
<span class="cm"> * have an existing running transaction: we only make a new transaction</span>
<span class="cm"> * once we have started to commit the old one).</span>
<span class="cm"> *</span>
<span class="cm"> * Preconditions:</span>
<span class="cm"> *	The journal MUST be locked.  We don&#39;t perform atomic mallocs on the</span>
<span class="cm"> *	new transaction	and we can&#39;t block without protecting against other</span>
<span class="cm"> *	processes trying to touch the journal while it is in transition.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under j_state_lock</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="n">transaction_t</span> <span class="o">*</span>
<span class="nf">get_transaction</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span> <span class="o">=</span> <span class="n">journal</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">=</span> <span class="n">T_RUNNING</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_start_time</span> <span class="o">=</span> <span class="n">ktime_get</span><span class="p">();</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span><span class="o">++</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_interval</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>

	<span class="cm">/* Set up the commit timer for the new transaction. */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span>
				<span class="n">round_jiffies_up</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_expires</span><span class="p">);</span>
	<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_commit_timer</span><span class="p">);</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">transaction</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle management.</span>
<span class="cm"> *</span>
<span class="cm"> * A handle_t is an object which represents a single atomic update to a</span>
<span class="cm"> * filesystem, and which tracks all of the modifications which form part</span>
<span class="cm"> * of that one update.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * start_this_handle: Given a handle, deal with any locking or stalling</span>
<span class="cm"> * needed to make sure that there is enough journal space for the handle</span>
<span class="cm"> * to begin.  Attach the handle to a transaction and set up the</span>
<span class="cm"> * transaction&#39;s buffer credits.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">start_this_handle</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">needed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nblocks</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">new_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nblocks</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: %s wants too many credits (%d &gt; %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span>
		       <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">alloc_transaction:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_transaction</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_transaction</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">congestion_wait</span><span class="p">(</span><span class="n">BLK_RW_ASYNC</span><span class="p">,</span> <span class="n">HZ</span><span class="o">/</span><span class="mi">50</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">alloc_transaction</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;New handle %p going live.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>

<span class="nl">repeat:</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to hold j_state_lock until t_updates has been incremented,</span>
<span class="cm">	 * for proper journal barrier handling</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="nl">repeat_locked:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_journal_aborted</span><span class="p">(</span><span class="n">journal</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_errno</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JFS_ACK_ERR</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wait on the journal&#39;s transaction barrier if necessary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">,</span>
				<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">alloc_transaction</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">get_transaction</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">new_transaction</span><span class="p">);</span>
		<span class="n">new_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the current transaction is locked down for commit, wait for the</span>
<span class="cm">	 * lock to be released.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">T_LOCKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is not enough space left in the log to write all potential</span>
<span class="cm">	 * buffers requested by this operation, we need to stall pending a log</span>
<span class="cm">	 * checkpoint to free some more log space.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
	<span class="n">needed</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span> <span class="o">+</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">needed</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the current transaction is already too large, then start</span>
<span class="cm">		 * to commit it: we can then go back and attach this handle to</span>
<span class="cm">		 * a new transaction.</span>
<span class="cm">		 */</span>
		<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Handle %p starting new commit...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
				<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">__log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * The commit code assumes that it can get enough log space</span>
<span class="cm">	 * without forcing a checkpoint.  This is *critical* for</span>
<span class="cm">	 * correctness: a checkpoint of a buffer which is also</span>
<span class="cm">	 * associated with a committing transaction creates a deadlock,</span>
<span class="cm">	 * so commit simply cannot force through checkpoints.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We must therefore ensure the necessary space in the journal</span>
<span class="cm">	 * *before* starting to dirty potentially checkpointed buffers</span>
<span class="cm">	 * in the new transaction.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The worst part is, any transaction currently committing can</span>
<span class="cm">	 * reduce the free space arbitrarily.  Be careful to account for</span>
<span class="cm">	 * those buffers when checkpointing.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * @@@ AKPM: This seems rather over-defensive.  We&#39;re giving commit</span>
<span class="cm">	 * a _lot_ of headroom: 1/4 of the journal plus the size of</span>
<span class="cm">	 * the committing transaction.  Really, we only need to give it</span>
<span class="cm">	 * committing_transaction-&gt;t_outstanding_credits plus &quot;enough&quot; for</span>
<span class="cm">	 * the log control blocks.</span>
<span class="cm">	 * Also, this test is inconsistent with the matching one in</span>
<span class="cm">	 * journal_extend().</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__log_space_left</span><span class="p">(</span><span class="n">journal</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">jbd_space_needed</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Handle %p waiting for checkpoint...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
		<span class="n">__log_wait_for_space</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">repeat_locked</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* OK, account for the buffers that this operation expects to</span>
<span class="cm">	 * use and add the handle to the running transaction. */</span>

	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span> <span class="o">+=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="o">++</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_count</span><span class="o">++</span><span class="p">;</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Handle %p given %d credits (total %d, free %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span><span class="p">,</span>
		  <span class="n">__log_space_left</span><span class="p">(</span><span class="n">journal</span><span class="p">));</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">lock_map_acquire</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_lockdep_map</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">new_transaction</span><span class="p">))</span>		<span class="cm">/* It&#39;s usually NULL */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">new_transaction</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">lock_class_key</span> <span class="n">jbd_handle_key</span><span class="p">;</span>

<span class="cm">/* Allocate a new handle.  This should probably be in a slab... */</span>
<span class="k">static</span> <span class="n">handle_t</span> <span class="o">*</span><span class="nf">new_handle</span><span class="p">(</span><span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">jbd_alloc_handle</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">handle</span><span class="p">));</span>
	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lockdep_init_map</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_lockdep_map</span><span class="p">,</span> <span class="s">&quot;jbd_handle&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">jbd_handle_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * handle_t *journal_start() - Obtain a new handle.</span>
<span class="cm"> * @journal: Journal to start transaction on.</span>
<span class="cm"> * @nblocks: number of block buffer we might modify</span>
<span class="cm"> *</span>
<span class="cm"> * We make sure that the transaction can guarantee at least nblocks of</span>
<span class="cm"> * modified buffers in the log.  We block until the log can guarantee</span>
<span class="cm"> * that much space.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is visible to journal users (like ext3fs), so is not</span>
<span class="cm"> * called with the journal already locked.</span>
<span class="cm"> *</span>
<span class="cm"> * Return a pointer to a newly allocated handle, or an ERR_PTR() value</span>
<span class="cm"> * on failure.</span>
<span class="cm"> */</span>
<span class="n">handle_t</span> <span class="o">*</span><span class="nf">journal_start</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span> <span class="o">=</span> <span class="n">journal_current_handle</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">journal</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">EROFS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span> <span class="o">==</span> <span class="n">journal</span><span class="p">);</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_ref</span><span class="o">++</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">handle</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">new_handle</span><span class="p">(</span><span class="n">nblocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">handle</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">handle</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">start_this_handle</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_free_handle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">handle</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">handle</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_extend() - extend buffer credits.</span>
<span class="cm"> * @handle:  handle to &#39;extend&#39;</span>
<span class="cm"> * @nblocks: nr blocks to try to extend by.</span>
<span class="cm"> *</span>
<span class="cm"> * Some transactions, such as large extends and truncates, can be done</span>
<span class="cm"> * atomically all at once or in several stages.  The operation requests</span>
<span class="cm"> * a credit for a number of buffer modications in advance, but can</span>
<span class="cm"> * extend its credit if it needs more.</span>
<span class="cm"> *</span>
<span class="cm"> * journal_extend tries to give the running handle more buffer credits.</span>
<span class="cm"> * It does not guarantee that allocation - this is a best-effort only.</span>
<span class="cm"> * The calling process MUST be able to deal cleanly with a failure to</span>
<span class="cm"> * extend here.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on success, non-zero on failure.</span>
<span class="cm"> *</span>
<span class="cm"> * return code &lt; 0 implies an error</span>
<span class="cm"> * return code &gt; 0 implies normal transaction-full status.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_extend</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">result</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wanted</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">result</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="cm">/* Don&#39;t extend a locked-down transaction! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">!=</span> <span class="n">T_RUNNING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;denied handle %p %d blocks: &quot;</span>
			  <span class="s">&quot;transaction not running</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
	<span class="n">wanted</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span> <span class="o">+</span> <span class="n">nblocks</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wanted</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;denied handle %p %d blocks: &quot;</span>
			  <span class="s">&quot;transaction too large</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wanted</span> <span class="o">&gt;</span> <span class="n">__log_space_left</span><span class="p">(</span><span class="n">journal</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;denied handle %p %d blocks: &quot;</span>
			  <span class="s">&quot;insufficient log space</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span> <span class="o">+=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span> <span class="o">+=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;extended handle %p by %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">,</span> <span class="n">nblocks</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
<span class="nl">error_out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * int journal_restart() - restart a handle.</span>
<span class="cm"> * @handle:  handle to restart</span>
<span class="cm"> * @nblocks: nr credits requested</span>
<span class="cm"> *</span>
<span class="cm"> * Restart a handle for a multi-transaction filesystem</span>
<span class="cm"> * operation.</span>
<span class="cm"> *</span>
<span class="cm"> * If the journal_extend() call above fails to grant new buffer credits</span>
<span class="cm"> * to a running handle, a call to journal_restart will commit the</span>
<span class="cm"> * handle&#39;s transaction so far and reattach the handle to a new</span>
<span class="cm"> * transaction capabable of guaranteeing the requested number of</span>
<span class="cm"> * credits.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">journal_restart</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nblocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If we&#39;ve had an abort of any type, don&#39;t even think about</span>
<span class="cm">	 * actually doing the restart! */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First unlink the handle from its current transaction, and start the</span>
<span class="cm">	 * commit on that.</span>
<span class="cm">	 */</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal_current_handle</span><span class="p">()</span> <span class="o">==</span> <span class="n">handle</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span> <span class="o">-=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="p">)</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_updates</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;restarting handle %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="n">__log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_lockdep_map</span><span class="p">);</span>
	<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span> <span class="o">=</span> <span class="n">nblocks</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">start_this_handle</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/**</span>
<span class="cm"> * void journal_lock_updates () - establish a transaction barrier.</span>
<span class="cm"> * @journal:  Journal to establish a barrier on.</span>
<span class="cm"> *</span>
<span class="cm"> * This locks out any further updates from being started, and blocks until all</span>
<span class="cm"> * existing updates have completed, returning only once the journal is in a</span>
<span class="cm"> * quiescent state with no updates running.</span>
<span class="cm"> *</span>
<span class="cm"> * We do not use simple mutex for synchronization as there are syscalls which</span>
<span class="cm"> * want to return with filesystem locked and that trips up lockdep. Also</span>
<span class="cm"> * hibernate needs to lock filesystem but locked mutex then blocks hibernation.</span>
<span class="cm"> * Since locking filesystem is rare operation, we use simple counter and</span>
<span class="cm"> * waitqueue for locking.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">journal_lock_updates</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

<span class="nl">wait:</span>
	<span class="cm">/* Wait for previous locked operation to finish */</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">,</span>
		   <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Check reliably under the lock whether we are the ones winning the race</span>
<span class="cm">	 * and locking the journal</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">wait</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">++</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span><span class="p">;</span>

	<span class="cm">/* Wait until there are no running updates */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_updates</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
				<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">schedule</span><span class="p">();</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_updates</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * void journal_unlock_updates (journal_t* journal) - release barrier</span>
<span class="cm"> * @journal:  Journal to release the barrier on.</span>
<span class="cm"> *</span>
<span class="cm"> * Release a transaction barrier obtained with journal_lock_updates().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">journal_unlock_updates</span> <span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="o">--</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">warn_dirty_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
	       <span class="s">&quot;JBD: Spotted dirty metadata buffer (dev = %s, blocknr = %llu). &quot;</span>
	       <span class="s">&quot;There&#39;s a risk of filesystem corruption in case of system &quot;</span>
	       <span class="s">&quot;crash.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">bdevname</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the buffer is already part of the current transaction, then there</span>
<span class="cm"> * is nothing we need to do.  If it is already part of a prior</span>
<span class="cm"> * transaction which we are still committing to disk, then we need to</span>
<span class="cm"> * make sure that we do not overwrite the old copy: we do copy-out to</span>
<span class="cm"> * preserve the copy going to disk.  We also account the buffer against</span>
<span class="cm"> * the handle&#39;s metadata buffer credits (unless the buffer is already</span>
<span class="cm"> * part of the transaction, that is).</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">do_get_write_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">force_copy</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">frozen_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_copy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
	<span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;journal_head %p, force_copy %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jh</span><span class="p">,</span> <span class="n">force_copy</span><span class="p">);</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>
<span class="nl">repeat:</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="cm">/* @@@ Need to check for errors here at some point. */</span>

	<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/* We now hold the buffer lock so it is safe to query the buffer</span>
<span class="cm">	 * state.  Is the buffer dirty?</span>
<span class="cm">	 *</span>
<span class="cm">	 * If so, there are two possibilities.  The buffer may be</span>
<span class="cm">	 * non-journaled, and undergoing a quite legitimate writeback.</span>
<span class="cm">	 * Otherwise, it is journaled, and we don&#39;t expect dirty buffers</span>
<span class="cm">	 * in that state (the buffers should be marked JBD_Dirty</span>
<span class="cm">	 * instead.)  So either the IO is being done under our own</span>
<span class="cm">	 * control and this is a bug, or it&#39;s a third party IO such as</span>
<span class="cm">	 * dump(8) (which may leave the buffer scheduled for read ---</span>
<span class="cm">	 * ie. locked but not dirty) or tune2fs (which may actually have</span>
<span class="cm">	 * the buffer dirtied, ugh.)  */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * First question: is this buffer already part of the current</span>
<span class="cm">		 * transaction or the existing committing transaction?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span>
				<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">transaction</span> <span class="o">||</span>
				<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span>
					<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span><span class="p">)</span>
				<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span>
							<span class="n">transaction</span><span class="p">);</span>
			<span class="n">warn_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * In any case we need to clean the dirty flag and we must</span>
<span class="cm">		 * do it under the buffer lock to be sure we don&#39;t race</span>
<span class="cm">		 * with running write-out.</span>
<span class="cm">		 */</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;Journalling dirty buffer&quot;</span><span class="p">);</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">set_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The buffer is already part of this transaction if b_transaction or</span>
<span class="cm">	 * b_next_transaction points to it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">transaction</span> <span class="o">||</span>
	    <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="n">transaction</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * this is the first time this transaction is touching this buffer,</span>
<span class="cm">	 * reset the modified flag</span>
<span class="cm">	 */</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If there is already a copy-out version of this buffer, then we don&#39;t</span>
<span class="cm">	 * need to make another one</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;has frozen data&quot;</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Is there data here we need to preserve? */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">&amp;&amp;</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">!=</span> <span class="n">transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;owned by older transaction&quot;</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span>
					<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">);</span>

		<span class="cm">/* There is one case we have to be very careful about.</span>
<span class="cm">		 * If the committing transaction is currently writing</span>
<span class="cm">		 * this buffer out to disk and has NOT made a copy-out,</span>
<span class="cm">		 * then we cannot modify the buffer contents at all</span>
<span class="cm">		 * right now.  The essence of copy-out is that it is the</span>
<span class="cm">		 * extra copy, not the primary copy, which gets</span>
<span class="cm">		 * journaled.  If the primary copy is already going to</span>
<span class="cm">		 * disk then we cannot do copy-out here. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_Shadow</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">,</span> <span class="n">BH_Unshadow</span><span class="p">);</span>
			<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span><span class="p">;</span>

			<span class="n">wqh</span> <span class="o">=</span> <span class="n">bit_waitqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_state</span><span class="p">,</span> <span class="n">BH_Unshadow</span><span class="p">);</span>

			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;on shadow: sleep&quot;</span><span class="p">);</span>
			<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="cm">/* commit wakes up all shadow buffers after IO */</span>
			<span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
				<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">,</span>
						<span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_Shadow</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">schedule</span><span class="p">();</span>
			<span class="p">}</span>
			<span class="n">finish_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">.</span><span class="n">wait</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Only do the copy if the currently-owning transaction</span>
<span class="cm">		 * still needs it.  If it is on the Forget list, the</span>
<span class="cm">		 * committing transaction is past that stage.  The</span>
<span class="cm">		 * buffer had better remain locked during the kmalloc,</span>
<span class="cm">		 * but that should be true --- we hold the journal lock</span>
<span class="cm">		 * still and the buffer is already on the BUF_JOURNAL</span>
<span class="cm">		 * list so won&#39;t be flushed.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Subtle point, though: if this is a get_undo_access,</span>
<span class="cm">		 * then we will be relying on the frozen_data to contain</span>
<span class="cm">		 * the new value of the committed_data record after the</span>
<span class="cm">		 * transaction, so we HAVE to force the frozen_data copy</span>
<span class="cm">		 * in that case. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_Forget</span> <span class="o">||</span> <span class="n">force_copy</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;generate frozen data&quot;</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frozen_buffer</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;allocate memory for buffer&quot;</span><span class="p">);</span>
				<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">frozen_buffer</span> <span class="o">=</span>
					<span class="n">jbd_alloc</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span>
							 <span class="n">GFP_NOFS</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frozen_buffer</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span>
					       <span class="s">&quot;%s: OOM for frozen_buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="n">__func__</span><span class="p">);</span>
					<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;oom!&quot;</span><span class="p">);</span>
					<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span> <span class="o">=</span> <span class="n">frozen_buffer</span><span class="p">;</span>
			<span class="n">frozen_buffer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">need_copy</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="cm">/*</span>
<span class="cm">	 * Finally, if the buffer is not journaled right now, we need to make</span>
<span class="cm">	 * sure it doesn&#39;t get written to disk before the caller actually</span>
<span class="cm">	 * commits the new data</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;no transaction&quot;</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span><span class="p">);</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;file as BJ_Reserved&quot;</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">BJ_Reserved</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_copy</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>

		<span class="n">J_EXPECT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)),</span>
			    <span class="s">&quot;Possible IO failure.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">);</span>
		<span class="n">source</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">,</span> <span class="n">source</span><span class="o">+</span><span class="n">offset</span><span class="p">,</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">source</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we are about to journal a buffer, then any revoke pending on it is</span>
<span class="cm">	 * no longer valid</span>
<span class="cm">	 */</span>
	<span class="n">journal_cancel_revoke</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">frozen_buffer</span><span class="p">))</span>	<span class="cm">/* It&#39;s usually NULL */</span>
		<span class="n">jbd_free</span><span class="p">(</span><span class="n">frozen_buffer</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_get_write_access() - notify intent to modify a buffer for metadata (not data) update.</span>
<span class="cm"> * @handle: transaction to add buffer modifications to</span>
<span class="cm"> * @bh:     bh to be used for metadata writes</span>
<span class="cm"> *</span>
<span class="cm"> * Returns an error code or 0 on success.</span>
<span class="cm"> *</span>
<span class="cm"> * In full data journalling mode the buffer may be of type BJ_AsyncData,</span>
<span class="cm"> * because we&#39;re write()ing a buffer which is also part of a shared mapping.</span>
<span class="cm"> */</span>

<span class="kt">int</span> <span class="nf">journal_get_write_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">journal_add_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* We do not want to get caught playing with fields which the</span>
<span class="cm">	 * log thread also manipulates.  Make sure that the buffer</span>
<span class="cm">	 * completes any outstanding IO before proceeding. */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">do_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">jh</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * When the user wants to journal a newly created buffer_head</span>
<span class="cm"> * (ie. getblk() returned a new buffer and we are going to populate it</span>
<span class="cm"> * manually rather than reading off disk), then we need to keep the</span>
<span class="cm"> * buffer_head locked until it has been completely filled with new</span>
<span class="cm"> * data.  In this case, we should be able to make the assertion that</span>
<span class="cm"> * the bh is not already part of an existing transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer should already be locked by the caller by this point.</span>
<span class="cm"> * There is no lock ranking violation: it was a newly created,</span>
<span class="cm"> * unlocked buffer beforehand. */</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_get_create_access () - notify intent to use newly created bh</span>
<span class="cm"> * @handle: transaction to new buffer to</span>
<span class="cm"> * @bh: new buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Call this if you create a new bh.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_get_create_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">journal_add_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;journal_head %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * The buffer may already belong to this transaction due to pre-zeroing</span>
<span class="cm">	 * in the filesystem&#39;s new_block code.  It may also be on the previous,</span>
<span class="cm">	 * committing transaction&#39;s lists, but it HAS to be in Forget state in</span>
<span class="cm">	 * that case: the transaction must have deleted the buffer for it to be</span>
<span class="cm">	 * reused here.</span>
<span class="cm">	 */</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">transaction</span> <span class="o">||</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span>
		<span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span> <span class="o">&amp;&amp;</span>
			  <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_Forget</span><span class="p">)));</span>

	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">buffer_locked</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Previous journal_forget() could have left the buffer</span>
<span class="cm">		 * with jbddirty bit set because it was being committed. When</span>
<span class="cm">		 * the commit finished, we&#39;ve filed the buffer for</span>
<span class="cm">		 * checkpointing and marked it dirty. Now we are reallocating</span>
<span class="cm">		 * the buffer so the transaction freeing it must have</span>
<span class="cm">		 * committed and so it&#39;s safe to clear the dirty bit.</span>
<span class="cm">		 */</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">));</span>

		<span class="cm">/* first access by this transaction */</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;file as BJ_Reserved&quot;</span><span class="p">);</span>
		<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">BJ_Reserved</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first access by this transaction */</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;set next transaction&quot;</span><span class="p">);</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * akpm: I added this.  ext3_alloc_branch can pick up new indirect</span>
<span class="cm">	 * blocks which contain freed but then revoked metadata.  We need</span>
<span class="cm">	 * to cancel the revoke in case we end up freeing it yet again</span>
<span class="cm">	 * and the reallocating as data - this would cause a second revoke,</span>
<span class="cm">	 * which hits an assertion error.</span>
<span class="cm">	 */</span>
	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;cancelling revoke&quot;</span><span class="p">);</span>
	<span class="n">journal_cancel_revoke</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_get_undo_access() - Notify intent to modify metadata with non-rewindable consequences</span>
<span class="cm"> * @handle: transaction</span>
<span class="cm"> * @bh: buffer to undo</span>
<span class="cm"> *</span>
<span class="cm"> * Sometimes there is a need to distinguish between metadata which has</span>
<span class="cm"> * been committed to disk and that which has not.  The ext3fs code uses</span>
<span class="cm"> * this for freeing and allocating space, we have to make sure that we</span>
<span class="cm"> * do not reuse freed space until the deallocation has been committed,</span>
<span class="cm"> * since if we overwrote that space we would make the delete</span>
<span class="cm"> * un-rewindable in case of a crash.</span>
<span class="cm"> *</span>
<span class="cm"> * To deal with that, journal_get_undo_access requests write access to a</span>
<span class="cm"> * buffer for parts of non-rewindable operations such as delete</span>
<span class="cm"> * operations on the bitmaps.  The journaling code must keep a copy of</span>
<span class="cm"> * the buffer&#39;s contents prior to the undo_access call until such time</span>
<span class="cm"> * as we know that the buffer has definitely been committed to disk.</span>
<span class="cm"> *</span>
<span class="cm"> * We never need to know which transaction the committed data is part</span>
<span class="cm"> * of, buffers touched here are guaranteed to be dirtied later and so</span>
<span class="cm"> * will be committed to a new transaction in due course, at which point</span>
<span class="cm"> * we can discard the old committed data pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns error number or 0 on success.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_get_undo_access</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">journal_add_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">committed_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Do this first --- it can drop the journal lock, so we want to</span>
<span class="cm">	 * make sure that obtaining the committed_data is done</span>
<span class="cm">	 * atomically wrt. completion of any outstanding commits.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">do_get_write_access</span><span class="p">(</span><span class="n">handle</span><span class="p">,</span> <span class="n">jh</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">committed_data</span> <span class="o">=</span> <span class="n">jbd_alloc</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">committed_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_EMERG</span> <span class="s">&quot;%s: No memory for committed data</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Copy out the current buffer contents into the</span>
<span class="cm">		 * preserved, committed copy. */</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;generate b_committed data&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">committed_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span> <span class="o">=</span> <span class="n">committed_data</span><span class="p">;</span>
		<span class="n">committed_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">committed_data</span><span class="p">))</span>
		<span class="n">jbd_free</span><span class="p">(</span><span class="n">committed_data</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_dirty_data() - mark a buffer as containing dirty data to be flushed</span>
<span class="cm"> * @handle: transaction</span>
<span class="cm"> * @bh: bufferhead to mark</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> * Mark a buffer as containing dirty data which needs to be flushed before</span>
<span class="cm"> * we can commit the current transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer is placed on the transaction&#39;s data list and is marked as</span>
<span class="cm"> * belonging to the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns error number or 0 on success.</span>
<span class="cm"> *</span>
<span class="cm"> * journal_dirty_data() can be called via page_launder-&gt;ext3_writepage</span>
<span class="cm"> * by kswapd.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_dirty_data</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_brelse</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">jh</span> <span class="o">=</span> <span class="n">journal_add_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The buffer could *already* be dirty.  Writeout can start</span>
<span class="cm">	 * at any time.</span>
<span class="cm">	 */</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;jh: %p, tid:%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jh</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * What if the buffer is already part of a running transaction?</span>
<span class="cm">	 *</span>
<span class="cm">	 * There are two cases:</span>
<span class="cm">	 * 1) It is part of the current running transaction.  Refile it,</span>
<span class="cm">	 *    just in case we have allocated it as metadata, deallocated</span>
<span class="cm">	 *    it, then reallocated it as data.</span>
<span class="cm">	 * 2) It is part of the previous, still-committing transaction.</span>
<span class="cm">	 *    If all we want to do is to guarantee that the buffer will be</span>
<span class="cm">	 *    written to disk before this new transaction commits, then</span>
<span class="cm">	 *    being sure that the *previous* transaction has this same</span>
<span class="cm">	 *    property is sufficient for us!  Just leave it on its old</span>
<span class="cm">	 *    transaction.</span>
<span class="cm">	 *</span>
<span class="cm">	 * In case (2), the buffer must not already exist as metadata</span>
<span class="cm">	 * --- that would violate write ordering (a transaction is free</span>
<span class="cm">	 * to write its data at any point, even before the previous</span>
<span class="cm">	 * committing transaction has committed).  The caller must</span>
<span class="cm">	 * never, ever allow this to happen: there&#39;s nothing we can do</span>
<span class="cm">	 * about it in this layer.</span>
<span class="cm">	 */</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="cm">/* Now that we have bh_state locked, are we really still mapped? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;unmapped buffer, bailing out&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_journal</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;has transaction&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">!=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;belongs to older transaction&quot;</span><span class="p">);</span>
			<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span>
					<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">);</span>

			<span class="cm">/* @@@ IS THIS TRUE  ? */</span>
			<span class="cm">/*</span>
<span class="cm">			 * Not any more.  Scenario: someone does a write()</span>
<span class="cm">			 * in data=journal mode.  The buffer&#39;s transaction has</span>
<span class="cm">			 * moved into commit.  Then someone does another</span>
<span class="cm">			 * write() to the file.  We do the frozen data copyout</span>
<span class="cm">			 * and set b_next_transaction to point to j_running_t.</span>
<span class="cm">			 * And while we&#39;re in that state, someone does a</span>
<span class="cm">			 * writepage() in an attempt to pageout the same area</span>
<span class="cm">			 * of the file via a shared mapping.  At present that</span>
<span class="cm">			 * calls journal_dirty_data(), and we get right here.</span>
<span class="cm">			 * It may be too late to journal the data.  Simply</span>
<span class="cm">			 * falling through to the next test will suffice: the</span>
<span class="cm">			 * data will be dirty and wil be checkpointed.  The</span>
<span class="cm">			 * ordering comments in the next comment block still</span>
<span class="cm">			 * apply.</span>
<span class="cm">			 */</span></pre></div></td></tr>


<tr id="section-2"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-2">&#182;</a></div><p>J<em>ASSERT</em>JH(jh, jh->b<em>next</em>transaction == NULL);</p></td><td class="code"><div class="highlight"><pre>			<span class="cm">/*</span>
<span class="cm">			 * If we&#39;re journalling data, and this buffer was</span>
<span class="cm">			 * subject to a write(), it could be metadata, forget</span>
<span class="cm">			 * or shadow against the committing transaction.  Now,</span>
<span class="cm">			 * someone has dirtied the same darn page via a mapping</span>
<span class="cm">			 * and it is being writepage()&#39;d.</span>
<span class="cm">			 * We *could* just steal the page from commit, with some</span>
<span class="cm">			 * fancy locking there.  Instead, we just skip it -</span>
<span class="cm">			 * don&#39;t tie the page&#39;s buffers to the new transaction</span>
<span class="cm">			 * at all.</span>
<span class="cm">			 * Implication: if we crash before the writepage() data</span>
<span class="cm">			 * is written into the filesystem, recovery will replay</span>
<span class="cm">			 * the write() data.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_None</span> <span class="o">&amp;&amp;</span>
					<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_SyncData</span> <span class="o">&amp;&amp;</span>
					<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_Locked</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;Not stealing&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">no_journal</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * This buffer may be undergoing writeout in commit.  We</span>
<span class="cm">			 * can&#39;t return from here and let the caller dirty it</span>
<span class="cm">			 * again because that can cause the write-out loop in</span>
<span class="cm">			 * commit to never terminate.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
				<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">need_brelse</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
				<span class="cm">/* Since we dropped the lock... */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;buffer got unmapped&quot;</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">no_journal</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="cm">/* The buffer may become locked again at any</span>
<span class="cm">				   time if it is redirtied */</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * We cannot remove the buffer with io error from the</span>
<span class="cm">			 * committing transaction, because otherwise it would</span>
<span class="cm">			 * miss the error and the commit would not abort.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">no_journal</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* We might have slept so buffer could be refiled now */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
			    <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">!=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;unfile from commit&quot;</span><span class="p">);</span>
				<span class="n">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
				<span class="cm">/* It still points to the committing</span>
<span class="cm">				 * transaction; move it to this one so</span>
<span class="cm">				 * that the refile assert checks are</span>
<span class="cm">				 * happy. */</span>
				<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* The buffer will be refiled below */</span>

		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Special case --- the buffer might actually have been</span>
<span class="cm">		 * allocated and then immediately deallocated in the previous,</span>
<span class="cm">		 * committing transaction, so might still be left on that</span>
<span class="cm">		 * transaction&#39;s metadata lists.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_SyncData</span> <span class="o">&amp;&amp;</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_Locked</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;not on correct data list: unfile&quot;</span><span class="p">);</span>
			<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_Shadow</span><span class="p">);</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;file as data&quot;</span><span class="p">);</span>
			<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">,</span>
						<span class="n">BJ_SyncData</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;not on a transaction&quot;</span><span class="p">);</span>
		<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">,</span> <span class="n">BJ_SyncData</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">no_journal:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">need_brelse</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;brelse&quot;</span><span class="p">);</span>
		<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>
	<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_dirty_metadata() - mark a buffer as containing dirty metadata</span>
<span class="cm"> * @handle: transaction to add buffer to.</span>
<span class="cm"> * @bh: buffer to mark</span>
<span class="cm"> *</span>
<span class="cm"> * Mark dirty metadata which needs to be journaled as part of the current</span>
<span class="cm"> * transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * The buffer is placed on the transaction&#39;s metadata list and is marked</span>
<span class="cm"> * as belonging to the transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns error number or 0 on success.</span>
<span class="cm"> *</span>
<span class="cm"> * Special care needs to be taken if the buffer already belongs to the</span>
<span class="cm"> * current committing transaction (in which case we should have frozen</span>
<span class="cm"> * data present for that commit).  In that case, we don&#39;t relink the</span>
<span class="cm"> * buffer: that only gets done when the old transaction finally</span>
<span class="cm"> * completes its commit.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_dirty_metadata</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="s">&quot;journal_head %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This buffer&#39;s got modified and becoming part</span>
<span class="cm">		 * of the transaction. This needs to be done</span>
<span class="cm">		 * once a transaction -bzzz</span>
<span class="cm">		 */</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * fastpath, to avoid expensive locking.  If this buffer is already</span>
<span class="cm">	 * on the running transaction&#39;s metadata list there is nothing to do.</span>
<span class="cm">	 * Nobody can take it off again because there is a handle open.</span>
<span class="cm">	 * I _think_ we&#39;re OK here with SMP barriers - a mistaken decision will</span>
<span class="cm">	 * result in this test being false, so we go in and take the locks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">transaction</span> <span class="o">&amp;&amp;</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_Metadata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;fastpath&quot;</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span>
					<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock_bh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Metadata already on the current transaction list doesn&#39;t</span>
<span class="cm">	 * need to be filed.  Metadata on another transaction&#39;s list must</span>
<span class="cm">	 * be committing, and will be refiled once the commit completes:</span>
<span class="cm">	 * leave it alone for now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">!=</span> <span class="n">transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;already on other transaction&quot;</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span>
					<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="n">transaction</span><span class="p">);</span>
		<span class="cm">/* And this case is illegal: we can&#39;t reuse another</span>
<span class="cm">		 * transaction&#39;s data buffer, ever. */</span>
		<span class="k">goto</span> <span class="n">out_unlock_bh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* That test should have eliminated the following case: */</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;file as BJ_Metadata&quot;</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">,</span> <span class="n">BJ_Metadata</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
<span class="nl">out_unlock_bh:</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;exit&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * journal_release_buffer: undo a get_write_access without any buffer</span>
<span class="cm"> * updates, if the update decided in the end that it didn&#39;t need access.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">journal_release_buffer</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * void journal_forget() - bforget() for potentially-journaled buffers.</span>
<span class="cm"> * @handle: transaction handle</span>
<span class="cm"> * @bh:     bh to &#39;forget&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * We can only do the bforget if there are no commits pending against the</span>
<span class="cm"> * buffer.  If the buffer is dirty in the current running transaction we</span>
<span class="cm"> * can safely unlink it.</span>
<span class="cm"> *</span>
<span class="cm"> * bh may not be a journalled buffer at all - it may be a non-JBD</span>
<span class="cm"> * buffer which came off the hashtable.  Check for this.</span>
<span class="cm"> *</span>
<span class="cm"> * Decrements bh-&gt;b_count by one.</span>
<span class="cm"> *</span>
<span class="cm"> * Allow this call even if the handle has aborted --- it may be part of</span>
<span class="cm"> * the caller&#39;s cleanup after an abort.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_forget</span> <span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_reserve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>

	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">not_jbd</span><span class="p">;</span>
	<span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="cm">/* Critical error: attempting to delete a bitmap buffer, maybe?</span>
<span class="cm">	 * Don&#39;t do any jbd operations, and return an error. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">J_EXPECT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">,</span>
			 <span class="s">&quot;inconsistent data on disk&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">not_jbd</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* keep track of wether or not this transaction modified us */</span>
	<span class="n">was_modified</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The buffer&#39;s going from the transaction, we must drop</span>
<span class="cm">	 * all references -bzzz</span>
<span class="cm">	 */</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">);</span>

		<span class="cm">/* If we are forgetting a buffer which is already part</span>
<span class="cm">		 * of this transaction, then we can just drop it from</span>
<span class="cm">		 * the transaction immediately. */</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">clear_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;belongs to current transaction: unfile&quot;</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * we only want to drop a reference if this transaction</span>
<span class="cm">		 * modified the buffer</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">was_modified</span><span class="p">)</span>
			<span class="n">drop_reserve</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We are no longer going to journal this buffer.</span>
<span class="cm">		 * However, the commit of this transaction is still</span>
<span class="cm">		 * important to the buffer: the delete that we are now</span>
<span class="cm">		 * processing might obsolete an old log entry, so by</span>
<span class="cm">		 * committing, we can satisfy the buffer&#39;s checkpoint.</span>
<span class="cm">		 *</span>
<span class="cm">		 * So, if we have a checkpoint on the buffer, we should</span>
<span class="cm">		 * now refile the buffer on our BJ_Forget list so that</span>
<span class="cm">		 * we know to remove the checkpoint after we commit.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
			<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">BJ_Forget</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">__journal_unfile_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
				<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">__bforget</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">drop</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span>
				 <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">));</span>
		<span class="cm">/* However, if the buffer is still owned by a prior</span>
<span class="cm">		 * (committing) transaction, we can&#39;t drop it yet... */</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;belongs to older transaction&quot;</span><span class="p">);</span>
		<span class="cm">/* ... but we CAN drop it from the new transaction if we</span>
<span class="cm">		 * have also modified it since the original commit. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="n">transaction</span><span class="p">);</span>
			<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * only drop a reference if this transaction modified</span>
<span class="cm">			 * the buffer</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">was_modified</span><span class="p">)</span>
				<span class="n">drop_reserve</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">not_jbd:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="nl">drop:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_reserve</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no need to reserve log space for this block -bzzz */</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_stop() - complete a transaction</span>
<span class="cm"> * @handle: tranaction to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * All done for a particular handle.</span>
<span class="cm"> *</span>
<span class="cm"> * There is not much action needed here.  We just return any remaining</span>
<span class="cm"> * buffer credits to the transaction and remove the handle.  The only</span>
<span class="cm"> * complication is that we need to start a commit operation if the</span>
<span class="cm"> * filesystem is marked for synchronous update.</span>
<span class="cm"> *</span>
<span class="cm"> * journal_stop itself will not usually return an error, but it may</span>
<span class="cm"> * do so in unusual circumstances.  In particular, expect it to</span>
<span class="cm"> * return -EIO if a journal_abort has been executed since the</span>
<span class="cm"> * transaction began.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_stop</span><span class="p">(</span><span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span> <span class="o">=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_transaction</span><span class="p">;</span>
	<span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">journal_current_handle</span><span class="p">()</span> <span class="o">==</span> <span class="n">handle</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_handle_aborted</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_ref</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;h_ref %d -&gt; %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_ref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_ref</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="s">&quot;Handle %p going down</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Implement synchronous transaction batching.  If the handle</span>
<span class="cm">	 * was synchronous, don&#39;t force a commit immediately.  Let&#39;s</span>
<span class="cm">	 * yield and let another thread piggyback onto this transaction.</span>
<span class="cm">	 * Keep doing that while new threads continue to arrive.</span>
<span class="cm">	 * It doesn&#39;t cost much - we&#39;re about to run a commit and sleep</span>
<span class="cm">	 * on IO anyway.  Speeds up many-threaded, many-dir operations</span>
<span class="cm">	 * by 30x or more...</span>
<span class="cm">	 *</span>
<span class="cm">	 * We try and optimize the sleep time against what the underlying disk</span>
<span class="cm">	 * can do, instead of having a static sleep time.  This is useful for</span>
<span class="cm">	 * the case where our storage is so fast that it is more optimal to go</span>
<span class="cm">	 * ahead and force a flush and wait for the transaction to be committed</span>
<span class="cm">	 * than it is to wait for an arbitrary amount of time for new writers to</span>
<span class="cm">	 * join the transaction.  We achieve this by measuring how long it takes</span>
<span class="cm">	 * to commit a transaction, and compare it with how long this</span>
<span class="cm">	 * transaction has been running, and if run time &lt; commit time then we</span>
<span class="cm">	 * sleep for the delta and commit.  This greatly helps super fast disks</span>
<span class="cm">	 * that would see slowdowns as more threads started doing fsyncs.</span>
<span class="cm">	 *</span>
<span class="cm">	 * But don&#39;t do this if this process was the most recent one to</span>
<span class="cm">	 * perform a synchronous write.  We do this to detect the case where a</span>
<span class="cm">	 * single process is doing a stream of sync writes.  No point in waiting</span>
<span class="cm">	 * for joiners in that case.</span>
<span class="cm">	 */</span>
	<span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">&amp;&amp;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_sync_writer</span> <span class="o">!=</span> <span class="n">pid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">commit_time</span><span class="p">,</span> <span class="n">trans_time</span><span class="p">;</span>

		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last_sync_writer</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="n">commit_time</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_average_commit_time</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

		<span class="n">trans_time</span> <span class="o">=</span> <span class="n">ktime_to_ns</span><span class="p">(</span><span class="n">ktime_sub</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span>
						   <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_start_time</span><span class="p">));</span>

		<span class="n">commit_time</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">commit_time</span><span class="p">,</span>
				    <span class="mi">1000</span><span class="o">*</span><span class="n">jiffies_to_usecs</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">trans_time</span> <span class="o">&lt;</span> <span class="n">commit_time</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ktime_t</span> <span class="n">expires</span> <span class="o">=</span> <span class="n">ktime_add_ns</span><span class="p">(</span><span class="n">ktime_get</span><span class="p">(),</span>
						       <span class="n">commit_time</span><span class="p">);</span>
			<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
			<span class="n">schedule_hrtimeout</span><span class="p">(</span><span class="o">&amp;</span><span class="n">expires</span><span class="p">,</span> <span class="n">HRTIMER_MODE_ABS</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span> <span class="o">-=</span> <span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_buffer_credits</span><span class="p">;</span>
	<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_updates</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_updates</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_barrier_count</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_wait_transaction_locked</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the handle is marked SYNC, we need to set another commit</span>
<span class="cm">	 * going!  We also want to force a commit if the current</span>
<span class="cm">	 * transaction is occupying too much of the log, or if the</span>
<span class="cm">	 * transaction is too old now.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">||</span>
			<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_outstanding_credits</span> <span class="o">&gt;</span>
				<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_max_transaction_buffers</span> <span class="o">||</span>
			<span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_expires</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Do this even for aborted journals: an abort still</span>
<span class="cm">		 * completes the commit thread, it just doesn&#39;t write</span>
<span class="cm">		 * anything to disk. */</span>
		<span class="n">tid_t</span> <span class="n">tid</span> <span class="o">=</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;transaction too old, requesting commit for &quot;</span>
					<span class="s">&quot;handle %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">handle</span><span class="p">);</span>
		<span class="cm">/* This is non-blocking */</span>
		<span class="n">__log_start_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_tid</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Special case: JFS_SYNC synchronous updates require us</span>
<span class="cm">		 * to wait for the commit to complete.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">))</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">log_wait_commit</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">tid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_handle_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">lock_map_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_lockdep_map</span><span class="p">);</span>

	<span class="n">jbd_free_handle</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_force_commit() - force any uncommitted transactions</span>
<span class="cm"> * @journal: journal to force</span>
<span class="cm"> *</span>
<span class="cm"> * For synchronous operations: force any uncommitted transactions</span>
<span class="cm"> * to disk.  May seem kludgy, but it reuses all the handle batching</span>
<span class="cm"> * code in a very simple manner.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_force_commit</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">handle_t</span> <span class="o">*</span><span class="n">handle</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">handle</span> <span class="o">=</span> <span class="n">journal_start</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">handle</span><span class="o">-&gt;</span><span class="n">h_sync</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">journal_stop</span><span class="p">(</span><span class="n">handle</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> *</span>
<span class="cm"> * List management code snippets: various functions for manipulating the</span>
<span class="cm"> * transaction buffer lists.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Append a buffer to a transaction list, given the transaction&#39;s list head</span>
<span class="cm"> * pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * j_list_lock is held.</span>
<span class="cm"> *</span>
<span class="cm"> * jbd_lock_bh_state(jh2bh(jh)) is held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__blist_add_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tnext</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tprev</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
		<span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Insert at the tail of the list to preserve order */</span>
		<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">first</span> <span class="o">=</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">b_tprev</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tprev</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
		<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tnext</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span>
		<span class="n">last</span><span class="o">-&gt;</span><span class="n">b_tnext</span> <span class="o">=</span> <span class="n">first</span><span class="o">-&gt;</span><span class="n">b_tprev</span> <span class="o">=</span> <span class="n">jh</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a buffer from a transaction list, given the transaction&#39;s list</span>
<span class="cm"> * head pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with j_list_lock held, and the journal may not be locked.</span>
<span class="cm"> *</span>
<span class="cm"> * jbd_lock_bh_state(jh2bh(jh)) is held.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__blist_del_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">list</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">list</span> <span class="o">==</span> <span class="n">jh</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tnext</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">list</span> <span class="o">==</span> <span class="n">jh</span><span class="p">)</span>
			<span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tprev</span><span class="o">-&gt;</span><span class="n">b_tnext</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tnext</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tnext</span><span class="o">-&gt;</span><span class="n">b_tprev</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_tprev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a buffer from the appropriate transaction list.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that this function can *change* the value of</span>
<span class="cm"> * bh-&gt;b_transaction-&gt;t_sync_datalist, t_buffers, t_forget,</span>
<span class="cm"> * t_iobuf_list, t_shadow_list, t_log_list or t_reserved_list.  If the caller</span>
<span class="cm"> * is holding onto a copy of one of thee pointers, it could go bad.</span>
<span class="cm"> * Generally the caller needs to re-read the pointer from the transaction_t.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under j_list_lock.  The journal may not be locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jbd_is_locked_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span><span class="p">)</span>
		<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">&lt;</span> <span class="n">BJ_Types</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">!=</span> <span class="n">BJ_None</span><span class="p">)</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BJ_None</span>:
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_SyncData</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_sync_datalist</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Metadata</span>:
		<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_nr_buffers</span><span class="o">--</span><span class="p">;</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_nr_buffers</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Forget</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_forget</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_IO</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_iobuf_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Shadow</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_shadow_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_LogCtl</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_log_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Reserved</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_reserved_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Locked</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_locked_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__blist_del_buffer</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">=</span> <span class="n">BJ_None</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>	<span class="cm">/* Expose it to the VM */</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove buffer from all transactions.</span>
<span class="cm"> *</span>
<span class="cm"> * Called with bh_state lock and j_list_lock</span>
<span class="cm"> *</span>
<span class="cm"> * jh and bh may be already freed when this function returns.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__journal_unfile_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">journal_unfile_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="cm">/* Get reference so that buffer cannot be freed before we unlock it */</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">__journal_unfile_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called from journal_try_to_free_buffers().</span>
<span class="cm"> *</span>
<span class="cm"> * Called under jbd_lock_bh_state(bh)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__journal_try_to_free_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>

	<span class="n">jh</span> <span class="o">=</span> <span class="n">bh2jh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span> <span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_SyncData</span> <span class="o">||</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_Locked</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* A written-back ordered data buffer */</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;release data&quot;</span><span class="p">);</span>
			<span class="n">__journal_unfile_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* written-back checkpointed metadata buffer */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_None</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;remove from checkpoint list&quot;</span><span class="p">);</span>
			<span class="n">__journal_remove_checkpoint</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * int journal_try_to_free_buffers() - try to free page buffers.</span>
<span class="cm"> * @journal: journal for operation</span>
<span class="cm"> * @page: to try and free</span>
<span class="cm"> * @gfp_mask: we use the mask to detect how hard should we try to release</span>
<span class="cm"> * buffers. If __GFP_WAIT and __GFP_FS is set, we wait for commit code to</span>
<span class="cm"> * release the buffers.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * For all the buffers on this page,</span>
<span class="cm"> * if they are fully written out ordered data, move them onto BUF_CLEAN</span>
<span class="cm"> * so try_to_free_buffers() can reap them.</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns non-zero if we wish try_to_free_buffers()</span>
<span class="cm"> * to be called. We do this if the page is releasable by try_to_free_buffers().</span>
<span class="cm"> * We also do it if the page has locked or dirty buffers and the caller wants</span>
<span class="cm"> * us to perform sync or async writeout.</span>
<span class="cm"> *</span>
<span class="cm"> * This complicates JBD locking somewhat.  We aren&#39;t protected by the</span>
<span class="cm"> * BKL here.  We wish to remove the buffer from its committing or</span>
<span class="cm"> * running transaction&#39;s -&gt;t_datalist via __journal_unfile_buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * This may *change* the value of transaction_t-&gt;t_datalist, so anyone</span>
<span class="cm"> * who looks at t_datalist needs to lock against this function.</span>
<span class="cm"> *</span>
<span class="cm"> * Even worse, someone may be doing a journal_dirty_data on this</span>
<span class="cm"> * buffer.  So we need to lock against that.  journal_dirty_data()</span>
<span class="cm"> * will come out of the lock with the buffer dirty, which makes it</span>
<span class="cm"> * ineligible for release here.</span>
<span class="cm"> *</span>
<span class="cm"> * Who else is affected by this?  hmm...  Really the only contender</span>
<span class="cm"> * is do_get_write_access() - it could be looking at the buffer while</span>
<span class="cm"> * journal_try_to_free_buffer() is changing its state.  But that</span>
<span class="cm"> * cannot happen because we never reallocate freed data as metadata</span>
<span class="cm"> * while the data is part of a transaction.  Yes?</span>
<span class="cm"> *</span>
<span class="cm"> * Return 0 on failure, 1 on success</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_try_to_free_buffers</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We take our own ref against the journal_head here to avoid</span>
<span class="cm">		 * having to add tons of locking around each instance of</span>
<span class="cm">		 * journal_put_journal_head().</span>
<span class="cm">		 */</span>
		<span class="n">jh</span> <span class="o">=</span> <span class="n">journal_grab_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">__journal_try_to_free_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">busy</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">((</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">)</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">busy:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This buffer is no longer needed.  If it is on an older transaction&#39;s</span>
<span class="cm"> * checkpoint list we need to record it on this transaction&#39;s forget list</span>
<span class="cm"> * to pin this buffer (and hence its checkpointing transaction) down until</span>
<span class="cm"> * this transaction commits.  If the buffer isn&#39;t on a checkpoint list, we</span>
<span class="cm"> * release it.</span>
<span class="cm"> * Returns non-zero if JBD no longer has an interest in the buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under j_list_lock.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under jbd_lock_bh_state(bh).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__dispose_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">may_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;on running+cp transaction&quot;</span><span class="p">);</span>
		<span class="n">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We don&#39;t want to write the buffer anymore, clear the</span>
<span class="cm">		 * bit so that we don&#39;t confuse checks in</span>
<span class="cm">		 * __journal_file_buffer</span>
<span class="cm">		 */</span>
		<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">BJ_Forget</span><span class="p">);</span>
		<span class="n">may_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;on running transaction&quot;</span><span class="p">);</span>
		<span class="n">__journal_unfile_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">may_free</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * journal_invalidatepage</span>
<span class="cm"> *</span>
<span class="cm"> * This code is tricky.  It has a number of cases to deal with.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two invariants which this code relies on:</span>
<span class="cm"> *</span>
<span class="cm"> * i_size must be updated on disk before we start calling invalidatepage on the</span>
<span class="cm"> * data.</span>
<span class="cm"> *</span>
<span class="cm"> *  This is done in ext3 by defining an ext3_setattr method which</span>
<span class="cm"> *  updates i_size before truncate gets going.  By maintaining this</span>
<span class="cm"> *  invariant, we can be sure that it is safe to throw away any buffers</span>
<span class="cm"> *  attached to the current transaction: once the transaction commits,</span>
<span class="cm"> *  we know that the data will not be needed.</span>
<span class="cm"> *</span>
<span class="cm"> *  Note however that we can *not* throw away data belonging to the</span>
<span class="cm"> *  previous, committing transaction!</span>
<span class="cm"> *</span>
<span class="cm"> * Any disk blocks which *are* part of the previous, committing</span>
<span class="cm"> * transaction (and which therefore cannot be discarded immediately) are</span>
<span class="cm"> * not going to be reused in the new running transaction</span>
<span class="cm"> *</span>
<span class="cm"> *  The bitmap committed_data images guarantee this: any block which is</span>
<span class="cm"> *  allocated in one transaction and removed in the next will be marked</span>
<span class="cm"> *  as in-use in the committed_data bitmap, so cannot be reused until</span>
<span class="cm"> *  the next transaction to delete the block commits.  This means that</span>
<span class="cm"> *  leaving committing buffers dirty is quite safe: the disk blocks</span>
<span class="cm"> *  cannot be reallocated to a different file and so buffer aliasing is</span>
<span class="cm"> *  not possible.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * The above applies mainly to ordered data mode.  In writeback mode we</span>
<span class="cm"> * don&#39;t make guarantees about the order in which data hits disk --- in</span>
<span class="cm"> * particular we don&#39;t guarantee that new dirty data is flushed before</span>
<span class="cm"> * transaction commit --- so it is always safe just to discard data</span>
<span class="cm"> * immediately in that mode.  --sct</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The journal_unmap_buffer helper function returns zero if the buffer</span>
<span class="cm"> * concerned remains pinned as an anonymous buffer belonging to an older</span>
<span class="cm"> * transaction.</span>
<span class="cm"> *</span>
<span class="cm"> * We&#39;re outside-transaction here.  Either or both of j_running_transaction</span>
<span class="cm"> * and j_committing_transaction may be NULL.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">journal_unmap_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">may_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="s">&quot;entry&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * It is safe to proceed here without the j_list_lock because the</span>
<span class="cm">	 * buffers cannot be stolen by try_to_free_buffers as long as we are</span>
<span class="cm">	 * holding the page lock. --sct</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_jbd</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">zap_buffer_unlocked</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="n">jh</span> <span class="o">=</span> <span class="n">journal_grab_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">zap_buffer_no_jh</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We cannot remove the buffer from checkpoint lists until the</span>
<span class="cm">	 * transaction adding inode to orphan list (let&#39;s call it T)</span>
<span class="cm">	 * is committed.  Otherwise if the transaction changing the</span>
<span class="cm">	 * buffer would be cleaned from the journal before T is</span>
<span class="cm">	 * committed, a crash will cause that the correct contents of</span>
<span class="cm">	 * the buffer will be lost.  On the other hand we have to</span>
<span class="cm">	 * clear the buffer dirty bit at latest at the moment when the</span>
<span class="cm">	 * transaction marking the buffer as freed in the filesystem</span>
<span class="cm">	 * structures is committed because from that moment on the</span>
<span class="cm">	 * buffer can be reallocated and used by a different page.</span>
<span class="cm">	 * Since the block hasn&#39;t been freed yet but the inode has</span>
<span class="cm">	 * already been added to orphan list, it is safe for us to add</span>
<span class="cm">	 * the buffer to BJ_Forget list of the newest transaction.</span>
<span class="cm">	 */</span>
	<span class="n">transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* First case: not on any transaction.  If it</span>
<span class="cm">		 * has no checkpoint link, then we can zap it:</span>
<span class="cm">		 * it&#39;s a writeback-mode buffer so we don&#39;t care</span>
<span class="cm">		 * if it hits disk safely. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_cp_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;not on any transaction: zap&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">zap_buffer</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* bdflush has written it.  We can drop it now */</span>
			<span class="k">goto</span> <span class="n">zap_buffer</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* OK, it must be in the journal but still not</span>
<span class="cm">		 * written fully to disk: it&#39;s metadata or</span>
<span class="cm">		 * journaled data... */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* ... and once the current transaction has</span>
<span class="cm">			 * committed, the buffer won&#39;t be needed any</span>
<span class="cm">			 * longer. */</span>
			<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;checkpointed: add to BJ_Forget&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__dispose_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span>
					<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">);</span>
			<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
			<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* There is no currently-running transaction. So the</span>
<span class="cm">			 * orphan record which we wrote for this file must have</span>
<span class="cm">			 * passed into commit.  We must attach this buffer to</span>
<span class="cm">			 * the committing transaction, if it exists. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;give to committing trans&quot;</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">__dispose_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span>
					<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">);</span>
				<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
				<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* The orphan record&#39;s transaction has</span>
<span class="cm">				 * committed.  We can cleanse this buffer */</span>
				<span class="n">clear_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">zap_buffer</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">transaction</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_committing_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;on committing transaction&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">BJ_Locked</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The buffer is on the committing transaction&#39;s locked</span>
<span class="cm">			 * list.  We have the buffer locked, so I/O has</span>
<span class="cm">			 * completed.  So we can nail the buffer now.</span>
<span class="cm">			 */</span>
			<span class="n">may_free</span> <span class="o">=</span> <span class="n">__dispose_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">zap_buffer</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * The buffer is committing, we simply cannot touch</span>
<span class="cm">		 * it. So we just set j_next_transaction to the</span>
<span class="cm">		 * running transaction (if there is one) and mark</span>
<span class="cm">		 * buffer as freed so that commit code knows it should</span>
<span class="cm">		 * clear dirty bits when it is done with the buffer.</span>
<span class="cm">		 */</span>
		<span class="n">set_buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span> <span class="o">&amp;&amp;</span> <span class="n">buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">;</span>
		<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
		<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Good, the buffer belongs to the running transaction.</span>
<span class="cm">		 * We are writing our own transaction&#39;s data, not any</span>
<span class="cm">		 * previous one&#39;s, so it is safe to throw it away</span>
<span class="cm">		 * (remember that we expect the filesystem to have set</span>
<span class="cm">		 * i_size already for this truncate so recovery will not</span>
<span class="cm">		 * expose the disk blocks we are discarding here.) */</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span> <span class="o">==</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_running_transaction</span><span class="p">);</span>
		<span class="n">JBUFFER_TRACE</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="s">&quot;on running transaction&quot;</span><span class="p">);</span>
		<span class="n">may_free</span> <span class="o">=</span> <span class="n">__dispose_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">zap_buffer:</span>
	<span class="n">journal_put_journal_head</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
<span class="nl">zap_buffer_no_jh:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_state_lock</span><span class="p">);</span>
<span class="nl">zap_buffer_unlocked:</span>
	<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">J_ASSERT_BH</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">!</span><span class="n">buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">clear_buffer_mapped</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_req</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">clear_buffer_new</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">may_free</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * void journal_invalidatepage() - invalidate a journal page</span>
<span class="cm"> * @journal: journal to use for flush</span>
<span class="cm"> * @page:    page to flush</span>
<span class="cm"> * @offset:  length of page to invalidate.</span>
<span class="cm"> *</span>
<span class="cm"> * Reap page buffers containing data after offset in page.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">journal_invalidatepage</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">curr_off</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">may_free</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* We will potentially be playing with lists other than just the</span>
<span class="cm">	 * data lists (especially for journaled data mode), so be</span>
<span class="cm">	 * cautious in our locking. */</span>

	<span class="n">head</span> <span class="o">=</span> <span class="n">bh</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">next_off</span> <span class="o">=</span> <span class="n">curr_off</span> <span class="o">+</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">curr_off</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This block is wholly outside the truncation point */</span>
			<span class="n">lock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">may_free</span> <span class="o">&amp;=</span> <span class="n">journal_unmap_buffer</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
			<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">curr_off</span> <span class="o">=</span> <span class="n">next_off</span><span class="p">;</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">may_free</span> <span class="o">&amp;&amp;</span> <span class="n">try_to_free_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">J_ASSERT</span><span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * File a buffer on the given transaction list.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__journal_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span>
			<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jlist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">journal_head</span> <span class="o">**</span><span class="n">list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">was_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jbd_is_locked_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">&lt;</span> <span class="n">BJ_Types</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="n">transaction</span> <span class="o">||</span>
				<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">&amp;&amp;</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">==</span> <span class="n">jlist</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jlist</span> <span class="o">==</span> <span class="n">BJ_Metadata</span> <span class="o">||</span> <span class="n">jlist</span> <span class="o">==</span> <span class="n">BJ_Reserved</span> <span class="o">||</span>
	    <span class="n">jlist</span> <span class="o">==</span> <span class="n">BJ_Shadow</span> <span class="o">||</span> <span class="n">jlist</span> <span class="o">==</span> <span class="n">BJ_Forget</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For metadata buffers, we track dirty bit in buffer_jbddirty</span>
<span class="cm">		 * instead of buffer_dirty. We should not see a dirty bit set</span>
<span class="cm">		 * here because we clear it in do_get_write_access but e.g.</span>
<span class="cm">		 * tune2fs can modify the sb and set the dirty bit at any time</span>
<span class="cm">		 * so we try to gracefully handle that.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">warn_dirty_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">test_clear_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">was_dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">)</span>
		<span class="n">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">journal_grab_journal_head</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">=</span> <span class="n">transaction</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">jlist</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BJ_None</span>:
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_committed_data</span><span class="p">);</span>
		<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="o">!</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_frozen_data</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_SyncData</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_sync_datalist</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Metadata</span>:
		<span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_nr_buffers</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_buffers</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Forget</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_forget</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_IO</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_iobuf_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Shadow</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_shadow_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_LogCtl</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_log_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Reserved</span>:
		<span class="n">list</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_reserved_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BJ_Locked</span>:
		<span class="n">list</span> <span class="o">=</span>  <span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_locked_list</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">__blist_add_buffer</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">jh</span><span class="p">);</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_jlist</span> <span class="o">=</span> <span class="n">jlist</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_dirty</span><span class="p">)</span>
		<span class="n">set_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">journal_file_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">,</span>
				<span class="n">transaction_t</span> <span class="o">*</span><span class="n">transaction</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jlist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">));</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">transaction</span><span class="p">,</span> <span class="n">jlist</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove a buffer from its current buffer list in preparation for</span>
<span class="cm"> * dropping it from its current transaction entirely.  If the buffer has</span>
<span class="cm"> * already started to be used by a subsequent transaction, refile the</span>
<span class="cm"> * buffer on that transaction&#39;s metadata list.</span>
<span class="cm"> *</span>
<span class="cm"> * Called under j_list_lock</span>
<span class="cm"> * Called under jbd_lock_bh_state(jh2bh(jh))</span>
<span class="cm"> *</span>
<span class="cm"> * jh and bh may be already free when this function returns</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__journal_refile_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">was_dirty</span><span class="p">,</span> <span class="n">jlist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jbd_is_locked_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">)</span>
		<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="o">-&gt;</span><span class="n">t_journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>

	<span class="cm">/* If the buffer is now unused, just drop it. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">__journal_unfile_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * It has been modified by a later transaction: add it to the new</span>
<span class="cm">	 * transaction&#39;s metadata list.</span>
<span class="cm">	 */</span>

	<span class="n">was_dirty</span> <span class="o">=</span> <span class="n">test_clear_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">__journal_temp_unlink_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We set b_transaction here because b_next_transaction will inherit</span>
<span class="cm">	 * our jh reference and thus __journal_file_buffer() must not take a</span>
<span class="cm">	 * new one.</span>
<span class="cm">	 */</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span> <span class="o">=</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span><span class="p">;</span>
	<span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_next_transaction</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_freed</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
		<span class="n">jlist</span> <span class="o">=</span> <span class="n">BJ_Forget</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_modified</span><span class="p">)</span>
		<span class="n">jlist</span> <span class="o">=</span> <span class="n">BJ_Metadata</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">jlist</span> <span class="o">=</span> <span class="n">BJ_Reserved</span><span class="p">;</span>
	<span class="n">__journal_file_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="p">,</span> <span class="n">jlist</span><span class="p">);</span>
	<span class="n">J_ASSERT_JH</span><span class="p">(</span><span class="n">jh</span><span class="p">,</span> <span class="n">jh</span><span class="o">-&gt;</span><span class="n">b_transaction</span><span class="o">-&gt;</span><span class="n">t_state</span> <span class="o">==</span> <span class="n">T_RUNNING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">was_dirty</span><span class="p">)</span>
		<span class="n">set_buffer_jbddirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * __journal_refile_buffer() with necessary locking added. We take our bh</span>
<span class="cm"> * reference so that we can safely unlock bh.</span>
<span class="cm"> *</span>
<span class="cm"> * The jh and bh may be freed by this call.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">journal_refile_buffer</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">journal_head</span> <span class="o">*</span><span class="n">jh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">jh2bh</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>

	<span class="cm">/* Get reference so that buffer cannot be freed before we unlock it */</span>
	<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">jbd_lock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">__journal_refile_buffer</span><span class="p">(</span><span class="n">jh</span><span class="p">);</span>
	<span class="n">jbd_unlock_bh_state</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_list_lock</span><span class="p">);</span>
	<span class="n">__brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
