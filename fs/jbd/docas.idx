f | journal.c | s | 57K | 1829 | Jan Kara | jack@suse.cz | 1337117677 |  | jbd: Write journal superblock with WRITE_FUA after checkpointing  If journal superblock is written only in disk's caches and other transaction starts reusing space of the transaction cleaned from the log, it can happen blocks of a new transaction reach the disk before journal superblock. When power failure happens in such case, subsequent journal replay would still try to replay the old transaction but some of it's blocks may be already overwritten by the new transaction. For this reason we must use WRITE_FUA when updating log tail and we must first write new log tail to disk and update in-memory information only after that.  Signed-off-by: Jan Kara <jack@suse.cz>
f | transaction.c | s | 64K | 1965 | Jan Kara | jack@suse.cz | 1334135564 |  | jbd: Refine commit writeout logic  Currently we write out all journal buffers in WRITE_SYNC mode. This improves performance for fsync heavy workloads but hinders performance when writes are mostly asynchronous, most noticably it slows down readers and users complain about slow desktop response etc.  So submit writes as asynchronous in the normal case and only submit writes as WRITE_SYNC if we detect someone is waiting for current transaction commit.  I've gathered some numbers to back this change. The first is the read latency test. It measures time to read 1 MB after several seconds of sleeping in presence of streaming writes.  Top 10 times (out of 90) in us: Before		After 2131586		697473 1709932		557487 1564598		535642 1480462		347573 1478579		323153 1408496		222181 1388960		181273 1329565		181070 1252486		172832 1223265		172278  Average: 619377		82180  So the improvement in both maximum and average latency is massive.  I've measured fsync throughput by: fs_mark -n 100 -t 1 -s 16384 -d /mnt/fsync/ -S 1 -L 4  in presence of streaming reader. The numbers (fsyncs/s) are: Before		After 9.9		6.3 6.8		6.0 6.3		6.2 5.8		6.1  So fsync performance seems unharmed by this change.  Signed-off-by: Jan Kara <jack@suse.cz>
f | recovery.c | s | 14K | 488 | Jan Kara | jack@suse.cz | 1326285417 |  | jbd: Issue cache flush after checkpointing  When we reach cleanup_journal_tail(), there is no guarantee that checkpointed buffers are on a stable storage - especially if buffers were written out by log_do_checkpoint(), they are likely to be only in disk's caches. Thus when we update journal superblock, effectively removing old transaction from journal, this write of superblock can get to stable storage before those checkpointed buffers which can result in filesystem corruption after a crash.  A similar problem can happen if we replay the journal and wipe it before flushing disk's caches.  Thus we must unconditionally issue a cache flush before we update journal superblock in these cases. The fix is slightly complicated by the fact that we have to get log tail before we issue cache flush but we can store it in the journal superblock only after the cache flush. Otherwise we risk races where new tail is written before appropriate cache flush is finished.  I managed to reproduce the corruption using somewhat tweaked Chris Mason's barrier-test scheduler. Also this should fix occasional reports of 'Bit already freed' filesystem errors which are totally unreproducible but inspection of several fs images I've gathered over time points to a problem like this.  CC: stable@kernel.org Signed-off-by: Jan Kara <jack@suse.cz>
f | Makefile | g | 157B |  | Linus Torvalds | torvalds@ppc970.osdl.org | 1113690036 |  | Linux-2.6.12-rc2  Initial git repository build. I'm not bothering with the full history, even though we have it. We can create a separate "historical" git archive of that later if we want to, and in the meantime it's about 3.2GB when imported into git - space that would just make the early git days unnecessarily complicated, when we don't have a lot of good infrastructure for it.  Let it rip!
f | checkpoint.c | s | 21K | 710 | Jan Kara | jack@suse.cz | 1337117677 |  | jbd: Write journal superblock with WRITE_FUA after checkpointing  If journal superblock is written only in disk's caches and other transaction starts reusing space of the transaction cleaned from the log, it can happen blocks of a new transaction reach the disk before journal superblock. When power failure happens in such case, subsequent journal replay would still try to replay the old transaction but some of it's blocks may be already overwritten by the new transaction. For this reason we must use WRITE_FUA when updating log tail and we must first write new log tail to disk and update in-memory information only after that.  Signed-off-by: Jan Kara <jack@suse.cz>
f | commit.c | s | 28K | 850 | Jan Kara | jack@suse.cz | 1337117677 |  | jbd: Write journal superblock with WRITE_FUA after checkpointing  If journal superblock is written only in disk's caches and other transaction starts reusing space of the transaction cleaned from the log, it can happen blocks of a new transaction reach the disk before journal superblock. When power failure happens in such case, subsequent journal replay would still try to replay the old transaction but some of it's blocks may be already overwritten by the new transaction. For this reason we must use WRITE_FUA when updating log tail and we must first write new log tail to disk and update in-memory information only after that.  Signed-off-by: Jan Kara <jack@suse.cz>
f | revoke.c | s | 21K | 646 | Yongqiang Yang | xiaoqiangnk@gmail.com | 1321921253 |  | jbd: clear revoked flag on buffers before a new transaction started  Currently, we clear revoked flag only when a block is reused.  However, this can tigger a false journal error.  Consider a situation when a block is used as a meta block and is deleted(revoked) in ordered mode, then the block is allocated as a data block to a file.  At this moment, user changes the file's journal mode from ordered to journaled and truncates the file. The block will be considered re-revoked by journal because it has revoked flag still pending from the last transaction and an assertion triggers.  We fix the problem by keeping the revoked status more uptodate - we clear revoked flag when switching revoke tables to reflect there is no revoked buffers in current transaction any more.  Signed-off-by: Yongqiang Yang <xiaoqiangnk@gmail.com> Signed-off-by: Jan Kara <jack@suse.cz>
f | Kconfig | g | 1.2K |  | Linus Torvalds | torvalds@linux-foundation.org | 1261085004 |  | Revert "task_struct: make journal_info conditional"  This reverts commit e4c570c4cb7a95dbfafa3d016d2739bf3fdfe319, as requested by Alexey:   "I think I gave a good enough arguments to not merge it.   To iterate:    * patch makes impossible to start using ext3 on EXT3_FS=n kernels      without reboot.    * this is done only for one pointer on task_struct"    None of config options which define task_struct are tristate directly   or effectively."  Requested-by: Alexey Dobriyan <adobriyan@gmail.com> Acked-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
