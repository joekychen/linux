<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jbd › recovery.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>recovery.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/jbd/recovery.c</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Stephen C. Tweedie &lt;sct@redhat.com&gt;, 1999</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1999-2000 Red Hat Software --- All Rights Reserved</span>
<span class="cm"> *</span>
<span class="cm"> * This file is part of the Linux kernel and is made available under</span>
<span class="cm"> * the terms of the GNU General Public License, version 2, or at your</span>
<span class="cm"> * option, any later version, incorporated herein by reference.</span>
<span class="cm"> *</span>
<span class="cm"> * Journal recovery routines for the generic filesystem journaling code;</span>
<span class="cm"> * part of the ext2fs journaling system.</span>
<span class="cm"> */</span>

<span class="cp">#ifndef __KERNEL__</span>
<span class="cp">#include &quot;jfs_user.h&quot;</span>
<span class="cp">#else</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/jbd.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Maintain information about the progress of the recovery job, so that</span>
<span class="cm"> * the different passes can carry information between them.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">recovery_info</span>
<span class="p">{</span>
	<span class="n">tid_t</span>		<span class="n">start_transaction</span><span class="p">;</span>
	<span class="n">tid_t</span>		<span class="n">end_transaction</span><span class="p">;</span>

	<span class="kt">int</span>		<span class="n">nr_replays</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nr_revokes</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">nr_revoke_hits</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">passtype</span> <span class="p">{</span><span class="n">PASS_SCAN</span><span class="p">,</span> <span class="n">PASS_REVOKE</span><span class="p">,</span> <span class="n">PASS_REPLAY</span><span class="p">};</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">recovery_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">enum</span> <span class="n">passtype</span> <span class="n">pass</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scan_revoke_records</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span>
				<span class="n">tid_t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">recovery_info</span> <span class="o">*</span><span class="p">);</span>

<span class="cp">#ifdef __KERNEL__</span>

<span class="cm">/* Release readahead buffers after use */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">journal_brelse_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">b</span><span class="p">[],</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">--</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">brelse</span> <span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * When reading from the journal, we are going through the block device</span>
<span class="cm"> * layer directly and so there is no readahead being done for us.  We</span>
<span class="cm"> * need to implement any readahead ourselves if we want it to happen at</span>
<span class="cm"> * all.  Recovery is basically one long sequential read, so make sure we</span>
<span class="cm"> * do the IO in reasonably large chunks.</span>
<span class="cm"> *</span>
<span class="cm"> * This is not so critical that we need to be enormously clever about</span>
<span class="cm"> * the readahead size, though.  128K is a purely arbitrary, good-enough</span>
<span class="cm"> * fixed value.</span>
<span class="cm"> */</span>

<span class="cp">#define MAXBUF 8</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_readahead</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">,</span> <span class="n">next</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span> <span class="n">bufs</span><span class="p">[</span><span class="n">MAXBUF</span><span class="p">];</span>

	<span class="cm">/* Do up to 128K of readahead */</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="p">(</span><span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">/</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&gt;</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span><span class="p">)</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span><span class="p">;</span>

	<span class="cm">/* Do the readahead itself.  We&#39;ll submit MAXBUF buffer_heads at</span>
<span class="cm">	 * a time to the block device IO layer. */</span>

	<span class="n">nbufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">next</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span> <span class="n">next</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">;</span> <span class="n">next</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_bmap</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocknr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: bad block at offset %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">next</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">buffer_locked</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">bufs</span><span class="p">[</span><span class="n">nbufs</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nbufs</span> <span class="o">==</span> <span class="n">MAXBUF</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">,</span> <span class="n">bufs</span><span class="p">);</span>
				<span class="n">journal_brelse_array</span><span class="p">(</span><span class="n">bufs</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">);</span>
				<span class="n">nbufs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nbufs</span><span class="p">)</span>
		<span class="n">ll_rw_block</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">,</span> <span class="n">bufs</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbufs</span><span class="p">)</span>
		<span class="n">journal_brelse_array</span><span class="p">(</span><span class="n">bufs</span><span class="p">,</span> <span class="n">nbufs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="cm">/* __KERNEL__ */</span><span class="cp"></span>


<span class="cm">/*</span>
<span class="cm"> * Read a block from the journal</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jread</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">bhp</span><span class="p">,</span> <span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="o">*</span><span class="n">bhp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_maxlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: corrupted journal superblock</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">journal_bmap</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blocknr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: bad block at offset %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_dev</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* If this is a brand new buffer, start readahead.</span>
<span class="cm">                   Otherwise, we assume we are already reading it.  */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_req</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
			<span class="n">do_readahead</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">wait_on_buffer</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: Failed to read block at offset %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">offset</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">bhp</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Count the number of in-use tags in a journal descriptor block.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">count_tags</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span>			<span class="n">tagp</span><span class="p">;</span>
	<span class="n">journal_block_tag_t</span> <span class="o">*</span>	<span class="n">tag</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tagp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">journal_header_t</span><span class="p">)];</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">tagp</span> <span class="o">-</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_block_tag_t</span><span class="p">))</span> <span class="o">&lt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_block_tag_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">tagp</span><span class="p">;</span>

		<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">tagp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_block_tag_t</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JFS_FLAG_SAME_UUID</span><span class="p">)))</span>
			<span class="n">tagp</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_flags</span> <span class="o">&amp;</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JFS_FLAG_LAST_TAG</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nr</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Make sure we wrap around the log correctly! */</span>
<span class="cp">#define wrap(journal, var)						\</span>
<span class="cp">do {									\</span>
<span class="cp">	if (var &gt;= (journal)-&gt;j_last)					\</span>
<span class="cp">		var -= ((journal)-&gt;j_last - (journal)-&gt;j_first);	\</span>
<span class="cp">} while (0)</span>

<span class="cm">/**</span>
<span class="cm"> * journal_recover - recovers a on-disk journal</span>
<span class="cm"> * @journal: the journal to recover</span>
<span class="cm"> *</span>
<span class="cm"> * The primary function for recovering the log contents when mounting a</span>
<span class="cm"> * journaled device.</span>
<span class="cm"> *</span>
<span class="cm"> * Recovery is done in three passes.  In the first pass, we look for the</span>
<span class="cm"> * end of the log.  In the second, we assemble the list of revoke</span>
<span class="cm"> * blocks.  In the third and final pass, we replay any un-revoked blocks</span>
<span class="cm"> * in the log.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_recover</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">err</span><span class="p">,</span> <span class="n">err2</span><span class="p">;</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span>	<span class="n">sb</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">recovery_info</span>	<span class="n">info</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">));</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The journal superblock&#39;s s_start field (the current log head)</span>
<span class="cm">	 * is always zero if, and only if, the journal was cleanly</span>
<span class="cm">	 * unmounted.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;No recovery required, last transaction %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_sequence</span><span class="p">));</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_sequence</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">PASS_SCAN</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">PASS_REVOKE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">PASS_REPLAY</span><span class="p">);</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD: recovery, exit status %d, &quot;</span>
		  <span class="s">&quot;recovered transactions %u to %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">err</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">start_transaction</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">end_transaction</span><span class="p">);</span>
	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;JBD: Replayed %d and revoked %d/%d blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">info</span><span class="p">.</span><span class="n">nr_replays</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">nr_revoke_hits</span><span class="p">,</span> <span class="n">info</span><span class="p">.</span><span class="n">nr_revokes</span><span class="p">);</span>

	<span class="cm">/* Restart the log at the next transaction ID, thus invalidating</span>
<span class="cm">	 * any existing commit records in the log. */</span>
	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span> <span class="o">=</span> <span class="o">++</span><span class="n">info</span><span class="p">.</span><span class="n">end_transaction</span><span class="p">;</span>

	<span class="n">journal_clear_revoke</span><span class="p">(</span><span class="n">journal</span><span class="p">);</span>
	<span class="n">err2</span> <span class="o">=</span> <span class="n">sync_blockdev</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">err2</span><span class="p">;</span>
	<span class="cm">/* Flush disk caches to get replayed data on the permanent storage */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_flags</span> <span class="o">&amp;</span> <span class="n">JFS_BARRIER</span><span class="p">)</span>
		<span class="n">blkdev_issue_flush</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * journal_skip_recovery - Start journal and wipe exiting records</span>
<span class="cm"> * @journal: journal to startup</span>
<span class="cm"> *</span>
<span class="cm"> * Locate any valid recovery information from the journal and set up the</span>
<span class="cm"> * journal structures in memory to ignore it (presumably because the</span>
<span class="cm"> * caller has evidence that it is out of date).</span>
<span class="cm"> * This function does&#39;nt appear to be exorted..</span>
<span class="cm"> *</span>
<span class="cm"> * We perform one pass over the journal to allow us to tell the user how</span>
<span class="cm"> * much recovery information is being erased, and to let us initialise</span>
<span class="cm"> * the journal transaction sequence numbers to the next unused ID.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">journal_skip_recovery</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>			<span class="n">err</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">recovery_info</span>	<span class="n">info</span><span class="p">;</span>

	<span class="n">memset</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">info</span><span class="p">));</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">do_one_pass</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">PASS_SCAN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: error %d scanning journal</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="o">++</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef CONFIG_JBD_DEBUG</span>
		<span class="kt">int</span> <span class="n">dropped</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">end_transaction</span> <span class="o">-</span>
			      <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="o">-&gt;</span><span class="n">s_sequence</span><span class="p">);</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span>
			  <span class="s">&quot;JBD: ignoring %d transaction%s from the journal.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">dropped</span><span class="p">,</span> <span class="p">(</span><span class="n">dropped</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;s&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_transaction_sequence</span> <span class="o">=</span> <span class="o">++</span><span class="n">info</span><span class="p">.</span><span class="n">end_transaction</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_tail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_one_pass</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">recovery_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="k">enum</span> <span class="n">passtype</span> <span class="n">pass</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">first_commit_ID</span><span class="p">,</span> <span class="n">next_commit_ID</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">next_log_block</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">err</span><span class="p">,</span> <span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">journal_superblock_t</span> <span class="o">*</span>	<span class="n">sb</span><span class="p">;</span>
	<span class="n">journal_header_t</span> <span class="o">*</span>	<span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>	<span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">sequence</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">blocktype</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * First thing is to establish what we expect to find in the log</span>
<span class="cm">	 * (in terms of transaction IDs), and where (in terms of log</span>
<span class="cm">	 * block offsets): query the superblock.</span>
<span class="cm">	 */</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_superblock</span><span class="p">;</span>
	<span class="n">next_commit_ID</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_sequence</span><span class="p">);</span>
	<span class="n">next_log_block</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_start</span><span class="p">);</span>

	<span class="n">first_commit_ID</span> <span class="o">=</span> <span class="n">next_commit_ID</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">==</span> <span class="n">PASS_SCAN</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">start_transaction</span> <span class="o">=</span> <span class="n">first_commit_ID</span><span class="p">;</span>

	<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Starting recovery pass %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">pass</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now we walk through the log, transaction by transaction,</span>
<span class="cm">	 * making sure that each transaction has a commit block in the</span>
<span class="cm">	 * expected place.  Each complete transaction gets replayed back</span>
<span class="cm">	 * into the main filesystem.</span>
<span class="cm">	 */</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span>			<span class="n">flags</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span>			<span class="n">tagp</span><span class="p">;</span>
		<span class="n">journal_block_tag_t</span> <span class="o">*</span>	<span class="n">tag</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>	<span class="n">obh</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>	<span class="n">nbh</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/* If we already know where to stop the log traversal,</span>
<span class="cm">		 * check right now that we haven&#39;t gone past the end of</span>
<span class="cm">		 * the log. */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">!=</span> <span class="n">PASS_SCAN</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tid_geq</span><span class="p">(</span><span class="n">next_commit_ID</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">end_transaction</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="s">&quot;Scanning for sequence ID %u at %u/%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">next_commit_ID</span><span class="p">,</span> <span class="n">next_log_block</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_last</span><span class="p">);</span>

		<span class="cm">/* Skip over each chunk of the transaction looking</span>
<span class="cm">		 * either the next descriptor block or the final commit</span>
<span class="cm">		 * record. */</span>

		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;JBD: checking block %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">next_log_block</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">jread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="p">,</span> <span class="n">journal</span><span class="p">,</span> <span class="n">next_log_block</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

		<span class="n">next_log_block</span><span class="o">++</span><span class="p">;</span>
		<span class="n">wrap</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">next_log_block</span><span class="p">);</span>

		<span class="cm">/* What kind of buffer is it?</span>
<span class="cm">		 *</span>
<span class="cm">		 * If it is a descriptor block, check that it has the</span>
<span class="cm">		 * expected sequence number.  Otherwise, we&#39;re all done</span>
<span class="cm">		 * here. */</span>

		<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_header_t</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_magic</span> <span class="o">!=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JFS_MAGIC_NUMBER</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">blocktype</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_blocktype</span><span class="p">);</span>
		<span class="n">sequence</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">h_sequence</span><span class="p">);</span>
		<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Found magic %d, sequence %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">blocktype</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sequence</span> <span class="o">!=</span> <span class="n">next_commit_ID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* OK, we have a valid descriptor block which matches</span>
<span class="cm">		 * all of the sequence number checks.  What are we going</span>
<span class="cm">		 * to do with it?  That depends on the pass... */</span>

		<span class="k">switch</span><span class="p">(</span><span class="n">blocktype</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">JFS_DESCRIPTOR_BLOCK</span>:
			<span class="cm">/* If it is a valid descriptor block, replay it</span>
<span class="cm">			 * in pass REPLAY; otherwise, just skip over the</span>
<span class="cm">			 * blocks it describes. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">!=</span> <span class="n">PASS_REPLAY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">next_log_block</span> <span class="o">+=</span>
					<span class="n">count_tags</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
				<span class="n">wrap</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">next_log_block</span><span class="p">);</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* A descriptor block: we can now write all of</span>
<span class="cm">			 * the data blocks.  Yay, useful work is finally</span>
<span class="cm">			 * getting done here! */</span>

			<span class="n">tagp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">journal_header_t</span><span class="p">)];</span>
			<span class="k">while</span> <span class="p">((</span><span class="n">tagp</span> <span class="o">-</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span><span class="k">sizeof</span><span class="p">(</span><span class="n">journal_block_tag_t</span><span class="p">))</span>
			       <span class="o">&lt;=</span> <span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">io_block</span><span class="p">;</span>

				<span class="n">tag</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_block_tag_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">tagp</span><span class="p">;</span>
				<span class="n">flags</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_flags</span><span class="p">);</span>

				<span class="n">io_block</span> <span class="o">=</span> <span class="n">next_log_block</span><span class="o">++</span><span class="p">;</span>
				<span class="n">wrap</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">next_log_block</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">jread</span><span class="p">(</span><span class="o">&amp;</span><span class="n">obh</span><span class="p">,</span> <span class="n">journal</span><span class="p">,</span> <span class="n">io_block</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Recover what we can, but</span>
<span class="cm">					 * report failure at the end. */</span>
					<span class="n">success</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
					<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span>
						<span class="s">&quot;JBD: IO error %d recovering &quot;</span>
						<span class="s">&quot;block %u in log</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						<span class="n">err</span><span class="p">,</span> <span class="n">io_block</span><span class="p">);</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocknr</span><span class="p">;</span>

					<span class="n">J_ASSERT</span><span class="p">(</span><span class="n">obh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
					<span class="n">blocknr</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">tag</span><span class="o">-&gt;</span><span class="n">t_blocknr</span><span class="p">);</span>

					<span class="cm">/* If the block has been</span>
<span class="cm">					 * revoked, then we&#39;re all done</span>
<span class="cm">					 * here. */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">journal_test_revoke</span>
					    <span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span>
					     <span class="n">next_commit_ID</span><span class="p">))</span> <span class="p">{</span>
						<span class="n">brelse</span><span class="p">(</span><span class="n">obh</span><span class="p">);</span>
						<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nr_revoke_hits</span><span class="p">;</span>
						<span class="k">goto</span> <span class="n">skip_write</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="cm">/* Find a buffer for the new</span>
<span class="cm">					 * data being restored */</span>
					<span class="n">nbh</span> <span class="o">=</span> <span class="n">__getblk</span><span class="p">(</span><span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_fs_dev</span><span class="p">,</span>
							<span class="n">blocknr</span><span class="p">,</span>
							<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">nbh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
						       <span class="s">&quot;JBD: Out of memory &quot;</span>
						       <span class="s">&quot;during recovery.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
						<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
						<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
						<span class="n">brelse</span><span class="p">(</span><span class="n">obh</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">lock_buffer</span><span class="p">(</span><span class="n">nbh</span><span class="p">);</span>
					<span class="n">memcpy</span><span class="p">(</span><span class="n">nbh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">obh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
							<span class="n">journal</span><span class="o">-&gt;</span><span class="n">j_blocksize</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">JFS_FLAG_ESCAPE</span><span class="p">)</span> <span class="p">{</span>
						<span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">nbh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">)</span> <span class="o">=</span>
						<span class="n">cpu_to_be32</span><span class="p">(</span><span class="n">JFS_MAGIC_NUMBER</span><span class="p">);</span>
					<span class="p">}</span>

					<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">nbh</span><span class="p">,</span> <span class="s">&quot;marking dirty&quot;</span><span class="p">);</span>
					<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">nbh</span><span class="p">);</span>
					<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">nbh</span><span class="p">);</span>
					<span class="n">BUFFER_TRACE</span><span class="p">(</span><span class="n">nbh</span><span class="p">,</span> <span class="s">&quot;marking uptodate&quot;</span><span class="p">);</span>
					<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nr_replays</span><span class="p">;</span>
					<span class="cm">/* ll_rw_block(WRITE, 1, &amp;nbh); */</span>
					<span class="n">unlock_buffer</span><span class="p">(</span><span class="n">nbh</span><span class="p">);</span>
					<span class="n">brelse</span><span class="p">(</span><span class="n">obh</span><span class="p">);</span>
					<span class="n">brelse</span><span class="p">(</span><span class="n">nbh</span><span class="p">);</span>
				<span class="p">}</span>

			<span class="nl">skip_write:</span>
				<span class="n">tagp</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_block_tag_t</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">JFS_FLAG_SAME_UUID</span><span class="p">))</span>
					<span class="n">tagp</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">JFS_FLAG_LAST_TAG</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">JFS_COMMIT_BLOCK</span>:
			<span class="cm">/* Found an expected commit block: not much to</span>
<span class="cm">			 * do other than move on to the next sequence</span>
<span class="cm">			 * number. */</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">next_commit_ID</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">JFS_REVOKE_BLOCK</span>:
			<span class="cm">/* If we aren&#39;t in the REVOKE pass, then we can</span>
<span class="cm">			 * just skip over this block. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">!=</span> <span class="n">PASS_REVOKE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">scan_revoke_records</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span>
						  <span class="n">next_commit_ID</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">jbd_debug</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="s">&quot;Unrecognised magic %d, end of scan.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">blocktype</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">done:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We broke out of the log scan loop: either we came to the</span>
<span class="cm">	 * known end of the log or we found an unexpected block in the</span>
<span class="cm">	 * log.  If the latter happened, then we know that the &quot;current&quot;</span>
<span class="cm">	 * transaction marks the end of the valid log.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pass</span> <span class="o">==</span> <span class="n">PASS_SCAN</span><span class="p">)</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">end_transaction</span> <span class="o">=</span> <span class="n">next_commit_ID</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* It&#39;s really bad news if different passes end up at</span>
<span class="cm">		 * different places (but possible due to IO errors). */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">end_transaction</span> <span class="o">!=</span> <span class="n">next_commit_ID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span> <span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;JBD: recovery pass %d ended at &quot;</span>
				<span class="s">&quot;transaction %u, expected %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">pass</span><span class="p">,</span> <span class="n">next_commit_ID</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">end_transaction</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">success</span><span class="p">)</span>
				<span class="n">success</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">success</span><span class="p">;</span>

 <span class="nl">failed:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/* Scan a revoke record, marking all blocks mentioned as revoked. */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scan_revoke_records</span><span class="p">(</span><span class="n">journal_t</span> <span class="o">*</span><span class="n">journal</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			       <span class="n">tid_t</span> <span class="n">sequence</span><span class="p">,</span> <span class="k">struct</span> <span class="n">recovery_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">journal_revoke_header_t</span> <span class="o">*</span><span class="n">header</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">journal_revoke_header_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">journal_revoke_header_t</span><span class="p">);</span>
	<span class="n">max</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">header</span><span class="o">-&gt;</span><span class="n">r_count</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocknr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span> <span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="o">+</span><span class="n">offset</span><span class="p">)));</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">journal_set_revoke</span><span class="p">(</span><span class="n">journal</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">sequence</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">nr_revokes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
