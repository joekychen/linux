<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cifs › cifspdu.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cifspdu.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   fs/cifs/cifspdu.h</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright (c) International Business Machines  Corp., 2002,2009</span>
<span class="cm"> *   Author(s): Steve French (sfrench@us.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU Lesser General Public License as published</span>
<span class="cm"> *   by the Free Software Foundation; either version 2.1 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> *   along with this library; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#ifndef _CIFSPDU_H</span>
<span class="cp">#define _CIFSPDU_H</span>

<span class="cp">#include &lt;net/sock.h&gt;</span>
<span class="cp">#include &lt;asm/unaligned.h&gt;</span>
<span class="cp">#include &quot;smbfsctl.h&quot;</span>

<span class="cp">#ifdef CONFIG_CIFS_WEAK_PW_HASH</span>
<span class="cp">#define LANMAN_PROT 0</span>
<span class="cp">#define LANMAN2_PROT 1</span>
<span class="cp">#define CIFS_PROT   2</span>
<span class="cp">#else</span>
<span class="cp">#define CIFS_PROT   0</span>
<span class="cp">#endif</span>
<span class="cp">#define POSIX_PROT  (CIFS_PROT+1)</span>
<span class="cp">#define BAD_PROT 0xFFFF</span>

<span class="cm">/* SMB command codes:</span>
<span class="cm"> * Note some commands have minimal (wct=0,bcc=0), or uninteresting, responses</span>
<span class="cm"> * (ie which include no useful data other than the SMB error code itself).</span>
<span class="cm"> * This can allow us to avoid response buffer allocations and copy in some cases</span>
<span class="cm"> */</span>
<span class="cp">#define SMB_COM_CREATE_DIRECTORY      0x00 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_DELETE_DIRECTORY      0x01 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_CLOSE                 0x04 </span><span class="cm">/* triv req/rsp, timestamp ignored */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_FLUSH                 0x05 </span><span class="cm">/* triv req/rsp */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_DELETE                0x06 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_RENAME                0x07 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_QUERY_INFORMATION     0x08 </span><span class="cm">/* aka getattr */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_SETATTR               0x09 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_LOCKING_ANDX          0x24 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_COPY                  0x29 </span><span class="cm">/* trivial rsp, fail filename ignrd*/</span><span class="cp"></span>
<span class="cp">#define SMB_COM_ECHO                  0x2B </span><span class="cm">/* echo request */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_OPEN_ANDX             0x2D </span><span class="cm">/* Legacy open for old servers */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_READ_ANDX             0x2E</span>
<span class="cp">#define SMB_COM_WRITE_ANDX            0x2F</span>
<span class="cp">#define SMB_COM_TRANSACTION2          0x32</span>
<span class="cp">#define SMB_COM_TRANSACTION2_SECONDARY 0x33</span>
<span class="cp">#define SMB_COM_FIND_CLOSE2           0x34 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_TREE_DISCONNECT       0x71 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_NEGOTIATE             0x72</span>
<span class="cp">#define SMB_COM_SESSION_SETUP_ANDX    0x73</span>
<span class="cp">#define SMB_COM_LOGOFF_ANDX           0x74 </span><span class="cm">/* trivial response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_TREE_CONNECT_ANDX     0x75</span>
<span class="cp">#define SMB_COM_NT_TRANSACT           0xA0</span>
<span class="cp">#define SMB_COM_NT_TRANSACT_SECONDARY 0xA1</span>
<span class="cp">#define SMB_COM_NT_CREATE_ANDX        0xA2</span>
<span class="cp">#define SMB_COM_NT_CANCEL             0xA4 </span><span class="cm">/* no response */</span><span class="cp"></span>
<span class="cp">#define SMB_COM_NT_RENAME             0xA5 </span><span class="cm">/* trivial response */</span><span class="cp"></span>

<span class="cm">/* Transact2 subcommand codes */</span>
<span class="cp">#define TRANS2_OPEN                   0x00</span>
<span class="cp">#define TRANS2_FIND_FIRST             0x01</span>
<span class="cp">#define TRANS2_FIND_NEXT              0x02</span>
<span class="cp">#define TRANS2_QUERY_FS_INFORMATION   0x03</span>
<span class="cp">#define TRANS2_SET_FS_INFORMATION     0x04</span>
<span class="cp">#define TRANS2_QUERY_PATH_INFORMATION 0x05</span>
<span class="cp">#define TRANS2_SET_PATH_INFORMATION   0x06</span>
<span class="cp">#define TRANS2_QUERY_FILE_INFORMATION 0x07</span>
<span class="cp">#define TRANS2_SET_FILE_INFORMATION   0x08</span>
<span class="cp">#define TRANS2_GET_DFS_REFERRAL       0x10</span>
<span class="cp">#define TRANS2_REPORT_DFS_INCOSISTENCY 0x11</span>

<span class="cm">/* SMB Transact (Named Pipe) subcommand codes */</span>
<span class="cp">#define TRANS_SET_NMPIPE_STATE      0x0001</span>
<span class="cp">#define TRANS_RAW_READ_NMPIPE       0x0011</span>
<span class="cp">#define TRANS_QUERY_NMPIPE_STATE    0x0021</span>
<span class="cp">#define TRANS_QUERY_NMPIPE_INFO     0x0022</span>
<span class="cp">#define TRANS_PEEK_NMPIPE           0x0023</span>
<span class="cp">#define TRANS_TRANSACT_NMPIPE       0x0026</span>
<span class="cp">#define TRANS_RAW_WRITE_NMPIPE      0x0031</span>
<span class="cp">#define TRANS_READ_NMPIPE           0x0036</span>
<span class="cp">#define TRANS_WRITE_NMPIPE          0x0037</span>
<span class="cp">#define TRANS_WAIT_NMPIPE           0x0053</span>
<span class="cp">#define TRANS_CALL_NMPIPE           0x0054</span>

<span class="cm">/* NT Transact subcommand codes */</span>
<span class="cp">#define NT_TRANSACT_CREATE            0x01</span>
<span class="cp">#define NT_TRANSACT_IOCTL             0x02</span>
<span class="cp">#define NT_TRANSACT_SET_SECURITY_DESC 0x03</span>
<span class="cp">#define NT_TRANSACT_NOTIFY_CHANGE     0x04</span>
<span class="cp">#define NT_TRANSACT_RENAME            0x05</span>
<span class="cp">#define NT_TRANSACT_QUERY_SECURITY_DESC 0x06</span>
<span class="cp">#define NT_TRANSACT_GET_USER_QUOTA    0x07</span>
<span class="cp">#define NT_TRANSACT_SET_USER_QUOTA    0x08</span>

<span class="cp">#define MAX_CIFS_SMALL_BUFFER_SIZE 448 </span><span class="cm">/* big enough for most */</span><span class="cp"></span>
<span class="cm">/* future chained NTCreateXReadX bigger, but for time being NTCreateX biggest */</span>
<span class="cm">/* among the requests (NTCreateX response is bigger with wct of 34) */</span>
<span class="cp">#define MAX_CIFS_HDR_SIZE 0x58 </span><span class="cm">/* 4 len + 32 hdr + (2*24 wct) + 2 bct + 2 pad */</span><span class="cp"></span>
<span class="cp">#define CIFS_SMALL_PATH 120 </span><span class="cm">/* allows for (448-88)/3 */</span><span class="cp"></span>

<span class="cm">/* internal cifs vfs structures */</span>
<span class="cm">/*****************************************************************</span>
<span class="cm"> * All constants go here</span>
<span class="cm"> *****************************************************************</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Starting value for maximum SMB size negotiation</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_MAX_MSGSIZE (4*4096)</span>

<span class="cm">/*</span>
<span class="cm"> * Size of encrypted user password in bytes</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_ENCPWD_SIZE (16)</span>

<span class="cm">/*</span>
<span class="cm"> * Size of the crypto key returned on the negotiate SMB in bytes</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_CRYPTO_KEY_SIZE (8)</span>

<span class="cm">/*</span>
<span class="cm"> * Size of the ntlm client response</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_AUTH_RESP_SIZE (24)</span>

<span class="cm">/*</span>
<span class="cm"> * Size of the session key (crypto key encrypted with the password</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_SESS_KEY_SIZE (16)</span>

<span class="cp">#define CIFS_CLIENT_CHALLENGE_SIZE (8)</span>
<span class="cp">#define CIFS_SERVER_CHALLENGE_SIZE (8)</span>
<span class="cp">#define CIFS_HMAC_MD5_HASH_SIZE (16)</span>
<span class="cp">#define CIFS_CPHTXT_SIZE (16)</span>
<span class="cp">#define CIFS_NTHASH_SIZE (16)</span>

<span class="cm">/*</span>
<span class="cm"> * Maximum user name length</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_UNLEN (20)</span>

<span class="cm">/*</span>
<span class="cm"> * Flags on SMB open</span>
<span class="cm"> */</span>
<span class="cp">#define SMBOPEN_WRITE_THROUGH 0x4000</span>
<span class="cp">#define SMBOPEN_DENY_ALL      0x0010</span>
<span class="cp">#define SMBOPEN_DENY_WRITE    0x0020</span>
<span class="cp">#define SMBOPEN_DENY_READ     0x0030</span>
<span class="cp">#define SMBOPEN_DENY_NONE     0x0040</span>
<span class="cp">#define SMBOPEN_READ          0x0000</span>
<span class="cp">#define SMBOPEN_WRITE         0x0001</span>
<span class="cp">#define SMBOPEN_READWRITE     0x0002</span>
<span class="cp">#define SMBOPEN_EXECUTE       0x0003</span>

<span class="cp">#define SMBOPEN_OCREATE       0x0010</span>
<span class="cp">#define SMBOPEN_OTRUNC        0x0002</span>
<span class="cp">#define SMBOPEN_OAPPEND       0x0001</span>

<span class="cm">/*</span>
<span class="cm"> * SMB flag definitions</span>
<span class="cm"> */</span>
<span class="cp">#define SMBFLG_EXTD_LOCK 0x01	</span><span class="cm">/* server supports lock-read write-unlock smb */</span><span class="cp"></span>
<span class="cp">#define SMBFLG_RCV_POSTED 0x02	</span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define SMBFLG_RSVD 0x04</span>
<span class="cp">#define SMBFLG_CASELESS 0x08	</span><span class="cm">/* all pathnames treated as caseless (off</span>
<span class="cm">				implies case sensitive file handling request) */</span><span class="cp"></span>
<span class="cp">#define SMBFLG_CANONICAL_PATH_FORMAT 0x10	</span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define SMBFLG_OLD_OPLOCK 0x20	</span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define SMBFLG_OLD_OPLOCK_NOTIFY 0x40	</span><span class="cm">/* obsolete */</span><span class="cp"></span>
<span class="cp">#define SMBFLG_RESPONSE 0x80	</span><span class="cm">/* this PDU is a response from server */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * SMB flag2 definitions</span>
<span class="cm"> */</span>
<span class="cp">#define SMBFLG2_KNOWS_LONG_NAMES cpu_to_le16(1)	</span><span class="cm">/* can send long (non-8.3)</span>
<span class="cm">						   path names in response */</span><span class="cp"></span>
<span class="cp">#define SMBFLG2_KNOWS_EAS cpu_to_le16(2)</span>
<span class="cp">#define SMBFLG2_SECURITY_SIGNATURE cpu_to_le16(4)</span>
<span class="cp">#define SMBFLG2_COMPRESSED (8)</span>
<span class="cp">#define SMBFLG2_SECURITY_SIGNATURE_REQUIRED (0x10)</span>
<span class="cp">#define SMBFLG2_IS_LONG_NAME cpu_to_le16(0x40)</span>
<span class="cp">#define SMBFLG2_REPARSE_PATH (0x400)</span>
<span class="cp">#define SMBFLG2_EXT_SEC cpu_to_le16(0x800)</span>
<span class="cp">#define SMBFLG2_DFS cpu_to_le16(0x1000)</span>
<span class="cp">#define SMBFLG2_PAGING_IO cpu_to_le16(0x2000)</span>
<span class="cp">#define SMBFLG2_ERR_STATUS cpu_to_le16(0x4000)</span>
<span class="cp">#define SMBFLG2_UNICODE cpu_to_le16(0x8000)</span>

<span class="cm">/*</span>
<span class="cm"> * These are the file access permission bits defined in CIFS for the</span>
<span class="cm"> * NTCreateAndX as well as the level 0x107</span>
<span class="cm"> * TRANS2_QUERY_PATH_INFORMATION API.  The level 0x107, SMB_QUERY_FILE_ALL_INFO</span>
<span class="cm"> * responds with the AccessFlags.</span>
<span class="cm"> * The AccessFlags specifies the access permissions a caller has to the</span>
<span class="cm"> * file and can have any suitable combination of the following values:</span>
<span class="cm"> */</span>

<span class="cp">#define FILE_READ_DATA        0x00000001  </span><span class="cm">/* Data can be read from the file   */</span><span class="cp"></span>
<span class="cp">#define FILE_WRITE_DATA       0x00000002  </span><span class="cm">/* Data can be written to the file  */</span><span class="cp"></span>
<span class="cp">#define FILE_APPEND_DATA      0x00000004  </span><span class="cm">/* Data can be appended to the file */</span><span class="cp"></span>
<span class="cp">#define FILE_READ_EA          0x00000008  </span><span class="cm">/* Extended attributes associated   */</span><span class="cp"></span>
					  <span class="cm">/* with the file can be read        */</span>
<span class="cp">#define FILE_WRITE_EA         0x00000010  </span><span class="cm">/* Extended attributes associated   */</span><span class="cp"></span>
					  <span class="cm">/* with the file can be written     */</span>
<span class="cp">#define FILE_EXECUTE          0x00000020  </span><span class="cm">/*Data can be read into memory from */</span><span class="cp"></span>
					  <span class="cm">/* the file using system paging I/O */</span>
<span class="cp">#define FILE_DELETE_CHILD     0x00000040</span>
<span class="cp">#define FILE_READ_ATTRIBUTES  0x00000080  </span><span class="cm">/* Attributes associated with the   */</span><span class="cp"></span>
					  <span class="cm">/* file can be read                 */</span>
<span class="cp">#define FILE_WRITE_ATTRIBUTES 0x00000100  </span><span class="cm">/* Attributes associated with the   */</span><span class="cp"></span>
					  <span class="cm">/* file can be written              */</span>
<span class="cp">#define DELETE                0x00010000  </span><span class="cm">/* The file can be deleted          */</span><span class="cp"></span>
<span class="cp">#define READ_CONTROL          0x00020000  </span><span class="cm">/* The access control list and      */</span><span class="cp"></span>
					  <span class="cm">/* ownership associated with the    */</span>
					  <span class="cm">/* file can be read                 */</span>
<span class="cp">#define WRITE_DAC             0x00040000  </span><span class="cm">/* The access control list and      */</span><span class="cp"></span>
					  <span class="cm">/* ownership associated with the    */</span>
					  <span class="cm">/* file can be written.             */</span>
<span class="cp">#define WRITE_OWNER           0x00080000  </span><span class="cm">/* Ownership information associated */</span><span class="cp"></span>
					  <span class="cm">/* with the file can be written     */</span>
<span class="cp">#define SYNCHRONIZE           0x00100000  </span><span class="cm">/* The file handle can waited on to */</span><span class="cp"></span>
					  <span class="cm">/* synchronize with the completion  */</span>
					  <span class="cm">/* of an input/output request       */</span>
<span class="cp">#define GENERIC_ALL           0x10000000</span>
<span class="cp">#define GENERIC_EXECUTE       0x20000000</span>
<span class="cp">#define GENERIC_WRITE         0x40000000</span>
<span class="cp">#define GENERIC_READ          0x80000000</span>
					 <span class="cm">/* In summary - Relevant file       */</span>
					 <span class="cm">/* access flags from CIFS are       */</span>
					 <span class="cm">/* file_read_data, file_write_data  */</span>
					 <span class="cm">/* file_execute, file_read_attributes*/</span>
					 <span class="cm">/* write_dac, and delete.           */</span>

<span class="cp">#define FILE_READ_RIGHTS (FILE_READ_DATA | FILE_READ_EA | FILE_READ_ATTRIBUTES)</span>
<span class="cp">#define FILE_WRITE_RIGHTS (FILE_WRITE_DATA | FILE_APPEND_DATA \</span>
<span class="cp">				| FILE_WRITE_EA | FILE_WRITE_ATTRIBUTES)</span>
<span class="cp">#define FILE_EXEC_RIGHTS (FILE_EXECUTE)</span>

<span class="cp">#define SET_FILE_READ_RIGHTS (FILE_READ_DATA | FILE_READ_EA | FILE_WRITE_EA \</span>
<span class="cp">				| FILE_READ_ATTRIBUTES \</span>
<span class="cp">				| FILE_WRITE_ATTRIBUTES \</span>
<span class="cp">				| DELETE | READ_CONTROL | WRITE_DAC \</span>
<span class="cp">				| WRITE_OWNER | SYNCHRONIZE)</span>
<span class="cp">#define SET_FILE_WRITE_RIGHTS (FILE_WRITE_DATA | FILE_APPEND_DATA \</span>
<span class="cp">				| FILE_READ_EA | FILE_WRITE_EA \</span>
<span class="cp">				| FILE_DELETE_CHILD | FILE_READ_ATTRIBUTES \</span>
<span class="cp">				| FILE_WRITE_ATTRIBUTES \</span>
<span class="cp">				| DELETE | READ_CONTROL | WRITE_DAC \</span>
<span class="cp">				| WRITE_OWNER | SYNCHRONIZE)</span>
<span class="cp">#define SET_FILE_EXEC_RIGHTS (FILE_READ_EA | FILE_WRITE_EA | FILE_EXECUTE \</span>
<span class="cp">				| FILE_READ_ATTRIBUTES \</span>
<span class="cp">				| FILE_WRITE_ATTRIBUTES \</span>
<span class="cp">				| DELETE | READ_CONTROL | WRITE_DAC \</span>
<span class="cp">				| WRITE_OWNER | SYNCHRONIZE)</span>

<span class="cp">#define SET_MINIMUM_RIGHTS (FILE_READ_EA | FILE_READ_ATTRIBUTES \</span>
<span class="cp">				| READ_CONTROL | SYNCHRONIZE)</span>


<span class="cm">/*</span>
<span class="cm"> * Invalid readdir handle</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_NO_HANDLE        0xFFFF</span>

<span class="cp">#define NO_CHANGE_64          0xFFFFFFFFFFFFFFFFULL</span>
<span class="cp">#define NO_CHANGE_32          0xFFFFFFFFUL</span>

<span class="cm">/* IPC$ in ASCII */</span>
<span class="cp">#define CIFS_IPC_RESOURCE &quot;\x49\x50\x43\x24&quot;</span>

<span class="cm">/* IPC$ in Unicode */</span>
<span class="cp">#define CIFS_IPC_UNICODE_RESOURCE &quot;\x00\x49\x00\x50\x00\x43\x00\x24\x00\x00&quot;</span>

<span class="cm">/* Unicode Null terminate 2 bytes of 0 */</span>
<span class="cp">#define UNICODE_NULL &quot;\x00\x00&quot;</span>
<span class="cp">#define ASCII_NULL 0x00</span>

<span class="cm">/*</span>
<span class="cm"> * Server type values (returned on EnumServer API</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_SV_TYPE_DC     0x00000008</span>
<span class="cp">#define CIFS_SV_TYPE_BACKDC 0x00000010</span>

<span class="cm">/*</span>
<span class="cm"> * Alias type flags (From EnumAlias API call</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_ALIAS_TYPE_FILE 0x0001</span>
<span class="cp">#define CIFS_SHARE_TYPE_FILE 0x0000</span>

<span class="cm">/*</span>
<span class="cm"> * File Attribute flags</span>
<span class="cm"> */</span>
<span class="cp">#define ATTR_READONLY  0x0001</span>
<span class="cp">#define ATTR_HIDDEN    0x0002</span>
<span class="cp">#define ATTR_SYSTEM    0x0004</span>
<span class="cp">#define ATTR_VOLUME    0x0008</span>
<span class="cp">#define ATTR_DIRECTORY 0x0010</span>
<span class="cp">#define ATTR_ARCHIVE   0x0020</span>
<span class="cp">#define ATTR_DEVICE    0x0040</span>
<span class="cp">#define ATTR_NORMAL    0x0080</span>
<span class="cp">#define ATTR_TEMPORARY 0x0100</span>
<span class="cp">#define ATTR_SPARSE    0x0200</span>
<span class="cp">#define ATTR_REPARSE   0x0400</span>
<span class="cp">#define ATTR_COMPRESSED 0x0800</span>
<span class="cp">#define ATTR_OFFLINE    0x1000	</span><span class="cm">/* ie file not immediately available -</span>
<span class="cm">					on offline storage */</span><span class="cp"></span>
<span class="cp">#define ATTR_NOT_CONTENT_INDEXED 0x2000</span>
<span class="cp">#define ATTR_ENCRYPTED  0x4000</span>
<span class="cp">#define ATTR_POSIX_SEMANTICS 0x01000000</span>
<span class="cp">#define ATTR_BACKUP_SEMANTICS 0x02000000</span>
<span class="cp">#define ATTR_DELETE_ON_CLOSE 0x04000000</span>
<span class="cp">#define ATTR_SEQUENTIAL_SCAN 0x08000000</span>
<span class="cp">#define ATTR_RANDOM_ACCESS   0x10000000</span>
<span class="cp">#define ATTR_NO_BUFFERING    0x20000000</span>
<span class="cp">#define ATTR_WRITE_THROUGH   0x80000000</span>

<span class="cm">/* ShareAccess flags */</span>
<span class="cp">#define FILE_NO_SHARE     0x00000000</span>
<span class="cp">#define FILE_SHARE_READ   0x00000001</span>
<span class="cp">#define FILE_SHARE_WRITE  0x00000002</span>
<span class="cp">#define FILE_SHARE_DELETE 0x00000004</span>
<span class="cp">#define FILE_SHARE_ALL    0x00000007</span>

<span class="cm">/* CreateDisposition flags, similar to CreateAction as well */</span>
<span class="cp">#define FILE_SUPERSEDE    0x00000000</span>
<span class="cp">#define FILE_OPEN         0x00000001</span>
<span class="cp">#define FILE_CREATE       0x00000002</span>
<span class="cp">#define FILE_OPEN_IF      0x00000003</span>
<span class="cp">#define FILE_OVERWRITE    0x00000004</span>
<span class="cp">#define FILE_OVERWRITE_IF 0x00000005</span>

<span class="cm">/* CreateOptions */</span>
<span class="cp">#define CREATE_NOT_FILE		0x00000001	</span><span class="cm">/* if set must not be file */</span><span class="cp"></span>
<span class="cp">#define CREATE_WRITE_THROUGH	0x00000002</span>
<span class="cp">#define CREATE_SEQUENTIAL       0x00000004</span>
<span class="cp">#define CREATE_NO_BUFFER        0x00000008      </span><span class="cm">/* should not buffer on srv */</span><span class="cp"></span>
<span class="cp">#define CREATE_SYNC_ALERT       0x00000010	</span><span class="cm">/* MBZ */</span><span class="cp"></span>
<span class="cp">#define CREATE_ASYNC_ALERT      0x00000020	</span><span class="cm">/* MBZ */</span><span class="cp"></span>
<span class="cp">#define CREATE_NOT_DIR		0x00000040    </span><span class="cm">/* if set must not be directory */</span><span class="cp"></span>
<span class="cp">#define CREATE_TREE_CONNECTION  0x00000080	</span><span class="cm">/* should be zero */</span><span class="cp"></span>
<span class="cp">#define CREATE_COMPLETE_IF_OPLK 0x00000100	</span><span class="cm">/* should be zero */</span><span class="cp"></span>
<span class="cp">#define CREATE_NO_EA_KNOWLEDGE  0x00000200</span>
<span class="cp">#define CREATE_EIGHT_DOT_THREE  0x00000400	</span><span class="cm">/* doc says this is obsolete</span>
<span class="cm">						 &quot;open for recovery&quot; flag should</span>
<span class="cm">						 be zero in any case */</span><span class="cp"></span>
<span class="cp">#define CREATE_OPEN_FOR_RECOVERY 0x00000400</span>
<span class="cp">#define CREATE_RANDOM_ACCESS	0x00000800</span>
<span class="cp">#define CREATE_DELETE_ON_CLOSE	0x00001000</span>
<span class="cp">#define CREATE_OPEN_BY_ID       0x00002000</span>
<span class="cp">#define CREATE_OPEN_BACKUP_INTENT 0x00004000</span>
<span class="cp">#define CREATE_NO_COMPRESSION   0x00008000</span>
<span class="cp">#define CREATE_RESERVE_OPFILTER 0x00100000	</span><span class="cm">/* should be zero */</span><span class="cp"></span>
<span class="cp">#define OPEN_REPARSE_POINT	0x00200000</span>
<span class="cp">#define OPEN_NO_RECALL          0x00400000</span>
<span class="cp">#define OPEN_FREE_SPACE_QUERY   0x00800000	</span><span class="cm">/* should be zero */</span><span class="cp"></span>
<span class="cp">#define CREATE_OPTIONS_MASK     0x007FFFFF</span>
<span class="cp">#define CREATE_OPTION_READONLY	0x10000000</span>
<span class="cp">#define CREATE_OPTION_SPECIAL   0x20000000   </span><span class="cm">/* system. NB not sent over wire */</span><span class="cp"></span>

<span class="cm">/* ImpersonationLevel flags */</span>
<span class="cp">#define SECURITY_ANONYMOUS      0</span>
<span class="cp">#define SECURITY_IDENTIFICATION 1</span>
<span class="cp">#define SECURITY_IMPERSONATION  2</span>
<span class="cp">#define SECURITY_DELEGATION     3</span>

<span class="cm">/* SecurityFlags */</span>
<span class="cp">#define SECURITY_CONTEXT_TRACKING 0x01</span>
<span class="cp">#define SECURITY_EFFECTIVE_ONLY   0x02</span>

<span class="cm">/*</span>
<span class="cm"> * Default PID value, used in all SMBs where the PID is not important</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_DFT_PID  0x1234</span>

<span class="cm">/*</span>
<span class="cm"> * We use the same routine for Copy and Move SMBs.  This flag is used to</span>
<span class="cm"> * distinguish</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_COPY_OP 1</span>
<span class="cp">#define CIFS_RENAME_OP 2</span>

<span class="cp">#define GETU16(var)  (*((__u16 *)var))	</span><span class="cm">/* BB check for endian issues */</span><span class="cp"></span>
<span class="cp">#define GETU32(var)  (*((__u32 *)var))	</span><span class="cm">/* BB check for endian issues */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="p">{</span>
	<span class="n">__be32</span> <span class="n">smb_buf_length</span><span class="p">;</span>	<span class="cm">/* BB length is only two (rarely three) bytes,</span>
<span class="cm">		with one or two byte &quot;type&quot; preceding it that will be</span>
<span class="cm">		zero - we could mask the type byte off */</span>
	<span class="n">__u8</span> <span class="n">Protocol</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">Command</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__u8</span> <span class="n">ErrorClass</span><span class="p">;</span>
			<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
			<span class="n">__le16</span> <span class="n">Error</span><span class="p">;</span>
		<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">DosError</span><span class="p">;</span>
		<span class="n">__le32</span> <span class="n">CifsError</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">Status</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags2</span><span class="p">;</span>		<span class="cm">/* note: le */</span>
	<span class="n">__le16</span> <span class="n">PidHigh</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="n">__le32</span> <span class="n">SequenceNumber</span><span class="p">;</span>  <span class="cm">/* le */</span>
			<span class="n">__u32</span> <span class="n">Reserved</span><span class="p">;</span> <span class="cm">/* zero */</span>
		<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">Sequence</span><span class="p">;</span>
		<span class="n">__u8</span> <span class="n">SecuritySignature</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>	<span class="cm">/* le */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">Signature</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">pad</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">__u16</span> <span class="n">Tid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Pid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Uid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Mid</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">WordCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* given a pointer to an smb_hdr, retrieve a void pointer to the ByteCount */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="o">*</span>
<span class="nf">BCC</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">smb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">smb</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">smb</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">WordCount</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* given a pointer to an smb_hdr retrieve the pointer to the byte area */</span>
<span class="cp">#define pByteArea(smb_var) (BCC(smb_var) + 2)</span>

<span class="cm">/* get the unconverted ByteCount for a SMB packet and return it */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u16</span>
<span class="nf">get_bcc</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">bc_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">BCC</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">get_unaligned_le16</span><span class="p">(</span><span class="n">bc_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* set the ByteCount for a SMB packet in little-endian */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">put_bcc</span><span class="p">(</span><span class="n">__u16</span> <span class="n">count</span><span class="p">,</span> <span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le16</span> <span class="o">*</span><span class="n">bc_ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">BCC</span><span class="p">(</span><span class="n">hdr</span><span class="p">);</span>

	<span class="n">put_unaligned_le16</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="n">bc_ptr</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Computer Name Length (since Netbios name was length 16 with last byte 0x20)</span>
<span class="cm"> * No longer as important, now that TCP names are more commonly used to</span>
<span class="cm"> * resolve hosts.</span>
<span class="cm"> */</span>
<span class="cp">#define CNLEN 15</span>

<span class="cm">/*</span>
<span class="cm"> * Share Name Length (SNLEN)</span>
<span class="cm"> * Note:  This length was limited by the SMB used to get</span>
<span class="cm"> *        the Share info.   NetShareEnum only returned 13</span>
<span class="cm"> *        chars, including the null termination.</span>
<span class="cm"> * This was removed because it no longer is limiting.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Comment Length</span>
<span class="cm"> */</span>
<span class="cp">#define MAXCOMMENTLEN 40</span>

<span class="cm">/*</span>
<span class="cm"> * The OS/2 maximum path name</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_PATHCONF 256</span>

<span class="cm">/*</span>
<span class="cm"> *  SMB frame definitions  (following must be packed structs)</span>
<span class="cm"> *  See the SNIA CIFS Specification for details.</span>
<span class="cm"> *</span>
<span class="cm"> *  The Naming convention is the lower case version of the</span>
<span class="cm"> *  smb command code name for the struct and this is typedef to the</span>
<span class="cm"> *  uppercase version of the same name with the prefix SMB_ removed</span>
<span class="cm"> *  for brevity.  Although typedefs are not commonly used for</span>
<span class="cm"> *  structure definitions in the Linux kernel, their use in the</span>
<span class="cm"> *  CIFS standards document, which this code is based on, may</span>
<span class="cm"> *  make this one of the cases where typedefs for structures make</span>
<span class="cm"> *  sense to improve readability for readers of the standards doc.</span>
<span class="cm"> *  Typedefs can always be removed later if they are too distracting</span>
<span class="cm"> *  and they are only used for the CIFSs PDUs themselves, not</span>
<span class="cm"> *  internal cifs vfs structures</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">negotiate_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">DialectsArray</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">NEGOTIATE_REQ</span><span class="p">;</span>

<span class="cm">/* Dialect index is 13 for LANMAN */</span>

<span class="cp">#define MIN_TZ_ADJ (15 * 60) </span><span class="cm">/* minimum grid for timezones in seconds */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">lanman_neg_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 13 */</span>
	<span class="n">__le16</span> <span class="n">DialectIndex</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SecurityMode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxBufSize</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxMpxCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxNumberVcs</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">RawMode</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">SessionKey</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="n">__le16</span> <span class="n">Time</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">Date</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SrvTime</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ServerTimeZone</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">EncryptionKeyLength</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__u16</span>  <span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">EncryptionKey</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">LANMAN_NEG_RSP</span><span class="p">;</span>

<span class="cp">#define READ_RAW_ENABLE 1</span>
<span class="cp">#define WRITE_RAW_ENABLE 2</span>
<span class="cp">#define RAW_ENABLE (READ_RAW_ENABLE | WRITE_RAW_ENABLE)</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">negotiate_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 17 */</span>
	<span class="n">__le16</span> <span class="n">DialectIndex</span><span class="p">;</span> <span class="cm">/* 0xFFFF = no dialect acceptable */</span>
	<span class="n">__u8</span> <span class="n">SecurityMode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxMpxCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxNumberVcs</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxBufferSize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxRawSize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">SessionKey</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Capabilities</span><span class="p">;</span>	<span class="cm">/* see below */</span>
	<span class="n">__le32</span> <span class="n">SystemTimeLow</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">SystemTimeHigh</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ServerTimeZone</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">EncryptionKeyLength</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">EncryptionKey</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* cap extended security off */</span>
		<span class="cm">/* followed by Domain name - if extended security is off */</span>
		<span class="cm">/* followed by 16 bytes of server GUID */</span>
		<span class="cm">/* then security blob if cap_extended_security negotiated */</span>
		<span class="k">struct</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">GUID</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">SecurityBlob</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">extended_response</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">NEGOTIATE_RSP</span><span class="p">;</span>

<span class="cm">/* SecurityMode bits */</span>
<span class="cp">#define SECMODE_USER          0x01	</span><span class="cm">/* off indicates share level security */</span><span class="cp"></span>
<span class="cp">#define SECMODE_PW_ENCRYPT    0x02</span>
<span class="cp">#define SECMODE_SIGN_ENABLED  0x04	</span><span class="cm">/* SMB security signatures enabled */</span><span class="cp"></span>
<span class="cp">#define SECMODE_SIGN_REQUIRED 0x08	</span><span class="cm">/* SMB security signatures required */</span><span class="cp"></span>

<span class="cm">/* Negotiate response Capabilities */</span>
<span class="cp">#define CAP_RAW_MODE           0x00000001</span>
<span class="cp">#define CAP_MPX_MODE           0x00000002</span>
<span class="cp">#define CAP_UNICODE            0x00000004</span>
<span class="cp">#define CAP_LARGE_FILES        0x00000008</span>
<span class="cp">#define CAP_NT_SMBS            0x00000010	</span><span class="cm">/* implies CAP_NT_FIND */</span><span class="cp"></span>
<span class="cp">#define CAP_RPC_REMOTE_APIS    0x00000020</span>
<span class="cp">#define CAP_STATUS32           0x00000040</span>
<span class="cp">#define CAP_LEVEL_II_OPLOCKS   0x00000080</span>
<span class="cp">#define CAP_LOCK_AND_READ      0x00000100</span>
<span class="cp">#define CAP_NT_FIND            0x00000200</span>
<span class="cp">#define CAP_DFS                0x00001000</span>
<span class="cp">#define CAP_INFOLEVEL_PASSTHRU 0x00002000</span>
<span class="cp">#define CAP_LARGE_READ_X       0x00004000</span>
<span class="cp">#define CAP_LARGE_WRITE_X      0x00008000</span>
<span class="cp">#define CAP_LWIO               0x00010000 </span><span class="cm">/* support fctl_srv_req_resume_key */</span><span class="cp"></span>
<span class="cp">#define CAP_UNIX               0x00800000</span>
<span class="cp">#define CAP_COMPRESSED_DATA    0x02000000</span>
<span class="cp">#define CAP_DYNAMIC_REAUTH     0x20000000</span>
<span class="cp">#define CAP_PERSISTENT_HANDLES 0x40000000</span>
<span class="cp">#define CAP_EXTENDED_SECURITY  0x80000000</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">smb_com_session_setup_andx</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* request format */</span>
		<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 12 */</span>
		<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
		<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">MaxBufferSize</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">MaxMpxCount</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">VcNumber</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">SessionKey</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">SecurityBlobLength</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">Reserved</span><span class="p">;</span>
		<span class="n">__le32</span> <span class="n">Capabilities</span><span class="p">;</span>	<span class="cm">/* see below */</span>
		<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">SecurityBlob</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* followed by */</span>
		<span class="cm">/* STRING NativeOS */</span>
		<span class="cm">/* STRING NativeLanMan */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">req</span><span class="p">;</span>	<span class="cm">/* NTLM request format (with</span>
<span class="cm">					extended security */</span>

	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* request format */</span>
		<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 13 */</span>
		<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
		<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">MaxBufferSize</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">MaxMpxCount</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">VcNumber</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">SessionKey</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">CaseInsensitivePasswordLength</span><span class="p">;</span> <span class="cm">/* ASCII password len */</span>
		<span class="n">__le16</span> <span class="n">CaseSensitivePasswordLength</span><span class="p">;</span> <span class="cm">/* Unicode password length*/</span>
		<span class="n">__u32</span> <span class="n">Reserved</span><span class="p">;</span>	<span class="cm">/* see below */</span>
		<span class="n">__le32</span> <span class="n">Capabilities</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">CaseInsensitivePassword</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>     <span class="cm">/* followed by: */</span>
		<span class="cm">/* unsigned char * CaseSensitivePassword; */</span>
		<span class="cm">/* STRING AccountName */</span>
		<span class="cm">/* STRING PrimaryDomain */</span>
		<span class="cm">/* STRING NativeOS */</span>
		<span class="cm">/* STRING NativeLanMan */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">req_no_secext</span><span class="p">;</span> <span class="cm">/* NTLM request format (without</span>
<span class="cm">							extended security */</span>

	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* default (NTLM) response format */</span>
		<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 4 */</span>
		<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
		<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">Action</span><span class="p">;</span>	<span class="cm">/* see below */</span>
		<span class="n">__le16</span> <span class="n">SecurityBlobLength</span><span class="p">;</span>
		<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">SecurityBlob</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* followed by */</span>
<span class="cm">/*      unsigned char  * NativeOS;      */</span>
<span class="cm">/*	unsigned char  * NativeLanMan;  */</span>
<span class="cm">/*      unsigned char  * PrimaryDomain; */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">resp</span><span class="p">;</span>	<span class="cm">/* NTLM response</span>
<span class="cm">					   (with or without extended sec) */</span>

	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* request format */</span>
		<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 */</span>
		<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
		<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">MaxBufferSize</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">MaxMpxCount</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">VcNumber</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">SessionKey</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">PasswordLength</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">Reserved</span><span class="p">;</span> <span class="cm">/* encrypt key len and offset */</span>
		<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">AccountPassword</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* followed by */</span>
		<span class="cm">/* STRING AccountName */</span>
		<span class="cm">/* STRING PrimaryDomain */</span>
		<span class="cm">/* STRING NativeOS */</span>
		<span class="cm">/* STRING NativeLanMan */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">old_req</span><span class="p">;</span> <span class="cm">/* pre-NTLM (LANMAN2.1) req format */</span>

	<span class="k">struct</span> <span class="p">{</span>		<span class="cm">/* default (NTLM) response format */</span>
		<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 3 */</span>
		<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
		<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
		<span class="n">__le16</span> <span class="n">Action</span><span class="p">;</span>	<span class="cm">/* see below */</span>
		<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">NativeOS</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* followed by */</span>
<span class="cm">/*	unsigned char * NativeLanMan; */</span>
<span class="cm">/*      unsigned char * PrimaryDomain; */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">old_resp</span><span class="p">;</span> <span class="cm">/* pre-NTLM (LANMAN2.1) response */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SESSION_SETUP_ANDX</span><span class="p">;</span>

<span class="cm">/* format of NLTMv2 Response ie &quot;case sensitive password&quot; hash when NTLMv2 */</span>

<span class="cp">#define NTLMSSP_SERVER_TYPE	1</span>
<span class="cp">#define NTLMSSP_DOMAIN_TYPE	2</span>
<span class="cp">#define NTLMSSP_FQ_DOMAIN_TYPE	3</span>
<span class="cp">#define NTLMSSP_DNS_DOMAIN_TYPE	4</span>
<span class="cp">#define NTLMSSP_DNS_PARENT_TYPE	5</span>

<span class="k">struct</span> <span class="n">ntlmssp2_name</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">length</span><span class="p">;</span>
<span class="cm">/*	char   name[length]; */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">ntlmv2_resp</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">ntlmv2_hash</span><span class="p">[</span><span class="n">CIFS_ENCPWD_SIZE</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">blob_signature</span><span class="p">;</span>
	<span class="n">__u32</span>  <span class="n">reserved</span><span class="p">;</span>
	<span class="n">__le64</span>  <span class="n">time</span><span class="p">;</span>
	<span class="n">__u64</span>  <span class="n">client_chal</span><span class="p">;</span> <span class="cm">/* random */</span>
	<span class="n">__u32</span>  <span class="n">reserved2</span><span class="p">;</span>
	<span class="cm">/* array of name entries could follow ending in minimum 4 byte struct */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="cp">#define CIFS_NETWORK_OPSYS &quot;CIFS VFS Client for Linux&quot;</span>

<span class="cm">/* Capabilities bits (for NTLM SessSetup request) */</span>
<span class="cp">#define CAP_UNICODE            0x00000004</span>
<span class="cp">#define CAP_LARGE_FILES        0x00000008</span>
<span class="cp">#define CAP_NT_SMBS            0x00000010</span>
<span class="cp">#define CAP_STATUS32           0x00000040</span>
<span class="cp">#define CAP_LEVEL_II_OPLOCKS   0x00000080</span>
<span class="cp">#define CAP_NT_FIND            0x00000200	</span><span class="cm">/* reserved should be zero</span>
<span class="cm">				(because NT_SMBs implies the same thing?) */</span><span class="cp"></span>
<span class="cp">#define CAP_BULK_TRANSFER      0x20000000</span>
<span class="cp">#define CAP_EXTENDED_SECURITY  0x80000000</span>

<span class="cm">/* Action bits */</span>
<span class="cp">#define GUEST_LOGIN 1</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_tconx_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 4 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>		<span class="cm">/* see below */</span>
	<span class="n">__le16</span> <span class="n">PasswordLength</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Password</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* followed by */</span>
<span class="cm">/* STRING Path    *//* \\server\share name */</span>
	<span class="cm">/* STRING Service */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TCONX_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_tconx_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 3 , not extended response */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">OptionalSupport</span><span class="p">;</span>	<span class="cm">/* see below */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Service</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* always ASCII, not Unicode */</span>
	<span class="cm">/* STRING NativeFileSystem */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TCONX_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_tconx_rsp_ext</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 7, extended response */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">OptionalSupport</span><span class="p">;</span>	<span class="cm">/* see below */</span>
	<span class="n">__le32</span> <span class="n">MaximalShareAccessRights</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">GuestMaximalShareAccessRights</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">Service</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* always ASCII, not Unicode */</span>
	<span class="cm">/* STRING NativeFileSystem */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TCONX_RSP_EXT</span><span class="p">;</span>


<span class="cm">/* tree connect Flags */</span>
<span class="cp">#define DISCONNECT_TID          0x0001</span>
<span class="cp">#define TCON_EXTENDED_SIGNATURES 0x0004</span>
<span class="cp">#define TCON_EXTENDED_SECINFO   0x0008</span>

<span class="cm">/* OptionalSupport bits */</span>
<span class="cp">#define SMB_SUPPORT_SEARCH_BITS 0x0001	</span><span class="cm">/* &quot;must have&quot; directory search bits</span>
<span class="cm">					 (exclusive searches supported) */</span><span class="cp"></span>
<span class="cp">#define SMB_SHARE_IS_IN_DFS     0x0002</span>
<span class="cp">#define SMB_CSC_MASK               0x000C</span>
<span class="cm">/* CSC flags defined as follows */</span>
<span class="cp">#define SMB_CSC_CACHE_MANUAL_REINT 0x0000</span>
<span class="cp">#define SMB_CSC_CACHE_AUTO_REINT   0x0004</span>
<span class="cp">#define SMB_CSC_CACHE_VDO          0x0008</span>
<span class="cp">#define SMB_CSC_NO_CACHING         0x000C</span>
<span class="cp">#define SMB_UNIQUE_FILE_NAME    0x0010</span>
<span class="cp">#define SMB_EXTENDED_SIGNATURES 0x0020</span>

<span class="cm">/* services</span>
<span class="cm"> *</span>
<span class="cm"> * A:       ie disk</span>
<span class="cm"> * LPT1:    ie printer</span>
<span class="cm"> * IPC      ie named pipe</span>
<span class="cm"> * COMM</span>
<span class="cm"> * ?????    ie any type</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_echo_req</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">EchoCount</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">Data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">ECHO_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_echo_rsp</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">SequenceNumber</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">Data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">ECHO_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_logoff_andx_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 2 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">LOGOFF_ANDX_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_logoff_andx_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 2 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">LOGOFF_ANDX_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">union</span> <span class="n">smb_com_tree_disconnect</span> <span class="p">{</span>	<span class="cm">/* as an altetnative can use flag on</span>
<span class="cm">					tree_connect PDU to effect disconnect */</span>
					<span class="cm">/* tdis is probably simplest SMB PDU */</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
		<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bcc = 0 */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">req</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
		<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bcc = 0 */</span>
	<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">resp</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TREE_DISCONNECT</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_close_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 3 */</span>
	<span class="n">__u16</span> <span class="n">FileID</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">LastWriteTime</span><span class="p">;</span>	<span class="cm">/* should be zero or -1 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">CLOSE_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_close_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">CLOSE_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_flush_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 1 */</span>
	<span class="n">__u16</span> <span class="n">FileID</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FLUSH_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_findclose_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span> <span class="cm">/* wct = 1 */</span>
	<span class="n">__u16</span> <span class="n">FileID</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>    <span class="cm">/* 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FINDCLOSE_REQ</span><span class="p">;</span>

<span class="cm">/* OpenFlags */</span>
<span class="cp">#define REQ_MORE_INFO      0x00000001  </span><span class="cm">/* legacy (OPEN_AND_X) only */</span><span class="cp"></span>
<span class="cp">#define REQ_OPLOCK         0x00000002</span>
<span class="cp">#define REQ_BATCHOPLOCK    0x00000004</span>
<span class="cp">#define REQ_OPENDIRONLY    0x00000008</span>
<span class="cp">#define REQ_EXTENDED_INFO  0x00000010</span>

<span class="cm">/* File type */</span>
<span class="cp">#define DISK_TYPE		0x0000</span>
<span class="cp">#define BYTE_PIPE_TYPE		0x0001</span>
<span class="cp">#define MESSAGE_PIPE_TYPE	0x0002</span>
<span class="cp">#define PRINTER_TYPE		0x0003</span>
<span class="cp">#define COMM_DEV_TYPE		0x0004</span>
<span class="cp">#define UNKNOWN_TYPE		0xFFFF</span>

<span class="cm">/* Device Type or File Status Flags */</span>
<span class="cp">#define NO_EAS			0x0001</span>
<span class="cp">#define NO_SUBSTREAMS		0x0002</span>
<span class="cp">#define NO_REPARSETAG		0x0004</span>
<span class="cm">/* following flags can apply if pipe */</span>
<span class="cp">#define ICOUNT_MASK		0x00FF</span>
<span class="cp">#define PIPE_READ_MODE		0x0100</span>
<span class="cp">#define NAMED_PIPE_TYPE		0x0400</span>
<span class="cp">#define PIPE_END_POINT		0x4000</span>
<span class="cp">#define BLOCKING_NAMED_PIPE	0x8000</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_open_req</span> <span class="p">{</span>	<span class="cm">/* also handles create */</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 24 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>		<span class="cm">/* Must Be Zero */</span>
	<span class="n">__le16</span> <span class="n">NameLength</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OpenFlags</span><span class="p">;</span>
	<span class="n">__u32</span>  <span class="n">RootDirectoryFid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DesiredAccess</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileAttributes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ShareAccess</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">CreateDisposition</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">CreateOptions</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ImpersonationLevel</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SecurityFlags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">fileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">OPEN_REQ</span><span class="p">;</span>

<span class="cm">/* open response: oplock levels */</span>
<span class="cp">#define OPLOCK_NONE  	 0</span>
<span class="cp">#define OPLOCK_EXCLUSIVE 1</span>
<span class="cp">#define OPLOCK_BATCH	 2</span>
<span class="cp">#define OPLOCK_READ	 3  </span><span class="cm">/* level 2 oplock */</span><span class="cp"></span>

<span class="cm">/* open response for CreateAction shifted left */</span>
<span class="cp">#define CIFS_CREATE_ACTION 0x20000 </span><span class="cm">/* file created */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_open_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 34 BB */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">OplockLevel</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">CreateAction</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileAttributes</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">FileType</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DeviceState</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">DirectoryFlag</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">OPEN_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_open_rsp_ext</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 42 but meaningless due to MS bug? */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">OplockLevel</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">CreateAction</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileAttributes</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">FileType</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DeviceState</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">DirectoryFlag</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">VolumeGUID</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="n">__u64</span> <span class="n">FileId</span><span class="p">;</span> <span class="cm">/* note no endian conversion - is opaque UniqueID */</span>
	<span class="n">__le32</span> <span class="n">MaximalAccessRights</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">GuestMaximalAccessRights</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>        <span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">OPEN_RSP_EXT</span><span class="p">;</span>


<span class="cm">/* format of legacy open request */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_openx_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span>	<span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">OpenFlags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Mode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Sattr</span><span class="p">;</span> <span class="cm">/* search attributes */</span>
	<span class="n">__le16</span> <span class="n">FileAttributes</span><span class="p">;</span>  <span class="cm">/* dos attrs */</span>
	<span class="n">__le32</span> <span class="n">CreateTime</span><span class="p">;</span> <span class="cm">/* os2 format */</span>
	<span class="n">__le16</span> <span class="n">OpenFunction</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span>  <span class="n">ByteCount</span><span class="p">;</span>  <span class="cm">/* file name follows */</span>
	<span class="kt">char</span>   <span class="n">fileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">OPENX_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_openx_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span>	<span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span>  <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">FileAttributes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">LastWriteTime</span><span class="p">;</span> <span class="cm">/* os2 format */</span>
	<span class="n">__le32</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Access</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">FileType</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">IPCState</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Action</span><span class="p">;</span>
	<span class="n">__u32</span>  <span class="n">FileId</span><span class="p">;</span>
	<span class="n">__u16</span>  <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__u16</span>  <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">OPENX_RSP</span><span class="p">;</span>

<span class="cm">/* For encoding of POSIX Open Request - see trans2 function 0x209 data struct */</span>

<span class="cm">/* Legacy write request for older servers */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_writex_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 12 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetLow</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">Reserved</span><span class="p">;</span> <span class="cm">/* Timeout */</span>
	<span class="n">__le16</span> <span class="n">WriteMode</span><span class="p">;</span> <span class="cm">/* 1 = write through */</span>
	<span class="n">__le16</span> <span class="n">Remaining</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataLengthLow</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>		<span class="cm">/* BB check for whether padded to DWORD</span>
<span class="cm">				   boundary and optimum performance here */</span>
	<span class="kt">char</span> <span class="n">Data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">WRITEX_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_write_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 14 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetLow</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">WriteMode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Remaining</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataLengthHigh</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataLengthLow</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetHigh</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>		<span class="cm">/* BB check for whether padded to DWORD</span>
<span class="cm">				   boundary and optimum performance here */</span>
	<span class="kt">char</span> <span class="n">Data</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">WRITE_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_write_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 6 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Count</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Remaining</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">CountHigh</span><span class="p">;</span>
	<span class="n">__u16</span>  <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">WRITE_RSP</span><span class="p">;</span>

<span class="cm">/* legacy read request for older servers */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_readx_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetLow</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MinCount</span><span class="p">;</span>	<span class="cm">/* obsolete */</span>
	<span class="n">__le32</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Remaining</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">READX_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_read_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 12 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetLow</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MinCount</span><span class="p">;</span>		<span class="cm">/* obsolete */</span>
	<span class="n">__le32</span> <span class="n">MaxCountHigh</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Remaining</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetHigh</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">READ_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_read_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 12 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Remaining</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCompactionMode</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataLength</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataLengthHigh</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="cm">/* read response data immediately follows */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">READ_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">locking_andx_range</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">Pid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetHigh</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">OffsetLow</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">LengthHigh</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">LengthLow</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">LOCKING_ANDX_RANGE</span><span class="p">;</span>

<span class="cp">#define LOCKING_ANDX_SHARED_LOCK     0x01</span>
<span class="cp">#define LOCKING_ANDX_OPLOCK_RELEASE  0x02</span>
<span class="cp">#define LOCKING_ANDX_CHANGE_LOCKTYPE 0x04</span>
<span class="cp">#define LOCKING_ANDX_CANCEL_LOCK     0x08</span>
<span class="cp">#define LOCKING_ANDX_LARGE_FILES     0x10	</span><span class="cm">/* always on for us */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_lock_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 8 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">LockType</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">OplockLevel</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">NumberOfUnlocks</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">NumberOfLocks</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">LOCKING_ANDX_RANGE</span> <span class="n">Locks</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">LOCK_REQ</span><span class="p">;</span>

<span class="cm">/* lock type */</span>
<span class="cp">#define CIFS_RDLCK	0</span>
<span class="cp">#define CIFS_WRLCK	1</span>
<span class="cp">#define CIFS_UNLCK      2</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">cifs_posix_lock</span> <span class="p">{</span>
	<span class="n">__le16</span>  <span class="n">lock_type</span><span class="p">;</span>  <span class="cm">/* 0 = Read, 1 = Write, 2 = Unlock */</span>
	<span class="n">__le16</span>  <span class="n">lock_flags</span><span class="p">;</span> <span class="cm">/* 1 = Wait (only valid for setlock) */</span>
	<span class="n">__le32</span>  <span class="n">pid</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">start</span><span class="p">;</span>
	<span class="n">__le64</span>	<span class="n">length</span><span class="p">;</span>
	<span class="cm">/* BB what about additional owner info to identify network client */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">CIFS_POSIX_LOCK</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_lock_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 2 */</span>
	<span class="n">__u8</span> <span class="n">AndXCommand</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">AndXReserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">AndXOffset</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">LOCK_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_rename_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 1 */</span>
	<span class="n">__le16</span> <span class="n">SearchAttributes</span><span class="p">;</span>	<span class="cm">/* target file attributes */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>	<span class="cm">/* 4 = ASCII or Unicode */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">OldFileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="cm">/* followed by __u8 BufferFormat2 */</span>
	<span class="cm">/* followed by NewFileName */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">RENAME_REQ</span><span class="p">;</span>

	<span class="cm">/* copy request flags */</span>
<span class="cp">#define COPY_MUST_BE_FILE      0x0001</span>
<span class="cp">#define COPY_MUST_BE_DIR       0x0002</span>
<span class="cp">#define COPY_TARGET_MODE_ASCII 0x0004 </span><span class="cm">/* if not set, binary */</span><span class="cp"></span>
<span class="cp">#define COPY_SOURCE_MODE_ASCII 0x0008 </span><span class="cm">/* if not set, binary */</span><span class="cp"></span>
<span class="cp">#define COPY_VERIFY_WRITES     0x0010</span>
<span class="cp">#define COPY_TREE              0x0020</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_copy_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 3 */</span>
	<span class="n">__u16</span> <span class="n">Tid2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">OpenFunction</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>	<span class="cm">/* 4 = ASCII or Unicode */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">OldFileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="cm">/* followed by __u8 BufferFormat2 */</span>
	<span class="cm">/* followed by NewFileName string */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">COPY_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_copy_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 1 */</span>
	<span class="n">__le16</span> <span class="n">CopyCount</span><span class="p">;</span>    <span class="cm">/* number of files copied */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>    <span class="cm">/* may be zero */</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>  <span class="cm">/* 0x04 - only present if errored file follows */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ErrorFileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="cm">/* only present if error in copy */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">COPY_RSP</span><span class="p">;</span>

<span class="cp">#define CREATE_HARD_LINK		0x103</span>
<span class="cp">#define MOVEFILE_COPY_ALLOWED		0x0002</span>
<span class="cp">#define MOVEFILE_REPLACE_EXISTING	0x0001</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_nt_rename_req</span> <span class="p">{</span>	<span class="cm">/* A5 - also used for create hardlink */</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 4 */</span>
	<span class="n">__le16</span> <span class="n">SearchAttributes</span><span class="p">;</span>	<span class="cm">/* target file attributes */</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>		<span class="cm">/* spec says Information Level */</span>
	<span class="n">__le32</span> <span class="n">ClusterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>	<span class="cm">/* 4 = ASCII or Unicode */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">OldFileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="cm">/* followed by __u8 BufferFormat2 */</span>
	<span class="cm">/* followed by NewFileName */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">NT_RENAME_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_rename_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">RENAME_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_delete_file_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 1 */</span>
	<span class="n">__le16</span> <span class="n">SearchAttributes</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>	<span class="cm">/* 4 = ASCII */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">DELETE_FILE_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_delete_file_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">DELETE_FILE_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_delete_directory_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>	<span class="cm">/* 4 = ASCII */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">DirName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">DELETE_DIRECTORY_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_delete_directory_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">DELETE_DIRECTORY_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_create_directory_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>	<span class="cm">/* 4 = ASCII */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">DirName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">CREATE_DIRECTORY_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_create_directory_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">CREATE_DIRECTORY_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_query_information_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 0 */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* 1 + namelen + 1 */</span>
	<span class="n">__u8</span> <span class="n">BufferFormat</span><span class="p">;</span>      <span class="cm">/* 4 = ASCII */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">QUERY_INFORMATION_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_query_information_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 10 */</span>
	<span class="n">__le16</span> <span class="n">attr</span><span class="p">;</span>
	<span class="n">__le32</span>  <span class="n">last_write_time</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">__u16</span>  <span class="n">reserved</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>	<span class="cm">/* bcc = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">QUERY_INFORMATION_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_setattr_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span> <span class="cm">/* wct = 8 */</span>
	<span class="n">__le16</span> <span class="n">attr</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">time_low</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">time_high</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">reserved</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span> <span class="cm">/* must be zero */</span>
	<span class="n">__u16</span>  <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">BufferFormat</span><span class="p">;</span> <span class="cm">/* 4 = ASCII */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">fileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SETATTR_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_setattr_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>        <span class="cm">/* bct = 0 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SETATTR_RSP</span><span class="p">;</span>

<span class="cm">/* empty wct response to setattr */</span>

<span class="cm">/*******************************************************/</span>
<span class="cm">/* NT Transact structure definitions follow            */</span>
<span class="cm">/* Currently only ioctl, acl (get security descriptor) */</span>
<span class="cm">/* and notify are implemented                          */</span>
<span class="cm">/*******************************************************/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_ntransact_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span> <span class="cm">/* wct &gt;= 19 */</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span> <span class="cm">/* four setup words follow subcommand */</span>
	<span class="cm">/* SNIA spec incorrectly included spurious pad here */</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span> <span class="cm">/* 2 = IOCTL/FSCTL */</span>
	<span class="cm">/* SetupCount words follow then */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">Parms</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">NTRANSACT_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_ntransact_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 18 */</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterDisplacement</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataDisplacement</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>   <span class="cm">/* 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="cm">/* __u8 Pad[3]; */</span>
	<span class="cm">/* parms and data follow */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">NTRANSACT_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_ioctl_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 23 */</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span> <span class="cm">/* four setup words follow subcommand */</span>
	<span class="cm">/* SNIA spec incorrectly included spurious pad here */</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span> <span class="cm">/* 2 = IOCTL/FSCTL */</span>
	<span class="n">__le32</span> <span class="n">FunctionCode</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">IsFsctl</span><span class="p">;</span>  <span class="cm">/* 1 = File System Control 0 = device control (IOCTL) */</span>
	<span class="n">__u8</span> <span class="n">IsRootFlag</span><span class="p">;</span> <span class="cm">/* 1 = apply command to root of share (must be DFS) */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u8</span> <span class="n">Data</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACT_IOCTL_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_ioctl_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 19 */</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterDisplacement</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataDisplacement</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>	<span class="cm">/* 1 */</span>
	<span class="n">__le16</span> <span class="n">ReturnedDataLen</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACT_IOCTL_RSP</span><span class="p">;</span>

<span class="cp">#define CIFS_ACL_OWNER 1</span>
<span class="cp">#define CIFS_ACL_GROUP 2</span>
<span class="cp">#define CIFS_ACL_DACL  4</span>
<span class="cp">#define CIFS_ACL_SACL  8</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_qsec_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 19 */</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span> <span class="cm">/* no setup words follow subcommand */</span>
	<span class="cm">/* SNIA spec incorrectly included spurious pad here */</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span> <span class="cm">/* 6 = QUERY_SECURITY_DESC */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span> <span class="cm">/* bcc = 3 + 8 */</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">AclFlags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">QUERY_SEC_DESC_REQ</span><span class="p">;</span>


<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_ssec_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 19 */</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span> <span class="cm">/* no setup words follow subcommand */</span>
	<span class="cm">/* SNIA spec incorrectly included spurious pad here */</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span> <span class="cm">/* 3 = SET_SECURITY_DESC */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span> <span class="cm">/* bcc = 3 + 8 */</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">AclFlags</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SET_SEC_DESC_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_change_notify_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 23 */</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span> <span class="cm">/* four setup words follow subcommand */</span>
	<span class="cm">/* SNIA spec incorrectly included spurious pad here */</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span><span class="cm">/* 4 = Change Notify */</span>
	<span class="n">__le32</span> <span class="n">CompletionFilter</span><span class="p">;</span>  <span class="cm">/* operation to monitor */</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">WatchTree</span><span class="p">;</span>  <span class="cm">/* 1 = Monitor subdirectories */</span>
	<span class="n">__u8</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="cm">/* 	__u8 Pad[3];*/</span>
<span class="cm">/*	__u8 Data[1];*/</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACT_CHANGE_NOTIFY_REQ</span><span class="p">;</span>

<span class="cm">/* BB eventually change to use generic ntransact rsp struct</span>
<span class="cm">      and validation routine */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_change_notify_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 18 */</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="n">__le32</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ParameterDisplacement</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataDisplacement</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>   <span class="cm">/* 0 */</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="cm">/* __u8 Pad[3]; */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACT_CHANGE_NOTIFY_RSP</span><span class="p">;</span>
<span class="cm">/* Completion Filter flags for Notify */</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_FILE_NAME    0x00000001</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_DIR_NAME     0x00000002</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_NAME         0x00000003</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_ATTRIBUTES   0x00000004</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_SIZE         0x00000008</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_LAST_WRITE   0x00000010</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_LAST_ACCESS  0x00000020</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_CREATION     0x00000040</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_EA           0x00000080</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_SECURITY     0x00000100</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_STREAM_NAME  0x00000200</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_STREAM_SIZE  0x00000400</span>
<span class="cp">#define FILE_NOTIFY_CHANGE_STREAM_WRITE 0x00000800</span>

<span class="cp">#define FILE_ACTION_ADDED		0x00000001</span>
<span class="cp">#define FILE_ACTION_REMOVED		0x00000002</span>
<span class="cp">#define FILE_ACTION_MODIFIED		0x00000003</span>
<span class="cp">#define FILE_ACTION_RENAMED_OLD_NAME	0x00000004</span>
<span class="cp">#define FILE_ACTION_RENAMED_NEW_NAME	0x00000005</span>
<span class="cp">#define FILE_ACTION_ADDED_STREAM	0x00000006</span>
<span class="cp">#define FILE_ACTION_REMOVED_STREAM	0x00000007</span>
<span class="cp">#define FILE_ACTION_MODIFIED_STREAM	0x00000008</span>

<span class="cm">/* response contains array of the following structures */</span>
<span class="k">struct</span> <span class="n">file_notify_information</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">NextEntryOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Action</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileNameLength</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">FileName</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">reparse_data</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">ReparseTag</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">ReparseDataLength</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">AltNameOffset</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">AltNameLen</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">TargetNameOffset</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">TargetNameLen</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">LinkNamesBuf</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">cifs_quota_data</span> <span class="p">{</span>
	<span class="n">__u32</span>	<span class="n">rsrvd1</span><span class="p">;</span>  <span class="cm">/* 0 */</span>
	<span class="n">__u32</span>	<span class="n">sid_size</span><span class="p">;</span>
	<span class="n">__u64</span>	<span class="n">rsrvd2</span><span class="p">;</span>  <span class="cm">/* 0 */</span>
	<span class="n">__u64</span>	<span class="n">space_used</span><span class="p">;</span>
	<span class="n">__u64</span>	<span class="n">soft_limit</span><span class="p">;</span>
	<span class="n">__u64</span>	<span class="n">hard_limit</span><span class="p">;</span>
	<span class="kt">char</span>	<span class="n">sid</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>  <span class="cm">/* variable size? */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* quota sub commands */</span>
<span class="cp">#define QUOTA_LIST_CONTINUE	    0</span>
<span class="cp">#define QUOTA_LIST_START	0x100</span>
<span class="cp">#define QUOTA_FOR_SID		0x101</span>

<span class="k">struct</span> <span class="n">trans2_req</span> <span class="p">{</span>
	<span class="cm">/* struct smb_hdr hdr precedes. Set wct = 14+ */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span> <span class="cm">/* 1st setup word - SetupCount words follow */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">smb_t2_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trans2_req</span> <span class="n">t2_req</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="p">{</span>
	<span class="cm">/* struct smb_hdr hdr precedes. Note wct = 10 + setup count */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterDisplacement</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataDisplacement</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved1</span><span class="p">;</span>
	<span class="cm">/* SetupWords[SetupCount];</span>
<span class="cm">	__u16 ByteCount;</span>
<span class="cm">	__u16 Reserved2;*/</span>
	<span class="cm">/* data area follows */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">smb_t2_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2_rsp</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* PathInfo/FileInfo infolevels */</span>
<span class="cp">#define SMB_INFO_STANDARD                   1</span>
<span class="cp">#define SMB_SET_FILE_EA                     2</span>
<span class="cp">#define SMB_QUERY_FILE_EA_SIZE              2</span>
<span class="cp">#define SMB_INFO_QUERY_EAS_FROM_LIST        3</span>
<span class="cp">#define SMB_INFO_QUERY_ALL_EAS              4</span>
<span class="cp">#define SMB_INFO_IS_NAME_VALID              6</span>
<span class="cp">#define SMB_QUERY_FILE_BASIC_INFO       0x101</span>
<span class="cp">#define SMB_QUERY_FILE_STANDARD_INFO    0x102</span>
<span class="cp">#define SMB_QUERY_FILE_EA_INFO          0x103</span>
<span class="cp">#define SMB_QUERY_FILE_NAME_INFO        0x104</span>
<span class="cp">#define SMB_QUERY_FILE_ALLOCATION_INFO  0x105</span>
<span class="cp">#define SMB_QUERY_FILE_END_OF_FILEINFO  0x106</span>
<span class="cp">#define SMB_QUERY_FILE_ALL_INFO         0x107</span>
<span class="cp">#define SMB_QUERY_ALT_NAME_INFO         0x108</span>
<span class="cp">#define SMB_QUERY_FILE_STREAM_INFO      0x109</span>
<span class="cp">#define SMB_QUERY_FILE_COMPRESSION_INFO 0x10B</span>
<span class="cp">#define SMB_QUERY_FILE_UNIX_BASIC       0x200</span>
<span class="cp">#define SMB_QUERY_FILE_UNIX_LINK        0x201</span>
<span class="cp">#define SMB_QUERY_POSIX_ACL             0x204</span>
<span class="cp">#define SMB_QUERY_XATTR                 0x205  </span><span class="cm">/* e.g. system EA name space */</span><span class="cp"></span>
<span class="cp">#define SMB_QUERY_ATTR_FLAGS            0x206  </span><span class="cm">/* append,immutable etc. */</span><span class="cp"></span>
<span class="cp">#define SMB_QUERY_POSIX_PERMISSION      0x207</span>
<span class="cp">#define SMB_QUERY_POSIX_LOCK            0x208</span>
<span class="cm">/* #define SMB_POSIX_OPEN               0x209 */</span>
<span class="cm">/* #define SMB_POSIX_UNLINK             0x20a */</span>
<span class="cp">#define SMB_QUERY_FILE__UNIX_INFO2      0x20b</span>
<span class="cp">#define SMB_QUERY_FILE_INTERNAL_INFO    0x3ee</span>
<span class="cp">#define SMB_QUERY_FILE_ACCESS_INFO      0x3f0</span>
<span class="cp">#define SMB_QUERY_FILE_NAME_INFO2       0x3f1 </span><span class="cm">/* 0x30 bytes */</span><span class="cp"></span>
<span class="cp">#define SMB_QUERY_FILE_POSITION_INFO    0x3f6</span>
<span class="cp">#define SMB_QUERY_FILE_MODE_INFO        0x3f8</span>
<span class="cp">#define SMB_QUERY_FILE_ALGN_INFO        0x3f9</span>


<span class="cp">#define SMB_SET_FILE_BASIC_INFO	        0x101</span>
<span class="cp">#define SMB_SET_FILE_DISPOSITION_INFO   0x102</span>
<span class="cp">#define SMB_SET_FILE_ALLOCATION_INFO    0x103</span>
<span class="cp">#define SMB_SET_FILE_END_OF_FILE_INFO   0x104</span>
<span class="cp">#define SMB_SET_FILE_UNIX_BASIC         0x200</span>
<span class="cp">#define SMB_SET_FILE_UNIX_LINK          0x201</span>
<span class="cp">#define SMB_SET_FILE_UNIX_HLINK         0x203</span>
<span class="cp">#define SMB_SET_POSIX_ACL               0x204</span>
<span class="cp">#define SMB_SET_XATTR                   0x205</span>
<span class="cp">#define SMB_SET_ATTR_FLAGS              0x206  </span><span class="cm">/* append, immutable etc. */</span><span class="cp"></span>
<span class="cp">#define SMB_SET_POSIX_LOCK              0x208</span>
<span class="cp">#define SMB_POSIX_OPEN                  0x209</span>
<span class="cp">#define SMB_POSIX_UNLINK                0x20a</span>
<span class="cp">#define SMB_SET_FILE_UNIX_INFO2         0x20b</span>
<span class="cp">#define SMB_SET_FILE_BASIC_INFO2        0x3ec</span>
<span class="cp">#define SMB_SET_FILE_RENAME_INFORMATION 0x3f2 </span><span class="cm">/* BB check if qpathinfo too */</span><span class="cp"></span>
<span class="cp">#define SMB_FILE_ALL_INFO2              0x3fa</span>
<span class="cp">#define SMB_SET_FILE_ALLOCATION_INFO2   0x3fb</span>
<span class="cp">#define SMB_SET_FILE_END_OF_FILE_INFO2  0x3fc</span>
<span class="cp">#define SMB_FILE_MOVE_CLUSTER_INFO      0x407</span>
<span class="cp">#define SMB_FILE_QUOTA_INFO             0x408</span>
<span class="cp">#define SMB_FILE_REPARSEPOINT_INFO      0x409</span>
<span class="cp">#define SMB_FILE_MAXIMUM_INFO           0x40d</span>

<span class="cm">/* Find File infolevels */</span>
<span class="cp">#define SMB_FIND_FILE_INFO_STANDARD       0x001</span>
<span class="cp">#define SMB_FIND_FILE_QUERY_EA_SIZE       0x002</span>
<span class="cp">#define SMB_FIND_FILE_QUERY_EAS_FROM_LIST 0x003</span>
<span class="cp">#define SMB_FIND_FILE_DIRECTORY_INFO      0x101</span>
<span class="cp">#define SMB_FIND_FILE_FULL_DIRECTORY_INFO 0x102</span>
<span class="cp">#define SMB_FIND_FILE_NAMES_INFO          0x103</span>
<span class="cp">#define SMB_FIND_FILE_BOTH_DIRECTORY_INFO 0x104</span>
<span class="cp">#define SMB_FIND_FILE_ID_FULL_DIR_INFO    0x105</span>
<span class="cp">#define SMB_FIND_FILE_ID_BOTH_DIR_INFO    0x106</span>
<span class="cp">#define SMB_FIND_FILE_UNIX                0x202</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_qpi_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 14+ */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* one setup word */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">Reserved4</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_QPI_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_qpi_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 + SetupCount */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span> <span class="cm">/* parameter word is present for infolevels &gt; 100 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_QPI_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_spi_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* one setup word */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Pad1</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">Reserved4</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_SPI_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_spi_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 + SetupCount */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span> <span class="cm">/* parameter word is present for infolevels &gt; 100 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_SPI_RSP</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">set_file_rename</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">overwrite</span><span class="p">;</span>   <span class="cm">/* 1 = overwrite dest */</span>
	<span class="n">__u32</span> <span class="n">root_fid</span><span class="p">;</span>   <span class="cm">/* zero */</span>
	<span class="n">__le32</span> <span class="n">target_name_len</span><span class="p">;</span>
	<span class="kt">char</span>  <span class="n">target_name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>  <span class="cm">/* Must be unicode */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">smb_com_transaction2_sfi_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* one setup word */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Pad1</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved4</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">smb_com_transaction2_sfi_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 + SetupCount */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>	<span class="cm">/* parameter word reserved -</span>
<span class="cm">					present for infolevels &gt; 100 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">smb_t2_qfi_req</span> <span class="p">{</span>
	<span class="k">struct</span>	<span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span>	<span class="n">trans2_req</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u8</span>	<span class="n">Pad</span><span class="p">;</span>
	<span class="n">__u16</span>	<span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">InformationLevel</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">smb_t2_qfi_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>     <span class="cm">/* wct = 10 + SetupCount */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>        <span class="cm">/* parameter word reserved -</span>
<span class="cm">				   present for infolevels &gt; 100 */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * Flags on T2 FINDFIRST and FINDNEXT</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_SEARCH_CLOSE_ALWAYS  0x0001</span>
<span class="cp">#define CIFS_SEARCH_CLOSE_AT_END  0x0002</span>
<span class="cp">#define CIFS_SEARCH_RETURN_RESUME 0x0004</span>
<span class="cp">#define CIFS_SEARCH_CONTINUE_FROM_LAST 0x0008</span>
<span class="cp">#define CIFS_SEARCH_BACKUP_SEARCH 0x0010</span>

<span class="cm">/*</span>
<span class="cm"> * Size of the resume key on FINDFIRST and FINDNEXT calls</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_SMB_RESUME_KEY_SIZE 4</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_ffirst_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>	<span class="cm">/* one */</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* TRANS2_FIND_FIRST */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SearchAttributes</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SearchCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SearchFlags</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">SearchStorageType</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_FFIRST_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_ffirst_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_FFIRST_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_ffirst_rsp_parms</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">SearchHandle</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SearchCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">EndofSearch</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">EAErrorOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastNameOffset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">T2_FFIRST_RSP_PARMS</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_fnext_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>	<span class="cm">/* one */</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* TRANS2_FIND_NEXT */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">SearchHandle</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SearchCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ResumeKey</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SearchFlags</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ResumeFileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_FNEXT_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_fnext_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_FNEXT_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_fnext_rsp_parms</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">SearchCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">EndofSearch</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">EAErrorOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastNameOffset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">T2_FNEXT_RSP_PARMS</span><span class="p">;</span>

<span class="cm">/* QFSInfo Levels */</span>
<span class="cp">#define SMB_INFO_ALLOCATION         1</span>
<span class="cp">#define SMB_INFO_VOLUME             2</span>
<span class="cp">#define SMB_QUERY_FS_VOLUME_INFO    0x102</span>
<span class="cp">#define SMB_QUERY_FS_SIZE_INFO      0x103</span>
<span class="cp">#define SMB_QUERY_FS_DEVICE_INFO    0x104</span>
<span class="cp">#define SMB_QUERY_FS_ATTRIBUTE_INFO 0x105</span>
<span class="cp">#define SMB_QUERY_CIFS_UNIX_INFO    0x200</span>
<span class="cp">#define SMB_QUERY_POSIX_FS_INFO     0x201</span>
<span class="cp">#define SMB_QUERY_POSIX_WHO_AM_I    0x202</span>
<span class="cp">#define SMB_REQUEST_TRANSPORT_ENCRYPTION 0x203</span>
<span class="cp">#define SMB_QUERY_FS_PROXY          0x204 </span><span class="cm">/* WAFS enabled. Returns structure</span>
<span class="cm">					    FILE_SYSTEM__UNIX_INFO to tell</span>
<span class="cm">					    whether new NTIOCTL available</span>
<span class="cm">					    (0xACE) for WAN friendly SMB</span>
<span class="cm">					    operations to be carried */</span><span class="cp"></span>
<span class="cp">#define SMB_QUERY_LABEL_INFO        0x3ea</span>
<span class="cp">#define SMB_QUERY_FS_QUOTA_INFO     0x3ee</span>
<span class="cp">#define SMB_QUERY_FS_FULL_SIZE_INFO 0x3ef</span>
<span class="cp">#define SMB_QUERY_OBJECTID_INFO     0x3f0</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_qfsi_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 14+ */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* one setup word */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_QFSI_REQ</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_qfsi_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 + SetupCount */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>	<span class="cm">/* may be three bytes? *//* followed by data area */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_QFSI_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">whoami_rsp_data</span> <span class="p">{</span> <span class="cm">/* Query level 0x202 */</span>
	<span class="n">__u32</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* 0 = Authenticated user 1 = GUEST */</span>
	<span class="n">__u32</span> <span class="n">mask</span><span class="p">;</span> <span class="cm">/* which flags bits server understands ie 0x0001 */</span>
	<span class="n">__u64</span> <span class="n">unix_user_id</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">unix_user_gid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">number_of_supplementary_gids</span><span class="p">;</span> <span class="cm">/* may be zero */</span>
	<span class="n">__u32</span> <span class="n">number_of_sids</span><span class="p">;</span> <span class="cm">/* may be zero */</span>
	<span class="n">__u32</span> <span class="n">length_of_sid_array</span><span class="p">;</span> <span class="cm">/* in bytes - may be zero */</span>
	<span class="n">__u32</span> <span class="n">pad</span><span class="p">;</span> <span class="cm">/* reserved - MBZ */</span>
	<span class="cm">/* __u64 gid_array[0]; */</span>  <span class="cm">/* may be empty */</span>
	<span class="cm">/* __u8 * psid_list */</span>  <span class="cm">/* may be empty */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">WHOAMI_RSP_DATA</span><span class="p">;</span>

<span class="cm">/* SETFSInfo Levels */</span>
<span class="cp">#define SMB_SET_CIFS_UNIX_INFO    0x200</span>
<span class="cm">/* level 0x203 is defined above in list of QFS info levels */</span>
<span class="cm">/* #define SMB_REQUEST_TRANSPORT_ENCRYPTION 0x203 */</span>

<span class="cm">/* Level 0x200 request structure follows */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_setfsi_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>	<span class="cm">/* 4 */</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>	<span class="cm">/* 12 */</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>	<span class="cm">/* one */</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* TRANS2_SET_FS_INFORMATION */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">FileNum</span><span class="p">;</span>		<span class="cm">/* Parameters start. */</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span><span class="cm">/* Parameters end. */</span>
	<span class="n">__le16</span> <span class="n">ClientUnixMajor</span><span class="p">;</span> <span class="cm">/* Data start. */</span>
	<span class="n">__le16</span> <span class="n">ClientUnixMinor</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ClientUnixCap</span><span class="p">;</span>   <span class="cm">/* Data end */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_SETFSI_REQ</span><span class="p">;</span>

<span class="cm">/* level 0x203 request structure follows */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_setfs_enc_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>	<span class="cm">/* 4 */</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>	<span class="cm">/* 12 */</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>	<span class="cm">/* one */</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* TRANS2_SET_FS_INFORMATION */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__u16</span>  <span class="n">Reserved4</span><span class="p">;</span>	<span class="cm">/* Parameters start. */</span>
	<span class="n">__le16</span> <span class="n">InformationLevel</span><span class="p">;</span><span class="cm">/* Parameters end. */</span>
	<span class="cm">/* NTLMSSP Blob, Data start. */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_SETFSI_ENC_REQ</span><span class="p">;</span>

<span class="cm">/* response for setfsinfo levels 0x200 and 0x203 */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_setfsi_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_SETFSI_RSP</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction2_get_dfs_refer_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 15 */</span>
	<span class="n">__le16</span> <span class="n">TotalParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">TotalDataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MaxDataCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">MaxSetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Flags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Timeout</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Reserved2</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ParameterOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataCount</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DataOffset</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">SetupCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Reserved3</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">SubCommand</span><span class="p">;</span>	<span class="cm">/* one setup word */</span>
	<span class="n">__le16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>		<span class="cm">/* Win2K has sent 0x0F01 (max response length</span>
<span class="cm">				   perhaps?) followed by one byte pad - doesn&#39;t</span>
<span class="cm">				   seem to matter though */</span>
	<span class="n">__le16</span> <span class="n">MaxReferralLevel</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">RequestFileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_GET_DFS_REFER_REQ</span><span class="p">;</span>

<span class="cp">#define DFS_VERSION cpu_to_le16(0x0003)</span>

<span class="cm">/* DFS server target type */</span>
<span class="cp">#define DFS_TYPE_LINK 0x0000  </span><span class="cm">/* also for sysvol targets */</span><span class="cp"></span>
<span class="cp">#define DFS_TYPE_ROOT 0x0001</span>

<span class="cm">/* Referral Entry Flags */</span>
<span class="cp">#define DFS_NAME_LIST_REF 0x0200 </span><span class="cm">/* set for domain or DC referral responses */</span><span class="cp"></span>
<span class="cp">#define DFS_TARGET_SET_BOUNDARY 0x0400 </span><span class="cm">/* only valid with version 4 dfs req */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">dfs_referral_level_3</span> <span class="p">{</span> <span class="cm">/* version 4 is same, + one flag bit */</span>
	<span class="n">__le16</span> <span class="n">VersionNumber</span><span class="p">;</span>  <span class="cm">/* must be 3 or 4 */</span>
	<span class="n">__le16</span> <span class="n">Size</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ServerType</span><span class="p">;</span> <span class="cm">/* 0x0001 = root targets; 0x0000 = link targets */</span>
	<span class="n">__le16</span> <span class="n">ReferralEntryFlags</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TimeToLive</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DfsPathOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">DfsAlternatePathOffset</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">NetworkAddressOffset</span><span class="p">;</span> <span class="cm">/* offset of the link target */</span>
	<span class="n">__u8</span>   <span class="n">ServiceSiteGuid</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>  <span class="cm">/* MBZ, ignored */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">REFERRAL3</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">smb_com_transaction_get_dfs_refer_rsp</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="n">hdr</span><span class="p">;</span>	<span class="cm">/* wct = 10 */</span>
	<span class="k">struct</span> <span class="n">trans2_resp</span> <span class="n">t2</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">ByteCount</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">PathConsumed</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">NumberOfReferrals</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DFSFlags</span><span class="p">;</span>
	<span class="n">REFERRAL3</span> <span class="n">referrals</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>	<span class="cm">/* array of level 3 dfs_referral structures */</span>
	<span class="cm">/* followed by the strings pointed to by the referral structures */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">TRANSACTION2_GET_DFS_REFER_RSP</span><span class="p">;</span>

<span class="cm">/* DFS Flags */</span>
<span class="cp">#define DFSREF_REFERRAL_SERVER  0x00000001 </span><span class="cm">/* all targets are DFS roots */</span><span class="cp"></span>
<span class="cp">#define DFSREF_STORAGE_SERVER   0x00000002 </span><span class="cm">/* no further ref requests needed */</span><span class="cp"></span>
<span class="cp">#define DFSREF_TARGET_FAILBACK  0x00000004 </span><span class="cm">/* only for DFS referral version 4 */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> ************************************************************************</span>
<span class="cm"> * All structs for everything above the SMB PDUs themselves</span>
<span class="cm"> * (such as the T2 level specific data) go here</span>
<span class="cm"> ************************************************************************</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * Information on a server</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">serverInfo</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">versionMajor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">versionMinor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">commentOffset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/*</span>
<span class="cm"> * The following structure is the format of the data returned on a NetShareEnum</span>
<span class="cm"> * with level &quot;90&quot; (x5A)</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">shareInfo</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">shareName</span><span class="p">[</span><span class="mi">13</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">pad</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">commentOffset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">aliasInfo</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">aliasName</span><span class="p">[</span><span class="mi">9</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">pad</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">commentOffset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">aliasInfo92</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">aliasNameOffset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">serverNameOffset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shareNameOffset</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">TotalAllocationUnits</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">FreeAllocationUnits</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">SectorsPerAllocationUnit</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">BytesPerSector</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_SYSTEM_INFO</span><span class="p">;</span>	<span class="cm">/* size info, level 0x103 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">fsid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">SectorsPerAllocationUnit</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">TotalAllocationUnits</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FreeAllocationUnits</span><span class="p">;</span>
	<span class="n">__le16</span>  <span class="n">BytesPerSector</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_SYSTEM_ALLOC_INFO</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">MajorVersionNumber</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">MinorVersionNumber</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">Capability</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_SYSTEM_UNIX_INFO</span><span class="p">;</span> <span class="cm">/* Unix extension level 0x200*/</span>

<span class="cm">/* Version numbers for CIFS UNIX major and minor. */</span>
<span class="cp">#define CIFS_UNIX_MAJOR_VERSION 1</span>
<span class="cp">#define CIFS_UNIX_MINOR_VERSION 0</span>

<span class="cm">/* Linux/Unix extensions capability flags */</span>
<span class="cp">#define CIFS_UNIX_FCNTL_CAP             0x00000001 </span><span class="cm">/* support for fcntl locks */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_POSIX_ACL_CAP         0x00000002 </span><span class="cm">/* support getfacl/setfacl */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_XATTR_CAP             0x00000004 </span><span class="cm">/* support new namespace   */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_EXTATTR_CAP           0x00000008 </span><span class="cm">/* support chattr/chflag   */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_POSIX_PATHNAMES_CAP   0x00000010 </span><span class="cm">/* Allow POSIX path chars  */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_POSIX_PATH_OPS_CAP    0x00000020 </span><span class="cm">/* Allow new POSIX path based</span>
<span class="cm">						      calls including posix open</span>
<span class="cm">						      and posix unlink */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_LARGE_READ_CAP        0x00000040 </span><span class="cm">/* support reads &gt;128K (up</span>
<span class="cm">						      to 0xFFFF00 */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_LARGE_WRITE_CAP       0x00000080</span>
<span class="cp">#define CIFS_UNIX_TRANSPORT_ENCRYPTION_CAP 0x00000100 </span><span class="cm">/* can do SPNEGO crypt */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_TRANSPORT_ENCRYPTION_MANDATORY_CAP  0x00000200 </span><span class="cm">/* must do  */</span><span class="cp"></span>
<span class="cp">#define CIFS_UNIX_PROXY_CAP             0x00000400 </span><span class="cm">/* Proxy cap: 0xACE ioctl and</span>
<span class="cm">						      QFS PROXY call */</span><span class="cp"></span>
<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
<span class="cm">/* presumably don&#39;t need the 0x20 POSIX_PATH_OPS_CAP since we never send</span>
<span class="cm">   LockingX instead of posix locking call on unix sess (and we do not expect</span>
<span class="cm">   LockingX to use different (ie Windows) semantics than posix locking on</span>
<span class="cm">   the same session (if WINE needs to do this later, we can add this cap</span>
<span class="cm">   back in later */</span>
<span class="cm">/* #define CIFS_UNIX_CAP_MASK              0x000000fb */</span>
<span class="cp">#define CIFS_UNIX_CAP_MASK              0x000003db</span>
<span class="cp">#else</span>
<span class="cp">#define CIFS_UNIX_CAP_MASK              0x00000013</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_POSIX */</span><span class="cp"></span>


<span class="cp">#define CIFS_POSIX_EXTENSIONS           0x00000010 </span><span class="cm">/* support for new QFSInfo */</span><span class="cp"></span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="cm">/* For undefined recommended transfer size return -1 in that field */</span>
	<span class="n">__le32</span> <span class="n">OptimalTransferSize</span><span class="p">;</span>  <span class="cm">/* bsize on some os, iosize on other os */</span>
	<span class="n">__le32</span> <span class="n">BlockSize</span><span class="p">;</span>
    <span class="cm">/* The next three fields are in terms of the block size.</span>
<span class="cm">	(above). If block size is unknown, 4096 would be a</span>
<span class="cm">	reasonable block size for a server to report.</span>
<span class="cm">	Note that returning the blocks/blocksavail removes need</span>
<span class="cm">	to make a second call (to QFSInfo level 0x103 to get this info.</span>
<span class="cm">	UserBlockAvail is typically less than or equal to BlocksAvail,</span>
<span class="cm">	if no distinction is made return the same value in each */</span>
	<span class="n">__le64</span> <span class="n">TotalBlocks</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">BlocksAvail</span><span class="p">;</span>       <span class="cm">/* bfree */</span>
	<span class="n">__le64</span> <span class="n">UserBlocksAvail</span><span class="p">;</span>   <span class="cm">/* bavail */</span>
    <span class="cm">/* For undefined Node fields or FSID return -1 */</span>
	<span class="n">__le64</span> <span class="n">TotalFileNodes</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">FreeFileNodes</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">FileSysIdentifier</span><span class="p">;</span>   <span class="cm">/* fsid */</span>
	<span class="cm">/* NB Namelen comes from FILE_SYSTEM_ATTRIBUTE_INFO call */</span>
	<span class="cm">/* NB flags can come from FILE_SYSTEM_DEVICE_INFO call   */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_SYSTEM_POSIX_INFO</span><span class="p">;</span>

<span class="cm">/* DeviceType Flags */</span>
<span class="cp">#define FILE_DEVICE_CD_ROM              0x00000002</span>
<span class="cp">#define FILE_DEVICE_CD_ROM_FILE_SYSTEM  0x00000003</span>
<span class="cp">#define FILE_DEVICE_DFS                 0x00000006</span>
<span class="cp">#define FILE_DEVICE_DISK                0x00000007</span>
<span class="cp">#define FILE_DEVICE_DISK_FILE_SYSTEM    0x00000008</span>
<span class="cp">#define FILE_DEVICE_FILE_SYSTEM         0x00000009</span>
<span class="cp">#define FILE_DEVICE_NAMED_PIPE          0x00000011</span>
<span class="cp">#define FILE_DEVICE_NETWORK             0x00000012</span>
<span class="cp">#define FILE_DEVICE_NETWORK_FILE_SYSTEM 0x00000014</span>
<span class="cp">#define FILE_DEVICE_NULL                0x00000015</span>
<span class="cp">#define FILE_DEVICE_PARALLEL_PORT       0x00000016</span>
<span class="cp">#define FILE_DEVICE_PRINTER             0x00000018</span>
<span class="cp">#define FILE_DEVICE_SERIAL_PORT         0x0000001b</span>
<span class="cp">#define FILE_DEVICE_STREAMS             0x0000001e</span>
<span class="cp">#define FILE_DEVICE_TAPE                0x0000001f</span>
<span class="cp">#define FILE_DEVICE_TAPE_FILE_SYSTEM    0x00000020</span>
<span class="cp">#define FILE_DEVICE_VIRTUAL_DISK        0x00000024</span>
<span class="cp">#define FILE_DEVICE_NETWORK_REDIRECTOR  0x00000028</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">DeviceType</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DeviceCharacteristics</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_SYSTEM_DEVICE_INFO</span><span class="p">;</span> <span class="cm">/* device info level 0x104 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">Attributes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">MaxPathNameComponentLength</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileSystemNameLen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileSystemName</span><span class="p">[</span><span class="mi">52</span><span class="p">];</span> <span class="cm">/* do not have to save this - get subset? */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_SYSTEM_ATTRIBUTE_INFO</span><span class="p">;</span>

<span class="cm">/******************************************************************************/</span>
<span class="cm">/* QueryFileInfo/QueryPathinfo (also for SetPath/SetFile) data buffer formats */</span>
<span class="cm">/******************************************************************************/</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="cm">/* data block encoding of response to level 263 QPathInfo */</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Attributes</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">Pad1</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>	<span class="cm">/* size ie offset to first free byte in file */</span>
	<span class="n">__le32</span> <span class="n">NumberOfLinks</span><span class="p">;</span>	<span class="cm">/* hard links */</span>
	<span class="n">__u8</span> <span class="n">DeletePending</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">Directory</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Pad2</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IndexNumber</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">EASize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">AccessFlags</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">IndexNumber1</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">CurrentByteOffset</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Mode</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">AlignmentRequirement</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileNameLength</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_ALL_INFO</span><span class="p">;</span>	<span class="cm">/* level 0x107 QPathInfo */</span>

<span class="cm">/* defines for enumerating possible values of the Unix type field below */</span>
<span class="cp">#define UNIX_FILE      0</span>
<span class="cp">#define UNIX_DIR       1</span>
<span class="cp">#define UNIX_SYMLINK   2</span>
<span class="cp">#define UNIX_CHARDEV   3</span>
<span class="cp">#define UNIX_BLOCKDEV  4</span>
<span class="cp">#define UNIX_FIFO      5</span>
<span class="cp">#define UNIX_SOCKET    6</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">NumOfBytes</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastStatusChange</span><span class="p">;</span> <span class="cm">/*SNIA specs DCE time for the 3 time fields */</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastModificationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">Uid</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">Gid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Type</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">DevMajor</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">DevMinor</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">UniqueId</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">Permissions</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">Nlinks</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_UNIX_BASIC_INFO</span><span class="p">;</span>	<span class="cm">/* level 0x200 QPathInfo */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="n">LinkDest</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_UNIX_LINK_INFO</span><span class="p">;</span>	<span class="cm">/* level 0x201 QPathInfo */</span>

<span class="cm">/* The following three structures are needed only for</span>
<span class="cm">	setting time to NT4 and some older servers via</span>
<span class="cm">	the primitive DOS time format */</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">Day</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Month</span><span class="o">:</span><span class="mi">4</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Year</span><span class="o">:</span><span class="mi">7</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SMB_DATE</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">TwoSeconds</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Minutes</span><span class="o">:</span><span class="mi">6</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Hours</span><span class="o">:</span><span class="mi">5</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SMB_TIME</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">CreationDate</span><span class="p">;</span> <span class="cm">/* SMB Date see above */</span>
	<span class="n">__le16</span> <span class="n">CreationTime</span><span class="p">;</span> <span class="cm">/* SMB Time */</span>
	<span class="n">__le16</span> <span class="n">LastAccessDate</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastWriteDate</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataSize</span><span class="p">;</span> <span class="cm">/* File Size (EOF) */</span>
	<span class="n">__le32</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Attributes</span><span class="p">;</span> <span class="cm">/* verify not u32 */</span>
	<span class="n">__le32</span> <span class="n">EASize</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_INFO_STANDARD</span><span class="p">;</span>  <span class="cm">/* level 1 SetPath/FileInfo */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">Attributes</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">Pad</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_BASIC_INFO</span><span class="p">;</span>	<span class="cm">/* size info, level 0x101 */</span>

<span class="k">struct</span> <span class="n">file_allocation_info</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span> <span class="cm">/* Note old Samba srvr rounds this up too much */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>	<span class="cm">/* size used on disk, for level 0x103 for set,</span>
<span class="cm">				   0x105 for query */</span>

<span class="k">struct</span> <span class="n">file_end_of_file_info</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">FileSize</span><span class="p">;</span>		<span class="cm">/* offset to end of file */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span> <span class="cm">/* size info, level 0x104 for set, 0x106 for query */</span>

<span class="k">struct</span> <span class="n">file_alt_name_info</span> <span class="p">{</span>
	<span class="n">__u8</span>   <span class="n">alt_name</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>      <span class="cm">/* level 0x0108 */</span>

<span class="k">struct</span> <span class="n">file_stream_info</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">number_of_streams</span><span class="p">;</span>  <span class="cm">/* BB check sizes and verify location */</span>
	<span class="cm">/* followed by info on streams themselves</span>
<span class="cm">		u64 size;</span>
<span class="cm">		u64 allocation_size</span>
<span class="cm">		stream info */</span>
<span class="p">};</span>      <span class="cm">/* level 0x109 */</span>

<span class="k">struct</span> <span class="n">file_compression_info</span> <span class="p">{</span>
	<span class="n">__le64</span> <span class="n">compressed_size</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">format</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">unit_shift</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">ch_shift</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">cl_shift</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">pad</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>      <span class="cm">/* level 0x10b */</span>

<span class="cm">/* POSIX ACL set/query path info structures */</span>
<span class="cp">#define CIFS_ACL_VERSION 1</span>
<span class="k">struct</span> <span class="n">cifs_posix_ace</span> <span class="p">{</span> <span class="cm">/* access control entry (ACE) */</span>
	<span class="n">__u8</span>  <span class="n">cifs_e_tag</span><span class="p">;</span>
	<span class="n">__u8</span>  <span class="n">cifs_e_perm</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">cifs_uid</span><span class="p">;</span> <span class="cm">/* or gid */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">cifs_posix_acl</span> <span class="p">{</span> <span class="cm">/* access conrol list  (ACL) */</span>
	<span class="n">__le16</span>	<span class="n">version</span><span class="p">;</span>
	<span class="n">__le16</span>	<span class="n">access_entry_count</span><span class="p">;</span>  <span class="cm">/* access ACL - count of entries */</span>
	<span class="n">__le16</span>	<span class="n">default_entry_count</span><span class="p">;</span> <span class="cm">/* default ACL - count of entries */</span>
	<span class="k">struct</span> <span class="n">cifs_posix_ace</span> <span class="n">ace_array</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* followed by</span>
<span class="cm">	struct cifs_posix_ace default_ace_arraay[] */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>  <span class="cm">/* level 0x204 */</span>

<span class="cm">/* types of access control entries already defined in posix_acl.h */</span>
<span class="cm">/* #define CIFS_POSIX_ACL_USER_OBJ	 0x01</span>
<span class="cm">#define CIFS_POSIX_ACL_USER      0x02</span>
<span class="cm">#define CIFS_POSIX_ACL_GROUP_OBJ 0x04</span>
<span class="cm">#define CIFS_POSIX_ACL_GROUP     0x08</span>
<span class="cm">#define CIFS_POSIX_ACL_MASK      0x10</span>
<span class="cm">#define CIFS_POSIX_ACL_OTHER     0x20 */</span>

<span class="cm">/* types of perms */</span>
<span class="cm">/* #define CIFS_POSIX_ACL_EXECUTE   0x01</span>
<span class="cm">#define CIFS_POSIX_ACL_WRITE     0x02</span>
<span class="cm">#define CIFS_POSIX_ACL_READ	     0x04 */</span>

<span class="cm">/* end of POSIX ACL definitions */</span>

<span class="cm">/* POSIX Open Flags */</span>
<span class="cp">#define SMB_O_RDONLY 	 0x1</span>
<span class="cp">#define SMB_O_WRONLY 	0x2</span>
<span class="cp">#define SMB_O_RDWR 	0x4</span>
<span class="cp">#define SMB_O_CREAT 	0x10</span>
<span class="cp">#define SMB_O_EXCL 	0x20</span>
<span class="cp">#define SMB_O_TRUNC 	0x40</span>
<span class="cp">#define SMB_O_APPEND 	0x80</span>
<span class="cp">#define SMB_O_SYNC 	0x100</span>
<span class="cp">#define SMB_O_DIRECTORY 0x200</span>
<span class="cp">#define SMB_O_NOFOLLOW 	0x400</span>
<span class="cp">#define SMB_O_DIRECT 	0x800</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">OpenFlags</span><span class="p">;</span> <span class="cm">/* same as NT CreateX */</span>
	<span class="n">__le32</span> <span class="n">PosixOpenFlags</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">Permissions</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Level</span><span class="p">;</span> <span class="cm">/* reply level requested (see QPathInfo levels) */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">OPEN_PSX_REQ</span><span class="p">;</span> <span class="cm">/* level 0x209 SetPathInfo data */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le16</span> <span class="n">OplockFlags</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Fid</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">CreateAction</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">ReturnedLevel</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Pad</span><span class="p">;</span>
	<span class="cm">/* struct following varies based on requested level */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">OPEN_PSX_RSP</span><span class="p">;</span> <span class="cm">/* level 0x209 SetPathInfo data */</span>

<span class="cp">#define SMB_POSIX_UNLINK_FILE_TARGET		0</span>
<span class="cp">#define SMB_POSIX_UNLINK_DIRECTORY_TARGET	1</span>

<span class="k">struct</span> <span class="n">unlink_psx_rq</span> <span class="p">{</span> <span class="cm">/* level 0x20a SetPathInfo */</span>
	<span class="n">__le16</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">file_internal_info</span> <span class="p">{</span>
	<span class="n">__le64</span>  <span class="n">UniqueId</span><span class="p">;</span> <span class="cm">/* inode number */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>      <span class="cm">/* level 0x3ee */</span>

<span class="k">struct</span> <span class="n">file_mode_info</span> <span class="p">{</span>
	<span class="n">__le32</span>	<span class="n">Mode</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>      <span class="cm">/* level 0x3f8 */</span>

<span class="k">struct</span> <span class="n">file_attrib_tag</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">Attribute</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ReparseTag</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>      <span class="cm">/* level 0x40b */</span>


<span class="cm">/********************************************************/</span>
<span class="cm">/*  FindFirst/FindNext transact2 data buffer formats    */</span>
<span class="cm">/********************************************************/</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">NextEntryOffset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">ResumeKey</span><span class="p">;</span> <span class="cm">/* as with FileIndex - no need to convert */</span>
	<span class="n">FILE_UNIX_BASIC_INFO</span> <span class="n">basic</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_UNIX_INFO</span><span class="p">;</span> <span class="cm">/* level 0x202 */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">NextEntryOffset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">FileIndex</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ExtFileAttributes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileNameLength</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_DIRECTORY_INFO</span><span class="p">;</span>   <span class="cm">/* level 0x101 FF resp data */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">NextEntryOffset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">FileIndex</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ExtFileAttributes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileNameLength</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">EaSize</span><span class="p">;</span> <span class="cm">/* length of the xattrs */</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_FULL_DIRECTORY_INFO</span><span class="p">;</span> <span class="cm">/* level 0x102 rsp data */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">NextEntryOffset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">FileIndex</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ExtFileAttributes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileNameLength</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">EaSize</span><span class="p">;</span> <span class="cm">/* EA size */</span>
	<span class="n">__le32</span> <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">UniqueId</span><span class="p">;</span> <span class="cm">/* inode num - le since Samba puts ino in low 32 bit*/</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">SEARCH_ID_FULL_DIR_INFO</span><span class="p">;</span> <span class="cm">/* level 0x105 FF rsp data */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">NextEntryOffset</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">FileIndex</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">CreationTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">ChangeTime</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">EndOfFile</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">ExtFileAttributes</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">FileNameLength</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">EaSize</span><span class="p">;</span> <span class="cm">/* length of the xattrs */</span>
	<span class="n">__u8</span>   <span class="n">ShortNameLength</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">Reserved</span><span class="p">;</span>
	<span class="n">__u8</span>   <span class="n">ShortName</span><span class="p">[</span><span class="mi">12</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_BOTH_DIRECTORY_INFO</span><span class="p">;</span> <span class="cm">/* level 0x104 FFrsp data */</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">__u32</span>  <span class="n">ResumeKey</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">CreationDate</span><span class="p">;</span> <span class="cm">/* SMB Date */</span>
	<span class="n">__le16</span> <span class="n">CreationTime</span><span class="p">;</span> <span class="cm">/* SMB Time */</span>
	<span class="n">__le16</span> <span class="n">LastAccessDate</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastAccessTime</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastWriteDate</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">LastWriteTime</span><span class="p">;</span>
	<span class="n">__le32</span> <span class="n">DataSize</span><span class="p">;</span> <span class="cm">/* File Size (EOF) */</span>
	<span class="n">__le32</span> <span class="n">AllocationSize</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Attributes</span><span class="p">;</span> <span class="cm">/* verify not u32 */</span>
	<span class="n">__u8</span>   <span class="n">FileNameLength</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">FileName</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FIND_FILE_STANDARD_INFO</span><span class="p">;</span> <span class="cm">/* level 0x1 FF resp data */</span>


<span class="k">struct</span> <span class="n">win_dev</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">type</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span> <span class="cm">/* IntxCHR or IntxBLK */</span>
	<span class="n">__le64</span> <span class="n">major</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">minor</span><span class="p">;</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">gea</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">gealist</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">list_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">gea</span> <span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">struct</span> <span class="n">fea</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">EA_flags</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">value_len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="cm">/* optionally followed by value */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>
<span class="cm">/* flags for _FEA.fEA */</span>
<span class="cp">#define FEA_NEEDEA         0x80	</span><span class="cm">/* need EA bit */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">fealist</span> <span class="p">{</span>
	<span class="n">__le32</span> <span class="n">list_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fea</span> <span class="n">list</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="cm">/* used to hold an arbitrary blob of data */</span>
<span class="k">struct</span> <span class="n">data_blob</span> <span class="p">{</span>
	<span class="n">__u8</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">length</span><span class="p">;</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">free</span><span class="p">)</span> <span class="p">(</span><span class="k">struct</span> <span class="n">data_blob</span> <span class="o">*</span><span class="n">data_blob</span><span class="p">);</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>


<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
<span class="cm">/*</span>
<span class="cm">	For better POSIX semantics from Linux client, (even better</span>
<span class="cm">	than the existing CIFS Unix Extensions) we need updated PDUs for:</span>

<span class="cm">	1) PosixCreateX - to set and return the mode, inode#, device info and</span>
<span class="cm">	perhaps add a CreateDevice - to create Pipes and other special .inodes</span>
<span class="cm">	Also note POSIX open flags</span>
<span class="cm">	2) Close - to return the last write time to do cache across close</span>
<span class="cm">		more safely</span>
<span class="cm">	3) FindFirst return unique inode number - what about resume key, two</span>
<span class="cm">	forms short (matches readdir) and full (enough info to cache inodes)</span>
<span class="cm">	4) Mkdir - set mode</span>

<span class="cm">	And under consideration:</span>
<span class="cm">	5) FindClose2 (return nanosecond timestamp ??)</span>
<span class="cm">	6) Use nanosecond timestamps throughout all time fields if</span>
<span class="cm">	   corresponding attribute flag is set</span>
<span class="cm">	7) sendfile - handle based copy</span>

<span class="cm">	what about fixing 64 bit alignment</span>

<span class="cm">	There are also various legacy SMB/CIFS requests used as is</span>

<span class="cm">	From existing Lanman and NTLM dialects:</span>
<span class="cm">	--------------------------------------</span>
<span class="cm">	NEGOTIATE</span>
<span class="cm">	SESSION_SETUP_ANDX (BB which?)</span>
<span class="cm">	TREE_CONNECT_ANDX (BB which wct?)</span>
<span class="cm">	TREE_DISCONNECT (BB add volume timestamp on response)</span>
<span class="cm">	LOGOFF_ANDX</span>
<span class="cm">	DELETE (note delete open file behavior)</span>
<span class="cm">	DELETE_DIRECTORY</span>
<span class="cm">	READ_AND_X</span>
<span class="cm">	WRITE_AND_X</span>
<span class="cm">	LOCKING_AND_X (note posix lock semantics)</span>
<span class="cm">	RENAME (note rename across dirs and open file rename posix behaviors)</span>
<span class="cm">	NT_RENAME (for hardlinks) Is this good enough for all features?</span>
<span class="cm">	FIND_CLOSE2</span>
<span class="cm">	TRANSACTION2 (18 cases)</span>
<span class="cm">		SMB_SET_FILE_END_OF_FILE_INFO2 SMB_SET_PATH_END_OF_FILE_INFO2</span>
<span class="cm">		(BB verify that never need to set allocation size)</span>
<span class="cm">		SMB_SET_FILE_BASIC_INFO2 (setting times - BB can it be done via</span>
<span class="cm">			 Unix ext?)</span>

<span class="cm">	COPY (note support for copy across directories) - FUTURE, OPTIONAL</span>
<span class="cm">	setting/getting OS/2 EAs - FUTURE (BB can this handle</span>
<span class="cm">	setting Linux xattrs perfectly)         - OPTIONAL</span>
<span class="cm">	dnotify                                 - FUTURE, OPTIONAL</span>
<span class="cm">	quota                                   - FUTURE, OPTIONAL</span>

<span class="cm">	Note that various requests implemented for NT interop such as</span>
<span class="cm">		NT_TRANSACT (IOCTL) QueryReparseInfo</span>
<span class="cm">	are unneeded to servers compliant with the CIFS POSIX extensions</span>

<span class="cm">	From CIFS Unix Extensions:</span>
<span class="cm">	-------------------------</span>
<span class="cm">	T2 SET_PATH_INFO (SMB_SET_FILE_UNIX_LINK) for symlinks</span>
<span class="cm">	T2 SET_PATH_INFO (SMB_SET_FILE_BASIC_INFO2)</span>
<span class="cm">	T2 QUERY_PATH_INFO (SMB_QUERY_FILE_UNIX_LINK)</span>
<span class="cm">	T2 QUERY_PATH_INFO (SMB_QUERY_FILE_UNIX_BASIC)	BB check for missing</span>
<span class="cm">							inode fields</span>
<span class="cm">				Actually a need QUERY_FILE_UNIX_INFO</span>
<span class="cm">				since has inode num</span>
<span class="cm">				BB what about a) blksize/blkbits/blocks</span>
<span class="cm">							  b) i_version</span>
<span class="cm">							  c) i_rdev</span>
<span class="cm">							  d) notify mask?</span>
<span class="cm">							  e) generation</span>
<span class="cm">							  f) size_seqcount</span>
<span class="cm">	T2 FIND_FIRST/FIND_NEXT FIND_FILE_UNIX</span>
<span class="cm">	TRANS2_GET_DFS_REFERRAL		      - OPTIONAL but recommended</span>
<span class="cm">	T2_QFS_INFO QueryDevice/AttributeInfo - OPTIONAL</span>
<span class="cm"> */</span>

<span class="cm">/* xsymlink is a symlink format (used by MacOS) that can be used</span>
<span class="cm">   to save symlink info in a regular file when</span>
<span class="cm">   mounted to operating systems that do not</span>
<span class="cm">   support the cifs Unix extensions or EAs (for xattr</span>
<span class="cm">   based symlinks).  For such a file to be recognized</span>
<span class="cm">   as containing symlink data:</span>

<span class="cm">   1) file size must be 1067,</span>
<span class="cm">   2) signature must begin file data,</span>
<span class="cm">   3) length field must be set to ASCII representation</span>
<span class="cm">	of a number which is less than or equal to 1024,</span>
<span class="cm">   4) md5 must match that of the path data */</span>

<span class="k">struct</span> <span class="n">xsymlink</span> <span class="p">{</span>
	<span class="cm">/* 1067 bytes */</span>
	<span class="kt">char</span> <span class="n">signature</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span> <span class="cm">/* XSym */</span> <span class="cm">/* not null terminated */</span>
	<span class="kt">char</span> <span class="n">cr0</span><span class="p">;</span>         <span class="cm">/* \n */</span>
<span class="cm">/* ASCII representation of length (4 bytes decimal) terminated by \n not null */</span>
	<span class="kt">char</span> <span class="n">length</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">cr1</span><span class="p">;</span>         <span class="cm">/* \n */</span>
<span class="cm">/* md5 of valid subset of path ie path[0] through path[length-1] */</span>
	<span class="n">__u8</span> <span class="n">md5</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">cr2</span><span class="p">;</span>        <span class="cm">/* \n */</span>
<span class="cm">/* if room left, then end with \n then 0x20s by convention but not required */</span>
	<span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">));</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">file_xattr_info</span> <span class="p">{</span>
	<span class="cm">/* BB do we need another field for flags? BB */</span>
	<span class="n">__u32</span> <span class="n">xattr_name_len</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">xattr_value_len</span><span class="p">;</span>
	<span class="kt">char</span>  <span class="n">xattr_name</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* followed by xattr_value[xattr_value_len], no pad */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_XATTR_INFO</span><span class="p">;</span> <span class="cm">/* extended attribute info</span>
<span class="cm">					      level 0x205 */</span>


<span class="cm">/* flags for chattr command */</span>
<span class="cp">#define EXT_SECURE_DELETE		0x00000001 </span><span class="cm">/* EXT3_SECRM_FL */</span><span class="cp"></span>
<span class="cp">#define EXT_ENABLE_UNDELETE		0x00000002 </span><span class="cm">/* EXT3_UNRM_FL */</span><span class="cp"></span>
<span class="cm">/* Reserved for compress file 0x4 */</span>
<span class="cp">#define EXT_SYNCHRONOUS			0x00000008 </span><span class="cm">/* EXT3_SYNC_FL */</span><span class="cp"></span>
<span class="cp">#define EXT_IMMUTABLE_FL		0x00000010 </span><span class="cm">/* EXT3_IMMUTABLE_FL */</span><span class="cp"></span>
<span class="cp">#define EXT_OPEN_APPEND_ONLY		0x00000020 </span><span class="cm">/* EXT3_APPEND_FL */</span><span class="cp"></span>
<span class="cp">#define EXT_DO_NOT_BACKUP		0x00000040 </span><span class="cm">/* EXT3_NODUMP_FL */</span><span class="cp"></span>
<span class="cp">#define EXT_NO_UPDATE_ATIME		0x00000080 </span><span class="cm">/* EXT3_NOATIME_FL */</span><span class="cp"></span>
<span class="cm">/* 0x100 through 0x800 reserved for compression flags and are GET-ONLY */</span>
<span class="cp">#define EXT_HASH_TREE_INDEXED_DIR	0x00001000 </span><span class="cm">/* GET-ONLY EXT3_INDEX_FL */</span><span class="cp"></span>
<span class="cm">/* 0x2000 reserved for IMAGIC_FL */</span>
<span class="cp">#define EXT_JOURNAL_THIS_FILE	0x00004000 </span><span class="cm">/* GET-ONLY EXT3_JOURNAL_DATA_FL */</span><span class="cp"></span>
<span class="cm">/* 0x8000 reserved for EXT3_NOTAIL_FL */</span>
<span class="cp">#define EXT_SYNCHRONOUS_DIR		0x00010000 </span><span class="cm">/* EXT3_DIRSYNC_FL */</span><span class="cp"></span>
<span class="cp">#define EXT_TOPDIR			0x00020000 </span><span class="cm">/* EXT3_TOPDIR_FL */</span><span class="cp"></span>

<span class="cp">#define EXT_SET_MASK			0x000300FF</span>
<span class="cp">#define EXT_GET_MASK			0x0003DFFF</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="n">file_chattr_info</span> <span class="p">{</span>
	<span class="n">__le64</span>	<span class="n">mask</span><span class="p">;</span> <span class="cm">/* list of all possible attribute bits */</span>
	<span class="n">__le64</span>	<span class="n">mode</span><span class="p">;</span> <span class="cm">/* list of actual attribute bits on this inode */</span>
<span class="p">}</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">FILE_CHATTR_INFO</span><span class="p">;</span>  <span class="cm">/* ext attributes</span>
<span class="cm">						(chattr, chflags) level 0x206 */</span>
<span class="cp">#endif 				</span><span class="cm">/* POSIX */</span><span class="cp"></span>
<span class="cp">#endif				</span><span class="cm">/* _CIFSPDU_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
