<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cifs › dir.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dir.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   fs/cifs/dir.c</span>
<span class="cm"> *</span>
<span class="cm"> *   vfs operations that deal with dentries</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright (C) International Business Machines  Corp., 2002,2009</span>
<span class="cm"> *   Author(s): Steve French (sfrench@us.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU Lesser General Public License as published</span>
<span class="cm"> *   by the Free Software Foundation; either version 2.1 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> *   along with this library; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &quot;cifsfs.h&quot;</span>
<span class="cp">#include &quot;cifspdu.h&quot;</span>
<span class="cp">#include &quot;cifsglob.h&quot;</span>
<span class="cp">#include &quot;cifsproto.h&quot;</span>
<span class="cp">#include &quot;cifs_debug.h&quot;</span>
<span class="cp">#include &quot;cifs_fs_sb.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">renew_parental_timestamps</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">direntry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* BB check if there is a way to get the kernel to do this or if we</span>
<span class="cm">	   really need this */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">direntry</span> <span class="o">=</span> <span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">direntry</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/* Note: caller must free return buffer */</span>
<span class="kt">char</span> <span class="o">*</span>
<span class="nf">build_path_from_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">direntry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">temp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dfsplen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">dirsep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">seq</span><span class="p">;</span>

	<span class="n">dirsep</span> <span class="o">=</span> <span class="n">CIFS_DIR_SEP</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SMB_SHARE_IS_IN_DFS</span><span class="p">)</span>
		<span class="n">dfsplen</span> <span class="o">=</span> <span class="n">strnlen</span><span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">treeName</span><span class="p">,</span> <span class="n">MAX_TREE_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dfsplen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">cifs_bp_rename_retry:</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">dfsplen</span><span class="p">;</span>
	<span class="n">seq</span> <span class="o">=</span> <span class="n">read_seqbegin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">);</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="n">direntry</span><span class="p">;</span> <span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">temp</span><span class="p">);)</span> <span class="p">{</span>
		<span class="n">namelen</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;corrupt dentry&quot;</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="n">full_path</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">namelen</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">full_path</span><span class="p">;</span>
	<span class="n">full_path</span><span class="p">[</span><span class="n">namelen</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* trailing null */</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">temp</span> <span class="o">=</span> <span class="n">direntry</span><span class="p">;</span> <span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">temp</span><span class="p">);)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">namelen</span> <span class="o">-=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">full_path</span><span class="p">[</span><span class="n">namelen</span><span class="p">]</span> <span class="o">=</span> <span class="n">dirsep</span><span class="p">;</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">full_path</span> <span class="o">+</span> <span class="n">namelen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;name: %s&quot;</span><span class="p">,</span> <span class="n">full_path</span> <span class="o">+</span> <span class="n">namelen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">temp</span> <span class="o">=</span> <span class="n">temp</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">temp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;corrupt dentry&quot;</span><span class="p">);</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">namelen</span> <span class="o">!=</span> <span class="n">dfsplen</span> <span class="o">||</span> <span class="n">read_seqretry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rename_lock</span><span class="p">,</span> <span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;did not end path lookup where expected. namelen=%d &quot;</span>
			<span class="s">&quot;dfsplen=%d&quot;</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">dfsplen</span><span class="p">);</span>
		<span class="cm">/* presumably this is only possible if racing with a rename</span>
<span class="cm">		of one of the parent directories  (we can not lock the dentries</span>
<span class="cm">		above us to prevent this, but retrying should be harmless) */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cifs_bp_rename_retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* DIR_SEP already set for byte  0 / vs \ but not for</span>
<span class="cm">	   subsequent slashes in prepath which currently must</span>
<span class="cm">	   be entered the right way - not sure if there is an alternative</span>
<span class="cm">	   since the &#39;\&#39; is a valid posix character so we can not switch</span>
<span class="cm">	   those safely to &#39;/&#39; if any are found in the middle of the prepath */</span>
	<span class="cm">/* BB test paths to Windows with &#39;/&#39; in the midst of prepath */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dfsplen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">treeName</span><span class="p">,</span> <span class="n">dfsplen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_POSIX_PATHS</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dfsplen</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span><span class="p">)</span>
					<span class="n">full_path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">full_path</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Inode operations in similar order to how they appear in Linux file fs.h */</span>

<span class="kt">int</span>
<span class="nf">cifs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">direntry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">create_options</span> <span class="o">=</span> <span class="n">CREATE_NOT_DIR</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">oplock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oflags</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * BB below access is probably too much for mknod to request</span>
<span class="cm">	 *    but we have to do query and setpathinfo so requesting</span>
<span class="cm">	 *    less could fail (unless we want to request getatr and setatr</span>
<span class="cm">	 *    permissions (only).  At least for POSIX we do not have to</span>
<span class="cm">	 *    request so much.</span>
<span class="cm">	 */</span>
	<span class="kt">int</span> <span class="n">desiredAccess</span> <span class="o">=</span> <span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">fileHandle</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">FILE_ALL_INFO</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">newinode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disposition</span> <span class="o">=</span> <span class="n">FILE_OVERWRITE_IF</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">tlink</span> <span class="o">=</span> <span class="n">cifs_sb_tlink</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">oplocks</span><span class="p">)</span>
		<span class="n">oplock</span> <span class="o">=</span> <span class="n">REQ_OPLOCK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">)</span>
		<span class="n">oflags</span> <span class="o">=</span> <span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">oflags</span> <span class="o">=</span> <span class="n">O_RDONLY</span> <span class="o">|</span> <span class="n">O_CREAT</span><span class="p">;</span>

	<span class="n">full_path</span> <span class="o">=</span> <span class="n">build_path_from_dentry</span><span class="p">(</span><span class="n">direntry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cifs_create_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_UNIX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">CIFS_UNIX_POSIX_PATH_OPS_CAP</span> <span class="o">&amp;</span>
			<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">fsUnixInfo</span><span class="p">.</span><span class="n">Capability</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_posix_open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newinode</span><span class="p">,</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">oflags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileHandle</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="cm">/* EIO could indicate that (posix open) operation is not</span>
<span class="cm">		   supported, despite what server claimed in capability</span>
<span class="cm">		   negotiation.  EREMOTE indicates DFS junction, which is not</span>
<span class="cm">		   handled in posix open */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newinode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="cm">/* query inode info */</span>
				<span class="k">goto</span> <span class="n">cifs_create_get_file_info</span><span class="p">;</span>
			<span class="k">else</span> <span class="cm">/* success, no need to query */</span>
				<span class="k">goto</span> <span class="n">cifs_create_set_dentry</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EREMOTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">cifs_create_out</span><span class="p">;</span>
		<span class="cm">/* else fallthrough to retry, using older open call, this is</span>
<span class="cm">		   case where server does not support this SMB level, and</span>
<span class="cm">		   falsely claims capability (also get here for DFS case</span>
<span class="cm">		   which should be rare for path not covered on files) */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* if the file is going to stay open, then we</span>
<span class="cm">		   need to set the desired access properly */</span>
		<span class="n">desiredAccess</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPEN_FMODE</span><span class="p">(</span><span class="n">oflags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
			<span class="n">desiredAccess</span> <span class="o">|=</span> <span class="n">GENERIC_READ</span><span class="p">;</span> <span class="cm">/* is this too little? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPEN_FMODE</span><span class="p">(</span><span class="n">oflags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
			<span class="n">desiredAccess</span> <span class="o">|=</span> <span class="n">GENERIC_WRITE</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">oflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">))</span>
			<span class="n">disposition</span> <span class="o">=</span> <span class="n">FILE_CREATE</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">oflags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">))</span>
			<span class="n">disposition</span> <span class="o">=</span> <span class="n">FILE_OVERWRITE_IF</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">oflags</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_CREAT</span><span class="p">)</span>
			<span class="n">disposition</span> <span class="o">=</span> <span class="n">FILE_OPEN_IF</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Create flag not set in create function&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* BB add processing to set equivalent of mode - e.g. via CreateX with</span>
<span class="cm">	   ACLs */</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FILE_ALL_INFO</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">cifs_create_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we&#39;re not using unix extensions, see if we need to set</span>
<span class="cm">	 * ATTR_READONLY on the create call</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">S_IWUGO</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">create_options</span> <span class="o">|=</span> <span class="n">CREATE_OPTION_READONLY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">backup_cred</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">))</span>
		<span class="n">create_options</span> <span class="o">|=</span> <span class="n">CREATE_OPEN_BACKUP_INTENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_NT_SMBS</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBOpen</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">disposition</span><span class="p">,</span>
			 <span class="n">desiredAccess</span><span class="p">,</span> <span class="n">create_options</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">fileHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span>
			 <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span> <span class="cm">/* no NT SMB support fall into legacy open below */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* old server, retry the open legacy style */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SMBLegacyOpen</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">disposition</span><span class="p">,</span>
			<span class="n">desiredAccess</span><span class="p">,</span> <span class="n">create_options</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">fileHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span>
			<span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_create returned 0x%x&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">cifs_create_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If Open reported that we actually created a file</span>
<span class="cm">	   then we now have to set the mode if possible */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">oplock</span> <span class="o">&amp;</span> <span class="n">CIFS_CREATE_ACTION</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cifs_unix_set_info_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
				<span class="p">.</span><span class="n">mode</span>	<span class="o">=</span> <span class="n">mode</span><span class="p">,</span>
				<span class="p">.</span><span class="n">ctime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
				<span class="p">.</span><span class="n">atime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
				<span class="p">.</span><span class="n">mtime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
				<span class="p">.</span><span class="n">device</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SET_UID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span> <span class="n">current_fsuid</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_ISGID</span><span class="p">)</span>
				<span class="n">args</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">args</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span> <span class="n">current_fsgid</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">args</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">;</span>
			<span class="n">args</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">CIFSSMBUnixSetFileInfo</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">,</span>
					<span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* BB implement mode setting via Windows security</span>
<span class="cm">		   descriptors e.g. */</span>
		<span class="cm">/* CIFSSMBWinSetPerms(xid,tcon,path,mode,-1,-1,nls);*/</span>

		<span class="cm">/* Could set r/o dos attribute if mode &amp; 0222 == 0 */</span>
	<span class="p">}</span>

<span class="nl">cifs_create_get_file_info:</span>
	<span class="cm">/* server might mask mode so we have to query for it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info_unix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newinode</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span>
					      <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newinode</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
					 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileHandle</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newinode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_DYNPERM</span><span class="p">)</span>
				<span class="n">newinode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">oplock</span> <span class="o">&amp;</span> <span class="n">CIFS_CREATE_ACTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SET_UID</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">newinode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_ISGID</span><span class="p">)</span>
					<span class="n">newinode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="n">newinode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">current_fsgid</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">cifs_create_set_dentry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">direntry</span><span class="p">,</span> <span class="n">newinode</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Create worked, get_inode_info failed rc = %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newinode</span> <span class="o">&amp;&amp;</span> <span class="n">nd</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">pfile_info</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>

		<span class="n">filp</span> <span class="o">=</span> <span class="n">lookup_instantiate_filp</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">direntry</span><span class="p">,</span> <span class="n">generic_file_open</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
			<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cifs_create_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pfile_info</span> <span class="o">=</span> <span class="n">cifs_new_fileinfo</span><span class="p">(</span><span class="n">fileHandle</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">tlink</span><span class="p">,</span> <span class="n">oplock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pfile_info</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
			<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">cifs_create_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
	<span class="n">cifs_put_tlink</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">direntry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span>
		<span class="n">dev_t</span> <span class="n">device_number</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">create_options</span> <span class="o">=</span> <span class="n">CREATE_NOT_DIR</span> <span class="o">|</span> <span class="n">CREATE_OPTION_SPECIAL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">pTcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_io_parms</span> <span class="n">io_parms</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">newinode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">oplock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u16</span> <span class="n">fileHandle</span><span class="p">;</span>
	<span class="n">FILE_ALL_INFO</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_written</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">win_dev</span> <span class="o">*</span><span class="n">pdev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_valid_dev</span><span class="p">(</span><span class="n">device_number</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">tlink</span> <span class="o">=</span> <span class="n">cifs_sb_tlink</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>

	<span class="n">pTcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">full_path</span> <span class="o">=</span> <span class="n">build_path_from_dentry</span><span class="p">(</span><span class="n">direntry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">mknod_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pTcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cifs_unix_set_info_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">mode</span>	<span class="o">=</span> <span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">(),</span>
			<span class="p">.</span><span class="n">ctime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">atime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">mtime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">device</span>	<span class="o">=</span> <span class="n">device_number</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SET_UID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">args</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span> <span class="n">current_fsuid</span><span class="p">();</span>
			<span class="n">args</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span> <span class="n">current_fsgid</span><span class="p">();</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">args</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">;</span>
			<span class="n">args</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBUnixSetPathInfo</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">pTcon</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span>
					    <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span>
					    <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span>
						<span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">mknod_out</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info_unix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newinode</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span>
						<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">d_instantiate</span><span class="p">(</span><span class="n">direntry</span><span class="p">,</span> <span class="n">newinode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">mknod_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_UNX_EMUL</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">mknod_out</span><span class="p">;</span>


	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;sfu compat create special file&quot;</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FILE_ALL_INFO</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">backup_cred</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">))</span>
		<span class="n">create_options</span> <span class="o">|=</span> <span class="n">CREATE_OPEN_BACKUP_INTENT</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBOpen</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">pTcon</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">FILE_CREATE</span><span class="p">,</span>
			 <span class="n">GENERIC_WRITE</span><span class="p">,</span> <span class="n">create_options</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">fileHandle</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span>
			 <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">mknod_out</span><span class="p">;</span>

	<span class="cm">/* BB Do not bother to decode buf since no local inode yet to put</span>
<span class="cm">	 * timestamps in, but we can reuse it safely */</span>

	<span class="n">pdev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">win_dev</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">io_parms</span><span class="p">.</span><span class="n">netfid</span> <span class="o">=</span> <span class="n">fileHandle</span><span class="p">;</span>
	<span class="n">io_parms</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">io_parms</span><span class="p">.</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">pTcon</span><span class="p">;</span>
	<span class="n">io_parms</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">io_parms</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">win_dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;IntxCHR&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span>
		      <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">device_number</span><span class="p">));</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span>
		      <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">device_number</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBWrite</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_parms</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">bytes_written</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pdev</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">pdev</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="s">&quot;IntxBLK&quot;</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">major</span> <span class="o">=</span>
		      <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">MAJOR</span><span class="p">(</span><span class="n">device_number</span><span class="p">));</span>
		<span class="n">pdev</span><span class="o">-&gt;</span><span class="n">minor</span> <span class="o">=</span>
		      <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">MINOR</span><span class="p">(</span><span class="n">device_number</span><span class="p">));</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBWrite</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_parms</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">bytes_written</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">pdev</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* else if (S_ISFIFO) */</span>
	<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">pTcon</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">);</span>
	<span class="n">d_drop</span><span class="p">(</span><span class="n">direntry</span><span class="p">);</span>

	<span class="cm">/* FIXME: add code here to set EAs */</span>

<span class="nl">mknod_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="n">cifs_put_tlink</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">cifs_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent_dir_inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">direntry</span><span class="p">,</span>
	    <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* to get around spurious gcc warning, set to zero here */</span>
	<span class="n">__u32</span> <span class="n">oplock</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">fileHandle</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">posix_open</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">pTcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">newInode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;parent inode = 0x%p name is: %s and dentry = 0x%p&quot;</span><span class="p">,</span>
	      <span class="n">parent_dir_inode</span><span class="p">,</span> <span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">direntry</span><span class="p">);</span>

	<span class="cm">/* check whether path exists */</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">parent_dir_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">tlink</span> <span class="o">=</span> <span class="n">cifs_sb_tlink</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">)</span><span class="n">tlink</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pTcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>

	<span class="n">oplock</span> <span class="o">=</span> <span class="n">pTcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">oplocks</span> <span class="o">?</span> <span class="n">REQ_OPLOCK</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t allow the separator character in a path component.</span>
<span class="cm">	 * The VFS will not allow &quot;/&quot;, but &quot;\&quot; is allowed by posix.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_POSIX_PATHS</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\\&#39;</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Invalid file name&quot;</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">lookup_out</span><span class="p">;</span>
			<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * O_EXCL: optimize away the lookup, but don&#39;t hash the dentry. Let</span>
<span class="cm">	 * the VFS handle the create.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_EXCL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">direntry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lookup_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* can not grab the rename sem here since it would</span>
<span class="cm">	deadlock in the cases (beginning of sys_rename itself)</span>
<span class="cm">	in which we already have the sb rename sem */</span>
	<span class="n">full_path</span> <span class="o">=</span> <span class="n">build_path_from_dentry</span><span class="p">(</span><span class="n">direntry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">lookup_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;non-NULL inode in lookup&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;NULL inode in lookup&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Full path: %s inode = 0x%p&quot;</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="cm">/* Posix open is only called (at lookup time) for file create now.</span>
<span class="cm">	 * For opens (rather than creates), because we do not know if it</span>
<span class="cm">	 * is a file or directory yet, and current Samba no longer allows</span>
<span class="cm">	 * us to do posix open on dirs, we could end up wasting an open call</span>
<span class="cm">	 * on what turns out to be a dir. For file opens, we wait to call posix</span>
<span class="cm">	 * open till cifs_open.  It could be added here (lookup) in the future</span>
<span class="cm">	 * but the performance tradeoff of the extra network request when EISDIR</span>
<span class="cm">	 * or EACCES is returned would have to be weighed against the 50%</span>
<span class="cm">	 * reduction in network traffic in the other paths.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pTcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_DIRECTORY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_OPEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">pTcon</span><span class="o">-&gt;</span><span class="n">broken_posix_open</span> <span class="o">&amp;&amp;</span>
		     <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_posix_open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newInode</span><span class="p">,</span>
					<span class="n">parent_dir_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					<span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">create_mode</span><span class="p">,</span>
					<span class="n">nd</span><span class="o">-&gt;</span><span class="n">intent</span><span class="p">.</span><span class="n">open</span><span class="p">.</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">fileHandle</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * The check below works around a bug in POSIX</span>
<span class="cm">			 * open in samba versions 3.3.1 and earlier where</span>
<span class="cm">			 * open could incorrectly fail with invalid parameter.</span>
<span class="cm">			 * If either that or op not supported returned, follow</span>
<span class="cm">			 * the normal lookup.</span>
<span class="cm">			 */</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="cm">/*</span>
<span class="cm">				 * The server may allow us to open things like</span>
<span class="cm">				 * FIFOs, but the client isn&#39;t set up to deal</span>
<span class="cm">				 * with that. If it&#39;s not a regular file, just</span>
<span class="cm">				 * close it and proceed as if it were a normal</span>
<span class="cm">				 * lookup.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">newInode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">newInode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">pTcon</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">ENOENT</span>:
				<span class="n">posix_open</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">case</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span>:
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">pTcon</span><span class="o">-&gt;</span><span class="n">broken_posix_open</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">posix_open</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info_unix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newInode</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span>
						<span class="n">parent_dir_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newInode</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="n">parent_dir_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">newInode</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">direntry</span><span class="p">,</span> <span class="n">newInode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">posix_open</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">filp</span> <span class="o">=</span> <span class="n">lookup_instantiate_filp</span><span class="p">(</span><span class="n">nd</span><span class="p">,</span> <span class="n">direntry</span><span class="p">,</span>
						       <span class="n">generic_file_open</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
				<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">pTcon</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">lookup_out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">cfile</span> <span class="o">=</span> <span class="n">cifs_new_fileinfo</span><span class="p">(</span><span class="n">fileHandle</span><span class="p">,</span> <span class="n">filp</span><span class="p">,</span> <span class="n">tlink</span><span class="p">,</span>
						  <span class="n">oplock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cfile</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">fput</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
				<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">pTcon</span><span class="p">,</span> <span class="n">fileHandle</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">lookup_out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* since paths are not looked up by component - the parent</span>
<span class="cm">		   directories are presumed to be good here */</span>
		<span class="n">renew_parental_timestamps</span><span class="p">(</span><span class="n">direntry</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
		<span class="n">d_add</span><span class="p">(</span><span class="n">direntry</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="cm">/*	if it was once a directory (but how can we tell?) we could do</span>
<span class="cm">		shrink_dcache_parent(direntry); */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Unexpected lookup error %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="cm">/* We special case check for Access Denied - since that</span>
<span class="cm">		is a common return code */</span>
	<span class="p">}</span>

<span class="nl">lookup_out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
	<span class="n">cifs_put_tlink</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_d_revalidate</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">direntry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">LOOKUP_RCU</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ECHILD</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cifs_revalidate_dentry</span><span class="p">(</span><span class="n">direntry</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If the inode wasn&#39;t known to be a dfs entry when</span>
<span class="cm">			 * the dentry was instantiated, such as when created</span>
<span class="cm">			 * via -&gt;readdir(), it needs to be set now since the</span>
<span class="cm">			 * attributes will have been updated by</span>
<span class="cm">			 * cifs_revalidate_dentry().</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_AUTOMOUNT</span><span class="p">(</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="p">(</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
				<span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">|=</span> <span class="n">DCACHE_NEED_AUTOMOUNT</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This may be nfsd (or something), anyway, we can&#39;t see the</span>
<span class="cm">	 * intent of this. So, since this can be for creation, drop it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nd</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Drop the negative dentry, in order to make sure to use the</span>
<span class="cm">	 * case sensitive name which is specified by user if this is</span>
<span class="cm">	 * for creation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">LOOKUP_CREATE</span> <span class="o">|</span> <span class="n">LOOKUP_RENAME_TARGET</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_after</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">direntry</span><span class="o">-&gt;</span><span class="n">d_time</span> <span class="o">+</span> <span class="n">HZ</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">lookupCacheEnabled</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* static int cifs_d_delete(struct dentry *direntry)</span>
<span class="cm">{</span>
<span class="cm">	int rc = 0;</span>

<span class="cm">	cFYI(1, &quot;In cifs d_delete, name = %s&quot;, direntry-&gt;d_name.name);</span>

<span class="cm">	return rc;</span>
<span class="cm">}     */</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">cifs_dentry_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_revalidate</span> <span class="o">=</span> <span class="n">cifs_d_revalidate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_automount</span> <span class="o">=</span> <span class="n">cifs_dfs_d_automount</span><span class="p">,</span>
<span class="cm">/* d_delete:       cifs_d_delete,      */</span> <span class="cm">/* not needed except for debugging */</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_ci_hash</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">q</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">codepage</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">hash</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">hash</span> <span class="o">=</span> <span class="n">init_name_hash</span><span class="p">();</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">hash</span> <span class="o">=</span> <span class="n">partial_name_hash</span><span class="p">(</span><span class="n">nls_tolower</span><span class="p">(</span><span class="n">codepage</span><span class="p">,</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
					 <span class="n">hash</span><span class="p">);</span>
	<span class="n">q</span><span class="o">-&gt;</span><span class="n">hash</span> <span class="o">=</span> <span class="n">end_name_hash</span><span class="p">(</span><span class="n">hash</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_ci_compare</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">pinode</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">codepage</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">pinode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">name</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">nls_strnicmp</span><span class="p">(</span><span class="n">codepage</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">str</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">cifs_ci_dentry_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_revalidate</span> <span class="o">=</span> <span class="n">cifs_d_revalidate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_hash</span> <span class="o">=</span> <span class="n">cifs_ci_hash</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_compare</span> <span class="o">=</span> <span class="n">cifs_ci_compare</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_automount</span> <span class="o">=</span> <span class="n">cifs_dfs_d_automount</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
