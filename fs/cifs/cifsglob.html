<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cifs › cifsglob.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cifsglob.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   fs/cifs/cifsglob.h</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright (C) International Business Machines  Corp., 2002,2008</span>
<span class="cm"> *   Author(s): Steve French (sfrench@us.ibm.com)</span>
<span class="cm"> *              Jeremy Allison (jra@samba.org)</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU Lesser General Public License as published</span>
<span class="cm"> *   by the Free Software Foundation; either version 2.1 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="cp">#ifndef _CIFS_GLOB_H</span>
<span class="cp">#define _CIFS_GLOB_H</span>

<span class="cp">#include &lt;linux/in.h&gt;</span>
<span class="cp">#include &lt;linux/in6.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &quot;cifs_fs_sb.h&quot;</span>
<span class="cp">#include &quot;cifsacl.h&quot;</span>
<span class="cp">#include &lt;crypto/internal/hash.h&gt;</span>
<span class="cp">#include &lt;linux/scatterlist.h&gt;</span>

<span class="cm">/*</span>
<span class="cm"> * The sizes of various internal tables and strings</span>
<span class="cm"> */</span>
<span class="cp">#define MAX_UID_INFO 16</span>
<span class="cp">#define MAX_SES_INFO 2</span>
<span class="cp">#define MAX_TCON_INFO 4</span>

<span class="cp">#define MAX_TREE_SIZE (2 + MAX_SERVER_SIZE + 1 + MAX_SHARE_SIZE + 1)</span>
<span class="cp">#define MAX_SERVER_SIZE 15</span>
<span class="cp">#define MAX_SHARE_SIZE 80</span>
<span class="cp">#define MAX_USERNAME_SIZE 256	</span><span class="cm">/* reasonable maximum for current servers */</span><span class="cp"></span>
<span class="cp">#define MAX_PASSWORD_SIZE 512	</span><span class="cm">/* max for windows seems to be 256 wide chars */</span><span class="cp"></span>

<span class="cp">#define CIFS_MIN_RCV_POOL 4</span>

<span class="cp">#define MAX_REOPEN_ATT	5 </span><span class="cm">/* these many maximum attempts to reopen a file */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> * default attribute cache timeout (jiffies)</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_DEF_ACTIMEO (1 * HZ)</span>

<span class="cm">/*</span>
<span class="cm"> * max attribute cache timeout (jiffies) - 2^30</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_MAX_ACTIMEO (1 &lt;&lt; 30)</span>

<span class="cm">/*</span>
<span class="cm"> * MAX_REQ is the maximum number of requests that WE will send</span>
<span class="cm"> * on one socket concurrently.</span>
<span class="cm"> */</span>
<span class="cp">#define CIFS_MAX_REQ 32767</span>

<span class="cp">#define RFC1001_NAME_LEN 15</span>
<span class="cp">#define RFC1001_NAME_LEN_WITH_NULL (RFC1001_NAME_LEN + 1)</span>

<span class="cm">/* currently length of NIP6_FMT */</span>
<span class="cp">#define SERVER_NAME_LENGTH 40</span>
<span class="cp">#define SERVER_NAME_LEN_WITH_NULL     (SERVER_NAME_LENGTH + 1)</span>

<span class="cm">/* used to define string lengths for reversing unicode strings */</span>
<span class="cm">/*         (256+1)*2 = 514                                     */</span>
<span class="cm">/*           (max path length + 1 for null) * 2 for unicode    */</span>
<span class="cp">#define MAX_NAME 514</span>

<span class="cp">#include &quot;cifspdu.h&quot;</span>

<span class="cp">#ifndef XATTR_DOS_ATTRIB</span>
<span class="cp">#define XATTR_DOS_ATTRIB &quot;user.DOSATTRIB&quot;</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * CIFS vfs client Status information (based on what we know.)</span>
<span class="cm"> */</span>

<span class="cm">/* associated with each tcp and smb session */</span>
<span class="k">enum</span> <span class="n">statusEnum</span> <span class="p">{</span>
	<span class="n">CifsNew</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CifsGood</span><span class="p">,</span>
	<span class="n">CifsExiting</span><span class="p">,</span>
	<span class="n">CifsNeedReconnect</span><span class="p">,</span>
	<span class="n">CifsNeedNegotiate</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">securityEnum</span> <span class="p">{</span>
	<span class="n">LANMAN</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>			<span class="cm">/* Legacy LANMAN auth */</span>
	<span class="n">NTLM</span><span class="p">,</span>			<span class="cm">/* Legacy NTLM012 auth with NTLM hash */</span>
	<span class="n">NTLMv2</span><span class="p">,</span>			<span class="cm">/* Legacy NTLM auth with NTLMv2 hash */</span>
	<span class="n">RawNTLMSSP</span><span class="p">,</span>		<span class="cm">/* NTLMSSP without SPNEGO, NTLMv2 hash */</span>
<span class="cm">/*	NTLMSSP, */</span> <span class="cm">/* can use rawNTLMSSP instead of NTLMSSP via SPNEGO */</span>
	<span class="n">Kerberos</span><span class="p">,</span>		<span class="cm">/* Kerberos via SPNEGO */</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="n">protocolEnum</span> <span class="p">{</span>
	<span class="n">TCP</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">SCTP</span>
	<span class="cm">/* Netbios frames protocol not supported at this time */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">session_key</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">response</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* crypto security descriptor definition */</span>
<span class="k">struct</span> <span class="n">sdesc</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">shash_desc</span> <span class="n">shash</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">ctx</span><span class="p">[];</span>
<span class="p">};</span>

<span class="cm">/* crypto hashing related structure/fields, not specific to a sec mech */</span>
<span class="k">struct</span> <span class="n">cifs_secmech</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">hmacmd5</span><span class="p">;</span> <span class="cm">/* hmac-md5 hash function */</span>
	<span class="k">struct</span> <span class="n">crypto_shash</span> <span class="o">*</span><span class="n">md5</span><span class="p">;</span> <span class="cm">/* md5 hash function */</span>
	<span class="k">struct</span> <span class="n">sdesc</span> <span class="o">*</span><span class="n">sdeschmacmd5</span><span class="p">;</span>  <span class="cm">/* ctxt to generate ntlmv2 hash, CR1 */</span>
	<span class="k">struct</span> <span class="n">sdesc</span> <span class="o">*</span><span class="n">sdescmd5</span><span class="p">;</span> <span class="cm">/* ctxt to generate cifs/smb signature */</span>
<span class="p">};</span>

<span class="cm">/* per smb session structure/fields */</span>
<span class="k">struct</span> <span class="n">ntlmssp_auth</span> <span class="p">{</span>
	<span class="n">__u32</span> <span class="n">client_flags</span><span class="p">;</span> <span class="cm">/* sent by client in type 1 ntlmsssp exchange */</span>
	<span class="n">__u32</span> <span class="n">server_flags</span><span class="p">;</span> <span class="cm">/* sent by server in type 2 ntlmssp exchange */</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">ciphertext</span><span class="p">[</span><span class="n">CIFS_CPHTXT_SIZE</span><span class="p">];</span> <span class="cm">/* sent to server */</span>
	<span class="kt">char</span> <span class="n">cryptkey</span><span class="p">[</span><span class="n">CIFS_CRYPTO_KEY_SIZE</span><span class="p">];</span> <span class="cm">/* used by ntlmssp */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cifs_cred</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">uid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">gid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cecount</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sid</span> <span class="n">osid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sid</span> <span class="n">gsid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_ntace</span> <span class="o">*</span><span class="n">ntaces</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_ace</span> <span class="o">*</span><span class="n">aces</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> *****************************************************************</span>
<span class="cm"> * Except the CIFS PDUs themselves all the</span>
<span class="cm"> * globally interesting structs should go here</span>
<span class="cm"> *****************************************************************</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="n">smb_version</span> <span class="p">{</span>
	<span class="n">Smb_1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">Smb_21</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">mid_q_entry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">TCP_Server_Info</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cifsFileInfo</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">cifs_ses</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">smb_version_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">send_cancel</span><span class="p">)(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">compare_fids</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* setup request: allocate mid, sign message */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">setup_request</span><span class="p">)(</span><span class="k">struct</span> <span class="n">cifs_ses</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">**</span><span class="p">);</span>
	<span class="cm">/* check response: verify signature, map error */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_receive</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">,</span>
			     <span class="n">bool</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">add_credits</span><span class="p">)(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">set_credits</span><span class="p">)(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="p">);</span>
	<span class="kt">int</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">get_credits_field</span><span class="p">)(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">__u64</span> <span class="p">(</span><span class="o">*</span><span class="n">get_next_mid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* data offset from read response message */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_data_offset</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* data length from read response message */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">read_data_length</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* map smb to linux error */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">map_error</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="n">bool</span><span class="p">);</span>
	<span class="cm">/* find mid corresponding to the response message */</span>
	<span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span> <span class="p">(</span><span class="o">*</span><span class="n">find_mid</span><span class="p">)(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">dump_detail</span><span class="p">)(</span><span class="kt">void</span> <span class="o">*</span><span class="p">);</span>
	<span class="cm">/* verify the message */</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">check_message</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>
	<span class="n">bool</span> <span class="p">(</span><span class="o">*</span><span class="n">is_oplock_break</span><span class="p">)(</span><span class="kt">char</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smb_version_values</span> <span class="p">{</span>
	<span class="kt">char</span>		<span class="o">*</span><span class="n">version_string</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">large_lock_type</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">exclusive_lock_type</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">shared_lock_type</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">unlock_lock_type</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">header_size</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">max_header_size</span><span class="p">;</span>
	<span class="kt">size_t</span>		<span class="n">read_rsp_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define HEADER_SIZE(server) (server-&gt;vals-&gt;header_size)</span>
<span class="cp">#define MAX_HEADER_SIZE(server) (server-&gt;vals-&gt;max_header_size)</span>

<span class="k">struct</span> <span class="n">smb_vol</span> <span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">username</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">domainname</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">UNC</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">UNCip</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">iocharset</span><span class="p">;</span>  <span class="cm">/* local code page for mapping to and from Unicode */</span>
	<span class="kt">char</span> <span class="n">source_rfc1001_name</span><span class="p">[</span><span class="n">RFC1001_NAME_LEN_WITH_NULL</span><span class="p">];</span> <span class="cm">/* clnt nb name */</span>
	<span class="kt">char</span> <span class="n">target_rfc1001_name</span><span class="p">[</span><span class="n">RFC1001_NAME_LEN_WITH_NULL</span><span class="p">];</span> <span class="cm">/* srvr nb name */</span>
	<span class="n">uid_t</span> <span class="n">cred_uid</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">linux_uid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">linux_gid</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">backupuid</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">backupgid</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">file_mode</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">dir_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">secFlg</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">retry</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">intr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">setuids</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">override_uid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">override_gid</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">dynperm</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">noperm</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">no_psx_acl</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* set if posix acl support should be disabled */</span>
	<span class="n">bool</span> <span class="n">cifs_acl</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">backupuid_specified</span><span class="p">;</span> <span class="cm">/* mount option  backupuid  is specified */</span>
	<span class="n">bool</span> <span class="n">backupgid_specified</span><span class="p">;</span> <span class="cm">/* mount option  backupgid  is specified */</span>
	<span class="n">bool</span> <span class="n">no_xattr</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/* set if xattr (EA) support should be disabled*/</span>
	<span class="n">bool</span> <span class="n">server_ino</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* use inode numbers from server ie UniqueId */</span>
	<span class="n">bool</span> <span class="n">direct_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">strict_io</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* strict cache behavior */</span>
	<span class="n">bool</span> <span class="n">remap</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>      <span class="cm">/* set to remap seven reserved chars in filenames */</span>
	<span class="n">bool</span> <span class="n">posix_paths</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* unset to not ask for posix pathnames. */</span>
	<span class="n">bool</span> <span class="n">no_linux_ext</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sfu_emul</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nullauth</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>   <span class="cm">/* attempt to authenticate with null user */</span>
	<span class="n">bool</span> <span class="n">nocase</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>     <span class="cm">/* request case insensitive filenames */</span>
	<span class="n">bool</span> <span class="n">nobrl</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>      <span class="cm">/* disable sending byte range locks to srv */</span>
	<span class="n">bool</span> <span class="n">mand_lock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* send mandatory not posix byte range lock reqs */</span>
	<span class="n">bool</span> <span class="n">seal</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>       <span class="cm">/* request transport encryption on share */</span>
	<span class="n">bool</span> <span class="n">nodfs</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>      <span class="cm">/* Do not request DFS, even if available */</span>
	<span class="n">bool</span> <span class="n">local_lease</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* check leases only on local system, not remote */</span>
	<span class="n">bool</span> <span class="n">noblocksnd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">noautotune</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nostrictsync</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* do not force expensive SMBflush on every sync */</span>
	<span class="n">bool</span> <span class="n">fsc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* enable fscache */</span>
	<span class="n">bool</span> <span class="n">mfsymlinks</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* use Minshall+French Symlinks */</span>
	<span class="n">bool</span> <span class="n">multiuser</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">rwpidforward</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* pid forward for read/write operations */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">wsize</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">sockopt_tcp_nodelay</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span> <span class="n">port</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">actimeo</span><span class="p">;</span> <span class="cm">/* attribute cache timeout (jiffies) */</span>
	<span class="k">struct</span> <span class="n">smb_version_operations</span> <span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smb_version_values</span> <span class="o">*</span><span class="n">vals</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">prepath</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">srcaddr</span><span class="p">;</span> <span class="cm">/* allow binding to a local IP */</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">local_nls</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define CIFS_MOUNT_MASK (CIFS_MOUNT_NO_PERM | CIFS_MOUNT_SET_UID | \</span>
<span class="cp">			 CIFS_MOUNT_SERVER_INUM | CIFS_MOUNT_DIRECT_IO | \</span>
<span class="cp">			 CIFS_MOUNT_NO_XATTR | CIFS_MOUNT_MAP_SPECIAL_CHR | \</span>
<span class="cp">			 CIFS_MOUNT_UNX_EMUL | CIFS_MOUNT_NO_BRL | \</span>
<span class="cp">			 CIFS_MOUNT_CIFS_ACL | CIFS_MOUNT_OVERR_UID | \</span>
<span class="cp">			 CIFS_MOUNT_OVERR_GID | CIFS_MOUNT_DYNPERM | \</span>
<span class="cp">			 CIFS_MOUNT_NOPOSIXBRL | CIFS_MOUNT_NOSSYNC | \</span>
<span class="cp">			 CIFS_MOUNT_FSCACHE | CIFS_MOUNT_MF_SYMLINKS | \</span>
<span class="cp">			 CIFS_MOUNT_MULTIUSER | CIFS_MOUNT_STRICT_IO | \</span>
<span class="cp">			 CIFS_MOUNT_CIFS_BACKUPUID | CIFS_MOUNT_CIFS_BACKUPGID)</span>

<span class="cp">#define CIFS_MS_MASK (MS_RDONLY | MS_MANDLOCK | MS_NOEXEC | MS_NOSUID | \</span>
<span class="cp">		      MS_NODEV | MS_SYNCHRONOUS)</span>

<span class="k">struct</span> <span class="n">cifs_mnt_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smb_vol</span> <span class="o">*</span><span class="n">vol</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">get_rfc1002_length</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">((</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tcp_ses_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">smb_ses_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">srv_count</span><span class="p">;</span> <span class="cm">/* reference counter */</span>
	<span class="cm">/* 15 character server name + 0x20 16th byte indicating type = srv */</span>
	<span class="kt">char</span> <span class="n">server_RFC1001_name</span><span class="p">[</span><span class="n">RFC1001_NAME_LEN_WITH_NULL</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">smb_version_operations</span>	<span class="o">*</span><span class="n">ops</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smb_version_values</span>	<span class="o">*</span><span class="n">vals</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">statusEnum</span> <span class="n">tcpStatus</span><span class="p">;</span> <span class="cm">/* what we think the status is */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">;</span> <span class="cm">/* hostname portion of UNC string */</span>
	<span class="k">struct</span> <span class="n">socket</span> <span class="o">*</span><span class="n">ssocket</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">dstaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_storage</span> <span class="n">srcaddr</span><span class="p">;</span> <span class="cm">/* locally bind to this IP */</span>
<span class="cp">#ifdef CONFIG_NET_NS</span>
	<span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">wait_queue_head_t</span> <span class="n">response_q</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span> <span class="n">request_q</span><span class="p">;</span> <span class="cm">/* if more than maxmpx to srvr must block*/</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">pending_mid_q</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">noblocksnd</span><span class="p">;</span>		<span class="cm">/* use blocking sendmsg */</span>
	<span class="n">bool</span> <span class="n">noautotune</span><span class="p">;</span>		<span class="cm">/* do not autotune send buf sizes */</span>
	<span class="n">bool</span> <span class="n">tcp_nodelay</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">credits</span><span class="p">;</span>  <span class="cm">/* send no more requests at once */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">in_flight</span><span class="p">;</span>  <span class="cm">/* number of requests on the wire to server */</span>
	<span class="n">spinlock_t</span> <span class="n">req_lock</span><span class="p">;</span>  <span class="cm">/* protect the two values above */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">srv_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">server_GUID</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">char</span> <span class="n">sec_mode</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">session_estab</span><span class="p">;</span> <span class="cm">/* mark when very first sess is established */</span>
	<span class="n">u16</span> <span class="n">dialect</span><span class="p">;</span> <span class="cm">/* dialect index that server chose */</span>
	<span class="k">enum</span> <span class="n">securityEnum</span> <span class="n">secType</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">oplocks</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* enable oplocks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxReq</span><span class="p">;</span>	<span class="cm">/* Clients should submit no more */</span>
	<span class="cm">/* than maxReq distinct unanswered SMBs to the server when using  */</span>
	<span class="cm">/* multiplexed reads or writes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxBuf</span><span class="p">;</span>	<span class="cm">/* maxBuf specifies the maximum */</span>
	<span class="cm">/* message size the server can send or receive for non-raw SMBs */</span>
	<span class="cm">/* maxBuf is returned by SMB NegotiateProtocol so maxBuf is only 0 */</span>
	<span class="cm">/* when socket is setup (and during reconnect) before NegProt sent */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_rw</span><span class="p">;</span>	<span class="cm">/* maxRw specifies the maximum */</span>
	<span class="cm">/* message size the server can send or receive for */</span>
	<span class="cm">/* SMB_COM_WRITE_RAW or SMB_COM_READ_RAW. */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_vcs</span><span class="p">;</span>	<span class="cm">/* maximum number of smb sessions, at least</span>
<span class="cm">				   those that can be specified uniquely with</span>
<span class="cm">				   vcnumbers */</span>
	<span class="kt">int</span> <span class="n">capabilities</span><span class="p">;</span> <span class="cm">/* allow selective disabling of caps by smb sess */</span>
	<span class="kt">int</span> <span class="n">timeAdj</span><span class="p">;</span>  <span class="cm">/* Adjust for difference in server time zone in sec */</span>
	<span class="n">__u64</span> <span class="n">CurrentMid</span><span class="p">;</span>         <span class="cm">/* multiplex id - rotating counter */</span>
	<span class="kt">char</span> <span class="n">cryptkey</span><span class="p">[</span><span class="n">CIFS_CRYPTO_KEY_SIZE</span><span class="p">];</span> <span class="cm">/* used by ntlm, ntlmv2 etc */</span>
	<span class="cm">/* 16th byte of RFC1001 workstation name is always null */</span>
	<span class="kt">char</span> <span class="n">workstation_RFC1001_name</span><span class="p">[</span><span class="n">RFC1001_NAME_LEN_WITH_NULL</span><span class="p">];</span>
	<span class="n">__u32</span> <span class="n">sequence_number</span><span class="p">;</span> <span class="cm">/* for signing, protected by srv_mutex */</span>
	<span class="k">struct</span> <span class="n">session_key</span> <span class="n">session_key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">lstrp</span><span class="p">;</span> <span class="cm">/* when we got last response from this server */</span>
	<span class="k">struct</span> <span class="n">cifs_secmech</span> <span class="n">secmech</span><span class="p">;</span> <span class="cm">/* crypto sec mech functs, descriptors */</span>
	<span class="cm">/* extended security flavors that server supports */</span>
	<span class="n">bool</span>	<span class="n">sec_ntlmssp</span><span class="p">;</span>		<span class="cm">/* supports NTLMSSP */</span>
	<span class="n">bool</span>	<span class="n">sec_kerberosu2u</span><span class="p">;</span>	<span class="cm">/* supports U2U Kerberos */</span>
	<span class="n">bool</span>	<span class="n">sec_kerberos</span><span class="p">;</span>		<span class="cm">/* supports plain Kerberos */</span>
	<span class="n">bool</span>	<span class="n">sec_mskerberos</span><span class="p">;</span>		<span class="cm">/* supports legacy MS Kerberos */</span>
	<span class="n">bool</span>	<span class="n">large_buf</span><span class="p">;</span>		<span class="cm">/* is current buffer large? */</span>
	<span class="k">struct</span> <span class="n">delayed_work</span>	<span class="n">echo</span><span class="p">;</span> <span class="cm">/* echo ping workqueue job */</span>
	<span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">;</span>	<span class="cm">/* reusable kvec array for receives */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_iov</span><span class="p">;</span>	<span class="cm">/* number of kvecs in array */</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">smallbuf</span><span class="p">;</span>	<span class="cm">/* pointer to current &quot;small&quot; buffer */</span>
	<span class="kt">char</span>	<span class="o">*</span><span class="n">bigbuf</span><span class="p">;</span>	<span class="cm">/* pointer to current &quot;big&quot; buffer */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_read</span><span class="p">;</span> <span class="cm">/* total amount of data read in this pass */</span>
<span class="cp">#ifdef CONFIG_CIFS_FSCACHE</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span>   <span class="o">*</span><span class="n">fscache</span><span class="p">;</span> <span class="cm">/* client index cache cookie */</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
	<span class="n">atomic_t</span> <span class="n">in_send</span><span class="p">;</span> <span class="cm">/* requests trying to send */</span>
	<span class="n">atomic_t</span> <span class="n">num_waiters</span><span class="p">;</span>   <span class="cm">/* blocked waiting to get in sendrecv */</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">in_flight</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">bool</span>
<span class="nf">has_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">credits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="n">num</span> <span class="o">=</span> <span class="o">*</span><span class="n">credits</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">num</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">add_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">add</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">add_credits</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">add</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">set_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">set_credits</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">val</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u64</span>
<span class="nf">get_next_mid</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">get_next_mid</span><span class="p">(</span><span class="n">server</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Macros to allow the TCP_Server_Info-&gt;net field and related code to drop out</span>
<span class="cm"> * when CONFIG_NET_NS isn&#39;t set.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef CONFIG_NET_NS</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">cifs_net_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">srv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">srv</span><span class="o">-&gt;</span><span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_set_net_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">srv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">srv</span><span class="o">-&gt;</span><span class="n">net</span> <span class="o">=</span> <span class="n">net</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="nf">cifs_net_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">srv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">init_net</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_set_net_ns</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">srv</span><span class="p">,</span> <span class="k">struct</span> <span class="n">net</span> <span class="o">*</span><span class="n">net</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * Session structure.  One of these for each uid session with a particular host</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cifs_ses</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">smb_ses_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tcon_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">session_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">;</span>	<span class="cm">/* pointer to server info */</span>
	<span class="kt">int</span> <span class="n">ses_count</span><span class="p">;</span>		<span class="cm">/* reference counter */</span>
	<span class="k">enum</span> <span class="n">statusEnum</span> <span class="n">status</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">overrideSecFlg</span><span class="p">;</span>  <span class="cm">/* if non-zero override global sec flags */</span>
	<span class="n">__u16</span> <span class="n">ipc_tid</span><span class="p">;</span>		<span class="cm">/* special tid for connection to IPC share */</span>
	<span class="n">__u16</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">vcnum</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">serverOS</span><span class="p">;</span>		<span class="cm">/* name of operating system underlying server */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">serverNOS</span><span class="p">;</span>	<span class="cm">/* name of network operating system of server */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">serverDomain</span><span class="p">;</span>	<span class="cm">/* security realm of server */</span>
	<span class="kt">int</span> <span class="n">Suid</span><span class="p">;</span>		<span class="cm">/* remote smb uid  */</span>
	<span class="n">uid_t</span> <span class="n">linux_uid</span><span class="p">;</span>        <span class="cm">/* overriding owner of files on the mount */</span>
	<span class="n">uid_t</span> <span class="n">cred_uid</span><span class="p">;</span>		<span class="cm">/* owner of credentials */</span>
	<span class="kt">int</span> <span class="n">capabilities</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">serverName</span><span class="p">[</span><span class="n">SERVER_NAME_LEN_WITH_NULL</span> <span class="o">*</span> <span class="mi">2</span><span class="p">];</span>	<span class="cm">/* BB make bigger for</span>
<span class="cm">				TCP names - will ipv6 and sctp addresses fit? */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">user_name</span><span class="p">;</span>	<span class="cm">/* must not be null except during init of sess</span>
<span class="cm">				   and after mount option parsing we fill it */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">domainName</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">session_key</span> <span class="n">auth_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ntlmssp_auth</span> <span class="o">*</span><span class="n">ntlmssp</span><span class="p">;</span> <span class="cm">/* ciphertext, flags, server challenge */</span>
	<span class="n">bool</span> <span class="n">need_reconnect</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* connection reset, uid now invalid */</span>
<span class="p">};</span>
<span class="cm">/* no more than one of the following three session flags may be set */</span>
<span class="cp">#define CIFS_SES_NT4 1</span>
<span class="cp">#define CIFS_SES_OS2 2</span>
<span class="cp">#define CIFS_SES_W9X 4</span>
<span class="cm">/* following flag is set for old servers such as OS2 (and Win95?)</span>
<span class="cm">   which do not negotiate NTLM or POSIX dialects, but instead</span>
<span class="cm">   negotiate one of the older LANMAN dialects */</span>
<span class="cp">#define CIFS_SES_LANMAN 8</span>
<span class="cm">/*</span>
<span class="cm"> * there is one of these for each connection to a resource on a particular</span>
<span class="cm"> * session</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tcon_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tc_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">openFileList</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_ses</span> <span class="o">*</span><span class="n">ses</span><span class="p">;</span>	<span class="cm">/* pointer to session associated with */</span>
	<span class="kt">char</span> <span class="n">treeName</span><span class="p">[</span><span class="n">MAX_TREE_SIZE</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span> <span class="cm">/* UNC name of resource in ASCII */</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">nativeFileSystem</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">password</span><span class="p">;</span>		<span class="cm">/* for share-level security */</span>
	<span class="n">__u16</span> <span class="n">tid</span><span class="p">;</span>		<span class="cm">/* The 2 byte tree id */</span>
	<span class="n">__u16</span> <span class="n">Flags</span><span class="p">;</span>		<span class="cm">/* optional support bits */</span>
	<span class="k">enum</span> <span class="n">statusEnum</span> <span class="n">tidStatus</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS</span>
	<span class="n">atomic_t</span> <span class="n">num_smbs_sent</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_writes</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_reads</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_flushes</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_oplock_brks</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_opens</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_closes</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_deletes</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_mkdirs</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_posixopens</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_posixmkdirs</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_rmdirs</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_renames</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_t2renames</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_ffirst</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_fnext</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_fclose</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_hardlinks</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_symlinks</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_locks</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_acl_get</span><span class="p">;</span>
	<span class="n">atomic_t</span> <span class="n">num_acl_set</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_writes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_reads</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_opens</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_deletes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_closes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_mkdirs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_rmdirs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_renames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_t2renames</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_ffirst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_fnext</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">time_fclose</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_STATS2 */</span><span class="cp"></span>
	<span class="n">__u64</span>    <span class="n">bytes_read</span><span class="p">;</span>
	<span class="n">__u64</span>    <span class="n">bytes_written</span><span class="p">;</span>
	<span class="n">spinlock_t</span> <span class="n">stat_lock</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_STATS */</span><span class="cp"></span>
	<span class="n">FILE_SYSTEM_DEVICE_INFO</span> <span class="n">fsDevInfo</span><span class="p">;</span>
	<span class="n">FILE_SYSTEM_ATTRIBUTE_INFO</span> <span class="n">fsAttrInfo</span><span class="p">;</span> <span class="cm">/* ok if fs name truncated */</span>
	<span class="n">FILE_SYSTEM_UNIX_INFO</span> <span class="n">fsUnixInfo</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ipc</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>		<span class="cm">/* set if connection to IPC$ eg for RPC/PIPES */</span>
	<span class="n">bool</span> <span class="n">retry</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nocase</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">seal</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>      <span class="cm">/* transport encryption for this mounted share */</span>
	<span class="n">bool</span> <span class="n">unix_ext</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* if false disable Linux extensions to CIFS protocol</span>
<span class="cm">				for this mount even if server would support */</span>
	<span class="n">bool</span> <span class="n">local_lease</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* check leases (only) on local system not remote */</span>
	<span class="n">bool</span> <span class="n">broken_posix_open</span><span class="p">;</span> <span class="cm">/* e.g. Samba server versions &lt; 3.3.2, 3.2.9 */</span>
	<span class="n">bool</span> <span class="n">need_reconnect</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* connection reset, tid now invalid */</span>
<span class="cp">#ifdef CONFIG_CIFS_FSCACHE</span>
	<span class="n">u64</span> <span class="n">resource_id</span><span class="p">;</span>		<span class="cm">/* server resource id */</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span> <span class="o">*</span><span class="n">fscache</span><span class="p">;</span>	<span class="cm">/* cookie for share */</span>
<span class="cp">#endif</span>
	<span class="cm">/* BB add field for back pointer to sb struct(s)? */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is a refcounted and timestamped container for a tcon pointer. The</span>
<span class="cm"> * container holds a tcon reference. It is considered safe to free one of</span>
<span class="cm"> * these when the tl_count goes to 0. The tl_time is the time of the last</span>
<span class="cm"> * &quot;get&quot; on the container.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">tcon_link</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">tl_rbnode</span><span class="p">;</span>
	<span class="n">uid_t</span>			<span class="n">tl_uid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tl_flags</span><span class="p">;</span>
<span class="cp">#define TCON_LINK_MASTER	0</span>
<span class="cp">#define TCON_LINK_PENDING	1</span>
<span class="cp">#define TCON_LINK_IN_TREE	2</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">tl_time</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">tl_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span>	<span class="o">*</span><span class="n">tl_tcon</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">cifs_sb_tlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span>
<span class="nf">tlink_tcon</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tlink</span><span class="o">-&gt;</span><span class="n">tl_tcon</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="n">cifs_put_tlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">);</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span>
<span class="nf">cifs_get_tlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tlink</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">))</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tlink</span><span class="o">-&gt;</span><span class="n">tl_count</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">tlink</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This function is always expected to succeed */</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This info hangs off the cifsFileInfo structure, pointed to by llist.</span>
<span class="cm"> * This is used to track byte stream locks on the file</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">llist</span><span class="p">;</span>	<span class="cm">/* pointer to next cifsLockInfo */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">blist</span><span class="p">;</span> <span class="cm">/* pointer to locks blocked on this */</span>
	<span class="n">wait_queue_head_t</span> <span class="n">block_q</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * One of these for each open instance of a file</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">cifs_search_info</span> <span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">index_of_last_entry</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">entries_in_buffer</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">info_level</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">resume_key</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ntwrk_buf_start</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">srch_entries_start</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">last_entry</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">presume_name</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">resume_name_len</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">endOfSearch</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">emptyDir</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">unicode</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">smallBuf</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* so we know which buf_release function to call */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tlist</span><span class="p">;</span>	<span class="cm">/* pointer to next fid owned by tcon */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">flist</span><span class="p">;</span>	<span class="cm">/* next fid (file instance) for this inode */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">llist</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">				 * brlocks held by this fid, protected by</span>
<span class="cm">				 * lock_mutex from cifsInodeInfo structure</span>
<span class="cm">				 */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">uid</span><span class="p">;</span>	<span class="cm">/* allows finding which FileInfo structure */</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>		<span class="cm">/* process id who opened file */</span>
	<span class="n">__u16</span> <span class="n">netfid</span><span class="p">;</span>		<span class="cm">/* file id from remote */</span>
	<span class="cm">/* BB add lock scope info here if needed */</span> <span class="p">;</span>
	<span class="cm">/* lock scope id (0 if none) */</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">invalidHandle</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* file closed via session abend */</span>
	<span class="n">bool</span> <span class="n">oplock_break_cancelled</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>		<span class="cm">/* refcount protected by cifs_file_list_lock */</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">fh_mutex</span><span class="p">;</span> <span class="cm">/* prevents reopen race after dead ses*/</span>
	<span class="k">struct</span> <span class="n">cifs_search_info</span> <span class="n">srch_inf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="n">oplock_break</span><span class="p">;</span> <span class="cm">/* work for oplock breaks */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">cifs_io_parms</span> <span class="p">{</span>
	<span class="n">__u16</span> <span class="n">netfid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Take a reference on the file private data. Must be called with</span>
<span class="cm"> * cifs_file_list_lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span>
<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="nf">cifsFileInfo_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cifs_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">++</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">cifs_file</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">cifsFileInfo_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cifs_file</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * One of these for each file inode</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="p">{</span>
	<span class="n">bool</span> <span class="n">can_cache_brlcks</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span> <span class="n">lock_mutex</span><span class="p">;</span>	<span class="cm">/*</span>
<span class="cm">					 * protect the field above and llist</span>
<span class="cm">					 * from every cifsFileInfo structure</span>
<span class="cm">					 * from openFileList</span>
<span class="cm">					 */</span>
	<span class="cm">/* BB add in lists for dirty pages i.e. write caching info for oplock */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">openFileList</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">cifsAttrs</span><span class="p">;</span> <span class="cm">/* e.g. DOS archive bit, sparse, compressed, system */</span>
	<span class="n">bool</span> <span class="n">clientCanCacheRead</span><span class="p">;</span>	<span class="cm">/* read oplock */</span>
	<span class="n">bool</span> <span class="n">clientCanCacheAll</span><span class="p">;</span>		<span class="cm">/* read and writebehind oplock */</span>
	<span class="n">bool</span> <span class="n">delete_pending</span><span class="p">;</span>		<span class="cm">/* DELETE_ON_CLOSE is set */</span>
	<span class="n">bool</span> <span class="n">invalid_mapping</span><span class="p">;</span>		<span class="cm">/* pagecache is invalid */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">time</span><span class="p">;</span>		<span class="cm">/* jiffies of last update of inode */</span>
	<span class="n">u64</span>  <span class="n">server_eof</span><span class="p">;</span>		<span class="cm">/* current file size on server -- protected by i_lock */</span>
	<span class="n">u64</span>  <span class="n">uniqueid</span><span class="p">;</span>			<span class="cm">/* server inode number */</span>
	<span class="n">u64</span>  <span class="n">createtime</span><span class="p">;</span>		<span class="cm">/* creation time on server */</span>
<span class="cp">#ifdef CONFIG_CIFS_FSCACHE</span>
	<span class="k">struct</span> <span class="n">fscache_cookie</span> <span class="o">*</span><span class="n">fscache</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span>
<span class="nf">CIFS_I</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">container_of</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsInodeInfo</span><span class="p">,</span> <span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span>
<span class="nf">CIFS_SB</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">char</span> <span class="nf">CIFS_DIR_SEP</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_POSIX_PATHS</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="sc">&#39;\\&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">convert_delimiter</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delim</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">old_delim</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">delim</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
		<span class="n">old_delim</span> <span class="o">=</span> <span class="sc">&#39;\\&#39;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">old_delim</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">old_delim</span><span class="p">)</span>
			<span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">delim</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CIFS_STATS</span>
<span class="cp">#define cifs_stats_inc atomic_inc</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_stats_bytes_written</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">tcon</span><span class="o">-&gt;</span><span class="n">bytes_written</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_stats_bytes_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">,</span>
					 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="n">tcon</span><span class="o">-&gt;</span><span class="n">bytes_read</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#else</span>

<span class="cp">#define  cifs_stats_inc(field) do {} while (0)</span>
<span class="cp">#define  cifs_stats_bytes_written(tcon, bytes) do {} while (0)</span>
<span class="cp">#define  cifs_stats_bytes_read(tcon, bytes) do {} while (0)</span>

<span class="cp">#endif</span>


<span class="cm">/*</span>
<span class="cm"> * This is the prototype for the mid receive function. This function is for</span>
<span class="cm"> * receiving the rest of the SMB frame, starting with the WordCount (which is</span>
<span class="cm"> * just after the MID in struct smb_hdr). Note:</span>
<span class="cm"> *</span>
<span class="cm"> * - This will be called by cifsd, with no locks held.</span>
<span class="cm"> * - The mid will still be on the pending_mid_q.</span>
<span class="cm"> * - mid-&gt;resp_buf will point to the current buffer.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns zero on a successful receive, or an error. The receive state in</span>
<span class="cm"> * the TCP_Server_Info will also be updated.</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">int</span> <span class="p">(</span><span class="n">mid_receive_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="n">mid</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * This is the prototype for the mid callback function. This is called once the</span>
<span class="cm"> * mid has been received off of the socket. When creating one, take special</span>
<span class="cm"> * care to avoid deadlocks. Things to bear in mind:</span>
<span class="cm"> *</span>
<span class="cm"> * - it will be called by cifsd, with no locks held</span>
<span class="cm"> * - the mid will be removed from any lists</span>
<span class="cm"> */</span>
<span class="k">typedef</span> <span class="kt">void</span> <span class="p">(</span><span class="n">mid_callback_t</span><span class="p">)(</span><span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="n">mid</span><span class="p">);</span>

<span class="cm">/* one of these for every pending CIFS request to the server */</span>
<span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">qhead</span><span class="p">;</span>	<span class="cm">/* mids waiting on reply from this server */</span>
	<span class="n">__u64</span> <span class="n">mid</span><span class="p">;</span>		<span class="cm">/* multiplex id */</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>		<span class="cm">/* process id */</span>
	<span class="n">__u32</span> <span class="n">sequence_number</span><span class="p">;</span>  <span class="cm">/* for CIFS signing */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">when_alloc</span><span class="p">;</span>  <span class="cm">/* when mid was created */</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">when_sent</span><span class="p">;</span> <span class="cm">/* time when smb send finished */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">when_received</span><span class="p">;</span> <span class="cm">/* when demux complete (taken off wire) */</span>
<span class="cp">#endif</span>
	<span class="n">mid_receive_t</span> <span class="o">*</span><span class="n">receive</span><span class="p">;</span> <span class="cm">/* call receive callback */</span>
	<span class="n">mid_callback_t</span> <span class="o">*</span><span class="n">callback</span><span class="p">;</span> <span class="cm">/* call completion callback */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">callback_data</span><span class="p">;</span>	  <span class="cm">/* general purpose pointer for callback */</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">resp_buf</span><span class="p">;</span>		<span class="cm">/* pointer to received SMB header */</span>
	<span class="kt">int</span> <span class="n">mid_state</span><span class="p">;</span>	<span class="cm">/* wish this were enum but can not pass to wait_event */</span>
	<span class="n">__le16</span> <span class="n">command</span><span class="p">;</span>		<span class="cm">/* smb command code */</span>
	<span class="n">bool</span> <span class="n">large_buf</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* if valid response, is pointer to large buf */</span>
	<span class="n">bool</span> <span class="n">multiRsp</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* multiple trans2 responses for one request  */</span>
	<span class="n">bool</span> <span class="n">multiEnd</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* both received */</span>
<span class="p">};</span>

<span class="cm">/*	Make code in transport.c a little cleaner by moving</span>
<span class="cm">	update of optional stats into function below */</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_in_send_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">in_send</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_in_send_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">in_send</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_num_waiters_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">num_waiters</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_num_waiters_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">num_waiters</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_save_when_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mid</span><span class="o">-&gt;</span><span class="n">when_sent</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_in_send_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_in_send_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_num_waiters_inc</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_num_waiters_dec</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">cifs_save_when_sent</span><span class="p">(</span><span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="cm">/* for pending dnotify requests */</span>
<span class="k">struct</span> <span class="n">dir_notify_req</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">lhead</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">Pid</span><span class="p">;</span>
	<span class="n">__le16</span> <span class="n">PidHigh</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Mid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Tid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">Uid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">netfid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">filter</span><span class="p">;</span> <span class="cm">/* CompletionFilter (for multishot) */</span>
	<span class="kt">int</span> <span class="n">multishot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">pfile</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dfs_info3_param</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span> <span class="cm">/* DFSREF_REFERRAL_SERVER, DFSREF_STORAGE_SERVER*/</span>
	<span class="kt">int</span> <span class="n">path_consumed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">server_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ref_flag</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">path_name</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">node_name</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * common struct for holding inode info when searching for or updating an</span>
<span class="cm"> * inode with new info</span>
<span class="cm"> */</span>

<span class="cp">#define CIFS_FATTR_DFS_REFERRAL		0x1</span>
<span class="cp">#define CIFS_FATTR_DELETE_PENDING	0x2</span>
<span class="cp">#define CIFS_FATTR_NEED_REVAL		0x4</span>
<span class="cp">#define CIFS_FATTR_INO_COLLISION	0x8</span>

<span class="k">struct</span> <span class="n">cifs_fattr</span> <span class="p">{</span>
	<span class="n">u32</span>		<span class="n">cf_flags</span><span class="p">;</span>
	<span class="n">u32</span>		<span class="n">cf_cifsattrs</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">cf_uniqueid</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">cf_eof</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">cf_bytes</span><span class="p">;</span>
	<span class="n">u64</span>		<span class="n">cf_createtime</span><span class="p">;</span>
	<span class="n">uid_t</span>		<span class="n">cf_uid</span><span class="p">;</span>
	<span class="n">gid_t</span>		<span class="n">cf_gid</span><span class="p">;</span>
	<span class="n">umode_t</span>		<span class="n">cf_mode</span><span class="p">;</span>
	<span class="n">dev_t</span>		<span class="n">cf_rdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cf_nlink</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">cf_dtype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">cf_atime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">cf_mtime</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span>	<span class="n">cf_ctime</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_dfs_info_param</span><span class="p">(</span><span class="k">struct</span> <span class="n">dfs_info3_param</span> <span class="o">*</span><span class="n">param</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">param</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">path_name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="o">-&gt;</span><span class="n">node_name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">free_dfs_info_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">dfs_info3_param</span> <span class="o">*</span><span class="n">param</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">number_of_items</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">number_of_items</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">param</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">number_of_items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">path_name</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">node_name</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">param</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define   MID_FREE 0</span>
<span class="cp">#define   MID_REQUEST_ALLOCATED 1</span>
<span class="cp">#define   MID_REQUEST_SUBMITTED 2</span>
<span class="cp">#define   MID_RESPONSE_RECEIVED 4</span>
<span class="cp">#define   MID_RETRY_NEEDED      8 </span><span class="cm">/* session closed while this request out */</span><span class="cp"></span>
<span class="cp">#define   MID_RESPONSE_MALFORMED 0x10</span>
<span class="cp">#define   MID_SHUTDOWN		 0x20</span>

<span class="cm">/* Types of response buffer returned from SendReceive2 */</span>
<span class="cp">#define   CIFS_NO_BUFFER        0    </span><span class="cm">/* Response buffer not returned */</span><span class="cp"></span>
<span class="cp">#define   CIFS_SMALL_BUFFER     1</span>
<span class="cp">#define   CIFS_LARGE_BUFFER     2</span>
<span class="cp">#define   CIFS_IOVEC            4    </span><span class="cm">/* array of response buffers */</span><span class="cp"></span>

<span class="cm">/* Type of Request to SendReceive2 */</span>
<span class="cp">#define   CIFS_BLOCKING_OP      1    </span><span class="cm">/* operation can block */</span><span class="cp"></span>
<span class="cp">#define   CIFS_ASYNC_OP         2    </span><span class="cm">/* do not wait for response */</span><span class="cp"></span>
<span class="cp">#define   CIFS_TIMEOUT_MASK 0x003    </span><span class="cm">/* only one of above set in req */</span><span class="cp"></span>
<span class="cp">#define   CIFS_LOG_ERROR    0x010    </span><span class="cm">/* log NT STATUS if non-zero */</span><span class="cp"></span>
<span class="cp">#define   CIFS_LARGE_BUF_OP 0x020    </span><span class="cm">/* large request buffer */</span><span class="cp"></span>
<span class="cp">#define   CIFS_NO_RESP      0x040    </span><span class="cm">/* no response buffer required */</span><span class="cp"></span>

<span class="cm">/* Security Flags: indicate type of session setup needed */</span>
<span class="cp">#define   CIFSSEC_MAY_SIGN	0x00001</span>
<span class="cp">#define   CIFSSEC_MAY_NTLM	0x00002</span>
<span class="cp">#define   CIFSSEC_MAY_NTLMV2	0x00004</span>
<span class="cp">#define   CIFSSEC_MAY_KRB5	0x00008</span>
<span class="cp">#ifdef CONFIG_CIFS_WEAK_PW_HASH</span>
<span class="cp">#define   CIFSSEC_MAY_LANMAN	0x00010</span>
<span class="cp">#define   CIFSSEC_MAY_PLNTXT	0x00020</span>
<span class="cp">#else</span>
<span class="cp">#define   CIFSSEC_MAY_LANMAN    0</span>
<span class="cp">#define   CIFSSEC_MAY_PLNTXT    0</span>
<span class="cp">#endif </span><span class="cm">/* weak passwords */</span><span class="cp"></span>
<span class="cp">#define   CIFSSEC_MAY_SEAL	0x00040 </span><span class="cm">/* not supported yet */</span><span class="cp"></span>
<span class="cp">#define   CIFSSEC_MAY_NTLMSSP	0x00080 </span><span class="cm">/* raw ntlmssp with ntlmv2 */</span><span class="cp"></span>

<span class="cp">#define   CIFSSEC_MUST_SIGN	0x01001</span>
<span class="cm">/* note that only one of the following can be set so the</span>
<span class="cm">result of setting MUST flags more than once will be to</span>
<span class="cm">require use of the stronger protocol */</span>
<span class="cp">#define   CIFSSEC_MUST_NTLM	0x02002</span>
<span class="cp">#define   CIFSSEC_MUST_NTLMV2	0x04004</span>
<span class="cp">#define   CIFSSEC_MUST_KRB5	0x08008</span>
<span class="cp">#ifdef CONFIG_CIFS_WEAK_PW_HASH</span>
<span class="cp">#define   CIFSSEC_MUST_LANMAN	0x10010</span>
<span class="cp">#define   CIFSSEC_MUST_PLNTXT	0x20020</span>
<span class="cp">#ifdef CONFIG_CIFS_UPCALL</span>
<span class="cp">#define   CIFSSEC_MASK          0xBF0BF </span><span class="cm">/* allows weak security but also krb5 */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define   CIFSSEC_MASK          0xB70B7 </span><span class="cm">/* current flags supported if weak */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* UPCALL */</span><span class="cp"></span>
<span class="cp">#else </span><span class="cm">/* do not allow weak pw hash */</span><span class="cp"></span>
<span class="cp">#define   CIFSSEC_MUST_LANMAN	0</span>
<span class="cp">#define   CIFSSEC_MUST_PLNTXT	0</span>
<span class="cp">#ifdef CONFIG_CIFS_UPCALL</span>
<span class="cp">#define   CIFSSEC_MASK          0x8F08F </span><span class="cm">/* flags supported if no weak allowed */</span><span class="cp"></span>
<span class="cp">#else</span>
<span class="cp">#define	  CIFSSEC_MASK          0x87087 </span><span class="cm">/* flags supported if no weak allowed */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* UPCALL */</span><span class="cp"></span>
<span class="cp">#endif </span><span class="cm">/* WEAK_PW_HASH */</span><span class="cp"></span>
<span class="cp">#define   CIFSSEC_MUST_SEAL	0x40040 </span><span class="cm">/* not supported yet */</span><span class="cp"></span>
<span class="cp">#define   CIFSSEC_MUST_NTLMSSP	0x80080 </span><span class="cm">/* raw ntlmssp with ntlmv2 */</span><span class="cp"></span>

<span class="cp">#define   CIFSSEC_DEF (CIFSSEC_MAY_SIGN | CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2)</span>
<span class="cp">#define   CIFSSEC_MAX (CIFSSEC_MUST_SIGN | CIFSSEC_MUST_NTLMV2)</span>
<span class="cp">#define   CIFSSEC_AUTH_MASK (CIFSSEC_MAY_NTLM | CIFSSEC_MAY_NTLMV2 | CIFSSEC_MAY_LANMAN | CIFSSEC_MAY_PLNTXT | CIFSSEC_MAY_KRB5 | CIFSSEC_MAY_NTLMSSP)</span>
<span class="cm">/*</span>
<span class="cm"> *****************************************************************</span>
<span class="cm"> * All constants go here</span>
<span class="cm"> *****************************************************************</span>
<span class="cm"> */</span>

<span class="cp">#define UID_HASH (16)</span>

<span class="cm">/*</span>
<span class="cm"> * Note that ONE module should define _DECLARE_GLOBALS_HERE to cause the</span>
<span class="cm"> * following to be declared.</span>
<span class="cm"> */</span>

<span class="cm">/****************************************************************************</span>
<span class="cm"> *  Locking notes.  All updates to global variables and lists should be</span>
<span class="cm"> *                  protected by spinlocks or semaphores.</span>
<span class="cm"> *</span>
<span class="cm"> *  Spinlocks</span>
<span class="cm"> *  ---------</span>
<span class="cm"> *  GlobalMid_Lock protects:</span>
<span class="cm"> *	list operations on pending_mid_q and oplockQ</span>
<span class="cm"> *      updates to XID counters, multiplex id  and SMB sequence numbers</span>
<span class="cm"> *  cifs_file_list_lock protects:</span>
<span class="cm"> *	list operations on tcp and SMB session lists and tCon lists</span>
<span class="cm"> *  f_owner.lock protects certain per file struct operations</span>
<span class="cm"> *  mapping-&gt;page_lock protects certain per page operations</span>
<span class="cm"> *</span>
<span class="cm"> *  Semaphores</span>
<span class="cm"> *  ----------</span>
<span class="cm"> *  sesSem     operations on smb session</span>
<span class="cm"> *  tconSem    operations on tree connection</span>
<span class="cm"> *  fh_sem      file handle reconnection operations</span>
<span class="cm"> *</span>
<span class="cm"> ****************************************************************************/</span>

<span class="cp">#ifdef DECLARE_GLOBALS_HERE</span>
<span class="cp">#define GLOBAL_EXTERN</span>
<span class="cp">#else</span>
<span class="cp">#define GLOBAL_EXTERN extern</span>
<span class="cp">#endif</span>

<span class="cm">/*</span>
<span class="cm"> * the list of TCP_Server_Info structures, ie each of the sockets</span>
<span class="cm"> * connecting our client to a distinct server (ip address), is</span>
<span class="cm"> * chained together by cifs_tcp_ses_list. The list of all our SMB</span>
<span class="cm"> * sessions (and from that the tree connections) can be found</span>
<span class="cm"> * by iterating over cifs_tcp_ses_list</span>
<span class="cm"> */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="k">struct</span> <span class="n">list_head</span>		<span class="n">cifs_tcp_ses_list</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This lock protects the cifs_tcp_ses_list, the list of smb sessions per</span>
<span class="cm"> * tcp session, and the list of tcon&#39;s per smb session. It also protects</span>
<span class="cm"> * the reference counters for the server, smb session, and tcon. Finally,</span>
<span class="cm"> * changes to the tcon-&gt;tidStatus should be done while holding this lock.</span>
<span class="cm"> */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">spinlock_t</span>		<span class="n">cifs_tcp_ses_lock</span><span class="p">;</span>

<span class="cm">/*</span>
<span class="cm"> * This lock protects the cifs_file-&gt;llist and cifs_file-&gt;flist</span>
<span class="cm"> * list operations, and updates to some flags (cifs_file-&gt;invalidHandle)</span>
<span class="cm"> * It will be moved to either use the tcon-&gt;stat_lock or equivalent later.</span>
<span class="cm"> * If cifs_tcp_ses_lock and the lock below are both needed to be held, then</span>
<span class="cm"> * the cifs_tcp_ses_lock must be grabbed first and released last.</span>
<span class="cm"> */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">spinlock_t</span>	<span class="n">cifs_file_list_lock</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL </span><span class="cm">/* unused temporarily */</span><span class="cp"></span>
<span class="cm">/* Outstanding dir notify requests */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">GlobalDnotifyReqList</span><span class="p">;</span>
<span class="cm">/* DirNotify response queue */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="n">GlobalDnotifyRsp_Q</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* was needed for dnotify, and will be needed for inotify when VFS fix */</span><span class="cp"></span>

<span class="cm">/*</span>
<span class="cm"> * Global transaction id (XID) information</span>
<span class="cm"> */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">GlobalCurrentXid</span><span class="p">;</span>	<span class="cm">/* protected by GlobalMid_Sem */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">GlobalTotalActiveXid</span><span class="p">;</span> <span class="cm">/* prot by GlobalMid_Sem */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">GlobalMaxActiveXid</span><span class="p">;</span>	<span class="cm">/* prot by GlobalMid_Sem */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">spinlock_t</span> <span class="n">GlobalMid_Lock</span><span class="p">;</span>  <span class="cm">/* protects above &amp; list operations */</span>
					  <span class="cm">/* on midQ entries */</span>
<span class="cm">/*</span>
<span class="cm"> *  Global counters, updated atomically</span>
<span class="cm"> */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">sesInfoAllocCount</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">tconInfoAllocCount</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">tcpSesAllocCount</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">tcpSesReconnectCount</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">tconInfoReconnectCount</span><span class="p">;</span>

<span class="cm">/* Various Debug counters */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">bufAllocCount</span><span class="p">;</span>    <span class="cm">/* current number allocated  */</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">totBufAllocCount</span><span class="p">;</span> <span class="cm">/* total allocated over all time */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">totSmBufAllocCount</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">smBufAllocCount</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">atomic_t</span> <span class="n">midCount</span><span class="p">;</span>

<span class="cm">/* Misc globals */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">bool</span> <span class="n">enable_oplocks</span><span class="p">;</span> <span class="cm">/* enable or disable oplocks */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lookupCacheEnabled</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">global_secflags</span><span class="p">;</span>	<span class="cm">/* if on, session setup sent</span>
<span class="cm">				with more secure ntlmssp2 challenge/resp */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sign_CIFS_PDUs</span><span class="p">;</span>  <span class="cm">/* enable smb packet signing */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">linuxExtEnabled</span><span class="p">;</span><span class="cm">/*enable Linux/Unix CIFS extensions*/</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CIFSMaxBufSize</span><span class="p">;</span>  <span class="cm">/* max size not including hdr */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cifs_min_rcv</span><span class="p">;</span>    <span class="cm">/* min size of big ntwrk buf pool */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cifs_min_small</span><span class="p">;</span>  <span class="cm">/* min size of small buf pool */</span>
<span class="n">GLOBAL_EXTERN</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cifs_max_pending</span><span class="p">;</span> <span class="cm">/* MAX requests at once to server*/</span>

<span class="cp">#ifdef CONFIG_CIFS_ACL</span>
<span class="n">GLOBAL_EXTERN</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">uidtree</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">gidtree</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">spinlock_t</span> <span class="n">siduidlock</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">spinlock_t</span> <span class="n">sidgidlock</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">siduidtree</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="n">sidgidtree</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">spinlock_t</span> <span class="n">uidsidlock</span><span class="p">;</span>
<span class="n">GLOBAL_EXTERN</span> <span class="n">spinlock_t</span> <span class="n">gidsidlock</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_ACL */</span><span class="cp"></span>

<span class="kt">void</span> <span class="n">cifs_oplock_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>

<span class="k">extern</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">slow_work_ops</span> <span class="n">cifs_oplock_break_ops</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">cifsiod_wq</span><span class="p">;</span>

<span class="cm">/* Operations for different SMB versions */</span>
<span class="cp">#define SMB1_VERSION_STRING	&quot;1.0&quot;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">smb_version_operations</span> <span class="n">smb1_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">smb_version_values</span> <span class="n">smb1_values</span><span class="p">;</span>
<span class="cp">#define SMB21_VERSION_STRING	&quot;2.1&quot;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">smb_version_operations</span> <span class="n">smb21_operations</span><span class="p">;</span>
<span class="k">extern</span> <span class="k">struct</span> <span class="n">smb_version_values</span> <span class="n">smb21_values</span><span class="p">;</span>
<span class="cp">#endif	</span><span class="cm">/* _CIFS_GLOB_H */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
