<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cifs › misc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>misc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   fs/cifs/misc.c</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright (C) International Business Machines  Corp., 2002,2008</span>
<span class="cm"> *   Author(s): Steve French (sfrench@us.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU Lesser General Public License as published</span>
<span class="cm"> *   by the Free Software Foundation; either version 2.1 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> *   along with this library; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &quot;cifspdu.h&quot;</span>
<span class="cp">#include &quot;cifsglob.h&quot;</span>
<span class="cp">#include &quot;cifsproto.h&quot;</span>
<span class="cp">#include &quot;cifs_debug.h&quot;</span>
<span class="cp">#include &quot;smberr.h&quot;</span>
<span class="cp">#include &quot;nterr.h&quot;</span>
<span class="cp">#include &quot;cifs_unicode.h&quot;</span>

<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_sm_req_poolp</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_req_poolp</span><span class="p">;</span>

<span class="cm">/* The xid serves as a useful identifier for each incoming vfs request,</span>
<span class="cm">   in a similar way to the mid which is useful to track each sent smb,</span>
<span class="cm">   and CurrentXid can also provide a running counter (although it</span>
<span class="cm">   will eventually wrap past zero) of the total vfs operations handled</span>
<span class="cm">   since the cifs fs was mounted */</span>

<span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">_GetXid</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
	<span class="n">GlobalTotalActiveXid</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* keep high water mark for number of simultaneous ops in filesystem */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GlobalTotalActiveXid</span> <span class="o">&gt;</span> <span class="n">GlobalMaxActiveXid</span><span class="p">)</span>
		<span class="n">GlobalMaxActiveXid</span> <span class="o">=</span> <span class="n">GlobalTotalActiveXid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">GlobalTotalActiveXid</span> <span class="o">&gt;</span> <span class="mi">65000</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;warning: more than 65000 requests active&quot;</span><span class="p">);</span>
	<span class="n">xid</span> <span class="o">=</span> <span class="n">GlobalCurrentXid</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">xid</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">_FreeXid</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
	<span class="cm">/* if (GlobalTotalActiveXid == 0)</span>
<span class="cm">		BUG(); */</span>
	<span class="n">GlobalTotalActiveXid</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cifs_ses</span> <span class="o">*</span>
<span class="nf">sesInfoAlloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_ses</span> <span class="o">*</span><span class="n">ret_buf</span><span class="p">;</span>

	<span class="n">ret_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_ses</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sesInfoAllocCount</span><span class="p">);</span>
		<span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">status</span> <span class="o">=</span> <span class="n">CifsNew</span><span class="p">;</span>
		<span class="o">++</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">ses_count</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">smb_ses_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">tcon_list</span><span class="p">);</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">session_mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">sesInfoFree</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_ses</span> <span class="o">*</span><span class="n">buf_to_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_to_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Null buffer passed to sesInfoFree&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sesInfoAllocCount</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">serverOS</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">serverDomain</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">serverNOS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">user_name</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">domainName</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span>
<span class="nf">tconInfoAlloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">ret_buf</span><span class="p">;</span>
	<span class="n">ret_buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_tcon</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tconInfoAllocCount</span><span class="p">);</span>
		<span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">tidStatus</span> <span class="o">=</span> <span class="n">CifsNew</span><span class="p">;</span>
		<span class="o">++</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">tc_count</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">tcon_list</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret_buf</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">tconInfoFree</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">buf_to_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_to_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Null buffer passed to tconInfoFree&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tconInfoAllocCount</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">nativeFileSystem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="o">-&gt;</span><span class="n">password</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf_to_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span>
<span class="nf">cifs_buf_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">ret_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* We could use negotiated size instead of max_msgsize -</span>
<span class="cm">   but it may be more efficient to always alloc same size</span>
<span class="cm">   albeit slightly larger than necessary and maxbuffersize</span>
<span class="cm">   defaults to this and can not be bigger */</span>
	<span class="n">ret_buf</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">cifs_req_poolp</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="cm">/* clear the first few header bytes */</span>
	<span class="cm">/* for most paths, more is cleared in header_assemble */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">ret_buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufAllocCount</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">totBufAllocCount</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_STATS2 */</span><span class="cp"></span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">cifs_buf_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_to_free</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">buf_to_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* cFYI(1, &quot;Null buffer passed to cifs_buf_release&quot;);*/</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">buf_to_free</span><span class="p">,</span> <span class="n">cifs_req_poolp</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufAllocCount</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span>
<span class="nf">cifs_small_buf_get</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">ret_buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="cm">/* We could use negotiated size instead of max_msgsize -</span>
<span class="cm">   but it may be more efficient to always alloc same size</span>
<span class="cm">   albeit slightly larger than necessary and maxbuffersize</span>
<span class="cm">   defaults to this and can not be bigger */</span>
	<span class="n">ret_buf</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">cifs_sm_req_poolp</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret_buf</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* No need to clear memory here, cleared in header assemble */</span>
	<span class="cm">/*	memset(ret_buf, 0, sizeof(struct smb_hdr) + 27);*/</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smBufAllocCount</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">totSmBufAllocCount</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_STATS2 */</span><span class="cp"></span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret_buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">cifs_small_buf_release</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf_to_free</span><span class="p">)</span>
<span class="p">{</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf_to_free</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Null buffer passed to cifs_small_buf_release&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mempool_free</span><span class="p">(</span><span class="n">buf_to_free</span><span class="p">,</span> <span class="n">cifs_sm_req_poolp</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smBufAllocCount</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* NB: MID can not be set if treeCon not passed in, in that</span>
<span class="cm">   case it is responsbility of caller to set the mid */</span>
<span class="kt">void</span>
<span class="nf">header_assemble</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="kt">char</span> <span class="n">smb_command</span> <span class="cm">/* command */</span> <span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">treeCon</span><span class="p">,</span> <span class="kt">int</span> <span class="n">word_count</span>
		<span class="cm">/* length of fixed section (word count) in two byte units  */</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">temp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">buffer</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">temp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">256</span><span class="p">);</span> <span class="cm">/* bigger than MAX_CIFS_HDR_SIZE */</span>

	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">smb_buf_length</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span>
	    <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">word_count</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">)</span> <span class="o">-</span>
	    <span class="mi">4</span> <span class="cm">/*  RFC 1001 length field does not count */</span>  <span class="o">+</span>
	    <span class="mi">2</span> <span class="cm">/* for bcc field itself */</span><span class="p">)</span> <span class="p">;</span>

	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Protocol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mh">0xFF</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Protocol</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;S&#39;</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Protocol</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;M&#39;</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Protocol</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Command</span> <span class="o">=</span> <span class="n">smb_command</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">=</span> <span class="mh">0x00</span><span class="p">;</span>	<span class="cm">/* case sensitive */</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Flags2</span> <span class="o">=</span> <span class="n">SMBFLG2_KNOWS_LONG_NAMES</span><span class="p">;</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Pid</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">__u16</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">);</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">PidHigh</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">((</span><span class="n">__u16</span><span class="p">)(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">treeCon</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Tid</span> <span class="o">=</span> <span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">tid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_UNICODE</span><span class="p">)</span>
				<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Flags2</span> <span class="o">|=</span> <span class="n">SMBFLG2_UNICODE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_STATUS32</span><span class="p">)</span>
				<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Flags2</span> <span class="o">|=</span> <span class="n">SMBFLG2_ERR_STATUS</span><span class="p">;</span>

			<span class="cm">/* Uid is not converted */</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Uid</span> <span class="o">=</span> <span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">Suid</span><span class="p">;</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Mid</span> <span class="o">=</span> <span class="n">get_next_mid</span><span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SMB_SHARE_IS_IN_DFS</span><span class="p">)</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Flags2</span> <span class="o">|=</span> <span class="n">SMBFLG2_DFS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">nocase</span><span class="p">)</span>
			<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Flags</span>  <span class="o">|=</span> <span class="n">SMBFLG_CASELESS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">))</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">treeCon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">sec_mode</span> <span class="o">&amp;</span>
			  <span class="p">(</span><span class="n">SECMODE_SIGN_REQUIRED</span> <span class="o">|</span> <span class="n">SECMODE_SIGN_ENABLED</span><span class="p">))</span>
				<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">Flags2</span> <span class="o">|=</span> <span class="n">SMBFLG2_SECURITY_SIGNATURE</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cm">/*  endian conversion of flags is now done just before sending */</span>
	<span class="n">buffer</span><span class="o">-&gt;</span><span class="n">WordCount</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span> <span class="n">word_count</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">check_smb_hdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">smb</span><span class="p">,</span> <span class="n">__u16</span> <span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* does it have the right SMB &quot;signature&quot; ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le32</span> <span class="o">*</span><span class="p">)</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">Protocol</span> <span class="o">!=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mh">0x424d53ff</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bad protocol string signature header 0x%x&quot;</span><span class="p">,</span>
			<span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">smb</span><span class="o">-&gt;</span><span class="n">Protocol</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Make sure that message ids match */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">!=</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Mids do not match. received=%u expected=%u&quot;</span><span class="p">,</span>
			<span class="n">smb</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if it&#39;s a response then accept */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smb</span><span class="o">-&gt;</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SMBFLG_RESPONSE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* only one valid case where server sends us request */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">smb</span><span class="o">-&gt;</span><span class="n">Command</span> <span class="o">==</span> <span class="n">SMB_COM_LOCKING_ANDX</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Server sent request, not response. mid=%u&quot;</span><span class="p">,</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">checkSMB</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">smb</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">mid</span> <span class="o">=</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">rfclen</span> <span class="o">=</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">smb</span><span class="o">-&gt;</span><span class="n">smb_buf_length</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">clc_len</span><span class="p">;</span>  <span class="cm">/* calculated length */</span>
	<span class="n">cFYI</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">&quot;checkSMB Length: 0x%x, smb_buf_length: 0x%x&quot;</span><span class="p">,</span>
		<span class="n">total_read</span><span class="p">,</span> <span class="n">rfclen</span><span class="p">);</span>

	<span class="cm">/* is this frame too small to even get to a BCC? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_read</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">total_read</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			    <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">smb</span><span class="o">-&gt;</span><span class="n">Status</span><span class="p">.</span><span class="n">CifsError</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* it&#39;s an error return */</span>
			<span class="n">smb</span><span class="o">-&gt;</span><span class="n">WordCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="cm">/* some error cases do not return wct and bcc */</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">total_read</span> <span class="o">==</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
				<span class="p">(</span><span class="n">smb</span><span class="o">-&gt;</span><span class="n">WordCount</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">smb</span><span class="p">;</span>
			<span class="cm">/* Need to work around a bug in two servers here */</span>
			<span class="cm">/* First, check if the part of bcc they sent was zero */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">)]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* some servers return only half of bcc</span>
<span class="cm">				 * on simple responses (wct, bcc both zero)</span>
<span class="cm">				 * in particular have seen this on</span>
<span class="cm">				 * ulogoffX and FindClose. This leaves</span>
<span class="cm">				 * one byte of bcc potentially unitialized</span>
<span class="cm">				 */</span>
				<span class="cm">/* zero rest of bcc */</span>
				<span class="n">tmp</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;rcvd invalid byte count (bcc)&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Length less than smb header size&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* otherwise, there is enough to get to the BCC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_smb_hdr</span><span class="p">(</span><span class="n">smb</span><span class="p">,</span> <span class="n">mid</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">clc_len</span> <span class="o">=</span> <span class="n">smbCalcSize</span><span class="p">(</span><span class="n">smb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">rfclen</span> <span class="o">!=</span> <span class="n">total_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Length read does not match RFC1001 length %d&quot;</span><span class="p">,</span>
				<span class="n">rfclen</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">rfclen</span> <span class="o">!=</span> <span class="n">clc_len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* check if bcc wrapped around for large read responses */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">rfclen</span> <span class="o">&gt;</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rfclen</span> <span class="o">&gt;</span> <span class="n">clc_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* check if lengths match mod 64K */</span>
			<span class="k">if</span> <span class="p">(((</span><span class="mi">4</span> <span class="o">+</span> <span class="n">rfclen</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">clc_len</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* bcc wrapped */</span>
		<span class="p">}</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Calculated size %u vs length %u mismatch for mid=%u&quot;</span><span class="p">,</span>
				<span class="n">clc_len</span><span class="p">,</span> <span class="mi">4</span> <span class="o">+</span> <span class="n">rfclen</span><span class="p">,</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="mi">4</span> <span class="o">+</span> <span class="n">rfclen</span> <span class="o">&lt;</span> <span class="n">clc_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;RFC1001 size %u smaller than SMB for mid=%u&quot;</span><span class="p">,</span>
					<span class="n">rfclen</span><span class="p">,</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rfclen</span> <span class="o">&gt;</span> <span class="n">clc_len</span> <span class="o">+</span> <span class="mi">512</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Some servers (Windows XP in particular) send more</span>
<span class="cm">			 * data than the lengths in the SMB packet would</span>
<span class="cm">			 * indicate on certain calls (byte range locks and</span>
<span class="cm">			 * trans2 find first calls in particular). While the</span>
<span class="cm">			 * client can handle such a frame by ignoring the</span>
<span class="cm">			 * trailing data, we choose limit the amount of extra</span>
<span class="cm">			 * data to 512 bytes.</span>
<span class="cm">			 */</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;RFC1001 size %u more than 512 bytes larger &quot;</span>
				  <span class="s">&quot;than SMB for mid=%u&quot;</span><span class="p">,</span> <span class="n">rfclen</span><span class="p">,</span> <span class="n">smb</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">bool</span>
<span class="nf">is_valid_oplock_break</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span> <span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">srv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smb_com_lock_req</span> <span class="o">*</span><span class="n">pSMB</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smb_com_lock_req</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp1</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_ses</span> <span class="o">*</span><span class="n">ses</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">pCifsInode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">netfile</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Checking for oplock break or dnotify response&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Command</span> <span class="o">==</span> <span class="n">SMB_COM_NT_TRANSACT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SMBFLG_RESPONSE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">smb_com_transaction_change_notify_rsp</span> <span class="o">*</span><span class="n">pSMBr</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">smb_com_transaction_change_notify_rsp</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">file_notify_information</span> <span class="o">*</span><span class="n">pnotify</span><span class="p">;</span>
		<span class="n">__u32</span> <span class="n">data_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">get_bcc</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_notify_information</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">data_offset</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pSMBr</span><span class="o">-&gt;</span><span class="n">DataOffset</span><span class="p">);</span>

			<span class="n">pnotify</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">file_notify_information</span> <span class="o">*</span><span class="p">)</span>
				<span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">pSMBr</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Protocol</span> <span class="o">+</span> <span class="n">data_offset</span><span class="p">);</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dnotify on %s Action: 0x%x&quot;</span><span class="p">,</span>
				 <span class="n">pnotify</span><span class="o">-&gt;</span><span class="n">FileName</span><span class="p">,</span> <span class="n">pnotify</span><span class="o">-&gt;</span><span class="n">Action</span><span class="p">);</span>
			<span class="cm">/*   cifs_dump_mem(&quot;Rcvd notify Data: &quot;,buf,</span>
<span class="cm">				sizeof(struct smb_hdr)+60); */</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pSMBr</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Status</span><span class="p">.</span><span class="n">CifsError</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;notify err 0x%d&quot;</span><span class="p">,</span>
				<span class="n">pSMBr</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Status</span><span class="p">.</span><span class="n">CifsError</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Command</span> <span class="o">!=</span> <span class="n">SMB_COM_LOCKING_ANDX</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SMBFLG_RESPONSE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* no sense logging error on invalid handle on oplock</span>
<span class="cm">		   break - harmless race between close request and oplock</span>
<span class="cm">		   break response is expected from time to time writing out</span>
<span class="cm">		   large dirty files cached on the client */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">NT_STATUS_INVALID_HANDLE</span><span class="p">)</span> <span class="o">==</span>
		   <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Status</span><span class="p">.</span><span class="n">CifsError</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;invalid handle on oplock break&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ERRbadfid</span> <span class="o">==</span>
		   <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">Status</span><span class="p">.</span><span class="n">DosError</span><span class="p">.</span><span class="n">Error</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="cm">/* on valid oplock brk we get &quot;request&quot; */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">.</span><span class="n">WordCount</span> <span class="o">!=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;oplock type 0x%d level 0x%d&quot;</span><span class="p">,</span>
		 <span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">LockType</span><span class="p">,</span> <span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">OplockLevel</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">LockType</span> <span class="o">&amp;</span> <span class="n">LOCKING_ANDX_OPLOCK_RELEASE</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/* look up tcon based on tid &amp; uid */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">srv</span><span class="o">-&gt;</span><span class="n">smb_ses_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ses</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifs_ses</span><span class="p">,</span> <span class="n">smb_ses_list</span><span class="p">);</span>
		<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">tcon_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">tcon</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifs_tcon</span><span class="p">,</span> <span class="n">tcon_list</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">tid</span> <span class="o">!=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">Tid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">cifs_stats_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">num_oplock_brks</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
			<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">netfile</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp2</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsFileInfo</span><span class="p">,</span>
						     <span class="n">tlist</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">Fid</span> <span class="o">!=</span> <span class="n">netfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>

				<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;file id match, oplock break&quot;</span><span class="p">);</span>
				<span class="n">pCifsInode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">netfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

				<span class="n">cifs_set_oplock_level</span><span class="p">(</span><span class="n">pCifsInode</span><span class="p">,</span>
					<span class="n">pSMB</span><span class="o">-&gt;</span><span class="n">OplockLevel</span> <span class="o">?</span> <span class="n">OPLOCK_READ</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">queue_work</span><span class="p">(</span><span class="n">cifsiod_wq</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">netfile</span><span class="o">-&gt;</span><span class="n">oplock_break</span><span class="p">);</span>
				<span class="n">netfile</span><span class="o">-&gt;</span><span class="n">oplock_break_cancelled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;No matching file for oplock break&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>
	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Can not process oplock break for non-existent connection&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">dump_smb</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">smb_buf_length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">debug_line</span><span class="p">[</span><span class="mi">17</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">traceSMB</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">smb_buf_length</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* have reached the beginning of line */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;| &quot;</span><span class="p">);</span>
			<span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;%0#4x &quot;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">debug_line</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">isprint</span><span class="p">(</span><span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">debug_line</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="n">buffer</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">else</span>
			<span class="n">debug_line</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="sc">&#39;_&#39;</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">8</span> <span class="o">==</span> <span class="mi">7</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* reached end of line, time to print ascii */</span>
			<span class="n">debug_line</span><span class="p">[</span><span class="mi">16</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; | %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">debug_line</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;     &quot;</span><span class="p">);</span>
		<span class="n">debug_line</span><span class="p">[</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
		<span class="n">debug_line</span><span class="p">[</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">j</span><span class="p">)]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot; | %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">debug_line</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">cifs_autodisable_serverino</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SERVER_INUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">CIFS_MOUNT_SERVER_INUM</span><span class="p">;</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Autodisabling the use of server inode numbers on &quot;</span>
			   <span class="s">&quot;%s. This server doesn&#39;t seem to support them &quot;</span>
			   <span class="s">&quot;properly. Hardlinks will not be recognized on this &quot;</span>
			   <span class="s">&quot;mount. Consider mounting with the </span><span class="se">\&quot;</span><span class="s">noserverino</span><span class="se">\&quot;</span><span class="s"> &quot;</span>
			   <span class="s">&quot;option to silence this message.&quot;</span><span class="p">,</span>
			   <span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">treeName</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cifs_set_oplock_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">oplock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">oplock</span> <span class="o">&amp;=</span> <span class="mh">0xF</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">oplock</span> <span class="o">==</span> <span class="n">OPLOCK_EXCLUSIVE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheAll</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Exclusive Oplock granted on inode %p&quot;</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">oplock</span> <span class="o">==</span> <span class="n">OPLOCK_READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheAll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Level II Oplock granted on inode %p&quot;</span><span class="p">,</span>
		    <span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheAll</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="n">bool</span>
<span class="nf">backup_cred</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_CIFS_BACKUPUID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_backupuid</span> <span class="o">==</span> <span class="n">current_fsuid</span><span class="p">())</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_CIFS_BACKUPGID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">in_group_p</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_backupgid</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
