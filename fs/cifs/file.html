<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cifs › file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   fs/cifs/file.c</span>
<span class="cm"> *</span>
<span class="cm"> *   vfs operations that deal with files</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright (C) International Business Machines  Corp., 2002,2010</span>
<span class="cm"> *   Author(s): Steve French (sfrench@us.ibm.com)</span>
<span class="cm"> *              Jeremy Allison (jra@samba.org)</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU Lesser General Public License as published</span>
<span class="cm"> *   by the Free Software Foundation; either version 2.1 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> *   along with this library; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/fcntl.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/task_io_accounting_ops.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;asm/div64.h&gt;</span>
<span class="cp">#include &quot;cifsfs.h&quot;</span>
<span class="cp">#include &quot;cifspdu.h&quot;</span>
<span class="cp">#include &quot;cifsglob.h&quot;</span>
<span class="cp">#include &quot;cifsproto.h&quot;</span>
<span class="cp">#include &quot;cifs_unicode.h&quot;</span>
<span class="cp">#include &quot;cifs_debug.h&quot;</span>
<span class="cp">#include &quot;cifs_fs_sb.h&quot;</span>
<span class="cp">#include &quot;fscache.h&quot;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cifs_convert_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">GENERIC_READ</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_WRONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">GENERIC_WRITE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_RDWR</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* GENERIC_ALL is too much permission to request</span>
<span class="cm">		   can cause unnecessary access denied on create */</span>
		<span class="cm">/* return GENERIC_ALL; */</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">GENERIC_READ</span> <span class="o">|</span> <span class="n">GENERIC_WRITE</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="p">(</span><span class="n">READ_CONTROL</span> <span class="o">|</span> <span class="n">FILE_WRITE_ATTRIBUTES</span> <span class="o">|</span> <span class="n">FILE_READ_ATTRIBUTES</span> <span class="o">|</span>
		<span class="n">FILE_WRITE_EA</span> <span class="o">|</span> <span class="n">FILE_APPEND_DATA</span> <span class="o">|</span> <span class="n">FILE_WRITE_DATA</span> <span class="o">|</span>
		<span class="n">FILE_READ_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u32</span> <span class="nf">cifs_posix_convert_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">posix_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_RDONLY</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">=</span> <span class="n">SMB_O_RDONLY</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_WRONLY</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">=</span> <span class="n">SMB_O_WRONLY</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_RDWR</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">=</span> <span class="n">SMB_O_RDWR</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">|=</span> <span class="n">SMB_O_CREAT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_EXCL</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">|=</span> <span class="n">SMB_O_EXCL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">|=</span> <span class="n">SMB_O_TRUNC</span><span class="p">;</span>
	<span class="cm">/* be safe and imply O_SYNC for O_DSYNC */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_DSYNC</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">|=</span> <span class="n">SMB_O_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECTORY</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">|=</span> <span class="n">SMB_O_DIRECTORY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_NOFOLLOW</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">|=</span> <span class="n">SMB_O_NOFOLLOW</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECT</span><span class="p">)</span>
		<span class="n">posix_flags</span> <span class="o">|=</span> <span class="n">SMB_O_DIRECT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">posix_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">cifs_get_disposition</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FILE_CREATE</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">))</span> <span class="o">==</span> <span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">FILE_OVERWRITE_IF</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_CREAT</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_CREAT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FILE_OPEN_IF</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">O_TRUNC</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_TRUNC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">FILE_OVERWRITE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">FILE_OPEN</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_posix_open</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">**</span><span class="n">pinode</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_flags</span><span class="p">,</span>
			<span class="n">__u32</span> <span class="o">*</span><span class="n">poplock</span><span class="p">,</span> <span class="n">__u16</span> <span class="o">*</span><span class="n">pnetfid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">FILE_UNIX_BASIC_INFO</span> <span class="o">*</span><span class="n">presp_data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">posix_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_fattr</span> <span class="n">fattr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;posix open %s&quot;</span><span class="p">,</span> <span class="n">full_path</span><span class="p">);</span>

	<span class="n">presp_data</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FILE_UNIX_BASIC_INFO</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">presp_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tlink</span> <span class="o">=</span> <span class="n">cifs_sb_tlink</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">posix_open_ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">current_umask</span><span class="p">();</span>

	<span class="n">posix_flags</span> <span class="o">=</span> <span class="n">cifs_posix_convert_flags</span><span class="p">(</span><span class="n">f_flags</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSPOSIXCreate</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">posix_flags</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">pnetfid</span><span class="p">,</span> <span class="n">presp_data</span><span class="p">,</span>
			     <span class="n">poplock</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span>
			     <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span>
					<span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>
	<span class="n">cifs_put_tlink</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">posix_open_ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">presp_data</span><span class="o">-&gt;</span><span class="n">Type</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">posix_open_ret</span><span class="p">;</span> <span class="cm">/* open ok, caller does qpathinfo */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pinode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">posix_open_ret</span><span class="p">;</span> <span class="cm">/* caller does not need info */</span>

	<span class="n">cifs_unix_basic_to_fattr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fattr</span><span class="p">,</span> <span class="n">presp_data</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="p">);</span>

	<span class="cm">/* get new inode and set it up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">pinode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifs_fill_uniqueid</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="p">);</span>
		<span class="o">*</span><span class="n">pinode</span> <span class="o">=</span> <span class="n">cifs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pinode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">posix_open_ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cifs_fattr_to_inode</span><span class="p">(</span><span class="o">*</span><span class="n">pinode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fattr</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">posix_open_ret:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">presp_data</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_nt_open</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">,</span>
	     <span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">f_flags</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">poplock</span><span class="p">,</span>
	     <span class="n">__u16</span> <span class="o">*</span><span class="n">pnetfid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">desiredAccess</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disposition</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">create_options</span> <span class="o">=</span> <span class="n">CREATE_NOT_DIR</span><span class="p">;</span>
	<span class="n">FILE_ALL_INFO</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">desiredAccess</span> <span class="o">=</span> <span class="n">cifs_convert_flags</span><span class="p">(</span><span class="n">f_flags</span><span class="p">);</span>

<span class="cm">/*********************************************************************</span>
<span class="cm"> *  open flag mapping table:</span>
<span class="cm"> *</span>
<span class="cm"> *	POSIX Flag            CIFS Disposition</span>
<span class="cm"> *	----------            ----------------</span>
<span class="cm"> *	O_CREAT               FILE_OPEN_IF</span>
<span class="cm"> *	O_CREAT | O_EXCL      FILE_CREATE</span>
<span class="cm"> *	O_CREAT | O_TRUNC     FILE_OVERWRITE_IF</span>
<span class="cm"> *	O_TRUNC               FILE_OVERWRITE</span>
<span class="cm"> *	none of the above     FILE_OPEN</span>
<span class="cm"> *</span>
<span class="cm"> *	Note that there is not a direct match between disposition</span>
<span class="cm"> *	FILE_SUPERSEDE (ie create whether or not file exists although</span>
<span class="cm"> *	O_CREAT | O_TRUNC is similar but truncates the existing</span>
<span class="cm"> *	file rather than creating a new file as FILE_SUPERSEDE does</span>
<span class="cm"> *	(which uses the attributes / metadata passed in on open call)</span>
<span class="cm"> *?</span>
<span class="cm"> *?  O_SYNC is a reasonable match to CIFS writethrough flag</span>
<span class="cm"> *?  and the read write flags match reasonably.  O_LARGEFILE</span>
<span class="cm"> *?  is irrelevant because largefile support is always used</span>
<span class="cm"> *?  by this client. Flags O_APPEND, O_DIRECT, O_DIRECTORY,</span>
<span class="cm"> *	 O_FASYNC, O_NOFOLLOW, O_NONBLOCK need further investigation</span>
<span class="cm"> *********************************************************************/</span>

	<span class="n">disposition</span> <span class="o">=</span> <span class="n">cifs_get_disposition</span><span class="p">(</span><span class="n">f_flags</span><span class="p">);</span>

	<span class="cm">/* BB pass O_SYNC flag through on file attributes .. BB */</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">FILE_ALL_INFO</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">backup_cred</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">))</span>
		<span class="n">create_options</span> <span class="o">|=</span> <span class="n">CREATE_OPEN_BACKUP_INTENT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_NT_SMBS</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBOpen</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">disposition</span><span class="p">,</span>
			 <span class="n">desiredAccess</span><span class="p">,</span> <span class="n">create_options</span><span class="p">,</span> <span class="n">pnetfid</span><span class="p">,</span> <span class="n">poplock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
			 <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span>
				 <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SMBLegacyOpen</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">disposition</span><span class="p">,</span>
			<span class="n">desiredAccess</span><span class="p">,</span> <span class="n">CREATE_NOT_DIR</span><span class="p">,</span> <span class="n">pnetfid</span><span class="p">,</span> <span class="n">poplock</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
			<span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span>
				<span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info_unix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					      <span class="n">xid</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
					 <span class="n">xid</span><span class="p">,</span> <span class="n">pnetfid</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span>
<span class="nf">cifs_new_fileinfo</span><span class="p">(</span><span class="n">__u16</span> <span class="n">fileHandle</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">oplock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">pCifsInode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">pCifsFile</span><span class="p">;</span>

	<span class="n">pCifsFile</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pCifsFile</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">pCifsFile</span><span class="p">;</span>

	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">netfid</span> <span class="o">=</span> <span class="n">fileHandle</span><span class="p">;</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">;</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">invalidHandle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">tlink</span> <span class="o">=</span> <span class="n">cifs_get_tlink</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">fh_mutex</span><span class="p">);</span>
	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">oplock_break</span><span class="p">,</span> <span class="n">cifs_oplock_break</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">tlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">tlink_tcon</span><span class="p">(</span><span class="n">tlink</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">));</span>
	<span class="cm">/* if readable file instance put first in list*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pCifsInode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pCifsInode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>

	<span class="n">cifs_set_oplock_level</span><span class="p">(</span><span class="n">pCifsInode</span><span class="p">,</span> <span class="n">oplock</span><span class="p">);</span>
	<span class="n">pCifsInode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span> <span class="o">=</span> <span class="n">pCifsInode</span><span class="o">-&gt;</span><span class="n">clientCanCacheAll</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">pCifsFile</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">pCifsFile</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">cifs_del_lock_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">lock</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * Release a reference on the file private data. This may involve closing</span>
<span class="cm"> * the filehandle out on the server. Must be called without holding</span>
<span class="cm"> * cifs_file_list_lock.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cifsFileInfo_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cifs_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifsi</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">li</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* remove it from the lists */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">tlist</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;closing last open instance for inode %p&quot;</span><span class="p">,</span>
			<span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

		<span class="cm">/* in strict cache mode we need invalidate mapping on the last</span>
<span class="cm">		   close  because it may cause a error when we open this file</span>
<span class="cm">		   again and get at least level II oplock */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_STRICT_IO</span><span class="p">)</span>
			<span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">invalid_mapping</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">cifs_set_oplock_level</span><span class="p">(</span><span class="n">cifsi</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>

	<span class="n">cancel_work_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">oplock_break</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">need_reconnect</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">xid</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>

		<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Delete any outstanding lock records. We&#39;ll lose them when the file</span>
<span class="cm">	 * is closed anyway.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
		<span class="n">cifs_del_lock_waiters</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>

	<span class="n">cifs_put_tlink</span><span class="p">(</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">cifs_file</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cifs_file</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_open</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">oplock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tcon_link</span> <span class="o">*</span><span class="n">tlink</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">pCifsFile</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">posix_open_ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">netfid</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">tlink</span> <span class="o">=</span> <span class="n">cifs_sb_tlink</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>

	<span class="n">full_path</span> <span class="o">=</span> <span class="n">build_path_from_dentry</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;inode = 0x%p file flags are 0x%x for %s&quot;</span><span class="p">,</span>
		 <span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">,</span> <span class="n">full_path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">oplocks</span><span class="p">)</span>
		<span class="n">oplock</span> <span class="o">=</span> <span class="n">REQ_OPLOCK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">oplock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">broken_posix_open</span> <span class="o">&amp;&amp;</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_UNIX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">CIFS_UNIX_POSIX_PATH_OPS_CAP</span> <span class="o">&amp;</span>
			<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">fsUnixInfo</span><span class="p">.</span><span class="n">Capability</span><span class="p">)))</span> <span class="p">{</span>
		<span class="cm">/* can not refresh inode info since size could be stale */</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_posix_open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				<span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_file_mode</span> <span class="cm">/* ignored */</span><span class="p">,</span>
				<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netfid</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;posix open succeeded&quot;</span><span class="p">);</span>
			<span class="n">posix_open_ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">serverNOS</span><span class="p">)</span>
				<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;server %s of type %s returned&quot;</span>
					   <span class="s">&quot; unexpected error on SMB posix open&quot;</span>
					   <span class="s">&quot;, disabling posix open support.&quot;</span>
					   <span class="s">&quot; Check if server update available.&quot;</span><span class="p">,</span>
					   <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">serverName</span><span class="p">,</span>
					   <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">serverNOS</span><span class="p">);</span>
			<span class="n">tcon</span><span class="o">-&gt;</span><span class="n">broken_posix_open</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EREMOTE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">))</span> <span class="cm">/* path not found or net err */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/* else fallthrough to retry open the old way on network i/o</span>
<span class="cm">		   or DFS errors */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">posix_open_ok</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_nt_open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span>
				  <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netfid</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pCifsFile</span> <span class="o">=</span> <span class="n">cifs_new_fileinfo</span><span class="p">(</span><span class="n">netfid</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">tlink</span><span class="p">,</span> <span class="n">oplock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pCifsFile</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CIFSSMBClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">netfid</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cifs_fscache_set_inode_cookie</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">oplock</span> <span class="o">&amp;</span> <span class="n">CIFS_CREATE_ACTION</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">posix_open_ok</span> <span class="o">&amp;&amp;</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* time to set mode which we can not set earlier due to</span>
<span class="cm">		   problems creating new read-only files */</span>
		<span class="k">struct</span> <span class="n">cifs_unix_set_info_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">mode</span>	<span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			<span class="p">.</span><span class="n">uid</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">gid</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">ctime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">atime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">mtime</span>	<span class="o">=</span> <span class="n">NO_CHANGE_64</span><span class="p">,</span>
			<span class="p">.</span><span class="n">device</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">};</span>
		<span class="n">CIFSSMBUnixSetFileInfo</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">netfid</span><span class="p">,</span>
					<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="n">cifs_put_tlink</span><span class="p">(</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Try to reacquire byte range locks that were released when session */</span>
<span class="cm">/* to server was lost */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_relock_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cifsFile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cm">/* BB list all locks open on this file and relock */</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_reopen_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">pCifsFile</span><span class="p">,</span> <span class="n">bool</span> <span class="n">can_flush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">oplock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">pCifsInode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">desiredAccess</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">disposition</span> <span class="o">=</span> <span class="n">FILE_OPEN</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">create_options</span> <span class="o">=</span> <span class="n">CREATE_NOT_DIR</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">netfid</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">fh_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">fh_mutex</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

<span class="cm">/* can not grab rename sem here because various ops, including</span>
<span class="cm">   those that already have the rename sem can end up causing writepage</span>
<span class="cm">   to get called and if the server was down that means we end up here,</span>
<span class="cm">   and we can never tell if the caller already has the rename_sem */</span>
	<span class="n">full_path</span> <span class="o">=</span> <span class="n">build_path_from_dentry</span><span class="p">(</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">fh_mutex</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;inode = 0x%p file flags 0x%x for %s&quot;</span><span class="p">,</span>
		 <span class="n">inode</span><span class="p">,</span> <span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">,</span> <span class="n">full_path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">oplocks</span><span class="p">)</span>
		<span class="n">oplock</span> <span class="o">=</span> <span class="n">REQ_OPLOCK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">oplock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_UNIX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">CIFS_UNIX_POSIX_PATH_OPS_CAP</span> <span class="o">&amp;</span>
			<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">fsUnixInfo</span><span class="p">.</span><span class="n">Capability</span><span class="p">)))</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * O_CREAT, O_EXCL and O_TRUNC already had their effect on the</span>
<span class="cm">		 * original open. Must mask them off for a reopen.</span>
<span class="cm">		 */</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">oflags</span> <span class="o">=</span> <span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span>
						<span class="o">~</span><span class="p">(</span><span class="n">O_CREAT</span> <span class="o">|</span> <span class="n">O_EXCL</span> <span class="o">|</span> <span class="n">O_TRUNC</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_posix_open</span><span class="p">(</span><span class="n">full_path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				<span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_file_mode</span> <span class="cm">/* ignored */</span><span class="p">,</span>
				<span class="n">oflags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netfid</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;posix reopen succeeded&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">reopen_success</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* fallthrough to retry open the old way on errors, especially</span>
<span class="cm">		   in the reconnect path it is important to retry hard */</span>
	<span class="p">}</span>

	<span class="n">desiredAccess</span> <span class="o">=</span> <span class="n">cifs_convert_flags</span><span class="p">(</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">backup_cred</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">))</span>
		<span class="n">create_options</span> <span class="o">|=</span> <span class="n">CREATE_OPEN_BACKUP_INTENT</span><span class="p">;</span>

	<span class="cm">/* Can not refresh inode by passing in file_info buf to be returned</span>
<span class="cm">	   by SMBOpen and then calling get_inode_info with returned buf</span>
<span class="cm">	   since file might have write behind data that needs to be flushed</span>
<span class="cm">	   and server version of file size can be stale. If we knew for sure</span>
<span class="cm">	   that inode was not dirty locally we could do this */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBOpen</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">full_path</span><span class="p">,</span> <span class="n">disposition</span><span class="p">,</span> <span class="n">desiredAccess</span><span class="p">,</span>
			 <span class="n">create_options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">netfid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">oplock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			 <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span>
				<span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">fh_mutex</span><span class="p">);</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_open returned 0x%x&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;oplock: %d&quot;</span><span class="p">,</span> <span class="n">oplock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">reopen_error_exit</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">reopen_success:</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">netfid</span> <span class="o">=</span> <span class="n">netfid</span><span class="p">;</span>
	<span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">invalidHandle</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pCifsFile</span><span class="o">-&gt;</span><span class="n">fh_mutex</span><span class="p">);</span>
	<span class="n">pCifsInode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">can_flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
		<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info_unix</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">full_path</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_get_inode_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">full_path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span>
				<span class="n">xid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="cm">/* else we are writing out data to server already</span>
<span class="cm">	     and could deadlock if we tried to flush data, and</span>
<span class="cm">	     since we do not know if we have data that would</span>
<span class="cm">	     invalidate the current end of file on the server</span>
<span class="cm">	     we can not go to the server to get the new inod</span>
<span class="cm">	     info */</span>

	<span class="n">cifs_set_oplock_level</span><span class="p">(</span><span class="n">pCifsInode</span><span class="p">,</span> <span class="n">oplock</span><span class="p">);</span>

	<span class="n">cifs_relock_file</span><span class="p">(</span><span class="n">pCifsFile</span><span class="p">);</span>

<span class="nl">reopen_error_exit:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_close</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifsFileInfo_put</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* return code from the -&gt;release op is always ignored */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_closedir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">pCFileStruct</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptmp</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Closedir inode = 0x%p&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pCFileStruct</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">pTcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Freeing private data in close dir&quot;</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">srch_inf</span><span class="p">.</span><span class="n">endOfSearch</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">invalidHandle</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSFindClose</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">pTcon</span><span class="p">,</span> <span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">);</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Closing uncompleted readdir with rc %d&quot;</span><span class="p">,</span>
				 <span class="n">rc</span><span class="p">);</span>
			<span class="cm">/* not much we can do if it fails anyway, ignore rc */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
		<span class="n">ptmp</span> <span class="o">=</span> <span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">srch_inf</span><span class="p">.</span><span class="n">ntwrk_buf_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;closedir free smb buf in srch struct&quot;</span><span class="p">);</span>
			<span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">srch_inf</span><span class="p">.</span><span class="n">ntwrk_buf_start</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">srch_inf</span><span class="p">.</span><span class="n">smallBuf</span><span class="p">)</span>
				<span class="n">cifs_small_buf_release</span><span class="p">(</span><span class="n">ptmp</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">cifs_buf_release</span><span class="p">(</span><span class="n">ptmp</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cifs_put_tlink</span><span class="p">(</span><span class="n">pCFileStruct</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">);</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* BB can we lock the filestruct while this is going on? */</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span>
<span class="nf">cifs_lock_init</span><span class="p">(</span><span class="n">__u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">length</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">lock</span> <span class="o">=</span>
		<span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsLockInfo</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">lock</span><span class="p">;</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">lock</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">block_q</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">lock</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_del_lock_waiters</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">li</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">,</span> <span class="n">blist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">block_q</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">cifs_find_fid_lock_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">offset</span><span class="p">,</span>
			    <span class="n">__u64</span> <span class="n">length</span><span class="p">,</span> <span class="n">__u8</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cur</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">**</span><span class="n">conf_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">li</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">||</span>
		    <span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			 <span class="p">((</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">ops</span><span class="o">-&gt;</span><span class="n">compare_fids</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">cfile</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">==</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span> <span class="o">||</span> <span class="n">type</span> <span class="o">==</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">conf_lock</span> <span class="o">=</span> <span class="n">li</span><span class="p">;</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">cifs_find_lock_conflict</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">length</span><span class="p">,</span>
			<span class="n">__u8</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">**</span><span class="n">conf_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">rc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">fid</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">,</span> <span class="n">flist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_find_fid_lock_conflict</span><span class="p">(</span><span class="n">fid</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
						 <span class="n">cfile</span><span class="p">,</span> <span class="n">conf_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if there is another lock that prevents us to set the lock (mandatory</span>
<span class="cm"> * style). If such a lock exists, update the flock structure with its</span>
<span class="cm"> * properties. Otherwise, set the flock type to F_UNLCK if we can cache brlocks</span>
<span class="cm"> * or leave it the same if we can&#39;t. Returns 0 if we don&#39;t need to request to</span>
<span class="cm"> * the server or 1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_lock_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">length</span><span class="p">,</span>
	       <span class="n">__u8</span> <span class="n">type</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">conf_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">exist</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>

	<span class="n">exist</span> <span class="o">=</span> <span class="n">cifs_find_lock_conflict</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">conf_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">exist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">conf_lock</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">=</span> <span class="n">conf_lock</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">conf_lock</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_pid</span> <span class="o">=</span> <span class="n">conf_lock</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">conf_lock</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">)</span>
			<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_RDLCK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_lock_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the byte-range lock (mandatory style). Returns:</span>
<span class="cm"> * 1) 0, if we set the lock and don&#39;t need to request to the server;</span>
<span class="cm"> * 2) 1, if no locks prevent us but we need to request to the server;</span>
<span class="cm"> * 3) -EACCESS, if there is a lock that prevents us and wait is false.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_lock_add_if</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span>
		 <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">conf_lock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">exist</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">try_again:</span>
	<span class="n">exist</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>

	<span class="n">exist</span> <span class="o">=</span> <span class="n">cifs_find_lock_conflict</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">lock</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span>
					<span class="n">lock</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exist</span> <span class="o">&amp;&amp;</span> <span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">exist</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">conf_lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">block_q</span><span class="p">,</span>
					<span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">.</span><span class="n">prev</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
					<span class="p">(</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">.</span><span class="n">next</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="o">-&gt;</span><span class="n">blist</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check if there is another lock that prevents us to set the lock (posix</span>
<span class="cm"> * style). If such a lock exists, update the flock structure with its</span>
<span class="cm"> * properties. Otherwise, set the flock type to F_UNLCK if we can cache brlocks</span>
<span class="cm"> * or leave it the same if we can&#39;t. Returns 0 if we don&#39;t need to request to</span>
<span class="cm"> * the server or 1 otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_posix_lock_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">saved_type</span> <span class="o">=</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_POSIX</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="n">posix_test_lock</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">flock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">saved_type</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Set the byte-range lock (posix style). Returns:</span>
<span class="cm"> * 1) 0, if we set the lock and don&#39;t need to request to the server;</span>
<span class="cm"> * 2) 1, if we need to request to the server;</span>
<span class="cm"> * 3) &lt;0, if the error occurs while setting the lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_posix_lock_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_POSIX</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

<span class="nl">try_again:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">posix_lock_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">flock</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="n">FILE_LOCK_DEFERRED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_event_interruptible</span><span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_wait</span><span class="p">,</span> <span class="o">!</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">try_again</span><span class="p">;</span>
		<span class="n">locks_delete_block</span><span class="p">(</span><span class="n">flock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_push_mandatory_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">,</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stored_rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">li</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">max_num</span><span class="p">,</span> <span class="n">max_buf</span><span class="p">;</span>
	<span class="n">LOCKING_ANDX_RANGE</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">LOCKING_ANDX_LARGE_FILES</span><span class="p">,</span>
		       <span class="n">LOCKING_ANDX_SHARED_LOCK</span> <span class="o">|</span> <span class="n">LOCKING_ANDX_LARGE_FILES</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>
	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Accessing maxBuf is racy with cifs_reconnect - need to store value</span>
<span class="cm">	 * and check it for zero before using.</span>
<span class="cm">	 */</span>
	<span class="n">max_buf</span> <span class="o">=</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">maxBuf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_buf</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">))</span> <span class="o">/</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">LOCKING_ANDX_RANGE</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">max_num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LOCKING_ANDX_RANGE</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">Pid</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">LengthLow</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">LengthHigh</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">));</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">OffsetLow</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">OffsetHigh</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">num</span> <span class="o">==</span> <span class="n">max_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stored_rc</span> <span class="o">=</span> <span class="n">cifs_lockv</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">,</span>
						       <span class="p">(</span><span class="n">__u8</span><span class="p">)</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
						       <span class="n">buf</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">stored_rc</span><span class="p">)</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="n">stored_rc</span><span class="p">;</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
				<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">cur</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stored_rc</span> <span class="o">=</span> <span class="n">cifs_lockv</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">,</span>
					       <span class="p">(</span><span class="n">__u8</span><span class="p">)</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stored_rc</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">stored_rc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* copied from fs/locks.c with a name change */</span>
<span class="cp">#define cifs_for_each_lock(inode, lockp) \</span>
<span class="cp">	for (lockp = &amp;inode-&gt;i_flock; *lockp != NULL; \</span>
<span class="cp">	     lockp = &amp;(*lockp)-&gt;fl_next)</span>

<span class="k">struct</span> <span class="n">lock_to_push</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">llist</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">netfid</span><span class="p">;</span>
	<span class="n">__u8</span> <span class="n">type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_push_posix_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">,</span> <span class="o">**</span><span class="n">before</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">xid</span><span class="p">,</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">locks_to_send</span><span class="p">,</span> <span class="o">*</span><span class="n">el</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">lock_to_push</span> <span class="o">*</span><span class="n">lck</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">cifs_for_each_lock</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">before</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">before</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_POSIX</span><span class="p">)</span>
			<span class="n">count</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locks_to_send</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocating count locks is enough because no FL_POSIX locks can be</span>
<span class="cm">	 * added to the list while we are holding cinode-&gt;lock_mutex that</span>
<span class="cm">	 * protects locking operations of this inode.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lck</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">lock_to_push</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lck</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locks_to_send</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">el</span> <span class="o">=</span> <span class="n">locks_to_send</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
	<span class="n">lock_flocks</span><span class="p">();</span>
	<span class="n">cifs_for_each_lock</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">before</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flock</span> <span class="o">=</span> <span class="o">*</span><span class="n">before</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_POSIX</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">el</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">locks_to_send</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The list ended. We don&#39;t have enough allocated</span>
<span class="cm">			 * structures - something is really wrong.</span>
<span class="cm">			 */</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Can&#39;t push all brlocks!&quot;</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">-</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_RDLCK</span> <span class="o">||</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_SHLCK</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">CIFS_RDLCK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">CIFS_WRLCK</span><span class="p">;</span>
		<span class="n">lck</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="k">struct</span> <span class="n">lock_to_push</span><span class="p">,</span> <span class="n">llist</span><span class="p">);</span>
		<span class="n">lck</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_pid</span><span class="p">;</span>
		<span class="n">lck</span><span class="o">-&gt;</span><span class="n">netfid</span> <span class="o">=</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">;</span>
		<span class="n">lck</span><span class="o">-&gt;</span><span class="n">length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">lck</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
		<span class="n">lck</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
		<span class="n">el</span> <span class="o">=</span> <span class="n">el</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">unlock_flocks</span><span class="p">();</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lck</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locks_to_send</span><span class="p">,</span> <span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">file_lock</span> <span class="n">tmp_lock</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">stored_rc</span><span class="p">;</span>

		<span class="n">tmp_lock</span><span class="p">.</span><span class="n">fl_start</span> <span class="o">=</span> <span class="n">lck</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">stored_rc</span> <span class="o">=</span> <span class="n">CIFSSMBPosixLock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">lck</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">,</span> <span class="n">lck</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="n">lck</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_lock</span><span class="p">,</span>
					     <span class="n">lck</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">stored_rc</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">stored_rc</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lck</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>

	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="nl">err_out:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">lck</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">locks_to_send</span><span class="p">,</span> <span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lck</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">lck</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_push_locks</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_UNIX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">CIFS_UNIX_FCNTL_CAP</span> <span class="o">&amp;</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">fsUnixInfo</span><span class="p">.</span><span class="n">Capability</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NOPOSIXBRL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">cifs_push_posix_locks</span><span class="p">(</span><span class="n">cfile</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cifs_push_mandatory_locks</span><span class="p">(</span><span class="n">cfile</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_read_flock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">,</span> <span class="n">__u32</span> <span class="o">*</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">unlock</span><span class="p">,</span>
		<span class="n">bool</span> <span class="o">*</span><span class="n">wait_flag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_POSIX</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Posix&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_FLOCK</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Flock&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_SLEEP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Blocking lock&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">wait_flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_ACCESS</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Process suspended by mandatory locking - &quot;</span>
			<span class="s">&quot;not implemented yet&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_LEASE</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Lease on file - not implemented yet&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span>
	    <span class="p">(</span><span class="o">~</span><span class="p">(</span><span class="n">FL_POSIX</span> <span class="o">|</span> <span class="n">FL_FLOCK</span> <span class="o">|</span> <span class="n">FL_SLEEP</span> <span class="o">|</span> <span class="n">FL_ACCESS</span> <span class="o">|</span> <span class="n">FL_LEASE</span><span class="p">)))</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Unknown lock flags 0x%x&quot;</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span><span class="p">);</span>

	<span class="o">*</span><span class="n">type</span> <span class="o">=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">large_lock_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_WRLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;F_WRLCK &quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">|=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">exclusive_lock_type</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_UNLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;F_UNLCK&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">|=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">unlock_lock_type</span><span class="p">;</span>
		<span class="o">*</span><span class="n">unlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/* Check if unlock includes more than one lock range */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_RDLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;F_RDLCK&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">|=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_EXLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;F_EXLCK&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">|=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">exclusive_lock_type</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">==</span> <span class="n">F_SHLCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;F_SHLCK&quot;</span><span class="p">);</span>
		<span class="o">*</span><span class="n">type</span> <span class="o">|=</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Unknown type of lock&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_mandatory_lock</span><span class="p">(</span><span class="kt">int</span> <span class="n">xid</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">offset</span><span class="p">,</span>
		    <span class="n">__u64</span> <span class="n">length</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unlock</span><span class="p">,</span> <span class="n">bool</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">CIFSSMBLock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">),</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">,</span>
			   <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">unlock</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">__u8</span><span class="p">)</span><span class="n">type</span><span class="p">,</span> <span class="n">wait</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_getlk</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">type</span><span class="p">,</span>
	   <span class="n">bool</span> <span class="n">wait_flag</span><span class="p">,</span> <span class="n">bool</span> <span class="n">posix_lck</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">-</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">netfid</span> <span class="o">=</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">posix_lck</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">posix_lock_type</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_posix_lock_test</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">flock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">)</span>
			<span class="n">posix_lock_type</span> <span class="o">=</span> <span class="n">CIFS_RDLCK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">posix_lock_type</span> <span class="o">=</span> <span class="n">CIFS_WRLCK</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBPosixLock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">netfid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">,</span>
				      <span class="mi">1</span> <span class="cm">/* get */</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">flock</span><span class="p">,</span>
				      <span class="n">posix_lock_type</span><span class="p">,</span> <span class="n">wait_flag</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_lock_test</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">flock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* BB we could chain these into one lock request BB */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_mandatory_lock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">cfile</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span>
				 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_mandatory_lock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">cfile</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
					 <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_UNLCK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Error unlocking previously locked &quot;</span>
				  <span class="s">&quot;range %d during test of lock&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_mandatory_lock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">cfile</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
				 <span class="n">type</span> <span class="o">|</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_mandatory_lock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">cfile</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
					 <span class="n">type</span> <span class="o">|</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_RDLCK</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Error unlocking previously locked &quot;</span>
				  <span class="s">&quot;range %d during test of lock&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span> <span class="o">=</span> <span class="n">F_WRLCK</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_move_llist</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">source</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">li</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">source</span><span class="p">)</span>
		<span class="n">list_move</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_free_llist</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">llist</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">li</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">llist</span><span class="p">,</span> <span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifs_del_lock_waiters</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_unlock_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">stored_rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">LOCKING_ANDX_LARGE_FILES</span><span class="p">,</span>
		       <span class="n">LOCKING_ANDX_SHARED_LOCK</span> <span class="o">|</span> <span class="n">LOCKING_ANDX_LARGE_FILES</span><span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_num</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="n">max_buf</span><span class="p">;</span>
	<span class="n">LOCKING_ANDX_RANGE</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">li</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">-</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tmp_llist</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_llist</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Accessing maxBuf is racy with cifs_reconnect - need to store value</span>
<span class="cm">	 * and check it for zero before using.</span>
<span class="cm">	 */</span>
	<span class="n">max_buf</span> <span class="o">=</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">maxBuf</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">max_num</span> <span class="o">=</span> <span class="p">(</span><span class="n">max_buf</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">))</span> <span class="o">/</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="n">LOCKING_ANDX_RANGE</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">max_num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">LOCKING_ANDX_RANGE</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">li</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="n">llist</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">&gt;</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">||</span>
			    <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span> <span class="o">+</span> <span class="n">length</span><span class="p">)</span> <span class="o">&lt;</span>
			    <span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span> <span class="o">!=</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="n">li</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">can_cache_brlcks</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We can cache brlock requests - simply remove</span>
<span class="cm">				 * a lock from the file&#39;s list.</span>
<span class="cm">				 */</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
				<span class="n">cifs_del_lock_waiters</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">li</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">Pid</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">);</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">LengthLow</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">LengthHigh</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">length</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">));</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">OffsetLow</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">cur</span><span class="o">-&gt;</span><span class="n">OffsetHigh</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">((</span><span class="n">u32</span><span class="p">)(</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">&gt;&gt;</span><span class="mi">32</span><span class="p">));</span>
			<span class="cm">/*</span>
<span class="cm">			 * We need to save a lock here to let us add it again to</span>
<span class="cm">			 * the file&#39;s list if the unlock range request fails on</span>
<span class="cm">			 * the server.</span>
<span class="cm">			 */</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">li</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_llist</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">num</span> <span class="o">==</span> <span class="n">max_num</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">stored_rc</span> <span class="o">=</span> <span class="n">cifs_lockv</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">,</span>
						       <span class="n">li</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">stored_rc</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * We failed on the unlock range</span>
<span class="cm">					 * request - add all locks from the tmp</span>
<span class="cm">					 * list to the head of the file&#39;s list.</span>
<span class="cm">					 */</span>
					<span class="n">cifs_move_llist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_llist</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
					<span class="n">rc</span> <span class="o">=</span> <span class="n">stored_rc</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span>
					<span class="cm">/*</span>
<span class="cm">					 * The unlock range request succeed -</span>
<span class="cm">					 * free the tmp list.</span>
<span class="cm">					 */</span>
					<span class="n">cifs_free_llist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_llist</span><span class="p">);</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
				<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">cur</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">stored_rc</span> <span class="o">=</span> <span class="n">cifs_lockv</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">,</span>
					       <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">num</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stored_rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cifs_move_llist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_llist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">llist</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">stored_rc</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">cifs_free_llist</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_llist</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_setlk</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">type</span><span class="p">,</span>
	   <span class="n">bool</span> <span class="n">wait_flag</span><span class="p">,</span> <span class="n">bool</span> <span class="n">posix_lck</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unlock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">xid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_end</span> <span class="o">-</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span> <span class="o">=</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">netfid</span> <span class="o">=</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">posix_lck</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">posix_lock_type</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_posix_lock_set</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">flock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span> <span class="o">||</span> <span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">shared_lock_type</span><span class="p">)</span>
			<span class="n">posix_lock_type</span> <span class="o">=</span> <span class="n">CIFS_RDLCK</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">posix_lock_type</span> <span class="o">=</span> <span class="n">CIFS_WRLCK</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlock</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">posix_lock_type</span> <span class="o">=</span> <span class="n">CIFS_UNLCK</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBPosixLock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">netfid</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">,</span>
				      <span class="mi">0</span> <span class="cm">/* set */</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">flock</span><span class="p">,</span>
				      <span class="n">posix_lock_type</span><span class="p">,</span> <span class="n">wait_flag</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">cifsLockInfo</span> <span class="o">*</span><span class="n">lock</span><span class="p">;</span>

		<span class="n">lock</span> <span class="o">=</span> <span class="n">cifs_lock_init</span><span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_lock_add_if</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">wait_flag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_mandatory_lock</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">cfile</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
					 <span class="n">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wait_flag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cifs_lock_add</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlock</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_unlock_range</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">flock</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span> <span class="o">&amp;</span> <span class="n">FL_POSIX</span><span class="p">)</span>
		<span class="n">posix_lock_file_wait</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">flock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">*</span><span class="n">flock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">xid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">unlock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wait_flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">posix_lck</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">netfid</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Lock parm: 0x%x flockflags: 0x%x flocktype: 0x%x start: %lld &quot;</span>
		<span class="s">&quot;end: %lld&quot;</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_flags</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_type</span><span class="p">,</span>
		<span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_start</span><span class="p">,</span> <span class="n">flock</span><span class="o">-&gt;</span><span class="n">fl_end</span><span class="p">);</span>

	<span class="n">cfile</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="p">)</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

	<span class="n">cifs_read_flock</span><span class="p">(</span><span class="n">flock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unlock</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait_flag</span><span class="p">,</span>
			<span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">);</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="n">netfid</span> <span class="o">=</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">;</span>
	<span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_UNIX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">CIFS_UNIX_FCNTL_CAP</span> <span class="o">&amp;</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">fsUnixInfo</span><span class="p">.</span><span class="n">Capability</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NOPOSIXBRL</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">posix_lck</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * BB add code here to normalize offset and length to account for</span>
<span class="cm">	 * negative length which we can not accept over the wire.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_GETLK</span><span class="p">(</span><span class="n">cmd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_getlk</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">flock</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">wait_flag</span><span class="p">,</span> <span class="n">posix_lck</span><span class="p">,</span> <span class="n">xid</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lock</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">unlock</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if no lock or unlock then nothing to do since we do not</span>
<span class="cm">		 * know what it is</span>
<span class="cm">		 */</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_setlk</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">flock</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">wait_flag</span><span class="p">,</span> <span class="n">posix_lck</span><span class="p">,</span> <span class="n">lock</span><span class="p">,</span> <span class="n">unlock</span><span class="p">,</span>
			<span class="n">xid</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update the file size (if needed) after a write. Should be called with</span>
<span class="cm"> * the inode-&gt;i_lock held</span>
<span class="cm"> */</span>
<span class="kt">void</span>
<span class="nf">cifs_update_eof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifsi</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
		      <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_written</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">end_of_write</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">bytes_written</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">end_of_write</span> <span class="o">&gt;</span> <span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">server_eof</span><span class="p">)</span>
		<span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">server_eof</span> <span class="o">=</span> <span class="n">end_of_write</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cifs_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">pid</span><span class="p">,</span>
			  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">write_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">write_size</span><span class="p">,</span>
			  <span class="n">loff_t</span> <span class="o">*</span><span class="n">poffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_written</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">pTcon</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifsi</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_io_parms</span> <span class="n">io_parms</span><span class="p">;</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;write %zd bytes to offset %lld of %s&quot;</span><span class="p">,</span> <span class="n">write_size</span><span class="p">,</span>
	   <span class="o">*</span><span class="n">poffset</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>

	<span class="n">pTcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">total_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">write_size</span> <span class="o">&gt;</span> <span class="n">total_written</span><span class="p">;</span>
	     <span class="n">total_written</span> <span class="o">+=</span> <span class="n">bytes_written</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">kvec</span> <span class="n">iov</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we could deadlock if we called</span>
<span class="cm">				   filemap_fdatawait from here so tell</span>
<span class="cm">				   reopen_file not to flush data to</span>
<span class="cm">				   server now */</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_reopen_file</span><span class="p">(</span><span class="n">open_file</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">,</span>
				  <span class="n">write_size</span> <span class="o">-</span> <span class="n">total_written</span><span class="p">);</span>
			<span class="cm">/* iov[0] is reserved for smb header */</span>
			<span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">write_data</span> <span class="o">+</span> <span class="n">total_written</span><span class="p">;</span>
			<span class="n">iov</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">netfid</span> <span class="o">=</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">pTcon</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">poffset</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBWrite2</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_parms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_written</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
					   <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">total_written</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">cifs_update_eof</span><span class="p">(</span><span class="n">cifsi</span><span class="p">,</span> <span class="o">*</span><span class="n">poffset</span><span class="p">,</span> <span class="n">bytes_written</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="o">*</span><span class="n">poffset</span> <span class="o">+=</span> <span class="n">bytes_written</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cifs_stats_bytes_written</span><span class="p">(</span><span class="n">pTcon</span><span class="p">,</span> <span class="n">total_written</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total_written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">poffset</span> <span class="o">&gt;</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
			<span class="n">i_size_write</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="o">*</span><span class="n">poffset</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mark_inode_dirty_sync</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">total_written</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="nf">find_readable_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifs_inode</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">fsuid_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="cm">/* only filter by fsuid on multiuser mounts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MULTIUSER</span><span class="p">))</span>
		<span class="n">fsuid_only</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="cm">/* we could simply get the first_list_entry since write-only entries</span>
<span class="cm">	   are always at the end of the list but since the first entry might</span>
<span class="cm">	   have a close pending, we go through the whole list */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">open_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">,</span> <span class="n">flist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsuid_only</span> <span class="o">&amp;&amp;</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">current_fsuid</span><span class="p">())</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPEN_FMODE</span><span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* found a good file */</span>
				<span class="cm">/* lock it so it will not be closed on us */</span>
				<span class="n">cifsFileInfo_get</span><span class="p">(</span><span class="n">open_file</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">open_file</span><span class="p">;</span>
			<span class="p">}</span> <span class="cm">/* else might as well continue, and look for</span>
<span class="cm">			     another, or simply have the caller reopen it</span>
<span class="cm">			     again rather than trying to fix this handle */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="cm">/* write only file */</span>
			<span class="k">break</span><span class="p">;</span> <span class="cm">/* write only files are last so must be done */</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="nf">find_writable_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifs_inode</span><span class="p">,</span>
					<span class="n">bool</span> <span class="n">fsuid_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span><span class="p">,</span> <span class="o">*</span><span class="n">inv_file</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">any_available</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">refind</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Having a null inode here (because mapping-&gt;host was set to zero by</span>
<span class="cm">	the VFS or MM) should not happen but we had reports of on oops (due to</span>
<span class="cm">	it being zero) during stress testcases so we need to check for it */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_inode</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Null inode passed to cifs_writeable_file&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="cm">/* only filter by fsuid on multiuser mounts */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MULTIUSER</span><span class="p">))</span>
		<span class="n">fsuid_only</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
<span class="nl">refind_writable:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">refind</span> <span class="o">&gt;</span> <span class="n">MAX_REOPEN_ATT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">open_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">,</span> <span class="n">flist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">any_available</span> <span class="o">&amp;&amp;</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">!=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fsuid_only</span> <span class="o">&amp;&amp;</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">!=</span> <span class="n">current_fsuid</span><span class="p">())</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPEN_FMODE</span><span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* found a good writable file */</span>
				<span class="n">cifsFileInfo_get</span><span class="p">(</span><span class="n">open_file</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">open_file</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inv_file</span><span class="p">)</span>
					<span class="n">inv_file</span> <span class="o">=</span> <span class="n">open_file</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* couldn&#39;t find useable FH with same pid, try any available */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">any_available</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">any_available</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">refind_writable</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inv_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">any_available</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">cifsFileInfo_get</span><span class="p">(</span><span class="n">inv_file</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inv_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_reopen_file</span><span class="p">(</span><span class="n">inv_file</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">inv_file</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inv_file</span><span class="o">-&gt;</span><span class="n">flist</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
			<span class="n">cifsFileInfo_put</span><span class="p">(</span><span class="n">inv_file</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
			<span class="o">++</span><span class="n">refind</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">refind_writable</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_partialpagewrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">from</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">to</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">write_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">bytes_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span> <span class="o">||</span> <span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">from</span><span class="p">;</span>
	<span class="n">write_data</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">write_data</span> <span class="o">+=</span> <span class="n">from</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">to</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">from</span> <span class="o">&gt;</span> <span class="n">to</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* racing with truncate? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* don&#39;t care */</span>
	<span class="p">}</span>

	<span class="cm">/* check to make sure that we are not extending the file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">to</span><span class="p">)</span>
		<span class="n">to</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">open_file</span> <span class="o">=</span> <span class="n">find_writable_file</span><span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span> <span class="nb">false</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">open_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bytes_written</span> <span class="o">=</span> <span class="n">cifs_write</span><span class="p">(</span><span class="n">open_file</span><span class="p">,</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">,</span>
					   <span class="n">write_data</span><span class="p">,</span> <span class="n">to</span> <span class="o">-</span> <span class="n">from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">cifsFileInfo_put</span><span class="p">(</span><span class="n">open_file</span><span class="p">);</span>
		<span class="cm">/* Does mm or vfs already set times? */</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">current_fs_time</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">bytes_written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">offset</span><span class="p">))</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytes_written</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">bytes_written</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;No writeable filehandles for inode&quot;</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Marshal up the iov array, reserving the first one for the header. Also,</span>
<span class="cm"> * set wdata-&gt;bytes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_writepages_marshal_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifs_writedata</span> <span class="o">*</span><span class="n">wdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/* marshal up the pages into iov array */</span>
	<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iov</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">size</span> <span class="o">-</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]),</span>
					<span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="n">iov</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">+=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">bool</span> <span class="n">done</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">scanned</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="n">range_whole</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">end</span><span class="p">,</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_writedata</span> <span class="o">*</span><span class="n">wdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If wsize is smaller than the page cache size, default to writing</span>
<span class="cm">	 * one page at a time via cifs_writepage</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">wsize</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">generic_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span><span class="p">;</span> <span class="cm">/* Start from prev offset */</span>
		<span class="n">end</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span> <span class="o">==</span> <span class="n">LLONG_MAX</span><span class="p">)</span>
			<span class="n">range_whole</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">scanned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">retry:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">found_pages</span><span class="p">;</span>
		<span class="n">pgoff_t</span> <span class="n">next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">tofind</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>

		<span class="n">tofind</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">wsize</span> <span class="o">/</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">end</span> <span class="o">-</span> <span class="n">index</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">wdata</span> <span class="o">=</span> <span class="n">cifs_writedata_alloc</span><span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">tofind</span><span class="p">,</span>
					     <span class="n">cifs_writev_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wdata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * find_get_pages_tag seems to return a max of 256 on each</span>
<span class="cm">		 * iteration, so we must call it several times in order to</span>
<span class="cm">		 * fill the array or the wsize is effectively limited to</span>
<span class="cm">		 * 256 * PAGE_CACHE_SIZE.</span>
<span class="cm">		 */</span>
		<span class="n">found_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">;</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">find_get_pages_tag</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span>
							<span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">,</span>
							<span class="n">tofind</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
			<span class="n">found_pages</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>
			<span class="n">tofind</span> <span class="o">-=</span> <span class="n">nr_pages</span><span class="p">;</span>
			<span class="n">pages</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">&amp;&amp;</span> <span class="n">tofind</span> <span class="o">&amp;&amp;</span> <span class="n">index</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_writedata_release</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">found_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="cm">/*</span>
<span class="cm">			 * At this point we hold neither mapping-&gt;tree_lock nor</span>
<span class="cm">			 * lock on the page itself: the page may be truncated or</span>
<span class="cm">			 * invalidated (changing page-&gt;mapping to NULL), or even</span>
<span class="cm">			 * swizzled back from swapper_space to tmpfs file</span>
<span class="cm">			 * mapping</span>
<span class="cm">			 */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">&amp;&amp;</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">next</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* Not next consecutive page */</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_NONE</span><span class="p">)</span>
				<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span>
					<span class="o">!</span><span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * This actually clears the dirty bit in the radix tree.</span>
<span class="cm">			 * See cifs_writepage() for more commentary.</span>
<span class="cm">			 */</span>
			<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">++</span><span class="n">nr_pages</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* reset index to refind any pages skipped */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">index</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* put any pages we aren&#39;t going to use */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">found_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* nothing to write? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_writedata_release</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span><span class="p">;</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">marshal_iov</span> <span class="o">=</span> <span class="n">cifs_writepages_marshal_iov</span><span class="p">;</span>

		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
				<span class="n">cifsFileInfo_put</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="p">);</span>
			<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span> <span class="o">=</span> <span class="n">find_writable_file</span><span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
							  <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;No writable handles for inode&quot;</span><span class="p">);</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_async_writev</span><span class="p">(</span><span class="n">wdata</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">&amp;&amp;</span> <span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

		<span class="cm">/* send failure -- clean up the mess */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
					<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span>
							   <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="k">else</span>
					<span class="n">SetPageError</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_writedata_release</span><span class="p">);</span>

		<span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">-=</span> <span class="n">nr_pages</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">scanned</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">done</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We hit the last page and there is more work to be done: wrap</span>
<span class="cm">		 * back to the start of the file</span>
<span class="cm">		 */</span>
		<span class="n">scanned</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">||</span> <span class="p">(</span><span class="n">range_whole</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="n">mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">=</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_writepage_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>
<span class="cm">/* BB add check for wbc flags */</span>
	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;ppw - page not up to date&quot;</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set the &quot;writeback&quot; flag, and clear &quot;dirty&quot; in the radix tree.</span>
<span class="cm">	 *</span>
<span class="cm">	 * A writepage() implementation always needs to do either this,</span>
<span class="cm">	 * or re-dirty the page with &quot;redirty_page_for_writepage()&quot; in</span>
<span class="cm">	 * the case of a failure.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Just unlocking the page will cause the radix tree tag-bits</span>
<span class="cm">	 * to fail to update with the state of the page correctly.</span>
<span class="cm">	 */</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">retry_write:</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_partialpagewrite</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">retry_write</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
		<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_writepage_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_RWPIDFORWARD</span><span class="p">)</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;write_end for page %p from pos %lld with %d bytes&quot;</span><span class="p">,</span>
		 <span class="n">page</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">copied</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">page_data</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>

		<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>
		<span class="cm">/* this is probably better than directly calling</span>
<span class="cm">		   partialpage_write since in this function the file handle is</span>
<span class="cm">		   known which we might as well	leverage */</span>
		<span class="cm">/* BB check if anything else missing out of ppw</span>
<span class="cm">		   such as updating last write time */</span>
		<span class="n">page_data</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_write</span><span class="p">(</span><span class="n">cfile</span><span class="p">,</span> <span class="n">pid</span><span class="p">,</span> <span class="n">page_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
		<span class="cm">/* if (rc &lt; 0) should we set writebehind rc? */</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="n">pos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
			<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_strict_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">smbfile</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Sync file - name: %s datasync: 0x%x&quot;</span><span class="p">,</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_invalidate_mapping</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;rc: %d during invalidate phase&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* don&#39;t care about it in fsync */</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">smbfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NOSSYNC</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBFlush</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">smbfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">);</span>

	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">smbfile</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Sync file - name: %s datasync: 0x%x&quot;</span><span class="p">,</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>

	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">smbfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NOSSYNC</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBFlush</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">smbfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">);</span>

	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * As file closes, flush all cached write data for this inode checking</span>
<span class="cm"> * for write behind errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cifs_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">fl_owner_t</span> <span class="n">id</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_write_and_wait</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Flush inode %p file %p rc %d&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_write_allocate_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_HIGHMEM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * save number of pages we have already allocated and</span>
<span class="cm">			 * return with ENOMEM error</span>
<span class="cm">			 */</span>
			<span class="n">num_pages</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span>
<span class="kt">size_t</span> <span class="nf">get_numpages</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span> <span class="n">wsize</span><span class="p">,</span> <span class="k">const</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">cur_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">clen</span><span class="p">;</span>

	<span class="n">clen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">wsize</span><span class="p">);</span>
	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">clen</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_len</span><span class="p">)</span>
		<span class="o">*</span><span class="n">cur_len</span> <span class="o">=</span> <span class="n">clen</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">num_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_uncached_marshal_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifs_writedata</span> <span class="o">*</span><span class="n">wdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">;</span>

	<span class="cm">/* marshal up the pages into iov array */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iov</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">iov</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_uncached_writev_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_writedata</span> <span class="o">*</span><span class="n">wdata</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cifs_writedata</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifsi</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">cifs_update_eof</span><span class="p">(</span><span class="n">cifsi</span><span class="p">,</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">server_eof</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">server_eof</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_writedata_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* attempt to send write to server, retry on any -EAGAIN errors */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_uncached_retry_writev</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_writedata</span> <span class="o">*</span><span class="n">wdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_reopen_file</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_async_writev</span><span class="p">(</span><span class="n">wdata</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">cifs_iovec_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">poffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">copied</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">cur_len</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">total_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iov_iter</span> <span class="n">it</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_writedata</span> <span class="o">*</span><span class="n">wdata</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">wdata_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">generic_write_checks</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">poffset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata_list</span><span class="p">);</span>
	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="n">open_file</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">poffset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_RWPIDFORWARD</span><span class="p">)</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="n">iov_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">it</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">save_len</span><span class="p">;</span>

		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">get_numpages</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_len</span><span class="p">);</span>
		<span class="n">wdata</span> <span class="o">=</span> <span class="n">cifs_writedata_alloc</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span>
					     <span class="n">cifs_uncached_writev_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wdata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_write_allocate_pages</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">wdata</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">save_len</span> <span class="o">=</span> <span class="n">cur_len</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">cur_len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="n">iov_iter_copy_from_user</span><span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">it</span><span class="p">,</span>
							 <span class="mi">0</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
			<span class="n">cur_len</span> <span class="o">-=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="n">iov_iter_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">it</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cur_len</span> <span class="o">=</span> <span class="n">save_len</span> <span class="o">-</span> <span class="n">cur_len</span><span class="p">;</span>

		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">WB_SYNC_ALL</span><span class="p">;</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">cfile</span> <span class="o">=</span> <span class="n">cifsFileInfo_get</span><span class="p">(</span><span class="n">open_file</span><span class="p">);</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">cur_len</span><span class="p">;</span>
		<span class="n">wdata</span><span class="o">-&gt;</span><span class="n">marshal_iov</span> <span class="o">=</span> <span class="n">cifs_uncached_marshal_iov</span><span class="p">;</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_uncached_retry_writev</span><span class="p">(</span><span class="n">wdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_writedata_release</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wdata_list</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">cur_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">cur_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If at least one write was successfully sent, then discard any rc</span>
<span class="cm">	 * value from the later writes. If the other write succeeds, then</span>
<span class="cm">	 * we&#39;ll end up returning whatever was written. If it fails, then</span>
<span class="cm">	 * we&#39;ll get a new rc value from that.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata_list</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wait for and collect replies for any successful sends in order of</span>
<span class="cm">	 * increasing offset. Once an error is hit or we get a fatal signal</span>
<span class="cm">	 * while waiting, then return without waiting for any more replies.</span>
<span class="cm">	 */</span>
<span class="nl">restart_loop:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">wdata</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wdata_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* FIXME: freezable too? */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_for_completion_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">total_written</span> <span class="o">+=</span> <span class="n">wdata</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">;</span>

			<span class="cm">/* resend call if it&#39;s a retryable error */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_uncached_retry_writev</span><span class="p">(</span><span class="n">wdata</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">restart_loop</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_writedata_release</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total_written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="o">*</span><span class="n">poffset</span> <span class="o">+=</span> <span class="n">total_written</span><span class="p">;</span>

	<span class="n">cifs_stats_bytes_written</span><span class="p">(</span><span class="n">tcon</span><span class="p">,</span> <span class="n">total_written</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">total_written</span> <span class="o">?</span> <span class="n">total_written</span> <span class="o">:</span> <span class="p">(</span><span class="kt">ssize_t</span><span class="p">)</span><span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">cifs_user_writev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * BB - optimize the way when signing is disabled. We can drop this</span>
<span class="cm">	 * extra memory-to-memory copying and use iovec buffers for constructing</span>
<span class="cm">	 * write request.</span>
<span class="cm">	 */</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">cifs_iovec_write</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">invalid_mapping</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">cifs_strict_writev</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheAll</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">generic_file_aio_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In strict cache mode we need to write the data to the server exactly</span>
<span class="cm">	 * from the pos to pos+len-1 rather than flush all affected pages</span>
<span class="cm">	 * because it may cause a error with mandatory locks on these pages but</span>
<span class="cm">	 * not on the region from pos to ppos+len-1.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">cifs_user_writev</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span>
<span class="nf">cifs_readdata_alloc</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_vecs</span><span class="p">,</span> <span class="n">work_func_t</span> <span class="n">complete</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>

	<span class="n">rdata</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rdata</span><span class="p">)</span> <span class="o">+</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">kvec</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_vecs</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kref_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">init_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">,</span> <span class="n">complete</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rdata</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="nf">cifs_readdata_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">refcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">refcount</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cifs_readdata</span><span class="p">,</span> <span class="n">refcount</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="p">)</span>
		<span class="n">cifsFileInfo_put</span><span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_read_allocate_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tpage</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">npages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_KERNEL</span><span class="o">|</span><span class="n">__GFP_HIGHMEM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_uncached_readdata_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">kref</span> <span class="o">*</span><span class="n">refcount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tpage</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">refcount</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">cifs_readdata</span><span class="p">,</span> <span class="n">refcount</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cifs_readdata_release</span><span class="p">(</span><span class="n">refcount</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_retry_async_readv</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_reopen_file</span><span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">cfile</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_async_readv</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * cifs_readdata_to_iov - copy data from pages in response to an iovec</span>
<span class="cm"> * @rdata:	the readdata response with list of pages holding data</span>
<span class="cm"> * @iov:	vector in which we should copy the data</span>
<span class="cm"> * @nr_segs:	number of segments in vector</span>
<span class="cm"> * @offset:	offset into file of the first iovec</span>
<span class="cm"> * @copied:	used to return the amount of data copied to the iov</span>
<span class="cm"> *</span>
<span class="cm"> * This function copies data from a list of pages in a readdata response into</span>
<span class="cm"> * an array of iovecs. It will first calculate where the data should go</span>
<span class="cm"> * based on the info in the readdata and then copy the data into that spot.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">cifs_readdata_to_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">ssize_t</span> <span class="o">*</span><span class="n">copied</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iov_iter</span> <span class="n">ii</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tpage</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">remaining</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pdata</span><span class="p">;</span>

	<span class="cm">/* set up iov_iter and advance to the correct offset */</span>
	<span class="n">iov_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">iov_iter_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="o">*</span><span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">ssize_t</span> <span class="n">copy</span><span class="p">;</span>

		<span class="cm">/* copy a whole page or whatever&#39;s left */</span>
		<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">ssize_t</span><span class="p">,</span> <span class="n">remaining</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="cm">/* ...but limit it to whatever space is left in the iov */</span>
		<span class="n">copy</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">ssize_t</span><span class="p">,</span> <span class="n">copy</span><span class="p">,</span> <span class="n">iov_iter_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="p">));</span>

		<span class="cm">/* go while there&#39;s data to be copied and no errors */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pdata</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">memcpy_toiovecend</span><span class="p">(</span><span class="n">ii</span><span class="p">.</span><span class="n">iov</span><span class="p">,</span> <span class="n">pdata</span><span class="p">,</span> <span class="n">ii</span><span class="p">.</span><span class="n">iov_offset</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">copy</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">copied</span> <span class="o">+=</span> <span class="n">copy</span><span class="p">;</span>
				<span class="n">remaining</span> <span class="o">-=</span> <span class="n">copy</span><span class="p">;</span>
				<span class="n">iov_iter_advance</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="p">,</span> <span class="n">copy</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_uncached_readv_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">cifs_readdata</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="cm">/* if the result is non-zero then the pages weren&#39;t kmapped */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_uncached_readdata_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_uncached_read_marshal_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remaining</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tpage</span><span class="p">;</span>

	<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enough data to fill the page */</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%u: idx=%lu iov_base=%p iov_len=%zu&quot;</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span><span class="p">);</span>
			<span class="o">++</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enough for partial page, fill and zero the rest */</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%u: idx=%lu iov_base=%p iov_len=%zu&quot;</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">remaining</span><span class="p">,</span>
				<span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">remaining</span><span class="p">);</span>
			<span class="o">++</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">remaining</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* no need to hold page hostage */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">cifs_iovec_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">poffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">rc</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">cur_len</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">total_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">poffset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">npages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span><span class="p">,</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">rdata_list</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_segs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata_list</span><span class="p">);</span>
	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="n">open_file</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">tcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_RWPIDFORWARD</span><span class="p">)</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_WRONLY</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;attempting read on write only file instance&quot;</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">cur_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="k">const</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">total_read</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">rsize</span><span class="p">);</span>
		<span class="n">npages</span> <span class="o">=</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">cur_len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="cm">/* allocate a readdata struct */</span>
		<span class="n">rdata</span> <span class="o">=</span> <span class="n">cifs_readdata_alloc</span><span class="p">(</span><span class="n">npages</span><span class="p">,</span>
					    <span class="n">cifs_uncached_readv_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rdata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_read_allocate_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>

		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">cfile</span> <span class="o">=</span> <span class="n">cifsFileInfo_get</span><span class="p">(</span><span class="n">open_file</span><span class="p">);</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">cur_len</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">marshal_iov</span> <span class="o">=</span> <span class="n">cifs_uncached_read_marshal_iov</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_retry_async_readv</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
<span class="nl">error:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span>
				 <span class="n">cifs_uncached_readdata_release</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_list</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">cur_len</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">cur_len</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* if at least one read request send succeeded, then reset rc */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata_list</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* the loop below should proceed in the order of increasing offsets */</span>
<span class="nl">restart_loop:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">rdata</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">ssize_t</span> <span class="n">copied</span><span class="p">;</span>

			<span class="cm">/* FIXME: freezable sleep too? */</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">wait_for_completion_killable</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">)</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">rdata</span><span class="o">-&gt;</span><span class="n">result</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_readdata_to_iov</span><span class="p">(</span><span class="n">rdata</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
							<span class="n">nr_segs</span><span class="p">,</span> <span class="o">*</span><span class="n">poffset</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">copied</span><span class="p">);</span>
				<span class="n">total_read</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* resend call if it&#39;s a retryable error */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_retry_async_readv</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">restart_loop</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_uncached_readdata_release</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cifs_stats_bytes_read</span><span class="p">(</span><span class="n">tcon</span><span class="p">,</span> <span class="n">total_read</span><span class="p">);</span>
	<span class="o">*</span><span class="n">poffset</span> <span class="o">+=</span> <span class="n">total_read</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">total_read</span> <span class="o">?</span> <span class="n">total_read</span> <span class="o">:</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">cifs_user_readv</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">ssize_t</span> <span class="n">read</span><span class="p">;</span>

	<span class="n">read</span> <span class="o">=</span> <span class="n">cifs_iovec_read</span><span class="p">(</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">read</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">ssize_t</span> <span class="nf">cifs_strict_readv</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
			  <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">generic_file_aio_read</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In strict cache mode we need to read from the server all the time</span>
<span class="cm">	 * if we don&#39;t have level II oplock because the server can delay mtime</span>
<span class="cm">	 * change - so we can&#39;t make a decision about inode invalidating.</span>
<span class="cm">	 * And we can also fail with pagereading if there are mandatory locks</span>
<span class="cm">	 * on pages affected by this read but not on the region from pos to</span>
<span class="cm">	 * pos+len-1.</span>
<span class="cm">	 */</span>

	<span class="k">return</span> <span class="n">cifs_user_readv</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cifs_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">read_data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">read_size</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="o">*</span><span class="n">poffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">total_read</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">current_read_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">pTcon</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">current_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_io_parms</span> <span class="n">io_parms</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">buf_type</span> <span class="o">=</span> <span class="n">CIFS_NO_BUFFER</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">pid</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>
	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>

	<span class="cm">/* FIXME: set up handlers for larger reads and/or convert to async */</span>
	<span class="n">rsize</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">rsize</span><span class="p">,</span> <span class="n">CIFSMaxBufSize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">open_file</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="n">pTcon</span> <span class="o">=</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_RWPIDFORWARD</span><span class="p">)</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">==</span> <span class="n">O_WRONLY</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;attempting read on write only file instance&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">total_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">current_offset</span> <span class="o">=</span> <span class="n">read_data</span><span class="p">;</span>
	     <span class="n">read_size</span> <span class="o">&gt;</span> <span class="n">total_read</span><span class="p">;</span>
	     <span class="n">total_read</span> <span class="o">+=</span> <span class="n">bytes_read</span><span class="p">,</span> <span class="n">current_offset</span> <span class="o">+=</span> <span class="n">bytes_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">current_read_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">read_size</span> <span class="o">-</span> <span class="n">total_read</span><span class="p">,</span> <span class="n">rsize</span><span class="p">);</span>

		<span class="cm">/* For windows me and 9x we do not want to request more</span>
<span class="cm">		than it negotiated since it will refuse the read then */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">pTcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="p">(</span><span class="n">pTcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_LARGE_FILES</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">current_read_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">uint</span><span class="p">,</span> <span class="n">current_read_size</span><span class="p">,</span>
					<span class="n">CIFSMaxBufSize</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">invalidHandle</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_reopen_file</span><span class="p">(</span><span class="n">open_file</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">netfid</span> <span class="o">=</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">pTcon</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">poffset</span><span class="p">;</span>
			<span class="n">io_parms</span><span class="p">.</span><span class="n">length</span> <span class="o">=</span> <span class="n">current_read_size</span><span class="p">;</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBRead</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">io_parms</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bytes_read</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">current_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf_type</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">||</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">total_read</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cifs_stats_bytes_read</span><span class="p">(</span><span class="n">pTcon</span><span class="p">,</span> <span class="n">total_read</span><span class="p">);</span>
			<span class="o">*</span><span class="n">poffset</span> <span class="o">+=</span> <span class="n">bytes_read</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">total_read</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If the page is mmap&#39;ed into a process&#39; page tables, then we need to make</span>
<span class="cm"> * sure that it doesn&#39;t change while being written back.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">cifs_file_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span> <span class="o">=</span> <span class="n">filemap_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_mkwrite</span> <span class="o">=</span> <span class="n">cifs_page_mkwrite</span><span class="p">,</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">cifs_file_strict_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">xid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_invalidate_mapping</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">generic_file_mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cifs_file_vm_ops</span><span class="p">;</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">cifs_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">,</span> <span class="n">xid</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_revalidate_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Validation prior to mmap failed, error=%d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">generic_file_mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vma</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cifs_file_vm_ops</span><span class="p">;</span>
	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_readv_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">cifs_readdata</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tpage</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">lru_cache_add_file</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">result</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cifs_readpage_to_fscache</span><span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_readdata_release</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_readpages_marshal_iov</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">remaining</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tpage</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">eof</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">eof_index</span><span class="p">;</span>

	<span class="cm">/* determine the eof that the server (probably) has */</span>
	<span class="n">eof</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">server_eof</span><span class="p">;</span>
	<span class="n">eof_index</span> <span class="o">=</span> <span class="n">eof</span> <span class="o">?</span> <span class="p">(</span><span class="n">eof</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;eof=%llu eof_index=%lu&quot;</span><span class="p">,</span> <span class="n">eof</span><span class="p">,</span> <span class="n">eof_index</span><span class="p">);</span>

	<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enough data to fill the page */</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%u: idx=%lu iov_base=%p iov_len=%zu&quot;</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span><span class="p">);</span>
			<span class="o">++</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">-=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">remaining</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* enough for partial page, fill and zero the rest */</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span> <span class="o">=</span> <span class="n">remaining</span><span class="p">;</span>
			<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%u: idx=%lu iov_base=%p iov_len=%zu&quot;</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span><span class="p">,</span>
				<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_len</span><span class="p">);</span>
			<span class="n">memset</span><span class="p">(</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">iov</span><span class="p">[</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">+</span> <span class="n">remaining</span><span class="p">,</span>
				<span class="sc">&#39;\0&#39;</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">remaining</span><span class="p">);</span>
			<span class="o">++</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">nr_iov</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">+=</span> <span class="n">remaining</span><span class="p">;</span>
			<span class="n">remaining</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">eof_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The VFS will not try to do readahead past the</span>
<span class="cm">			 * i_size, but it&#39;s possible that we have outstanding</span>
<span class="cm">			 * writes with gaps in the middle and the i_size hasn&#39;t</span>
<span class="cm">			 * caught up yet. Populate those with zeroed out pages</span>
<span class="cm">			 * to prevent the VFS from repeatedly attempting to</span>
<span class="cm">			 * fill them until the writes are flushed.</span>
<span class="cm">			 */</span>
			<span class="n">zero_user</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">lru_cache_add_file</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* no need to hold page hostage */</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
			<span class="n">lru_cache_add_file</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">page_list</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">num_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">tmplist</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rsize</span> <span class="o">=</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">rsize</span><span class="p">;</span>
	<span class="n">pid_t</span> <span class="n">pid</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Give up immediately if rsize is too small to read an entire page.</span>
<span class="cm">	 * The VFS will fall back to readpage. We should never reach this</span>
<span class="cm">	 * point however since we set ra_pages to 0 when the rsize is smaller</span>
<span class="cm">	 * than a cache page.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">rsize</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reads as many pages as possible from fscache. Returns -ENOBUFS</span>
<span class="cm">	 * immediately if the cookie is negative</span>
<span class="cm">	 */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_readpages_from_fscache</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">page_list</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">num_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_RWPIDFORWARD</span><span class="p">)</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">open_file</span><span class="o">-&gt;</span><span class="n">pid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">pid</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmplist</span><span class="p">);</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s: file=%p mapping=%p num_pages=%u&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span>
		<span class="n">mapping</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Start with the page at end of list and move it to private</span>
<span class="cm">	 * list. Do the same with any following pages until we hit</span>
<span class="cm">	 * the rsize limit, hit an index discontinuity, or run out of</span>
<span class="cm">	 * pages. Issue the async read and then start the loop again</span>
<span class="cm">	 * until the list is empty.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Note that list order is important. The page_list is in</span>
<span class="cm">	 * the order of declining indexes. When we put the pages in</span>
<span class="cm">	 * the rdata-&gt;pages, then we want them in increasing order.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">page_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">expected_index</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">loff_t</span> <span class="n">offset</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">tpage</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">cifs_readdata</span> <span class="o">*</span><span class="n">rdata</span><span class="p">;</span>

		<span class="n">page</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">page_list</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span><span class="p">,</span> <span class="n">lru</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Lock the page and put it in the cache. Since no one else</span>
<span class="cm">		 * should have access to this page, we&#39;re safe to simply set</span>
<span class="cm">		 * PG_locked without checking it first.</span>
<span class="cm">		 */</span>
		<span class="n">__set_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">add_to_page_cache_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
					      <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>

		<span class="cm">/* give up if we can&#39;t stick it in the cache */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__clear_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* move first page to the tmplist */</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmplist</span><span class="p">);</span>

		<span class="cm">/* now try and add more pages onto the request */</span>
		<span class="n">expected_index</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">list_for_each_entry_safe_reverse</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="n">page_list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* discontinuity ? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">expected_index</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="cm">/* would this page push the read over the rsize? */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&gt;</span> <span class="n">rsize</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">__set_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">add_to_page_cache_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span>
						<span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">__clear_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmplist</span><span class="p">);</span>
			<span class="n">bytes</span> <span class="o">+=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
			<span class="n">expected_index</span><span class="o">++</span><span class="p">;</span>
			<span class="n">nr_pages</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">rdata</span> <span class="o">=</span> <span class="n">cifs_readdata_alloc</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">cifs_readv_complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rdata</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* best to give up if we&#39;re out of mem */</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmplist</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
				<span class="n">lru_cache_add_file</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">cfile</span> <span class="o">=</span> <span class="n">cifsFileInfo_get</span><span class="p">(</span><span class="n">open_file</span><span class="p">);</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">mapping</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pid</span> <span class="o">=</span> <span class="n">pid</span><span class="p">;</span>
		<span class="n">rdata</span><span class="o">-&gt;</span><span class="n">marshal_iov</span> <span class="o">=</span> <span class="n">cifs_readpages_marshal_iov</span><span class="p">;</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmplist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_retry_async_readv</span><span class="p">(</span><span class="n">rdata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">tpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span>
						 <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
				<span class="n">lru_cache_add_file</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_readdata_release</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">kref_put</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rdata</span><span class="o">-&gt;</span><span class="n">refcount</span><span class="p">,</span> <span class="n">cifs_readdata_release</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_readpage_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
	<span class="n">loff_t</span> <span class="o">*</span><span class="n">poffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">read_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="cm">/* Is the page cached? */</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_readpage_from_fscache</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">read_complete</span><span class="p">;</span>

	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">read_data</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="cm">/* for reads over a certain size could initiate async read ahead */</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">read_data</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="n">poffset</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Bytes read %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span>
		<span class="n">current_fs_time</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">&gt;</span> <span class="n">rc</span><span class="p">)</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">read_data</span> <span class="o">+</span> <span class="n">rc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">rc</span><span class="p">);</span>

	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/* send this page to the cache */</span>
	<span class="n">cifs_readpage_to_fscache</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">io_error:</span>
	<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

<span class="nl">read_complete:</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;readpage %p at offset %d 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">page</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_readpage_worker</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">);</span>

	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">is_inode_writable</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifs_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">open_file</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">open_file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">,</span> <span class="n">flist</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">OPEN_FMODE</span><span class="p">(</span><span class="n">open_file</span><span class="o">-&gt;</span><span class="n">f_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We do not want to update the file size from server for inodes</span>
<span class="cm">   open for write - to avoid races with writepage extending</span>
<span class="cm">   the file - in the future we could consider allowing</span>
<span class="cm">   refreshing the inode only on increases in the file size</span>
<span class="cm">   but this is tricky to do without racing with writebehind</span>
<span class="cm">   page caching in the current Linux kernel design */</span>
<span class="n">bool</span> <span class="nf">is_size_safe_to_change</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifsInode</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">end_of_file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cifsInode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_inode_writable</span><span class="p">(</span><span class="n">cifsInode</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* This inode is open for write at least once */</span>
		<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>

		<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">cifsInode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_DIRECT_IO</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* since no page cache to corrupt on directio</span>
<span class="cm">			we can change size safely */</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifsInode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">end_of_file</span><span class="p">)</span>
			<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">page_start</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="n">PAGE_MASK</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;write_begin from %lld len %d&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">grab_cache_page_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we write a full page it will be up to date, no need to read from</span>
<span class="cm">	 * the server. If the write is short, we&#39;ll end up doing a sync write</span>
<span class="cm">	 * instead.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * optimize away the read when we have an oplock, and we&#39;re not</span>
<span class="cm">	 * expecting to use any of the data we&#39;d be reading in. That</span>
<span class="cm">	 * is, when the page lies beyond the EOF, or straddles the EOF</span>
<span class="cm">	 * and the write will cover all of the existing data.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_start</span> <span class="o">&gt;=</span> <span class="n">i_size</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">i_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">zero_user_segments</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					   <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
					   <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * PageChecked means that the parts of the page</span>
<span class="cm">			 * to which we&#39;re not writing are considered up</span>
<span class="cm">			 * to date. Once the data is copied to the</span>
<span class="cm">			 * page, it can be set uptodate.</span>
<span class="cm">			 */</span>
			<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_ACCMODE</span><span class="p">)</span> <span class="o">!=</span> <span class="n">O_WRONLY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * might as well read a page, it is fast enough. If we get</span>
<span class="cm">		 * an error, we don&#39;t need to return it. cifs_write_end will</span>
<span class="cm">		 * do a sync write instead since PG_uptodate isn&#39;t set.</span>
<span class="cm">		 */</span>
		<span class="n">cifs_readpage_worker</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">page_start</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* we could try using another file handle if there is one -</span>
<span class="cm">		   but how would we lock it to prevent close of that handle</span>
<span class="cm">		   racing with this read? In any case</span>
<span class="cm">		   this will be written out by write_end so is fine */</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="o">*</span><span class="n">pagep</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_release_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cifs_fscache_release_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cifs_invalidate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifsi</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">cifs_fscache_invalidate_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_launder_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">range_start</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">range_end</span> <span class="o">=</span> <span class="n">range_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">WB_SYNC_ALL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_start</span> <span class="o">=</span> <span class="n">range_start</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_end</span> <span class="o">=</span> <span class="n">range_end</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Launder page: %p&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_writepage_locked</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>

	<span class="n">cifs_fscache_invalidate_page</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">cifs_oplock_break</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsFileInfo</span><span class="p">,</span>
						  <span class="n">oplock_break</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cinode</span> <span class="o">=</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span><span class="p">)</span>
			<span class="n">break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">O_RDONLY</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">break_lease</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">O_WRONLY</span><span class="p">);</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_fdatawrite</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_fdatawait</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
			<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
			<span class="n">invalidate_remote_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Oplock flush inode %p rc %d&quot;</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_push_locks</span><span class="p">(</span><span class="n">cfile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Push locks rc = %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * releasing stale oplock after recent reconnect of smb session using</span>
<span class="cm">	 * a now incorrect file handle is not a data integrity issue but do</span>
<span class="cm">	 * not bother sending an oplock release if session to server still is</span>
<span class="cm">	 * disconnected since oplock already released by the server</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">oplock_break_cancelled</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBLock</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">),</span> <span class="n">cfile</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">,</span>
				 <span class="n">current</span><span class="o">-&gt;</span><span class="n">tgid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="n">LOCKING_ANDX_OPLOCK_RELEASE</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
				 <span class="n">cinode</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Oplock release rc = %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">cifs_addr_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span> <span class="o">=</span> <span class="n">cifs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span> <span class="o">=</span> <span class="n">cifs_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span> <span class="o">=</span> <span class="n">cifs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span> <span class="o">=</span> <span class="n">cifs_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span> <span class="o">=</span> <span class="n">cifs_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span> <span class="o">=</span> <span class="n">cifs_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span> <span class="o">=</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span> <span class="o">=</span> <span class="n">cifs_release_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">cifs_invalidate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">launder_page</span> <span class="o">=</span> <span class="n">cifs_launder_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * cifs_readpages requires the server to support a buffer large enough to</span>
<span class="cm"> * contain the header plus one complete page of data.  Otherwise, we need</span>
<span class="cm"> * to leave cifs_readpages out of the address space operations.</span>
<span class="cm"> */</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">cifs_addr_ops_smallbuf</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span> <span class="o">=</span> <span class="n">cifs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span> <span class="o">=</span> <span class="n">cifs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span> <span class="o">=</span> <span class="n">cifs_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span> <span class="o">=</span> <span class="n">cifs_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span> <span class="o">=</span> <span class="n">cifs_write_end</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span> <span class="o">=</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span> <span class="o">=</span> <span class="n">cifs_release_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">cifs_invalidate_page</span><span class="p">,</span>
	<span class="p">.</span><span class="n">launder_page</span> <span class="o">=</span> <span class="n">cifs_launder_page</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
