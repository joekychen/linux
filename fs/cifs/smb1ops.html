<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cifs › smb1ops.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>smb1ops.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  SMB1 (CIFS) version specific operations</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (c) 2012, Jeff Layton &lt;jlayton@redhat.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> *  This library is free software; you can redistribute it and/or modify</span>
<span class="cm"> *  it under the terms of the GNU General Public License v2 as published</span>
<span class="cm"> *  by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> *  This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *  but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *  the GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *  You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> *  along with this library; if not, write to the Free Software</span>
<span class="cm"> *  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;cifsglob.h&quot;</span>
<span class="cp">#include &quot;cifsproto.h&quot;</span>
<span class="cp">#include &quot;cifs_debug.h&quot;</span>
<span class="cp">#include &quot;cifspdu.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * An NT cancel request header looks just like the original request except:</span>
<span class="cm"> *</span>
<span class="cm"> * The Command is SMB_COM_NT_CANCEL</span>
<span class="cm"> * The WordCount is zeroed out</span>
<span class="cm"> * The ByteCount is zeroed out</span>
<span class="cm"> *</span>
<span class="cm"> * This function mangles an existing request buffer into a</span>
<span class="cm"> * SMB_COM_NT_CANCEL request and then sends it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">send_nt_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
	       <span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="n">mid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">in_buf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

	<span class="cm">/* -4 for RFC1001 length and +2 for BCC field */</span>
	<span class="n">in_buf</span><span class="o">-&gt;</span><span class="n">smb_buf_length</span> <span class="o">=</span> <span class="n">cpu_to_be32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">4</span>  <span class="o">+</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">in_buf</span><span class="o">-&gt;</span><span class="n">Command</span> <span class="o">=</span> <span class="n">SMB_COM_NT_CANCEL</span><span class="p">;</span>
	<span class="n">in_buf</span><span class="o">-&gt;</span><span class="n">WordCount</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">put_bcc</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">in_buf</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">srv_mutex</span><span class="p">);</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_sign_smb</span><span class="p">(</span><span class="n">in_buf</span><span class="p">,</span> <span class="n">server</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mid</span><span class="o">-&gt;</span><span class="n">sequence_number</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">srv_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">smb_send</span><span class="p">(</span><span class="n">server</span><span class="p">,</span> <span class="n">in_buf</span><span class="p">,</span> <span class="n">be32_to_cpu</span><span class="p">(</span><span class="n">in_buf</span><span class="o">-&gt;</span><span class="n">smb_buf_length</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">srv_mutex</span><span class="p">);</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;issued NT_CANCEL for mid %u, rc = %d&quot;</span><span class="p">,</span>
		<span class="n">in_buf</span><span class="o">-&gt;</span><span class="n">Mid</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span>
<span class="nf">cifs_compare_fids</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">ob1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">ob2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">ob1</span><span class="o">-&gt;</span><span class="n">netfid</span> <span class="o">==</span> <span class="n">ob2</span><span class="o">-&gt;</span><span class="n">netfid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">cifs_read_data_offset</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">READ_RSP</span> <span class="o">*</span><span class="n">rsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">READ_RSP</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rsp</span><span class="o">-&gt;</span><span class="n">DataOffset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span>
<span class="nf">cifs_read_data_length</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">READ_RSP</span> <span class="o">*</span><span class="n">rsp</span> <span class="o">=</span> <span class="p">(</span><span class="n">READ_RSP</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rsp</span><span class="o">-&gt;</span><span class="n">DataLengthHigh</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">+</span>
	       <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rsp</span><span class="o">-&gt;</span><span class="n">DataLength</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span>
<span class="nf">cifs_find_mid</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span> <span class="o">*</span><span class="p">)</span><span class="n">buffer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="n">mid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">pending_mid_q</span><span class="p">,</span> <span class="n">qhead</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span><span class="o">-&gt;</span><span class="n">mid</span> <span class="o">==</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">Mid</span> <span class="o">&amp;&amp;</span>
		    <span class="n">mid</span><span class="o">-&gt;</span><span class="n">mid_state</span> <span class="o">==</span> <span class="n">MID_REQUEST_SUBMITTED</span> <span class="o">&amp;&amp;</span>
		    <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mid</span><span class="o">-&gt;</span><span class="n">command</span><span class="p">)</span> <span class="o">==</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">Command</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_add_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">add</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">+=</span> <span class="n">add</span><span class="p">;</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">request_q</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_set_credits</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">credits</span> <span class="o">=</span> <span class="n">val</span><span class="p">;</span>
	<span class="n">server</span><span class="o">-&gt;</span><span class="n">oplocks</span> <span class="o">=</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">?</span> <span class="n">enable_oplocks</span> <span class="o">:</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">req_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="o">*</span>
<span class="nf">cifs_get_credits_field</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">credits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find a free multiplex id (SMB mid). Otherwise there could be</span>
<span class="cm"> * mid collisions which might cause problems, demultiplexing the</span>
<span class="cm"> * wrong response to this request. Multiplex ids could collide if</span>
<span class="cm"> * one of a series requests takes much longer than the others, or</span>
<span class="cm"> * if a very large number of long lived requests (byte range</span>
<span class="cm"> * locks or FindNotify requests) are pending. No more than</span>
<span class="cm"> * 64K-1 requests can be outstanding at one time. If no</span>
<span class="cm"> * mids are available, return zero. A future optimization</span>
<span class="cm"> * could make the combination of mids and uid the key we use</span>
<span class="cm"> * to demultiplex on (rather than mid alone).</span>
<span class="cm"> * In addition to the above check, the cifs demultiplex</span>
<span class="cm"> * code already used the command code as a secondary</span>
<span class="cm"> * check of the frame and if signing is negotiated the</span>
<span class="cm"> * response would be discarded if the mid were the same</span>
<span class="cm"> * but the signature was wrong. Since the mid is not put in the</span>
<span class="cm"> * pending queue until later (when it is about to be dispatched)</span>
<span class="cm"> * we do have to limit the number of outstanding requests</span>
<span class="cm"> * to somewhat less than 64K-1 although it is hard to imagine</span>
<span class="cm"> * so many threads being in the vfs at one time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">__u64</span>
<span class="nf">cifs_get_next_mid</span><span class="p">(</span><span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">mid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u16</span> <span class="n">last_mid</span><span class="p">,</span> <span class="n">cur_mid</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">collision</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>

	<span class="cm">/* mid is 16 bit only for CIFS/SMB */</span>
	<span class="n">cur_mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u16</span><span class="p">)((</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">CurrentMid</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
	<span class="cm">/* we do not want to loop forever */</span>
	<span class="n">last_mid</span> <span class="o">=</span> <span class="n">cur_mid</span><span class="p">;</span>
	<span class="n">cur_mid</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This nested loop looks more expensive than it is.</span>
<span class="cm">	 * In practice the list of pending requests is short,</span>
<span class="cm">	 * fewer than 50, and the mids are likely to be unique</span>
<span class="cm">	 * on the first pass through the loop unless some request</span>
<span class="cm">	 * takes longer than the 64 thousand requests before it</span>
<span class="cm">	 * (and it would also have to have been a request that</span>
<span class="cm">	 * did not time out).</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cur_mid</span> <span class="o">!=</span> <span class="n">last_mid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">mid_q_entry</span> <span class="o">*</span><span class="n">mid_entry</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_mids</span><span class="p">;</span>

		<span class="n">collision</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_mid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">cur_mid</span><span class="o">++</span><span class="p">;</span>

		<span class="n">num_mids</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">mid_entry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">pending_mid_q</span><span class="p">,</span> <span class="n">qhead</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">++</span><span class="n">num_mids</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mid_entry</span><span class="o">-&gt;</span><span class="n">mid</span> <span class="o">==</span> <span class="n">cur_mid</span> <span class="o">&amp;&amp;</span>
			    <span class="n">mid_entry</span><span class="o">-&gt;</span><span class="n">mid_state</span> <span class="o">==</span> <span class="n">MID_REQUEST_SUBMITTED</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* This mid is in use, try a different one */</span>
				<span class="n">collision</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * if we have more than 32k mids in the list, then something</span>
<span class="cm">		 * is very wrong. Possibly a local user is trying to DoS the</span>
<span class="cm">		 * box by issuing long-running calls and SIGKILL&#39;ing them. If</span>
<span class="cm">		 * we get to 2^16 mids then we&#39;re in big trouble as this</span>
<span class="cm">		 * function could loop forever.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Go ahead and assign out the mid in this situation, but force</span>
<span class="cm">		 * an eventual reconnect to clean out the pending_mid_q.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_mids</span> <span class="o">&gt;</span> <span class="mi">32768</span><span class="p">)</span>
			<span class="n">server</span><span class="o">-&gt;</span><span class="n">tcpStatus</span> <span class="o">=</span> <span class="n">CifsNeedReconnect</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">collision</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">__u64</span><span class="p">)</span><span class="n">cur_mid</span><span class="p">;</span>
			<span class="n">server</span><span class="o">-&gt;</span><span class="n">CurrentMid</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cur_mid</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">mid</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">smb_version_operations</span> <span class="n">smb1_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">send_cancel</span> <span class="o">=</span> <span class="n">send_nt_cancel</span><span class="p">,</span>
	<span class="p">.</span><span class="n">compare_fids</span> <span class="o">=</span> <span class="n">cifs_compare_fids</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setup_request</span> <span class="o">=</span> <span class="n">cifs_setup_request</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_receive</span> <span class="o">=</span> <span class="n">cifs_check_receive</span><span class="p">,</span>
	<span class="p">.</span><span class="n">add_credits</span> <span class="o">=</span> <span class="n">cifs_add_credits</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_credits</span> <span class="o">=</span> <span class="n">cifs_set_credits</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_credits_field</span> <span class="o">=</span> <span class="n">cifs_get_credits_field</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_next_mid</span> <span class="o">=</span> <span class="n">cifs_get_next_mid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_data_offset</span> <span class="o">=</span> <span class="n">cifs_read_data_offset</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_data_length</span> <span class="o">=</span> <span class="n">cifs_read_data_length</span><span class="p">,</span>
	<span class="p">.</span><span class="n">map_error</span> <span class="o">=</span> <span class="n">map_smb_to_linux_error</span><span class="p">,</span>
	<span class="p">.</span><span class="n">find_mid</span> <span class="o">=</span> <span class="n">cifs_find_mid</span><span class="p">,</span>
	<span class="p">.</span><span class="n">check_message</span> <span class="o">=</span> <span class="n">checkSMB</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dump_detail</span> <span class="o">=</span> <span class="n">cifs_dump_detail</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_oplock_break</span> <span class="o">=</span> <span class="n">is_valid_oplock_break</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">smb_version_values</span> <span class="n">smb1_values</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">version_string</span> <span class="o">=</span> <span class="n">SMB1_VERSION_STRING</span><span class="p">,</span>
	<span class="p">.</span><span class="n">large_lock_type</span> <span class="o">=</span> <span class="n">LOCKING_ANDX_LARGE_FILES</span><span class="p">,</span>
	<span class="p">.</span><span class="n">exclusive_lock_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">shared_lock_type</span> <span class="o">=</span> <span class="n">LOCKING_ANDX_SHARED_LOCK</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlock_lock_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="p">.</span><span class="n">header_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_hdr</span><span class="p">),</span>
	<span class="p">.</span><span class="n">max_header_size</span> <span class="o">=</span> <span class="n">MAX_CIFS_HDR_SIZE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read_rsp_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">READ_RSP</span><span class="p">),</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
