<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cifs › cifsfs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>cifsfs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *   fs/cifs/cifsfs.c</span>
<span class="cm"> *</span>
<span class="cm"> *   Copyright (C) International Business Machines  Corp., 2002,2008</span>
<span class="cm"> *   Author(s): Steve French (sfrench@us.ibm.com)</span>
<span class="cm"> *</span>
<span class="cm"> *   Common Internet FileSystem (CIFS) client</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is free software; you can redistribute it and/or modify</span>
<span class="cm"> *   it under the terms of the GNU Lesser General Public License as published</span>
<span class="cm"> *   by the Free Software Foundation; either version 2.1 of the License, or</span>
<span class="cm"> *   (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> *   This library is distributed in the hope that it will be useful,</span>
<span class="cm"> *   but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See</span>
<span class="cm"> *   the GNU Lesser General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> *   You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm"> *   along with this library; if not, write to the Free Software</span>
<span class="cm"> *   Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA</span>
<span class="cm"> */</span>

<span class="cm">/* Note that BB means BUGBUG (ie something to fix eventually) */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/vfs.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;net/ipv6.h&gt;</span>
<span class="cp">#include &quot;cifsfs.h&quot;</span>
<span class="cp">#include &quot;cifspdu.h&quot;</span>
<span class="cp">#define DECLARE_GLOBALS_HERE</span>
<span class="cp">#include &quot;cifsglob.h&quot;</span>
<span class="cp">#include &quot;cifsproto.h&quot;</span>
<span class="cp">#include &quot;cifs_debug.h&quot;</span>
<span class="cp">#include &quot;cifs_fs_sb.h&quot;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/key-type.h&gt;</span>
<span class="cp">#include &quot;cifs_spnego.h&quot;</span>
<span class="cp">#include &quot;fscache.h&quot;</span>
<span class="cp">#define CIFS_MAGIC_NUMBER 0xFF534D42	</span><span class="cm">/* the first four bytes of SMB PDUs */</span><span class="cp"></span>

<span class="kt">int</span> <span class="n">cifsFYI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">cifsERROR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">traceSMB</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="n">bool</span> <span class="n">enable_oplocks</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">linuxExtEnabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lookupCacheEnabled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">global_secflags</span> <span class="o">=</span> <span class="n">CIFSSEC_DEF</span><span class="p">;</span>
<span class="cm">/* unsigned int ntlmv2_support = 0; */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sign_CIFS_PDUs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">cifs_super_ops</span><span class="p">;</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">CIFSMaxBufSize</span> <span class="o">=</span> <span class="n">CIFS_MAX_MSGSIZE</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">CIFSMaxBufSize</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">CIFSMaxBufSize</span><span class="p">,</span> <span class="s">&quot;Network buffer size (not including header). &quot;</span>
				 <span class="s">&quot;Default: 16384 Range: 8192 to 130048&quot;</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cifs_min_rcv</span> <span class="o">=</span> <span class="n">CIFS_MIN_RCV_POOL</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">cifs_min_rcv</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cifs_min_rcv</span><span class="p">,</span> <span class="s">&quot;Network buffers in pool. Default: 4 Range: &quot;</span>
				<span class="s">&quot;1 to 64&quot;</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cifs_min_small</span> <span class="o">=</span> <span class="mi">30</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">cifs_min_small</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cifs_min_small</span><span class="p">,</span> <span class="s">&quot;Small network buffers in pool. Default: 30 &quot;</span>
				 <span class="s">&quot;Range: 2 to 256&quot;</span><span class="p">);</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">cifs_max_pending</span> <span class="o">=</span> <span class="n">CIFS_MAX_REQ</span><span class="p">;</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">cifs_max_pending</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="mo">0444</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">cifs_max_pending</span><span class="p">,</span> <span class="s">&quot;Simultaneous requests to server. &quot;</span>
				   <span class="s">&quot;Default: 32767 Range: 2 to 32767.&quot;</span><span class="p">);</span>
<span class="n">module_param</span><span class="p">(</span><span class="n">enable_oplocks</span><span class="p">,</span> <span class="n">bool</span><span class="p">,</span> <span class="mo">0644</span><span class="p">);</span>
<span class="n">MODULE_PARM_DESC</span><span class="p">(</span><span class="n">enable_oplocks</span><span class="p">,</span> <span class="s">&quot;Enable or disable oplocks (bool). Default:&quot;</span>
				 <span class="s">&quot;y/Y/1&quot;</span><span class="p">);</span>

<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_sm_req_poolp</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_req_poolp</span><span class="p">;</span>
<span class="k">extern</span> <span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_mid_poolp</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">workqueue_struct</span>	<span class="o">*</span><span class="n">cifsiod_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_read_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_POSIXACL</span><span class="p">)</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_POSIXACL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_LARGE_FILES</span><span class="p">)</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">MAX_NON_LFS</span><span class="p">;</span>

	<span class="cm">/* BB FIXME fix time_gran to be larger for LANMAN sessions */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">CIFS_MAGIC_NUMBER</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cifs_super_ops</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">=</span> <span class="n">CIFS_MAX_MSGSIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>	<span class="cm">/* default 2**14 = CIFS_MAX_MSGSIZE */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">cifs_root_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_no_root</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_no_root</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* do that *after* d_make_root() - we want NULL -&gt;d_op for root here */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nocase</span><span class="p">)</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cifs_ci_dentry_ops</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_d_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cifs_dentry_ops</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CIFS_NFSD_EXPORT</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SERVER_INUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;export ops supported&quot;</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_export_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">cifs_export_ops</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_NFSD_EXPORT */</span><span class="cp"></span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_no_root:</span>
	<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_read_super: get root inode failed&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cifs_kill_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">kill_anon_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">cifs_umount</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xid</span><span class="p">;</span>

	<span class="n">xid</span> <span class="o">=</span> <span class="n">GetXid</span><span class="p">();</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_type</span> <span class="o">=</span> <span class="n">CIFS_MAGIC_NUMBER</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * PATH_MAX may be too long - it would presumably be total path,</span>
<span class="cm">	 * but note that some servers (includinng Samba 3) have a shorter</span>
<span class="cm">	 * maximum path.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Instead could get the real value via SMB_QUERY_FS_ATTRIBUTE_INFO.</span>
<span class="cm">	 */</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_namelen</span> <span class="o">=</span> <span class="n">PATH_MAX</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_files</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* undefined */</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_ffree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* unlimited */</span>

	<span class="cm">/*</span>
<span class="cm">	 * We could add a second check for a QFS Unix capability bit</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_UNIX</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">CIFS_POSIX_EXTENSIONS</span> <span class="o">&amp;</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">fsUnixInfo</span><span class="p">.</span><span class="n">Capability</span><span class="p">)))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBQFSPosixInfo</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Only need to call the old QFSInfo if failed on newer one,</span>
<span class="cm">	 * e.g. by OS/2.</span>
<span class="cm">	 **/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">capabilities</span> <span class="o">&amp;</span> <span class="n">CAP_NT_SMBS</span><span class="p">))</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">CIFSSMBQFSInfo</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some old Windows servers also do not support level 103, retry with</span>
<span class="cm">	 * older level one if old server failed the previous call or we</span>
<span class="cm">	 * bypassed it because we detected that this was an older LANMAN sess</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="n">SMBOldQFSInfo</span><span class="p">(</span><span class="n">xid</span><span class="p">,</span> <span class="n">tcon</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

	<span class="n">FreeXid</span><span class="p">(</span><span class="n">xid</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NO_PERM</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_EXEC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">execute_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="cm">/* file mode might have been restricted at mount time</span>
<span class="cm">		on the client (above and beyond ACL on servers) for</span>
<span class="cm">		servers which do not support setting and viewing mode bits,</span>
<span class="cm">		so allowing client to check permissions is useful */</span>
		<span class="k">return</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cifs_inode_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cifs_req_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cifs_mid_cachep</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">cifs_sm_req_cachep</span><span class="p">;</span>
<span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_sm_req_poolp</span><span class="p">;</span>
<span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_req_poolp</span><span class="p">;</span>
<span class="n">mempool_t</span> <span class="o">*</span><span class="n">cifs_mid_poolp</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span>
<span class="nf">cifs_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifs_inode</span><span class="p">;</span>
	<span class="n">cifs_inode</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">cifs_inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cifs_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">cifsAttrs</span> <span class="o">=</span> <span class="mh">0x20</span><span class="p">;</span>	<span class="cm">/* default */</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="cm">/* Until the file is open and we have gotten oplock</span>
<span class="cm">	info back from the server, can not assume caching of</span>
<span class="cm">	file data or metadata */</span>
	<span class="n">cifs_set_oplock_level</span><span class="p">(</span><span class="n">cifs_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">delete_pending</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">invalid_mapping</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_blkbits</span> <span class="o">=</span> <span class="mi">14</span><span class="p">;</span>  <span class="cm">/* 2**14 = CIFS_MAX_MSGSIZE */</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">server_eof</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">uniqueid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">createtime</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Can not set i_flags here - they get immediately overwritten</span>
<span class="cm">	   to zero by the VFS */</span>
<span class="cm">/*	cifs_inode-&gt;vfs_inode.i_flags = S_NOATIME | S_NOCMTIME;*/</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">openFileList</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">cifs_inode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cifs_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">cifs_inode_cachep</span><span class="p">,</span> <span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">cifs_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">cifs_fscache_release_inode_cookie</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_show_address</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">sa</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">sa6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span> <span class="o">&amp;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,addr=&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">dstaddr</span><span class="p">.</span><span class="n">ss_family</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">AF_INET</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%pI4&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">AF_INET6</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%pI6&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">.</span><span class="n">s6_addr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sa6</span><span class="o">-&gt;</span><span class="n">sin6_scope_id</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;%%%u&quot;</span><span class="p">,</span> <span class="n">sa6</span><span class="o">-&gt;</span><span class="n">sin6_scope_id</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;(unknown)&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_show_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">TCP_Server_Info</span> <span class="o">*</span><span class="n">server</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,sec=&quot;</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">secType</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">LANMAN</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;lanman&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NTLMv2</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;ntlmv2&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NTLM</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;ntlm&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">Kerberos</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;krb5&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">RawNTLMSSP</span>:
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;ntlmssp&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* shouldn&#39;t ever happen */</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;unknown&quot;</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">sec_mode</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">SECMODE_SIGN_REQUIRED</span> <span class="o">|</span> <span class="n">SECMODE_SIGN_ENABLED</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;i&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_show_cache_flavor</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,cache=&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_STRICT_IO</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;strict&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_DIRECT_IO</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;none&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;loose&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cifs_show_options() is for displaying mount options in /proc/mounts.</span>
<span class="cm"> * Not all settable options are displayed but most of the important</span>
<span class="cm"> * ones are.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span> <span class="o">=</span> <span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="n">srcaddr</span><span class="p">;</span>
	<span class="n">srcaddr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">srcaddr</span><span class="p">;</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,vers=%s&quot;</span><span class="p">,</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">vals</span><span class="o">-&gt;</span><span class="n">version_string</span><span class="p">);</span>
	<span class="n">cifs_show_security</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">);</span>
	<span class="n">cifs_show_cache_flavor</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,unc=%s&quot;</span><span class="p">,</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">treeName</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MULTIUSER</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,multiuser&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">user_name</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,username=%s&quot;</span><span class="p">,</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">user_name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">domainName</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,domain=%s&quot;</span><span class="p">,</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">domainName</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">srcaddr</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">!=</span> <span class="n">AF_UNSPEC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="n">saddr4</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="n">saddr6</span><span class="p">;</span>
		<span class="n">saddr4</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="o">*</span><span class="p">)</span><span class="n">srcaddr</span><span class="p">;</span>
		<span class="n">saddr6</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in6</span> <span class="o">*</span><span class="p">)</span><span class="n">srcaddr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">srcaddr</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET6</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,srcaddr=%pI6c&quot;</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">saddr6</span><span class="o">-&gt;</span><span class="n">sin6_addr</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">srcaddr</span><span class="o">-&gt;</span><span class="n">sa_family</span> <span class="o">==</span> <span class="n">AF_INET</span><span class="p">)</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,srcaddr=%pI4&quot;</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">saddr4</span><span class="o">-&gt;</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,srcaddr=BAD-AF:%i&quot;</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">int</span><span class="p">)(</span><span class="n">srcaddr</span><span class="o">-&gt;</span><span class="n">sa_family</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,uid=%u&quot;</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_OVERR_UID</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,forceuid&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,noforceuid&quot;</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,gid=%u&quot;</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_gid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_OVERR_GID</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,forcegid&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,noforcegid&quot;</span><span class="p">);</span>

	<span class="n">cifs_show_address</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,file_mode=0%ho,dir_mode=0%ho&quot;</span><span class="p">,</span>
					   <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_file_mode</span><span class="p">,</span>
					   <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_dir_mode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">seal</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,seal&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">nocase</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,nocase&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">retry</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,hard&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">unix_ext</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,unix&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,nounix&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_POSIX_PATHS</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,posixpaths&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SET_UID</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,setuids&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SERVER_INUM</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,serverino&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_RWPIDFORWARD</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,rwpidforward&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NOPOSIXBRL</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,forcemand&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NO_XATTR</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,nouser_xattr&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MAP_SPECIAL_CHR</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,mapchars&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_UNX_EMUL</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,sfu&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NO_BRL</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,nobrl&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_CIFS_ACL</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,cifsacl&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_DYNPERM</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,dynperm&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_POSIXACL</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,acl&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_MF_SYMLINKS</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,mfsymlinks&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_FSCACHE</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,fsc&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NOSSYNC</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,nostrictsync&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_NO_PERM</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,noperm&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_CIFS_BACKUPUID</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,backupuid=%u&quot;</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_backupuid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_CIFS_BACKUPGID</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,backupgid=%u&quot;</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_backupgid</span><span class="p">);</span>

	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,rsize=%u&quot;</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">rsize</span><span class="p">);</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,wsize=%u&quot;</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">wsize</span><span class="p">);</span>
	<span class="cm">/* convert actimeo and display it in seconds */</span>
	<span class="n">seq_printf</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="s">&quot;,actimeo=%lu&quot;</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">actimeo</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">cifs_umount_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cifs_tcon</span> <span class="o">*</span><span class="n">tcon</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">tcon</span> <span class="o">=</span> <span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">tc_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">tidStatus</span> <span class="o">==</span> <span class="n">CifsExiting</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* we have other mounts to same share or we have</span>
<span class="cm">		   already tried to force umount this and woken up</span>
<span class="cm">		   all waiting network requests, nothing to do */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">tc_count</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">tcon</span><span class="o">-&gt;</span><span class="n">tidStatus</span> <span class="o">=</span> <span class="n">CifsExiting</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>

	<span class="cm">/* cancel_brl_requests(tcon); */</span> <span class="cm">/* BB mark all brl mids as exiting */</span>
	<span class="cm">/* cancel_notify_requests(tcon); */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span> <span class="o">&amp;&amp;</span> <span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;wake up tasks now - umount begin not complete&quot;</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">request_q</span><span class="p">);</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">response_q</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="cm">/* yield */</span>
		<span class="cm">/* we have to kick the requests once more */</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcon</span><span class="o">-&gt;</span><span class="n">ses</span><span class="o">-&gt;</span><span class="n">server</span><span class="o">-&gt;</span><span class="n">response_q</span><span class="p">);</span>
		<span class="n">msleep</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_show_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* BB FIXME */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="o">*</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MS_NODIRATIME</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_drop_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>

	<span class="cm">/* no serverino =&gt; unconditional eviction */</span>
	<span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mnt_cifs_flags</span> <span class="o">&amp;</span> <span class="n">CIFS_MOUNT_SERVER_INUM</span><span class="p">)</span> <span class="o">||</span>
		<span class="n">generic_drop_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">cifs_super_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">statfs</span> <span class="o">=</span> <span class="n">cifs_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">alloc_inode</span> <span class="o">=</span> <span class="n">cifs_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span> <span class="o">=</span> <span class="n">cifs_destroy_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">drop_inode</span>	<span class="o">=</span> <span class="n">cifs_drop_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evict_inode</span>	<span class="o">=</span> <span class="n">cifs_evict_inode</span><span class="p">,</span>
<span class="cm">/*	.delete_inode	= cifs_delete_inode,  */</span>  <span class="cm">/* Do not need above</span>
<span class="cm">	function unless later we add lazy close of inodes or unless the</span>
<span class="cm">	kernel forgets to call us with the same number of releases (closes)</span>
<span class="cm">	as opens */</span>
	<span class="p">.</span><span class="n">show_options</span> <span class="o">=</span> <span class="n">cifs_show_options</span><span class="p">,</span>
	<span class="p">.</span><span class="n">umount_begin</span>   <span class="o">=</span> <span class="n">cifs_umount_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remount_fs</span> <span class="o">=</span> <span class="n">cifs_remount</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
	<span class="p">.</span><span class="n">show_stats</span> <span class="o">=</span> <span class="n">cifs_show_stats</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Get root dentry from superblock according to prefix path mount option.</span>
<span class="cm"> * Return dentry with refcount + 1 on success and NULL otherwise.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">cifs_get_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">smb_vol</span> <span class="o">*</span><span class="n">vol</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">CIFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">full_path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">sep</span><span class="p">;</span>

	<span class="n">full_path</span> <span class="o">=</span> <span class="n">cifs_build_path_to_root</span><span class="p">(</span><span class="n">vol</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="p">,</span>
					    <span class="n">cifs_sb_master_tcon</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">full_path</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Get root dentry for %s&quot;</span><span class="p">,</span> <span class="n">full_path</span><span class="p">);</span>

	<span class="n">sep</span> <span class="o">=</span> <span class="n">CIFS_DIR_SEP</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">s</span> <span class="o">=</span> <span class="n">full_path</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* skip separators */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">==</span> <span class="n">sep</span><span class="p">)</span>
			<span class="n">s</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">s</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">s</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* next separator */</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">s</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">s</span> <span class="o">!=</span> <span class="n">sep</span><span class="p">)</span>
			<span class="n">s</span><span class="o">++</span><span class="p">;</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">child</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">s</span> <span class="o">-</span> <span class="n">p</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">child</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">full_path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">dentry</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_set_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifs_mnt_data</span> <span class="o">*</span><span class="n">mnt_data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">mnt_data</span><span class="o">-&gt;</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">set_anon_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">cifs_do_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
	      <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_sb_info</span> <span class="o">*</span><span class="n">cifs_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">smb_vol</span> <span class="o">*</span><span class="n">volume_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifs_mnt_data</span> <span class="n">mnt_data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Devname: %s flags: %d &quot;</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">volume_info</span> <span class="o">=</span> <span class="n">cifs_get_volume_info</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">volume_info</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">volume_info</span><span class="p">);</span>

	<span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifs_sb_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_nls</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mountdata</span> <span class="o">=</span> <span class="n">kstrndup</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mountdata</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_cifs_sb</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cifs_setup_cifs_sb</span><span class="p">(</span><span class="n">volume_info</span><span class="p">,</span> <span class="n">cifs_sb</span><span class="p">);</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_mount</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">,</span> <span class="n">volume_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_SILENT</span><span class="p">))</span>
			<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_mount failed w/return code = %d&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_mountdata</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mnt_data</span><span class="p">.</span><span class="n">vol</span> <span class="o">=</span> <span class="n">volume_info</span><span class="p">;</span>
	<span class="n">mnt_data</span><span class="p">.</span><span class="n">cifs_sb</span> <span class="o">=</span> <span class="n">cifs_sb</span><span class="p">;</span>
	<span class="n">mnt_data</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">sb</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">cifs_match_super</span><span class="p">,</span> <span class="n">cifs_set_super</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mnt_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">cifs_umount</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Use existing superblock&quot;</span><span class="p">);</span>
		<span class="n">cifs_umount</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="cm">/* BB should we make this contingent on mount parm? */</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_NODIRATIME</span> <span class="o">|</span> <span class="n">MS_NOATIME</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_read_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">rc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_super</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">cifs_get_root</span><span class="p">(</span><span class="n">volume_info</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_super</span><span class="p">;</span>

	<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;dentry root is: %p&quot;</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">out_super:</span>
	<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">cifs_cleanup_volume_info</span><span class="p">(</span><span class="n">volume_info</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">root</span><span class="p">;</span>

<span class="nl">out_mountdata:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cifs_sb</span><span class="o">-&gt;</span><span class="n">mountdata</span><span class="p">);</span>
<span class="nl">out_cifs_sb:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">cifs_sb</span><span class="p">);</span>
<span class="nl">out_nls:</span>
	<span class="n">unload_nls</span><span class="p">(</span><span class="n">volume_info</span><span class="o">-&gt;</span><span class="n">local_nls</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">cifs_file_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">generic_file_aio_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheAll</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">written</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_fdatawrite</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_file_aio_write: %d rc on %p inode&quot;</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">written</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">cifs_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * origin == SEEK_END || SEEK_DATA || SEEK_HOLE =&gt; we must revalidate</span>
<span class="cm">	 * the cached file length</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">!=</span> <span class="n">SEEK_SET</span> <span class="o">&amp;&amp;</span> <span class="n">origin</span> <span class="o">!=</span> <span class="n">SEEK_CUR</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rc</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to be sure that all dirty pages are written and the</span>
<span class="cm">		 * server has the newest file length.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rc</span> <span class="o">=</span> <span class="n">filemap_fdatawait</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">rc</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Some applications poll for the file length in this strange</span>
<span class="cm">		 * way so we must seek to end on non-oplocked files by</span>
<span class="cm">		 * setting the revalidate time to zero.</span>
<span class="cm">		 */</span>
		<span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">time</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_revalidate_file_attr</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rc</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span><span class="n">rc</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">generic_file_llseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cifs_setlease</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file_lock</span> <span class="o">**</span><span class="n">lease</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* note that this is called by vfs setlease with lock_flocks held</span>
<span class="cm">	   to protect *lease from going away */</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cifsFileInfo</span> <span class="o">*</span><span class="n">cfile</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/* check if file is oplocked */</span>
	<span class="k">if</span> <span class="p">(((</span><span class="n">arg</span> <span class="o">==</span> <span class="n">F_RDLCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span><span class="p">))</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">arg</span> <span class="o">==</span> <span class="n">F_WRLCK</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheAll</span><span class="p">)))</span>
		<span class="k">return</span> <span class="n">generic_setlease</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">lease</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tlink_tcon</span><span class="p">(</span><span class="n">cfile</span><span class="o">-&gt;</span><span class="n">tlink</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">local_lease</span> <span class="o">&amp;&amp;</span>
		 <span class="o">!</span><span class="n">CIFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">clientCanCacheRead</span><span class="p">)</span>
		<span class="cm">/* If the server claims to support oplock on this</span>
<span class="cm">		   file, then we still need to check oplock even</span>
<span class="cm">		   if the local_lease mount option is set, but there</span>
<span class="cm">		   are servers which do not support oplock for which</span>
<span class="cm">		   this mount option may be useful if the user</span>
<span class="cm">		   knows that the file won&#39;t be changed on the server</span>
<span class="cm">		   by anyone else */</span>
		<span class="k">return</span> <span class="n">generic_setlease</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">lease</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">cifs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span> <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;cifs&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span> <span class="o">=</span> <span class="n">cifs_do_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span> <span class="o">=</span> <span class="n">cifs_kill_sb</span><span class="p">,</span>
	<span class="cm">/*  .fs_flags */</span>
<span class="p">};</span>
<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">cifs_dir_inode_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">create</span> <span class="o">=</span> <span class="n">cifs_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span> <span class="o">=</span> <span class="n">cifs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span> <span class="o">=</span> <span class="n">cifs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span> <span class="o">=</span> <span class="n">cifs_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span> <span class="o">=</span> <span class="n">cifs_hardlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span> <span class="o">=</span> <span class="n">cifs_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span> <span class="o">=</span> <span class="n">cifs_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span> <span class="o">=</span> <span class="n">cifs_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span> <span class="o">=</span> <span class="n">cifs_permission</span><span class="p">,</span>
<span class="cm">/*	revalidate:cifs_revalidate,   */</span>
	<span class="p">.</span><span class="n">setattr</span> <span class="o">=</span> <span class="n">cifs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span> <span class="o">=</span> <span class="n">cifs_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>   <span class="o">=</span> <span class="n">cifs_mknod</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span> <span class="o">=</span> <span class="n">cifs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span> <span class="o">=</span> <span class="n">cifs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span> <span class="o">=</span> <span class="n">cifs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span> <span class="o">=</span> <span class="n">cifs_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">cifs_file_inode_ops</span> <span class="o">=</span> <span class="p">{</span>
<span class="cm">/*	revalidate:cifs_revalidate, */</span>
	<span class="p">.</span><span class="n">setattr</span> <span class="o">=</span> <span class="n">cifs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span> <span class="o">=</span> <span class="n">cifs_getattr</span><span class="p">,</span> <span class="cm">/* do we need this anymore? */</span>
	<span class="p">.</span><span class="n">rename</span> <span class="o">=</span> <span class="n">cifs_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span> <span class="o">=</span> <span class="n">cifs_permission</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span> <span class="o">=</span> <span class="n">cifs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span> <span class="o">=</span> <span class="n">cifs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span> <span class="o">=</span> <span class="n">cifs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span> <span class="o">=</span> <span class="n">cifs_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">cifs_symlink_inode_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span> <span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span> <span class="o">=</span> <span class="n">cifs_follow_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_link</span> <span class="o">=</span> <span class="n">cifs_put_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span> <span class="o">=</span> <span class="n">cifs_permission</span><span class="p">,</span>
	<span class="cm">/* BB add the following two eventually */</span>
	<span class="cm">/* revalidate: cifs_revalidate,</span>
<span class="cm">	   setattr:    cifs_notify_change, *//* BB do we need notify change */</span>
<span class="cp">#ifdef CONFIG_CIFS_XATTR</span>
	<span class="p">.</span><span class="n">setxattr</span> <span class="o">=</span> <span class="n">cifs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span> <span class="o">=</span> <span class="n">cifs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span> <span class="o">=</span> <span class="n">cifs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span> <span class="o">=</span> <span class="n">cifs_removexattr</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cifs_file_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span> <span class="n">generic_file_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">cifs_file_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cifs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cifs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">cifs_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span> <span class="o">=</span> <span class="n">cifs_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">cifs_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>  <span class="o">=</span> <span class="n">cifs_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">cifs_llseek</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">cifs_ioctl</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_POSIX */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">setlease</span> <span class="o">=</span> <span class="n">cifs_setlease</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cifs_file_strict_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span> <span class="n">cifs_strict_readv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">cifs_strict_writev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cifs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cifs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">cifs_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span> <span class="o">=</span> <span class="n">cifs_strict_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">cifs_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">cifs_file_strict_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">cifs_llseek</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">cifs_ioctl</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_POSIX */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">setlease</span> <span class="o">=</span> <span class="n">cifs_setlease</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cifs_file_direct_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* BB reevaluate whether they can be done with directio, no cache */</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span> <span class="n">cifs_user_readv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">cifs_user_writev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cifs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cifs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lock</span> <span class="o">=</span> <span class="n">cifs_lock</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span> <span class="o">=</span> <span class="n">cifs_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">cifs_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">cifs_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>  <span class="o">=</span> <span class="n">cifs_ioctl</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_POSIX */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">cifs_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setlease</span> <span class="o">=</span> <span class="n">cifs_setlease</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cifs_file_nobrl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span> <span class="n">generic_file_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">cifs_file_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cifs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cifs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span> <span class="o">=</span> <span class="n">cifs_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">cifs_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>  <span class="o">=</span> <span class="n">cifs_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">cifs_llseek</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">cifs_ioctl</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_POSIX */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">setlease</span> <span class="o">=</span> <span class="n">cifs_setlease</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cifs_file_strict_nobrl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span> <span class="n">cifs_strict_readv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">cifs_strict_writev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cifs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cifs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span> <span class="o">=</span> <span class="n">cifs_strict_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">cifs_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">cifs_file_strict_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">cifs_llseek</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">cifs_ioctl</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_POSIX */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">setlease</span> <span class="o">=</span> <span class="n">cifs_setlease</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cifs_file_direct_nobrl_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="cm">/* BB reevaluate whether they can be done with directio, no cache */</span>
	<span class="p">.</span><span class="n">read</span> <span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span> <span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span> <span class="o">=</span> <span class="n">cifs_user_readv</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span> <span class="o">=</span> <span class="n">cifs_user_writev</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span> <span class="o">=</span> <span class="n">cifs_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cifs_close</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span> <span class="o">=</span> <span class="n">cifs_fsync</span><span class="p">,</span>
	<span class="p">.</span><span class="n">flush</span> <span class="o">=</span> <span class="n">cifs_flush</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span> <span class="o">=</span> <span class="n">cifs_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span> <span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_CIFS_POSIX</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>  <span class="o">=</span> <span class="n">cifs_ioctl</span><span class="p">,</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_POSIX */</span><span class="cp"></span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">cifs_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setlease</span> <span class="o">=</span> <span class="n">cifs_setlease</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">cifs_dir_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readdir</span> <span class="o">=</span> <span class="n">cifs_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span> <span class="o">=</span> <span class="n">cifs_closedir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>    <span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>  <span class="o">=</span> <span class="n">cifs_ioctl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">llseek</span> <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cifsInodeInfo</span> <span class="o">*</span><span class="n">cifsi</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifsi</span><span class="o">-&gt;</span><span class="n">lock_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_init_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cifs_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;cifs_inode_cache&quot;</span><span class="p">,</span>
					      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">cifsInodeInfo</span><span class="p">),</span>
					      <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="o">|</span>
						<span class="n">SLAB_MEM_SPREAD</span><span class="p">),</span>
					      <span class="n">cifs_init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_inode_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_destroy_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_inode_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_init_request_bufs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">CIFSMaxBufSize</span> <span class="o">&lt;</span> <span class="mi">8192</span><span class="p">)</span> <span class="p">{</span>
	<span class="cm">/* Buffer size can not be smaller than 2 * PATH_MAX since maximum</span>
<span class="cm">	Unicode path name has to fit in any SMB/CIFS path based frames */</span>
		<span class="n">CIFSMaxBufSize</span> <span class="o">=</span> <span class="mi">8192</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CIFSMaxBufSize</span> <span class="o">&gt;</span> <span class="mi">1024</span><span class="o">*</span><span class="mi">127</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">CIFSMaxBufSize</span> <span class="o">=</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">127</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">CIFSMaxBufSize</span> <span class="o">&amp;=</span> <span class="mh">0x1FE00</span><span class="p">;</span> <span class="cm">/* Round size to even 512 byte mult*/</span>
	<span class="p">}</span>
<span class="cm">/*	cERROR(1, &quot;CIFSMaxBufSize %d 0x%x&quot;,CIFSMaxBufSize,CIFSMaxBufSize); */</span>
	<span class="n">cifs_req_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;cifs_request&quot;</span><span class="p">,</span>
					    <span class="n">CIFSMaxBufSize</span> <span class="o">+</span>
					    <span class="n">MAX_CIFS_HDR_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_req_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_min_rcv</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">cifs_min_rcv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cifs_min_rcv</span> <span class="o">&gt;</span> <span class="mi">64</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifs_min_rcv</span> <span class="o">=</span> <span class="mi">64</span><span class="p">;</span>
		<span class="n">cERROR</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_min_rcv set to maximum (64)&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cifs_req_poolp</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">cifs_min_rcv</span><span class="p">,</span>
						  <span class="n">cifs_req_cachep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_req_poolp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_req_cachep</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* MAX_CIFS_SMALL_BUFFER_SIZE bytes is enough for most SMB responses and</span>
<span class="cm">	almost all handle based requests (but not write response, nor is it</span>
<span class="cm">	sufficient for path based requests).  A smaller size would have</span>
<span class="cm">	been more efficient (compacting multiple slab items on one 4k page)</span>
<span class="cm">	for the case in which debug was on, but this larger size allows</span>
<span class="cm">	more SMBs to use small buffer alloc and is still much more</span>
<span class="cm">	efficient to alloc 1 per page off the slab compared to 17K (5page)</span>
<span class="cm">	alloc of large cifs buffers even when page debugging is on */</span>
	<span class="n">cifs_sm_req_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;cifs_small_rq&quot;</span><span class="p">,</span>
			<span class="n">MAX_CIFS_SMALL_BUFFER_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span>
			<span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sm_req_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cifs_req_poolp</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_req_cachep</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_min_small</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">cifs_min_small</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cifs_min_small</span> <span class="o">&gt;</span> <span class="mi">256</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifs_min_small</span> <span class="o">=</span> <span class="mi">256</span><span class="p">;</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_min_small set to maximum (256)&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cifs_sm_req_poolp</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">cifs_min_small</span><span class="p">,</span>
						     <span class="n">cifs_sm_req_cachep</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_sm_req_poolp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cifs_req_poolp</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_req_cachep</span><span class="p">);</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_sm_req_cachep</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_destroy_request_bufs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cifs_req_poolp</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_req_cachep</span><span class="p">);</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cifs_sm_req_poolp</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_sm_req_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">cifs_init_mids</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cifs_mid_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;cifs_mpx_ids&quot;</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">mid_q_entry</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
					    <span class="n">SLAB_HWCACHE_ALIGN</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_mid_cachep</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/* 3 is a reasonable minimum number of simultaneous operations */</span>
	<span class="n">cifs_mid_poolp</span> <span class="o">=</span> <span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">cifs_mid_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_mid_poolp</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_mid_cachep</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">cifs_destroy_mids</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">cifs_mid_poolp</span><span class="p">);</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">cifs_mid_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span>
<span class="nf">init_cifs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">cifs_proc_init</span><span class="p">();</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_list</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CIFS_DNOTIFY_EXPERIMENTAL </span><span class="cm">/* unused temporarily */</span><span class="cp"></span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalDnotifyReqList</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalDnotifyRsp_Q</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* was needed for dnotify, and will be needed for inotify when VFS fix */</span><span class="cp"></span>
<span class="cm">/*</span>
<span class="cm"> *  Initialize Global counters</span>
<span class="cm"> */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sesInfoAllocCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tconInfoAllocCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcpSesAllocCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tcpSesReconnectCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tconInfoReconnectCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bufAllocCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">smBufAllocCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_CIFS_STATS2</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">totBufAllocCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">totSmBufAllocCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_STATS2 */</span><span class="cp"></span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">midCount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">GlobalCurrentXid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">GlobalTotalActiveXid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">GlobalMaxActiveXid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_tcp_ses_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_file_list_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">GlobalMid_Lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cifs_max_pending</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifs_max_pending</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_max_pending set to min of 2&quot;</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cifs_max_pending</span> <span class="o">&gt;</span> <span class="n">CIFS_MAX_REQ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cifs_max_pending</span> <span class="o">=</span> <span class="n">CIFS_MAX_REQ</span><span class="p">;</span>
		<span class="n">cFYI</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;cifs_max_pending set to max of %u&quot;</span><span class="p">,</span> <span class="n">CIFS_MAX_REQ</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cifsiod_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;cifsiod&quot;</span><span class="p">,</span> <span class="n">WQ_FREEZABLE</span><span class="o">|</span><span class="n">WQ_MEM_RECLAIM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cifsiod_wq</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rc</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_clean_proc</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_fscache_register</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_destroy_wq</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_init_inodecache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unreg_fscache</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_init_mids</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_destroy_inodecache</span><span class="p">;</span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">cifs_init_request_bufs</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_destroy_mids</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_CIFS_UPCALL</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_spnego_key_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_destroy_request_bufs</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_UPCALL */</span><span class="cp"></span>

<span class="cp">#ifdef CONFIG_CIFS_ACL</span>
	<span class="n">rc</span> <span class="o">=</span> <span class="n">init_cifs_idmap</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_register_key_type</span><span class="p">;</span>
<span class="cp">#endif </span><span class="cm">/* CONFIG_CIFS_ACL */</span><span class="cp"></span>

	<span class="n">rc</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rc</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_init_cifs_idmap</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_init_cifs_idmap:</span>
<span class="cp">#ifdef CONFIG_CIFS_ACL</span>
	<span class="n">exit_cifs_idmap</span><span class="p">();</span>
<span class="nl">out_register_key_type:</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CIFS_UPCALL</span>
	<span class="n">unregister_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_spnego_key_type</span><span class="p">);</span>
<span class="nl">out_destroy_request_bufs:</span>
<span class="cp">#endif</span>
	<span class="n">cifs_destroy_request_bufs</span><span class="p">();</span>
<span class="nl">out_destroy_mids:</span>
	<span class="n">cifs_destroy_mids</span><span class="p">();</span>
<span class="nl">out_destroy_inodecache:</span>
	<span class="n">cifs_destroy_inodecache</span><span class="p">();</span>
<span class="nl">out_unreg_fscache:</span>
	<span class="n">cifs_fscache_unregister</span><span class="p">();</span>
<span class="nl">out_destroy_wq:</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">cifsiod_wq</span><span class="p">);</span>
<span class="nl">out_clean_proc:</span>
	<span class="n">cifs_proc_clean</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">rc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span>
<span class="nf">exit_cifs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">cFYI</span><span class="p">(</span><span class="n">DBG2</span><span class="p">,</span> <span class="s">&quot;exit_cifs&quot;</span><span class="p">);</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_fs_type</span><span class="p">);</span>
	<span class="n">cifs_dfs_release_automount_timer</span><span class="p">();</span>
<span class="cp">#ifdef CONFIG_CIFS_ACL</span>
	<span class="n">cifs_destroy_idmaptrees</span><span class="p">();</span>
	<span class="n">exit_cifs_idmap</span><span class="p">();</span>
<span class="cp">#endif</span>
<span class="cp">#ifdef CONFIG_CIFS_UPCALL</span>
	<span class="n">unregister_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cifs_spnego_key_type</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">cifs_destroy_request_bufs</span><span class="p">();</span>
	<span class="n">cifs_destroy_mids</span><span class="p">();</span>
	<span class="n">cifs_destroy_inodecache</span><span class="p">();</span>
	<span class="n">cifs_fscache_unregister</span><span class="p">();</span>
	<span class="n">destroy_workqueue</span><span class="p">(</span><span class="n">cifsiod_wq</span><span class="p">);</span>
	<span class="n">cifs_proc_clean</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;Steve French &lt;sfrench@us.ibm.com&gt;&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>	<span class="cm">/* combination of LGPL + GPL source behaves as GPL */</span>
<span class="n">MODULE_DESCRIPTION</span>
    <span class="p">(</span><span class="s">&quot;VFS to access servers complying with the SNIA CIFS Specification &quot;</span>
     <span class="s">&quot;e.g. Samba and Windows&quot;</span><span class="p">);</span>
<span class="n">MODULE_VERSION</span><span class="p">(</span><span class="n">CIFS_VERSION</span><span class="p">);</span>
<span class="n">module_init</span><span class="p">(</span><span class="n">init_cifs</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_cifs</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
