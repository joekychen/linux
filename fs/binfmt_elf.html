<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › binfmt_elf.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>binfmt_elf.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/binfmt_elf.c</span>
<span class="cm"> *</span>
<span class="cm"> * These are the functions used to load ELF format executables as used</span>
<span class="cm"> * on SVr4 machines.  Information on the format may be found in the book</span>
<span class="cm"> * &quot;UNIX SYSTEM V RELEASE 4 Programmers Guide: Ansi C and Programming Support</span>
<span class="cm"> * Tools&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright 1993, 1994: Eric Youngdale (ericy@cais.com).</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/mman.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/signal.h&gt;</span>
<span class="cp">#include &lt;linux/binfmts.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/personality.h&gt;</span>
<span class="cp">#include &lt;linux/elfcore.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/highuid.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/elf.h&gt;</span>
<span class="cp">#include &lt;linux/utsname.h&gt;</span>
<span class="cp">#include &lt;linux/coredump.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>
<span class="cp">#include &lt;asm/param.h&gt;</span>
<span class="cp">#include &lt;asm/page.h&gt;</span>
<span class="cp">#include &lt;asm/exec.h&gt;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">load_elf_binary</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">load_elf_library</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="p">,</span>
				<span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * If we don&#39;t support core dumping, then supply a NULL so we</span>
<span class="cm"> * don&#39;t even try.</span>
<span class="cm"> */</span>
<span class="cp">#ifdef CONFIG_ELF_CORE</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">elf_core_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">coredump_params</span> <span class="o">*</span><span class="n">cprm</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="cp">#define elf_core_dump	NULL</span>
<span class="cp">#endif</span>

<span class="cp">#if ELF_EXEC_PAGESIZE &gt; PAGE_SIZE</span>
<span class="cp">#define ELF_MIN_ALIGN	ELF_EXEC_PAGESIZE</span>
<span class="cp">#else</span>
<span class="cp">#define ELF_MIN_ALIGN	PAGE_SIZE</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef ELF_CORE_EFLAGS</span>
<span class="cp">#define ELF_CORE_EFLAGS	0</span>
<span class="cp">#endif</span>

<span class="cp">#define ELF_PAGESTART(_v) ((_v) &amp; ~(unsigned long)(ELF_MIN_ALIGN-1))</span>
<span class="cp">#define ELF_PAGEOFFSET(_v) ((_v) &amp; (ELF_MIN_ALIGN-1))</span>
<span class="cp">#define ELF_PAGEALIGN(_v) (((_v) + ELF_MIN_ALIGN - 1) &amp; ~(ELF_MIN_ALIGN - 1))</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">linux_binfmt</span> <span class="n">elf_format</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">module</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">load_binary</span>	<span class="o">=</span> <span class="n">load_elf_binary</span><span class="p">,</span>
	<span class="p">.</span><span class="n">load_shlib</span>	<span class="o">=</span> <span class="n">load_elf_library</span><span class="p">,</span>
	<span class="p">.</span><span class="n">core_dump</span>	<span class="o">=</span> <span class="n">elf_core_dump</span><span class="p">,</span>
	<span class="p">.</span><span class="n">min_coredump</span>	<span class="o">=</span> <span class="n">ELF_EXEC_PAGESIZE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cp">#define BAD_ADDR(x) ((unsigned long)(x) &gt;= TASK_SIZE)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_brk</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">start</span> <span class="o">=</span> <span class="n">ELF_PAGEALIGN</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">ELF_PAGEALIGN</span><span class="p">(</span><span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="n">vm_brk</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">addr</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We need to explicitly zero any fractional pages</span>
<span class="cm">   after the data section (i.e. bss).  This would</span>
<span class="cm">   contain the junk from the file that should not</span>
<span class="cm">   be in memory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">padzero</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_bss</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbyte</span><span class="p">;</span>

	<span class="n">nbyte</span> <span class="o">=</span> <span class="n">ELF_PAGEOFFSET</span><span class="p">(</span><span class="n">elf_bss</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nbyte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nbyte</span> <span class="o">=</span> <span class="n">ELF_MIN_ALIGN</span> <span class="o">-</span> <span class="n">nbyte</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clear_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">elf_bss</span><span class="p">,</span> <span class="n">nbyte</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Let&#39;s use some macros to make this stack manipulation a little clearer */</span>
<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
<span class="cp">#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) + (items))</span>
<span class="cp">#define STACK_ROUND(sp, items) \</span>
<span class="cp">	((15 + (unsigned long) ((sp) + (items))) &amp;~ 15UL)</span>
<span class="cp">#define STACK_ALLOC(sp, len) ({ \</span>
<span class="cp">	elf_addr_t __user *old_sp = (elf_addr_t __user *)sp; sp += len; \</span>
<span class="cp">	old_sp; })</span>
<span class="cp">#else</span>
<span class="cp">#define STACK_ADD(sp, items) ((elf_addr_t __user *)(sp) - (items))</span>
<span class="cp">#define STACK_ROUND(sp, items) \</span>
<span class="cp">	(((unsigned long) (sp - items)) &amp;~ 15UL)</span>
<span class="cp">#define STACK_ALLOC(sp, len) ({ sp -= len ; sp; })</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef ELF_BASE_PLATFORM</span>
<span class="cm">/*</span>
<span class="cm"> * AT_BASE_PLATFORM indicates the &quot;real&quot; hardware/microarchitecture.</span>
<span class="cm"> * If the arch defines ELF_BASE_PLATFORM (in asm/elf.h), the value</span>
<span class="cm"> * will be copied to the user stack in the same manner as AT_PLATFORM.</span>
<span class="cm"> */</span>
<span class="cp">#define ELF_BASE_PLATFORM NULL</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">create_elf_tables</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">exec</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load_addr</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interp_load_addr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">argc</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">argc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">envc</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">envc</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argv</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">envp</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_platform</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_base_platform</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="n">u_rand_bytes</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">k_platform</span> <span class="o">=</span> <span class="n">ELF_PLATFORM</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">k_base_platform</span> <span class="o">=</span> <span class="n">ELF_BASE_PLATFORM</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">k_rand_bytes</span><span class="p">[</span><span class="mi">16</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">items</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="o">*</span><span class="n">elf_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ei_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span> <span class="o">=</span> <span class="n">current_cred</span><span class="p">();</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * In some cases (e.g. Hyper-Threading), we want to avoid L1</span>
<span class="cm">	 * evictions by the processes running on the same package. One</span>
<span class="cm">	 * thing we can do is to shuffle the initial stack for them.</span>
<span class="cm">	 */</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">arch_align_stack</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this architecture has a platform capability string, copy it</span>
<span class="cm">	 * to userspace.  In some cases (Sparc), this info is impossible</span>
<span class="cm">	 * for userspace to get any other way, in others (i386) it is</span>
<span class="cm">	 * merely difficult.</span>
<span class="cm">	 */</span>
	<span class="n">u_platform</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k_platform</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">k_platform</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">u_platform</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">STACK_ALLOC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">u_platform</span><span class="p">,</span> <span class="n">k_platform</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this architecture has a &quot;base&quot; platform capability</span>
<span class="cm">	 * string, copy it to userspace.</span>
<span class="cm">	 */</span>
	<span class="n">u_base_platform</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k_base_platform</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">k_base_platform</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">u_base_platform</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">STACK_ALLOC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">u_base_platform</span><span class="p">,</span> <span class="n">k_base_platform</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Generate 16 random bytes for userspace PRNG seeding.</span>
<span class="cm">	 */</span>
	<span class="n">get_random_bytes</span><span class="p">(</span><span class="n">k_rand_bytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">k_rand_bytes</span><span class="p">));</span>
	<span class="n">u_rand_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
		       <span class="n">STACK_ALLOC</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">k_rand_bytes</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__copy_to_user</span><span class="p">(</span><span class="n">u_rand_bytes</span><span class="p">,</span> <span class="n">k_rand_bytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">k_rand_bytes</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Create the ELF interpreter info */</span>
	<span class="n">elf_info</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">saved_auxv</span><span class="p">;</span>
	<span class="cm">/* update AT_VECTOR_SIZE_BASE if the number of NEW_AUX_ENT() changes */</span>
<span class="cp">#define NEW_AUX_ENT(id, val) \</span>
<span class="cp">	do { \</span>
<span class="cp">		elf_info[ei_index++] = id; \</span>
<span class="cp">		elf_info[ei_index++] = val; \</span>
<span class="cp">	} while (0)</span>

<span class="cp">#ifdef ARCH_DLINFO</span>
	<span class="cm">/* </span>
<span class="cm">	 * ARCH_DLINFO must come first so PPC can do its special alignment of</span>
<span class="cm">	 * AUXV.</span>
<span class="cm">	 * update AT_VECTOR_SIZE_ARCH if the number of NEW_AUX_ENT() in</span>
<span class="cm">	 * ARCH_DLINFO changes</span>
<span class="cm">	 */</span>
	<span class="n">ARCH_DLINFO</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_HWCAP</span><span class="p">,</span> <span class="n">ELF_HWCAP</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_PAGESZ</span><span class="p">,</span> <span class="n">ELF_EXEC_PAGESIZE</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_CLKTCK</span><span class="p">,</span> <span class="n">CLOCKS_PER_SEC</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_PHDR</span><span class="p">,</span> <span class="n">load_addr</span> <span class="o">+</span> <span class="n">exec</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_PHENT</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">));</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_PHNUM</span><span class="p">,</span> <span class="n">exec</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_BASE</span><span class="p">,</span> <span class="n">interp_load_addr</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_FLAGS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_ENTRY</span><span class="p">,</span> <span class="n">exec</span><span class="o">-&gt;</span><span class="n">e_entry</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_UID</span><span class="p">,</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">));</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_EUID</span><span class="p">,</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">euid</span><span class="p">));</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_GID</span><span class="p">,</span> <span class="n">from_kgid_munged</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">));</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_EGID</span><span class="p">,</span> <span class="n">from_kgid_munged</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">egid</span><span class="p">));</span>
 	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_SECURE</span><span class="p">,</span> <span class="n">security_bprm_secureexec</span><span class="p">(</span><span class="n">bprm</span><span class="p">));</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_RANDOM</span><span class="p">,</span> <span class="p">(</span><span class="n">elf_addr_t</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">u_rand_bytes</span><span class="p">);</span>
	<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_EXECFN</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">exec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k_platform</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_PLATFORM</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">elf_addr_t</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">u_platform</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k_base_platform</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_BASE_PLATFORM</span><span class="p">,</span>
			    <span class="p">(</span><span class="n">elf_addr_t</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">u_base_platform</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">interp_flags</span> <span class="o">&amp;</span> <span class="n">BINPRM_FLAGS_EXECFD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NEW_AUX_ENT</span><span class="p">(</span><span class="n">AT_EXECFD</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">interp_data</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#undef NEW_AUX_ENT</span>
	<span class="cm">/* AT_NULL is zero; clear the rest too */</span>
	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elf_info</span><span class="p">[</span><span class="n">ei_index</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
	       <span class="k">sizeof</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">saved_auxv</span> <span class="o">-</span> <span class="n">ei_index</span> <span class="o">*</span> <span class="k">sizeof</span> <span class="n">elf_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/* And advance past the AT_NULL entry.  */</span>
	<span class="n">ei_index</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">sp</span> <span class="o">=</span> <span class="n">STACK_ADD</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">ei_index</span><span class="p">);</span>

	<span class="n">items</span> <span class="o">=</span> <span class="p">(</span><span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">envc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">=</span> <span class="n">STACK_ROUND</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">items</span><span class="p">);</span>

	<span class="cm">/* Point sp at the lowest address on the stack */</span>
<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span> <span class="o">-</span> <span class="n">items</span> <span class="o">-</span> <span class="n">ei_index</span><span class="p">;</span>
	<span class="n">bprm</span><span class="o">-&gt;</span><span class="n">exec</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sp</span><span class="p">;</span> <span class="cm">/* XXX: PARISC HACK */</span>
<span class="cp">#else</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>
<span class="cp">#endif</span>


	<span class="cm">/*</span>
<span class="cm">	 * Grow the stack manually; some architectures have a limit on how</span>
<span class="cm">	 * far ahead a user-space access may be in order to grow the stack.</span>
<span class="cm">	 */</span>
	<span class="n">vma</span> <span class="o">=</span> <span class="n">find_extend_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="cm">/* Now, let&#39;s put argc (and argv, envp if appropriate) on the stack */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">sp</span><span class="o">++</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">argv</span> <span class="o">=</span> <span class="n">sp</span><span class="p">;</span>
	<span class="n">envp</span> <span class="o">=</span> <span class="n">argv</span> <span class="o">+</span> <span class="n">argc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Populate argv and envp */</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">argc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">((</span><span class="n">elf_addr_t</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">argv</span><span class="o">++</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strnlen_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">argv</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_start</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">envc</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">((</span><span class="n">elf_addr_t</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">envp</span><span class="o">++</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">strnlen_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="p">,</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">len</span> <span class="o">||</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">MAX_ARG_STRLEN</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">__put_user</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">envp</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">env_end</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Put the elf_info on the stack in the right place.  */</span>
	<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">envp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">elf_info</span><span class="p">,</span> <span class="n">ei_index</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_addr_t</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">elf_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filep</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">eppnt</span><span class="p">,</span> <span class="kt">int</span> <span class="n">prot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map_addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size</span> <span class="o">=</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">+</span> <span class="n">ELF_PAGEOFFSET</span><span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">off</span> <span class="o">=</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_offset</span> <span class="o">-</span> <span class="n">ELF_PAGEOFFSET</span><span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">);</span>
	<span class="n">addr</span> <span class="o">=</span> <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">ELF_PAGEALIGN</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* mmap() will return -EINVAL if given a zero size, but a</span>
<span class="cm">	 * segment with zero filesize is perfectly valid */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">addr</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	* total_size is the size of the ELF (interpreter) image.</span>
<span class="cm">	* The _first_ mmap needs to know the full size, otherwise</span>
<span class="cm">	* randomization might put this image into an overlapping</span>
<span class="cm">	* position with the ELF binary image. (since size &lt; total_size)</span>
<span class="cm">	* So we first map the &#39;big&#39; image - and unmap the remainder at</span>
<span class="cm">	* the end. (which unmap is needed for ELF images with holes.)</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">total_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">total_size</span> <span class="o">=</span> <span class="n">ELF_PAGEALIGN</span><span class="p">(</span><span class="n">total_size</span><span class="p">);</span>
		<span class="n">map_addr</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="n">filep</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">map_addr</span><span class="p">))</span>
			<span class="n">vm_munmap</span><span class="p">(</span><span class="n">map_addr</span><span class="o">+</span><span class="n">size</span><span class="p">,</span> <span class="n">total_size</span><span class="o">-</span><span class="n">size</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">map_addr</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="n">filep</span><span class="p">,</span> <span class="n">addr</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">prot</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">off</span><span class="p">);</span>

	<span class="k">return</span><span class="p">(</span><span class="n">map_addr</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">total_mapping_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">cmds</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">first_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">last_idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cmds</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_LOAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">first_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">first_idx</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">cmds</span><span class="p">[</span><span class="n">last_idx</span><span class="p">].</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">cmds</span><span class="p">[</span><span class="n">last_idx</span><span class="p">].</span><span class="n">p_memsz</span> <span class="o">-</span>
				<span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">cmds</span><span class="p">[</span><span class="n">first_idx</span><span class="p">].</span><span class="n">p_vaddr</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* This is much more generalized than the library routine read function,</span>
<span class="cm">   so we keep this separate.  Technically the library read function</span>
<span class="cm">   is only provided so that we can read a.out libraries that have</span>
<span class="cm">   an ELF header */</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">load_elf_interp</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">interp_elf_ex</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">interpreter</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">interp_map_addr</span><span class="p">,</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">no_base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">elf_phdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">eppnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">load_addr_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_bss</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">elf_bss</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">size</span><span class="p">;</span>

	<span class="cm">/* First of all, some simple consistency checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_EXEC</span> <span class="o">&amp;&amp;</span>
	    <span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_DYN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_check_arch</span><span class="p">(</span><span class="n">interp_elf_ex</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">interpreter</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">interpreter</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the size of this structure has changed, then punt, since</span>
<span class="cm">	 * we will be doing the wrong thing.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_phentsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span>
		<span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">&gt;</span> <span class="mi">65536U</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Now read in all of the header information */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">ELF_MIN_ALIGN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">elf_phdata</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_phdata</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">interpreter</span><span class="p">,</span> <span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_phoff</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">elf_phdata</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">retval</span><span class="p">;</span>	
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">total_size</span> <span class="o">=</span> <span class="n">total_mapping_size</span><span class="p">(</span><span class="n">elf_phdata</span><span class="p">,</span> <span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">eppnt</span> <span class="o">=</span> <span class="n">elf_phdata</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">eppnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_LOAD</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">elf_type</span> <span class="o">=</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_DENYWRITE</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">elf_prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">vaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">k</span><span class="p">,</span> <span class="n">map_addr</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_R</span><span class="p">)</span>
		    		<span class="n">elf_prot</span> <span class="o">=</span> <span class="n">PROT_READ</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_W</span><span class="p">)</span>
				<span class="n">elf_prot</span> <span class="o">|=</span> <span class="n">PROT_WRITE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_X</span><span class="p">)</span>
				<span class="n">elf_prot</span> <span class="o">|=</span> <span class="n">PROT_EXEC</span><span class="p">;</span>
			<span class="n">vaddr</span> <span class="o">=</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_EXEC</span> <span class="o">||</span> <span class="n">load_addr_set</span><span class="p">)</span>
				<span class="n">elf_type</span> <span class="o">|=</span> <span class="n">MAP_FIXED</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">no_base</span> <span class="o">&amp;&amp;</span> <span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_DYN</span><span class="p">)</span>
				<span class="n">load_addr</span> <span class="o">=</span> <span class="o">-</span><span class="n">vaddr</span><span class="p">;</span>

			<span class="n">map_addr</span> <span class="o">=</span> <span class="n">elf_map</span><span class="p">(</span><span class="n">interpreter</span><span class="p">,</span> <span class="n">load_addr</span> <span class="o">+</span> <span class="n">vaddr</span><span class="p">,</span>
					<span class="n">eppnt</span><span class="p">,</span> <span class="n">elf_prot</span><span class="p">,</span> <span class="n">elf_type</span><span class="p">,</span> <span class="n">total_size</span><span class="p">);</span>
			<span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">interp_map_addr</span><span class="p">)</span>
				<span class="o">*</span><span class="n">interp_map_addr</span> <span class="o">=</span> <span class="n">map_addr</span><span class="p">;</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">map_addr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">map_addr</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_addr_set</span> <span class="o">&amp;&amp;</span>
			    <span class="n">interp_elf_ex</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_DYN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">load_addr</span> <span class="o">=</span> <span class="n">map_addr</span> <span class="o">-</span> <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">vaddr</span><span class="p">);</span>
				<span class="n">load_addr_set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Check to see if the section&#39;s size will overflow the</span>
<span class="cm">			 * allowed task size. Note that p_filesz must always be</span>
<span class="cm">			 * &lt;= p_memsize so it&#39;s only necessary to check p_memsz.</span>
<span class="cm">			 */</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">load_addr</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">&gt;</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">||</span>
			    <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span> <span class="o">||</span>
			    <span class="n">TASK_SIZE</span> <span class="o">-</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * Find the end of the file mapping for this phdr, and</span>
<span class="cm">			 * keep track of the largest address we see for this.</span>
<span class="cm">			 */</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">load_addr</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">elf_bss</span><span class="p">)</span>
				<span class="n">elf_bss</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * Do the same thing for the memory mapping - between</span>
<span class="cm">			 * elf_bss and last_bss is the bss section.</span>
<span class="cm">			 */</span>
			<span class="n">k</span> <span class="o">=</span> <span class="n">load_addr</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">last_bss</span><span class="p">)</span>
				<span class="n">last_bss</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_bss</span> <span class="o">&gt;</span> <span class="n">elf_bss</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Now fill out the bss section.  First pad the last page up</span>
<span class="cm">		 * to the page boundary, and then perform a mmap to make sure</span>
<span class="cm">		 * that there are zero-mapped pages up to and including the</span>
<span class="cm">		 * last bss page.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">padzero</span><span class="p">(</span><span class="n">elf_bss</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* What we have mapped so far */</span>
		<span class="n">elf_bss</span> <span class="o">=</span> <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">elf_bss</span> <span class="o">+</span> <span class="n">ELF_MIN_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/* Map the last of the bss segment */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vm_brk</span><span class="p">(</span><span class="n">elf_bss</span><span class="p">,</span> <span class="n">last_bss</span> <span class="o">-</span> <span class="n">elf_bss</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_close</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">load_addr</span><span class="p">;</span>

<span class="nl">out_close:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">elf_phdata</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * These are the functions used to load ELF style executables and shared</span>
<span class="cm"> * libraries.  There is no binary dependent code anywhere else.</span>
<span class="cm"> */</span>

<span class="cp">#define INTERPRETER_NONE 0</span>
<span class="cp">#define INTERPRETER_ELF 2</span>

<span class="cp">#ifndef STACK_RND_MASK</span>
<span class="cp">#define STACK_RND_MASK (0x7ff &gt;&gt; (PAGE_SHIFT - 12))	</span><span class="cm">/* 8MB of VA */</span><span class="cp"></span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">randomize_stack_top</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">stack_top</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">random_variable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">random_variable</span> <span class="o">=</span> <span class="n">get_random_int</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">STACK_RND_MASK</span><span class="p">;</span>
		<span class="n">random_variable</span> <span class="o">&lt;&lt;=</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_STACK_GROWSUP</span>
	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack_top</span><span class="p">)</span> <span class="o">+</span> <span class="n">random_variable</span><span class="p">;</span>
<span class="cp">#else</span>
	<span class="k">return</span> <span class="n">PAGE_ALIGN</span><span class="p">(</span><span class="n">stack_top</span><span class="p">)</span> <span class="o">-</span> <span class="n">random_variable</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_elf_binary</span><span class="p">(</span><span class="k">struct</span> <span class="n">linux_binprm</span> <span class="o">*</span><span class="n">bprm</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">interpreter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="cm">/* to shut gcc up */</span>
 	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">load_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">load_bias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">load_addr_set</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span> <span class="n">elf_interpreter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">elf_ppnt</span><span class="p">,</span> <span class="o">*</span><span class="n">elf_phdata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_bss</span><span class="p">,</span> <span class="n">elf_brk</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_entry</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">interp_load_addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_code</span><span class="p">,</span> <span class="n">end_code</span><span class="p">,</span> <span class="n">start_data</span><span class="p">,</span> <span class="n">end_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">reloc_func_desc</span> <span class="n">__maybe_unused</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">executable_stack</span> <span class="o">=</span> <span class="n">EXSTACK_DEFAULT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">def_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">elfhdr</span> <span class="n">elf_ex</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">elfhdr</span> <span class="n">interp_elf_ex</span><span class="p">;</span>
	<span class="p">}</span> <span class="o">*</span><span class="n">loc</span><span class="p">;</span>

	<span class="n">loc</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">loc</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">loc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_ret</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="cm">/* Get the exec-header */</span>
	<span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="cm">/* First of all, some simple consistency checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_EXEC</span> <span class="o">&amp;&amp;</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_DYN</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_check_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Now read in all of the header information */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phentsize</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span>
	 	<span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span> <span class="o">&gt;</span> <span class="mi">65536U</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">elf_phdata</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_phdata</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">retval</span> <span class="o">=</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phoff</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">elf_phdata</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_ph</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">elf_ppnt</span> <span class="o">=</span> <span class="n">elf_phdata</span><span class="p">;</span>
	<span class="n">elf_bss</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">elf_brk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">start_code</span> <span class="o">=</span> <span class="o">~</span><span class="mi">0UL</span><span class="p">;</span>
	<span class="n">end_code</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">start_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">end_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_INTERP</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This is the program interpreter used for</span>
<span class="cm">			 * shared libraries - for now assume that this</span>
<span class="cm">			 * is an a.out format binary</span>
<span class="cm">			 */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">&gt;</span> <span class="n">PATH_MAX</span> <span class="o">||</span> 
			    <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_ph</span><span class="p">;</span>

			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">elf_interpreter</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">,</span>
						  <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_interpreter</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_ph</span><span class="p">;</span>

			<span class="n">retval</span> <span class="o">=</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">,</span>
					     <span class="n">elf_interpreter</span><span class="p">,</span>
					     <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free_interp</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* make sure path is NULL terminated */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">elf_interpreter</span><span class="p">[</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_free_interp</span><span class="p">;</span>

			<span class="n">interpreter</span> <span class="o">=</span> <span class="n">open_exec</span><span class="p">(</span><span class="n">elf_interpreter</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">interpreter</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">interpreter</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_free_interp</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * If the binary is not readable then enforce</span>
<span class="cm">			 * mm-&gt;dumpable = 0 regardless of the interpreter&#39;s</span>
<span class="cm">			 * permissions.</span>
<span class="cm">			 */</span>
			<span class="n">would_dump</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">interpreter</span><span class="p">);</span>

			<span class="n">retval</span> <span class="o">=</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">interpreter</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
					     <span class="n">BINPRM_BUF_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">BINPRM_BUF_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Get the exec headers */</span>
			<span class="n">loc</span><span class="o">-&gt;</span><span class="n">interp_elf_ex</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="p">)</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">elf_ppnt</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">elf_ppnt</span> <span class="o">=</span> <span class="n">elf_phdata</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">elf_ppnt</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_GNU_STACK</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_X</span><span class="p">)</span>
				<span class="n">executable_stack</span> <span class="o">=</span> <span class="n">EXSTACK_ENABLE_X</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">executable_stack</span> <span class="o">=</span> <span class="n">EXSTACK_DISABLE_X</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="cm">/* Some simple consistency checks for the interpreter */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf_interpreter</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">ELIBBAD</span><span class="p">;</span>
		<span class="cm">/* Not an ELF interpreter */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">interp_elf_ex</span><span class="p">.</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
		<span class="cm">/* Verify the interpreter has a valid arch */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_check_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">interp_elf_ex</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Flush all traces of the currently running executable */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">flush_old_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>

	<span class="cm">/* OK, This is the point of no return */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">def_flags</span> <span class="o">=</span> <span class="n">def_flags</span><span class="p">;</span>

	<span class="cm">/* Do this immediately, since STACK_TOP as used in setup_arg_pages</span>
<span class="cm">	   may depend on the personality.  */</span>
	<span class="n">SET_PERSONALITY</span><span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf_read_implies_exec</span><span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">,</span> <span class="n">executable_stack</span><span class="p">))</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">|=</span> <span class="n">READ_IMPLIES_EXEC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">ADDR_NO_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">randomize_va_space</span><span class="p">)</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_RANDOMIZE</span><span class="p">;</span>

	<span class="n">setup_new_exec</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>

	<span class="cm">/* Do this so that we can load the interpreter, if need be.  We will</span>
<span class="cm">	   change some of these later */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">free_area_cache</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap_base</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">cached_hole_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">setup_arg_pages</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="n">randomize_stack_top</span><span class="p">(</span><span class="n">STACK_TOP</span><span class="p">),</span>
				 <span class="n">executable_stack</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
	<span class="p">}</span>
	
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_stack</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>

	<span class="cm">/* Now we do a little grungy work by mmapping the ELF image into</span>
<span class="cm">	   the correct location in memory. */</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">elf_ppnt</span> <span class="o">=</span> <span class="n">elf_phdata</span><span class="p">;</span>
	    <span class="n">i</span> <span class="o">&lt;</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">elf_ppnt</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">elf_prot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">elf_flags</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">k</span><span class="p">,</span> <span class="n">vaddr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">!=</span> <span class="n">PT_LOAD</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span> <span class="p">(</span><span class="n">elf_brk</span> <span class="o">&gt;</span> <span class="n">elf_bss</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nbyte</span><span class="p">;</span>
	            
			<span class="cm">/* There was a PT_LOAD segment with p_memsz &gt; p_filesz</span>
<span class="cm">			   before this one. Map anonymous pages, if needed,</span>
<span class="cm">			   and clear the area.  */</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">set_brk</span><span class="p">(</span><span class="n">elf_bss</span> <span class="o">+</span> <span class="n">load_bias</span><span class="p">,</span>
					 <span class="n">elf_brk</span> <span class="o">+</span> <span class="n">load_bias</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">nbyte</span> <span class="o">=</span> <span class="n">ELF_PAGEOFFSET</span><span class="p">(</span><span class="n">elf_bss</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nbyte</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nbyte</span> <span class="o">=</span> <span class="n">ELF_MIN_ALIGN</span> <span class="o">-</span> <span class="n">nbyte</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nbyte</span> <span class="o">&gt;</span> <span class="n">elf_brk</span> <span class="o">-</span> <span class="n">elf_bss</span><span class="p">)</span>
					<span class="n">nbyte</span> <span class="o">=</span> <span class="n">elf_brk</span> <span class="o">-</span> <span class="n">elf_bss</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">clear_user</span><span class="p">((</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">elf_bss</span> <span class="o">+</span>
							<span class="n">load_bias</span><span class="p">,</span> <span class="n">nbyte</span><span class="p">))</span> <span class="p">{</span>
					<span class="cm">/*</span>
<span class="cm">					 * This bss-zeroing can fail if the ELF</span>
<span class="cm">					 * file specifies odd protections. So</span>
<span class="cm">					 * we don&#39;t check the return value</span>
<span class="cm">					 */</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_R</span><span class="p">)</span>
			<span class="n">elf_prot</span> <span class="o">|=</span> <span class="n">PROT_READ</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_W</span><span class="p">)</span>
			<span class="n">elf_prot</span> <span class="o">|=</span> <span class="n">PROT_WRITE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_X</span><span class="p">)</span>
			<span class="n">elf_prot</span> <span class="o">|=</span> <span class="n">PROT_EXEC</span><span class="p">;</span>

		<span class="n">elf_flags</span> <span class="o">=</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_DENYWRITE</span> <span class="o">|</span> <span class="n">MAP_EXECUTABLE</span><span class="p">;</span>

		<span class="n">vaddr</span> <span class="o">=</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_EXEC</span> <span class="o">||</span> <span class="n">load_addr_set</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">elf_flags</span> <span class="o">|=</span> <span class="n">MAP_FIXED</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_DYN</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Try and get dynamic programs out of the way of the</span>
<span class="cm">			 * default mmap base, as well as whatever program they</span>
<span class="cm">			 * might try to exec.  This is because the brk will</span>
<span class="cm">			 * follow the loader, and is not movable.  */</span>
<span class="cp">#ifdef CONFIG_ARCH_BINFMT_ELF_RANDOMIZE_PIE</span>
			<span class="cm">/* Memory randomization might have been switched off</span>
<span class="cm">			 * in runtime via sysctl.</span>
<span class="cm">			 * If that is the case, retain the original non-zero</span>
<span class="cm">			 * load_bias value in order to establish proper</span>
<span class="cm">			 * non-randomized mappings.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span>
				<span class="n">load_bias</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">load_bias</span> <span class="o">=</span> <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">ELF_ET_DYN_BASE</span> <span class="o">-</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="cp">#else</span>
			<span class="n">load_bias</span> <span class="o">=</span> <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">ELF_ET_DYN_BASE</span> <span class="o">-</span> <span class="n">vaddr</span><span class="p">);</span>
<span class="cp">#endif</span>
		<span class="p">}</span>

		<span class="n">error</span> <span class="o">=</span> <span class="n">elf_map</span><span class="p">(</span><span class="n">bprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">load_bias</span> <span class="o">+</span> <span class="n">vaddr</span><span class="p">,</span> <span class="n">elf_ppnt</span><span class="p">,</span>
				<span class="n">elf_prot</span><span class="p">,</span> <span class="n">elf_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">error</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">IS_ERR</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">error</span><span class="p">)</span> <span class="o">?</span>
				<span class="n">PTR_ERR</span><span class="p">((</span><span class="kt">void</span><span class="o">*</span><span class="p">)</span><span class="n">error</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">load_addr_set</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">load_addr_set</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">load_addr</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">-</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_type</span> <span class="o">==</span> <span class="n">ET_DYN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">load_bias</span> <span class="o">+=</span> <span class="n">error</span> <span class="o">-</span>
				             <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">load_bias</span> <span class="o">+</span> <span class="n">vaddr</span><span class="p">);</span>
				<span class="n">load_addr</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>
				<span class="n">reloc_func_desc</span> <span class="o">=</span> <span class="n">load_bias</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">start_code</span><span class="p">)</span>
			<span class="n">start_code</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start_data</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
			<span class="n">start_data</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check to see if the section&#39;s size will overflow the</span>
<span class="cm">		 * allowed task size. Note that p_filesz must always be</span>
<span class="cm">		 * &lt;= p_memsz so it is only necessary to check p_memsz.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">||</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">&gt;</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">||</span>
		    <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">&gt;</span> <span class="n">TASK_SIZE</span> <span class="o">||</span>
		    <span class="n">TASK_SIZE</span> <span class="o">-</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set_brk can never work. Avoid overflows. */</span>
			<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">k</span> <span class="o">=</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">elf_bss</span><span class="p">)</span>
			<span class="n">elf_bss</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">&amp;</span> <span class="n">PF_X</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">end_code</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
			<span class="n">end_code</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end_data</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">)</span>
			<span class="n">end_data</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
		<span class="n">k</span> <span class="o">=</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">elf_ppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">elf_brk</span><span class="p">)</span>
			<span class="n">elf_brk</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_entry</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>
	<span class="n">elf_bss</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>
	<span class="n">elf_brk</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>
	<span class="n">start_code</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>
	<span class="n">end_code</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>
	<span class="n">start_data</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>
	<span class="n">end_data</span> <span class="o">+=</span> <span class="n">load_bias</span><span class="p">;</span>

	<span class="cm">/* Calling set_brk effectively mmaps the pages that we need</span>
<span class="cm">	 * for the bss and break sections.  We must do this before</span>
<span class="cm">	 * mapping in the interpreter, to make sure it doesn&#39;t wind</span>
<span class="cm">	 * up getting placed where the bss needs to go.</span>
<span class="cm">	 */</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">set_brk</span><span class="p">(</span><span class="n">elf_bss</span><span class="p">,</span> <span class="n">elf_brk</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">elf_bss</span> <span class="o">!=</span> <span class="n">elf_brk</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">padzero</span><span class="p">(</span><span class="n">elf_bss</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span> <span class="cm">/* Nobody gets to see this, but.. */</span>
		<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">elf_interpreter</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">uninitialized_var</span><span class="p">(</span><span class="n">interp_map_addr</span><span class="p">);</span>

		<span class="n">elf_entry</span> <span class="o">=</span> <span class="n">load_elf_interp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">interp_elf_ex</span><span class="p">,</span>
					    <span class="n">interpreter</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">interp_map_addr</span><span class="p">,</span>
					    <span class="n">load_bias</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">elf_entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * load_elf_interp() returns relocation</span>
<span class="cm">			 * adjustment</span>
<span class="cm">			 */</span>
			<span class="n">interp_load_addr</span> <span class="o">=</span> <span class="n">elf_entry</span><span class="p">;</span>
			<span class="n">elf_entry</span> <span class="o">+=</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">interp_elf_ex</span><span class="p">.</span><span class="n">e_entry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">elf_entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="n">IS_ERR</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">elf_entry</span><span class="p">)</span> <span class="o">?</span>
					<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">elf_entry</span> <span class="o">:</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">reloc_func_desc</span> <span class="o">=</span> <span class="n">interp_load_addr</span><span class="p">;</span>

		<span class="n">allow_write_access</span><span class="p">(</span><span class="n">interpreter</span><span class="p">);</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">interpreter</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">elf_interpreter</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">elf_entry</span> <span class="o">=</span> <span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_entry</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BAD_ADDR</span><span class="p">(</span><span class="n">elf_entry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">force_sig</span><span class="p">(</span><span class="n">SIGSEGV</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
			<span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free_dentry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">elf_phdata</span><span class="p">);</span>

	<span class="n">set_binfmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elf_format</span><span class="p">);</span>

<span class="cp">#ifdef ARCH_HAS_SETUP_ADDITIONAL_PAGES</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">arch_setup_additional_pages</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="o">!!</span><span class="n">elf_interpreter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* ARCH_HAS_SETUP_ADDITIONAL_PAGES */</span><span class="cp"></span>

	<span class="n">install_exec_creds</span><span class="p">(</span><span class="n">bprm</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">create_elf_tables</span><span class="p">(</span><span class="n">bprm</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loc</span><span class="o">-&gt;</span><span class="n">elf_ex</span><span class="p">,</span>
			  <span class="n">load_addr</span><span class="p">,</span> <span class="n">interp_load_addr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">send_sig</span><span class="p">(</span><span class="n">SIGKILL</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* N.B. passed_fileno might not be initialized? */</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_code</span> <span class="o">=</span> <span class="n">end_code</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_code</span> <span class="o">=</span> <span class="n">start_code</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_data</span> <span class="o">=</span> <span class="n">start_data</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">end_data</span> <span class="o">=</span> <span class="n">end_data</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_stack</span> <span class="o">=</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">;</span>

<span class="cp">#ifdef arch_randomize_brk</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_RANDOMIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">randomize_va_space</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">brk</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">start_brk</span> <span class="o">=</span>
			<span class="n">arch_randomize_brk</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_COMPAT_BRK</span>
		<span class="n">current</span><span class="o">-&gt;</span><span class="n">brk_randomized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">personality</span> <span class="o">&amp;</span> <span class="n">MMAP_PAGE_ZERO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Why this, you ask???  Well SVr4 maps page 0 as read-only,</span>
<span class="cm">		   and some applications &quot;depend&quot; upon this behavior.</span>
<span class="cm">		   Since we do not have the power to recompile these, we</span>
<span class="cm">		   emulate the SVr4 behavior. Sigh. */</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_EXEC</span><span class="p">,</span>
				<span class="n">MAP_FIXED</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="cp">#ifdef ELF_PLAT_INIT</span>
	<span class="cm">/*</span>
<span class="cm">	 * The ABI may specify that certain registers be set up in special</span>
<span class="cm">	 * ways (on i386 %edx is the address of a DT_FINI function, for</span>
<span class="cm">	 * example.  In addition, it may also specify (eg, PowerPC64 ELF)</span>
<span class="cm">	 * that the e_entry field is the address of the function descriptor</span>
<span class="cm">	 * for the startup routine, rather than the address of the startup</span>
<span class="cm">	 * routine itself.  This macro performs whatever initialization to</span>
<span class="cm">	 * the regs structure is required as well as any relocations to the</span>
<span class="cm">	 * function descriptor entries when executing dynamically links apps.</span>
<span class="cm">	 */</span>
	<span class="n">ELF_PLAT_INIT</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">reloc_func_desc</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="n">start_thread</span><span class="p">(</span><span class="n">regs</span><span class="p">,</span> <span class="n">elf_entry</span><span class="p">,</span> <span class="n">bprm</span><span class="o">-&gt;</span><span class="n">p</span><span class="p">);</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">loc</span><span class="p">);</span>
<span class="nl">out_ret:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>

	<span class="cm">/* error cleanup */</span>
<span class="nl">out_free_dentry:</span>
	<span class="n">allow_write_access</span><span class="p">(</span><span class="n">interpreter</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">interpreter</span><span class="p">)</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">interpreter</span><span class="p">);</span>
<span class="nl">out_free_interp:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">elf_interpreter</span><span class="p">);</span>
<span class="nl">out_free_ph:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">elf_phdata</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* This is really simpleminded and specialized - we are loading an</span>
<span class="cm">   a.out library that is given an ELF header. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">load_elf_library</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">elf_phdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">eppnt</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">elf_bss</span><span class="p">,</span> <span class="n">bss</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retval</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elfhdr</span> <span class="n">elf_ex</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">elf_ex</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_ex</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_ex</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* First of all, some simple consistency checks */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_type</span> <span class="o">!=</span> <span class="n">ET_EXEC</span> <span class="o">||</span> <span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span> <span class="o">&gt;</span> <span class="mi">2</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">elf_check_arch</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elf_ex</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Now read in all of the header information */</span>

	<span class="n">j</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">)</span> <span class="o">*</span> <span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span><span class="p">;</span>
	<span class="cm">/* j &lt; ELF_MIN_ALIGN because elf_ex.e_phnum &lt;= 2 */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">elf_phdata</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_phdata</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">eppnt</span> <span class="o">=</span> <span class="n">elf_phdata</span><span class="p">;</span>
	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="n">kernel_read</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phoff</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">eppnt</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retval</span> <span class="o">!=</span> <span class="n">j</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_ph</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">elf_ex</span><span class="p">.</span><span class="n">e_phnum</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">eppnt</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">==</span> <span class="n">PT_LOAD</span><span class="p">)</span>
			<span class="n">j</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free_ph</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">!=</span> <span class="n">PT_LOAD</span><span class="p">)</span>
		<span class="n">eppnt</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* Now use mmap to map the library into memory. */</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">vm_mmap</span><span class="p">(</span><span class="n">file</span><span class="p">,</span>
			<span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">),</span>
			<span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">+</span>
			 <span class="n">ELF_PAGEOFFSET</span><span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">)),</span>
			<span class="n">PROT_READ</span> <span class="o">|</span> <span class="n">PROT_WRITE</span> <span class="o">|</span> <span class="n">PROT_EXEC</span><span class="p">,</span>
			<span class="n">MAP_FIXED</span> <span class="o">|</span> <span class="n">MAP_PRIVATE</span> <span class="o">|</span> <span class="n">MAP_DENYWRITE</span><span class="p">,</span>
			<span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_offset</span> <span class="o">-</span>
			 <span class="n">ELF_PAGEOFFSET</span><span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">)));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">!=</span> <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_free_ph</span><span class="p">;</span>

	<span class="n">elf_bss</span> <span class="o">=</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">padzero</span><span class="p">(</span><span class="n">elf_bss</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free_ph</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">ELF_PAGESTART</span><span class="p">(</span><span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">+</span>
			    <span class="n">ELF_MIN_ALIGN</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bss</span> <span class="o">=</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">+</span> <span class="n">eppnt</span><span class="o">-&gt;</span><span class="n">p_vaddr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bss</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
		<span class="n">vm_brk</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">bss</span> <span class="o">-</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_free_ph:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">elf_phdata</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef CONFIG_ELF_CORE</span>
<span class="cm">/*</span>
<span class="cm"> * ELF core dumper</span>
<span class="cm"> *</span>
<span class="cm"> * Modelled on fs/exec.c:aout_core_dump()</span>
<span class="cm"> * Jeremy Fitzhardinge &lt;jeremy@sw.oz.au&gt;</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * The purpose of always_dump_vma() is to make sure that special kernel mappings</span>
<span class="cm"> * that are useful for post-mortem analysis are included in every core dump.</span>
<span class="cm"> * In that way we ensure that the core dump is fully interpretable later</span>
<span class="cm"> * without matching up the same kernel and hardware config to see what PC values</span>
<span class="cm"> * meant. These special mappings include - vDSO, vsyscall, and other</span>
<span class="cm"> * architecture specific mappings</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">bool</span> <span class="nf">always_dump_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Any vsyscall mappings? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span> <span class="o">==</span> <span class="n">get_gate_vma</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_mm</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * arch_vma_name() returns non-NULL for special architecture mappings,</span>
<span class="cm">	 * such as vDSO sections.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arch_vma_name</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Decide what to dump of a segment, part, all or none.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">vma_dump_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mm_flags</span><span class="p">)</span>
<span class="p">{</span>
<span class="cp">#define FILTER(type)	(mm_flags &amp; (1UL &lt;&lt; MMF_DUMP_##type))</span>

	<span class="cm">/* always dump the vdso and vsyscall sections */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">always_dump_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">whole</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_NODUMP</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Hugetlb memory check */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_HUGETLB</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">FILTER</span><span class="p">(</span><span class="n">HUGETLB_SHARED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">whole</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">FILTER</span><span class="p">(</span><span class="n">HUGETLB_PRIVATE</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">whole</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Do not dump I/O mapped devices or special mappings */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">VM_IO</span> <span class="o">|</span> <span class="n">VM_RESERVED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* By default, dump shared memory if mapped from an anonymous file. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_SHARED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span>
		    <span class="n">FILTER</span><span class="p">(</span><span class="n">ANON_SHARED</span><span class="p">)</span> <span class="o">:</span> <span class="n">FILTER</span><span class="p">(</span><span class="n">MAPPED_SHARED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">whole</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Dump segments that have been written to.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">anon_vma</span> <span class="o">&amp;&amp;</span> <span class="n">FILTER</span><span class="p">(</span><span class="n">ANON_PRIVATE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">whole</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">FILTER</span><span class="p">(</span><span class="n">MAPPED_PRIVATE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">whole</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this looks like the beginning of a DSO or executable mapping,</span>
<span class="cm">	 * check for an ELF header.  If we find one, dump the first page to</span>
<span class="cm">	 * aid in determining what was mapped here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">FILTER</span><span class="p">(</span><span class="n">ELF_HEADERS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_pgoff</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_READ</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="n">header</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">u32</span> <span class="n">word</span><span class="p">;</span>
		<span class="n">mm_segment_t</span> <span class="n">fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
		<span class="cm">/*</span>
<span class="cm">		 * Doing it this way gets the constant folded by GCC.</span>
<span class="cm">		 */</span>
		<span class="k">union</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">cmp</span><span class="p">;</span>
			<span class="kt">char</span> <span class="n">elfmag</span><span class="p">[</span><span class="n">SELFMAG</span><span class="p">];</span>
		<span class="p">}</span> <span class="n">magic</span><span class="p">;</span>
		<span class="n">BUILD_BUG_ON</span><span class="p">(</span><span class="n">SELFMAG</span> <span class="o">!=</span> <span class="k">sizeof</span> <span class="n">word</span><span class="p">);</span>
		<span class="n">magic</span><span class="p">.</span><span class="n">elfmag</span><span class="p">[</span><span class="n">EI_MAG0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELFMAG0</span><span class="p">;</span>
		<span class="n">magic</span><span class="p">.</span><span class="n">elfmag</span><span class="p">[</span><span class="n">EI_MAG1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELFMAG1</span><span class="p">;</span>
		<span class="n">magic</span><span class="p">.</span><span class="n">elfmag</span><span class="p">[</span><span class="n">EI_MAG2</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELFMAG2</span><span class="p">;</span>
		<span class="n">magic</span><span class="p">.</span><span class="n">elfmag</span><span class="p">[</span><span class="n">EI_MAG3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELFMAG3</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Switch to the user &quot;segment&quot; for get_user(),</span>
<span class="cm">		 * then put back what elf_core_dump() had in place.</span>
<span class="cm">		 */</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">USER_DS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">get_user</span><span class="p">(</span><span class="n">word</span><span class="p">,</span> <span class="n">header</span><span class="p">)))</span>
			<span class="n">word</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">set_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">word</span> <span class="o">==</span> <span class="n">magic</span><span class="p">.</span><span class="n">cmp</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="p">}</span>

<span class="cp">#undef	FILTER</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">whole:</span>
	<span class="k">return</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* An ELF note in memory */</span>
<span class="k">struct</span> <span class="n">memelfnote</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">datasz</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">notesize</span><span class="p">(</span><span class="k">struct</span> <span class="n">memelfnote</span> <span class="o">*</span><span class="n">en</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>

	<span class="n">sz</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note</span><span class="p">);</span>
	<span class="n">sz</span> <span class="o">+=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">en</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="n">sz</span> <span class="o">+=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">en</span><span class="o">-&gt;</span><span class="n">datasz</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define DUMP_WRITE(addr, nr, foffset)	\</span>
<span class="cp">	do { if (!dump_write(file, (addr), (nr))) return 0; *foffset += (nr); } while(0)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alignfile</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">foffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="p">};</span>
	<span class="n">DUMP_WRITE</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">roundup</span><span class="p">(</span><span class="o">*</span><span class="n">foffset</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">-</span> <span class="o">*</span><span class="n">foffset</span><span class="p">,</span> <span class="n">foffset</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">writenote</span><span class="p">(</span><span class="k">struct</span> <span class="n">memelfnote</span> <span class="o">*</span><span class="n">men</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			<span class="n">loff_t</span> <span class="o">*</span><span class="n">foffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_note</span> <span class="n">en</span><span class="p">;</span>
	<span class="n">en</span><span class="p">.</span><span class="n">n_namesz</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">men</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">en</span><span class="p">.</span><span class="n">n_descsz</span> <span class="o">=</span> <span class="n">men</span><span class="o">-&gt;</span><span class="n">datasz</span><span class="p">;</span>
	<span class="n">en</span><span class="p">.</span><span class="n">n_type</span> <span class="o">=</span> <span class="n">men</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="n">DUMP_WRITE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">en</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">en</span><span class="p">),</span> <span class="n">foffset</span><span class="p">);</span>
	<span class="n">DUMP_WRITE</span><span class="p">(</span><span class="n">men</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">en</span><span class="p">.</span><span class="n">n_namesz</span><span class="p">,</span> <span class="n">foffset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alignfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">DUMP_WRITE</span><span class="p">(</span><span class="n">men</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="n">men</span><span class="o">-&gt;</span><span class="n">datasz</span><span class="p">,</span> <span class="n">foffset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alignfile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#undef DUMP_WRITE</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_elf_header</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">segs</span><span class="p">,</span>
			    <span class="n">u16</span> <span class="n">machine</span><span class="p">,</span> <span class="n">u32</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u8</span> <span class="n">osabi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">elf</span><span class="p">));</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">,</span> <span class="n">ELFMAG</span><span class="p">,</span> <span class="n">SELFMAG</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_CLASS</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELF_CLASS</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_DATA</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELF_DATA</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_VERSION</span><span class="p">]</span> <span class="o">=</span> <span class="n">EV_CURRENT</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ident</span><span class="p">[</span><span class="n">EI_OSABI</span><span class="p">]</span> <span class="o">=</span> <span class="n">ELF_OSABI</span><span class="p">;</span>

	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_type</span> <span class="o">=</span> <span class="n">ET_CORE</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_machine</span> <span class="o">=</span> <span class="n">machine</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_version</span> <span class="o">=</span> <span class="n">EV_CURRENT</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phoff</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_ehsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phentsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_phnum</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>

	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_elf_note_phdr</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">phdr</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_type</span> <span class="o">=</span> <span class="n">PT_NOTE</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_vaddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_paddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_filesz</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_memsz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">phdr</span><span class="o">-&gt;</span><span class="n">p_align</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_note</span><span class="p">(</span><span class="k">struct</span> <span class="n">memelfnote</span> <span class="o">*</span><span class="n">note</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> 
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sz</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">note</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span><span class="p">;</span>
	<span class="n">note</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">note</span><span class="o">-&gt;</span><span class="n">datasz</span> <span class="o">=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="n">note</span><span class="o">-&gt;</span><span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fill up all the fields in prstatus from the given task struct, except</span>
<span class="cm"> * registers which need to be filled up separately.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_prstatus</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_prstatus</span> <span class="o">*</span><span class="n">prstatus</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">long</span> <span class="n">signr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_info</span><span class="p">.</span><span class="n">si_signo</span> <span class="o">=</span> <span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_cursig</span> <span class="o">=</span> <span class="n">signr</span><span class="p">;</span>
	<span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_sigpend</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">pending</span><span class="p">.</span><span class="n">signal</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_sighold</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">.</span><span class="n">sig</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_ppid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_pgrp</span> <span class="o">=</span> <span class="n">task_pgrp_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_sid</span> <span class="o">=</span> <span class="n">task_session_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">thread_group_leader</span><span class="p">(</span><span class="n">p</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">task_cputime</span> <span class="n">cputime</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This is the record for the group leader.  It shows the</span>
<span class="cm">		 * group-wide total, not its individual thread total.</span>
<span class="cm">		 */</span>
		<span class="n">thread_group_cputime</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cputime</span><span class="p">);</span>
		<span class="n">cputime_to_timeval</span><span class="p">(</span><span class="n">cputime</span><span class="p">.</span><span class="n">utime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_utime</span><span class="p">);</span>
		<span class="n">cputime_to_timeval</span><span class="p">(</span><span class="n">cputime</span><span class="p">.</span><span class="n">stime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_stime</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">cputime_to_timeval</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">utime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_utime</span><span class="p">);</span>
		<span class="n">cputime_to_timeval</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">stime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_stime</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">cputime_to_timeval</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cutime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_cutime</span><span class="p">);</span>
	<span class="n">cputime_to_timeval</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">signal</span><span class="o">-&gt;</span><span class="n">cstime</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_cstime</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_psinfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_prpsinfo</span> <span class="o">*</span><span class="n">psinfo</span><span class="p">,</span> <span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">cred</span> <span class="o">*</span><span class="n">cred</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	
	<span class="cm">/* first copy the parameters from user space */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">psinfo</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_prpsinfo</span><span class="p">));</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_end</span> <span class="o">-</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">ELF_PRARGSZ</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ELF_PRARGSZ</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_psargs</span><span class="p">,</span>
		           <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">arg_start</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_psargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_psargs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_psargs</span><span class="p">[</span><span class="n">len</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_ppid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">rcu_dereference</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">real_parent</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_pid</span> <span class="o">=</span> <span class="n">task_pid_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_pgrp</span> <span class="o">=</span> <span class="n">task_pgrp_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_sid</span> <span class="o">=</span> <span class="n">task_session_vnr</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">?</span> <span class="n">ffz</span><span class="p">(</span><span class="o">~</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_state</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_sname</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39;.&#39;</span> <span class="o">:</span> <span class="s">&quot;RSDTZW&quot;</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_zomb</span> <span class="o">=</span> <span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_sname</span> <span class="o">==</span> <span class="sc">&#39;Z&#39;</span><span class="p">;</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_nice</span> <span class="o">=</span> <span class="n">task_nice</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_flag</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">cred</span> <span class="o">=</span> <span class="n">__task_cred</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">SET_UID</span><span class="p">(</span><span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_uid</span><span class="p">,</span> <span class="n">from_kuid_munged</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">uid</span><span class="p">));</span>
	<span class="n">SET_GID</span><span class="p">(</span><span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_gid</span><span class="p">,</span> <span class="n">from_kgid_munged</span><span class="p">(</span><span class="n">cred</span><span class="o">-&gt;</span><span class="n">user_ns</span><span class="p">,</span> <span class="n">cred</span><span class="o">-&gt;</span><span class="n">gid</span><span class="p">));</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="n">strncpy</span><span class="p">(</span><span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_fname</span><span class="p">,</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">psinfo</span><span class="o">-&gt;</span><span class="n">pr_fname</span><span class="p">));</span>
	
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_auxv_note</span><span class="p">(</span><span class="k">struct</span> <span class="n">memelfnote</span> <span class="o">*</span><span class="n">note</span><span class="p">,</span> <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">mm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elf_addr_t</span> <span class="o">*</span><span class="n">auxv</span> <span class="o">=</span> <span class="p">(</span><span class="n">elf_addr_t</span> <span class="o">*</span><span class="p">)</span> <span class="n">mm</span><span class="o">-&gt;</span><span class="n">saved_auxv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span>
		<span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">auxv</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">!=</span> <span class="n">AT_NULL</span><span class="p">);</span>
	<span class="n">fill_note</span><span class="p">(</span><span class="n">note</span><span class="p">,</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_AUXV</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">elf_addr_t</span><span class="p">),</span> <span class="n">auxv</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef CORE_DUMP_USE_REGSET</span>
<span class="cp">#include &lt;linux/regset.h&gt;</span>

<span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_prstatus</span> <span class="n">prstatus</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memelfnote</span> <span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">elf_note_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memelfnote</span> <span class="n">psinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">memelfnote</span> <span class="n">auxv</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">thread_notes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * When a regset has a writeback hook, we call it on each thread before</span>
<span class="cm"> * dumping user memory.  On register window machines, this makes sure the</span>
<span class="cm"> * user memory backing the register data is up to date before we read it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">do_thread_regset_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">task</span><span class="p">,</span>
				       <span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset</span> <span class="o">*</span><span class="n">regset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">regset</span><span class="o">-&gt;</span><span class="n">writeback</span><span class="p">)</span>
		<span class="n">regset</span><span class="o">-&gt;</span><span class="n">writeback</span><span class="p">(</span><span class="n">task</span><span class="p">,</span> <span class="n">regset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifndef PR_REG_SIZE</span>
<span class="cp">#define PR_REG_SIZE(S) sizeof(S)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef PRSTATUS_SIZE</span>
<span class="cp">#define PRSTATUS_SIZE(S) sizeof(S)</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef PR_REG_PTR</span>
<span class="cp">#define PR_REG_PTR(S) (&amp;((S)-&gt;pr_reg))</span>
<span class="cp">#endif</span>

<span class="cp">#ifndef SET_PR_FPVALID</span>
<span class="cp">#define SET_PR_FPVALID(S, V) ((S)-&gt;pr_fpvalid = (V))</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_thread_core_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="o">*</span><span class="n">t</span><span class="p">,</span>
				 <span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset_view</span> <span class="o">*</span><span class="n">view</span><span class="p">,</span>
				 <span class="kt">long</span> <span class="n">signr</span><span class="p">,</span> <span class="kt">size_t</span> <span class="o">*</span><span class="n">total</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * NT_PRSTATUS is the one special case, because the regset data</span>
<span class="cm">	 * goes into the pr_reg field inside the note contents, rather</span>
<span class="cm">	 * than being the whole note contents.  We fill the reset in here.</span>
<span class="cm">	 * We assume that regset 0 is NT_PRSTATUS.</span>
<span class="cm">	 */</span>
	<span class="n">fill_prstatus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">signr</span><span class="p">);</span>
	<span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="mi">0</span><span class="p">,</span> <span class="n">PR_REG_SIZE</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">.</span><span class="n">pr_reg</span><span class="p">),</span>
				    <span class="n">PR_REG_PTR</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">fill_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_PRSTATUS</span><span class="p">,</span>
		  <span class="n">PRSTATUS_SIZE</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">);</span>
	<span class="o">*</span><span class="n">total</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">do_thread_regset_writeback</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Each other regset might generate a note too.  For each regset</span>
<span class="cm">	 * that has no core_note_type or is inactive, we leave t-&gt;notes[i]</span>
<span class="cm">	 * all zero and we&#39;ll know to skip writing it later.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset</span> <span class="o">*</span><span class="n">regset</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">do_thread_regset_writeback</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">regset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">regset</span><span class="o">-&gt;</span><span class="n">core_note_type</span> <span class="o">&amp;&amp;</span> <span class="n">regset</span><span class="o">-&gt;</span><span class="n">get</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="o">!</span><span class="n">regset</span><span class="o">-&gt;</span><span class="n">active</span> <span class="o">||</span> <span class="n">regset</span><span class="o">-&gt;</span><span class="n">active</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">regset</span><span class="p">)))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
			<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="n">regset</span><span class="o">-&gt;</span><span class="n">n</span> <span class="o">*</span> <span class="n">regset</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="kt">void</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">regset</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">,</span> <span class="n">regset</span><span class="p">,</span>
					  <span class="mi">0</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">data</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">regset</span><span class="o">-&gt;</span><span class="n">core_note_type</span> <span class="o">!=</span> <span class="n">NT_PRFPREG</span><span class="p">)</span>
					<span class="n">fill_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;LINUX&quot;</span><span class="p">,</span>
						  <span class="n">regset</span><span class="o">-&gt;</span><span class="n">core_note_type</span><span class="p">,</span>
						  <span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
				<span class="k">else</span> <span class="p">{</span>
					<span class="n">SET_PR_FPVALID</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
					<span class="n">fill_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span>
						  <span class="n">NT_PRFPREG</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="o">*</span><span class="n">total</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_note_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phdrs</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			  <span class="kt">long</span> <span class="n">signr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">dump_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="k">const</span> <span class="k">struct</span> <span class="n">user_regset_view</span> <span class="o">*</span><span class="n">view</span> <span class="o">=</span> <span class="n">task_user_regset_view</span><span class="p">(</span><span class="n">dump_task</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_prpsinfo</span> <span class="o">*</span><span class="n">psinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">core_thread</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">psinfo</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">psinfo</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">psinfo</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fill_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">,</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_PRPSINFO</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">psinfo</span><span class="p">),</span> <span class="n">psinfo</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Figure out how many notes we&#39;re going to need for each thread.</span>
<span class="cm">	 */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_notes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">core_note_type</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">++</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_notes</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sanity check.  We rely on regset 0 being in NT_PRSTATUS,</span>
<span class="cm">	 * since it is our one special case.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_notes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">unlikely</span><span class="p">(</span><span class="n">view</span><span class="o">-&gt;</span><span class="n">regsets</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">core_note_type</span> <span class="o">!=</span> <span class="n">NT_PRSTATUS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Initialize the ELF file header.</span>
<span class="cm">	 */</span>
	<span class="n">fill_elf_header</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">phdrs</span><span class="p">,</span>
			<span class="n">view</span><span class="o">-&gt;</span><span class="n">e_machine</span><span class="p">,</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">e_flags</span><span class="p">,</span> <span class="n">view</span><span class="o">-&gt;</span><span class="n">ei_osabi</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Allocate a structure for each thread.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">ct</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dump_task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">dumper</span><span class="p">;</span> <span class="n">ct</span><span class="p">;</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_thread_core_info</span><span class="p">,</span>
				     <span class="n">notes</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_notes</span><span class="p">]),</span>
			    <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">t</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">=</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ct</span><span class="o">-&gt;</span><span class="n">task</span> <span class="o">==</span> <span class="n">dump_task</span> <span class="o">||</span> <span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Make sure to keep the original task at</span>
<span class="cm">			 * the head of the list.</span>
<span class="cm">			 */</span>
			<span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now fill in each thread&#39;s information.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">t</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span> <span class="n">t</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span> <span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fill_thread_core_info</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">view</span><span class="p">,</span> <span class="n">signr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Fill in the two process-wide notes.</span>
<span class="cm">	 */</span>
	<span class="n">fill_psinfo</span><span class="p">(</span><span class="n">psinfo</span><span class="p">,</span> <span class="n">dump_task</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span> <span class="n">dump_task</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">);</span>

	<span class="n">fill_auxv_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">auxv</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">auxv</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">get_note_info_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write all the notes for each thread.  When writing the first thread, the</span>
<span class="cm"> * process-wide notes are interleaved after the first thread-specific note.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_note_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">foffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">first</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writenote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">writenote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">writenote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">auxv</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_notes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">writenote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">first</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">t</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_note_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="o">*</span><span class="n">threads</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">threads</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">elf_thread_core_info</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">threads</span><span class="p">;</span>
		<span class="n">threads</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data</span> <span class="o">&amp;&amp;</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">data</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_notes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">data</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">.</span><span class="n">data</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#else</span>

<span class="cm">/* Here is the structure in which status of each thread is captured. */</span>
<span class="k">struct</span> <span class="n">elf_thread_status</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_prstatus</span> <span class="n">prstatus</span><span class="p">;</span>	<span class="cm">/* NT_PRSTATUS */</span>
	<span class="n">elf_fpregset_t</span> <span class="n">fpu</span><span class="p">;</span>		<span class="cm">/* NT_PRFPREG */</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="kr">thread</span><span class="p">;</span>
<span class="cp">#ifdef ELF_CORE_COPY_XFPREGS</span>
	<span class="n">elf_fpxregset_t</span> <span class="n">xfpu</span><span class="p">;</span>		<span class="cm">/* ELF_CORE_XFPREG_TYPE */</span>
<span class="cp">#endif</span>
	<span class="k">struct</span> <span class="n">memelfnote</span> <span class="n">notes</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">num_notes</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * In order to add the specific thread information for the elf file format,</span>
<span class="cm"> * we need to keep a linked list of every threads pr_status and then create</span>
<span class="cm"> * a single section for them in the final core file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">elf_dump_thread_status</span><span class="p">(</span><span class="kt">long</span> <span class="n">signr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_thread_status</span> <span class="o">*</span><span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="kr">thread</span><span class="p">;</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">num_notes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fill_prstatus</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">signr</span><span class="p">);</span>
	<span class="n">elf_core_copy_task_regs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">.</span><span class="n">pr_reg</span><span class="p">);</span>	
	
	<span class="n">fill_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_PRSTATUS</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">),</span>
		  <span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">));</span>
	<span class="n">t</span><span class="o">-&gt;</span><span class="n">num_notes</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sz</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">.</span><span class="n">pr_fpvalid</span> <span class="o">=</span> <span class="n">elf_core_copy_task_fpregs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
								<span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">fill_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_PRFPREG</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">),</span>
			  <span class="o">&amp;</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">));</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">num_notes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sz</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
	<span class="p">}</span>

<span class="cp">#ifdef ELF_CORE_COPY_XFPREGS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf_core_copy_task_xfpregs</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">fill_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="s">&quot;LINUX&quot;</span><span class="p">,</span> <span class="n">ELF_CORE_XFPREG_TYPE</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">);</span>
		<span class="n">t</span><span class="o">-&gt;</span><span class="n">num_notes</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sz</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif	</span>
	<span class="k">return</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">elf_note_info</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">memelfnote</span> <span class="o">*</span><span class="n">notes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_prstatus</span> <span class="o">*</span><span class="n">prstatus</span><span class="p">;</span>	<span class="cm">/* NT_PRSTATUS */</span>
	<span class="k">struct</span> <span class="n">elf_prpsinfo</span> <span class="o">*</span><span class="n">psinfo</span><span class="p">;</span>	<span class="cm">/* NT_PRPSINFO */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">thread_list</span><span class="p">;</span>
	<span class="n">elf_fpregset_t</span> <span class="o">*</span><span class="n">fpu</span><span class="p">;</span>
<span class="cp">#ifdef ELF_CORE_COPY_XFPREGS</span>
	<span class="n">elf_fpxregset_t</span> <span class="o">*</span><span class="n">xfpu</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="kt">int</span> <span class="n">thread_status_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">numnote</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">elf_note_info_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="p">));</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_list</span><span class="p">);</span>

	<span class="cm">/* Allocate space for six ELF notes */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="mi">6</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">memelfnote</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">notes_free</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">psinfo_free</span><span class="p">;</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">prstatus_free</span><span class="p">;</span>
<span class="cp">#ifdef ELF_CORE_COPY_XFPREGS</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">xfpu</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fpu_free</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef ELF_CORE_COPY_XFPREGS</span>
 <span class="nl">fpu_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">);</span>
<span class="cp">#endif</span>
 <span class="nl">prstatus_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">);</span>
 <span class="nl">psinfo_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">);</span>
 <span class="nl">notes_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">fill_note_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">phdrs</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			  <span class="kt">long</span> <span class="n">signr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_note_info_init</span><span class="p">(</span><span class="n">info</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">signr</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">core_thread</span> <span class="o">*</span><span class="n">ct</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">elf_thread_status</span> <span class="o">*</span><span class="n">ets</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">ct</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">core_state</span><span class="o">-&gt;</span><span class="n">dumper</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
						<span class="n">ct</span><span class="p">;</span> <span class="n">ct</span> <span class="o">=</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ets</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ets</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ets</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">ets</span><span class="o">-&gt;</span><span class="kr">thread</span> <span class="o">=</span> <span class="n">ct</span><span class="o">-&gt;</span><span class="n">task</span><span class="p">;</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ets</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_list</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">list_for_each</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>

			<span class="n">ets</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_thread_status</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">sz</span> <span class="o">=</span> <span class="n">elf_dump_thread_status</span><span class="p">(</span><span class="n">signr</span><span class="p">,</span> <span class="n">ets</span><span class="p">);</span>
			<span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_status_size</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* now collect the dump for the current */</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">));</span>
	<span class="n">fill_prstatus</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">,</span> <span class="n">current</span><span class="p">,</span> <span class="n">signr</span><span class="p">);</span>
	<span class="n">elf_core_copy_regs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_reg</span><span class="p">,</span> <span class="n">regs</span><span class="p">);</span>

	<span class="cm">/* Set up header */</span>
	<span class="n">fill_elf_header</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">phdrs</span><span class="p">,</span> <span class="n">ELF_ARCH</span><span class="p">,</span> <span class="n">ELF_CORE_EFLAGS</span><span class="p">,</span> <span class="n">ELF_OSABI</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Set up the notes in similar form to SVR4 core dumps made</span>
<span class="cm">	 * with info from their /proc.</span>
<span class="cm">	 */</span>

	<span class="n">fill_note</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">+</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_PRSTATUS</span><span class="p">,</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">),</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">);</span>
	<span class="n">fill_psinfo</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">group_leader</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="n">fill_note</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_PRPSINFO</span><span class="p">,</span>
		  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">),</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">);</span>

	<span class="n">info</span><span class="o">-&gt;</span><span class="n">numnote</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="n">fill_auxv_note</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">numnote</span><span class="o">++</span><span class="p">],</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>

	<span class="cm">/* Try to dump the FPU. */</span>
	<span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_fpvalid</span> <span class="o">=</span> <span class="n">elf_core_copy_task_fpregs</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">regs</span><span class="p">,</span>
							       <span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="o">-&gt;</span><span class="n">pr_fpvalid</span><span class="p">)</span>
		<span class="n">fill_note</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">numnote</span><span class="o">++</span><span class="p">,</span>
			  <span class="s">&quot;CORE&quot;</span><span class="p">,</span> <span class="n">NT_PRFPREG</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">),</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">);</span>
<span class="cp">#ifdef ELF_CORE_COPY_XFPREGS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">elf_core_copy_task_xfpregs</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">))</span>
		<span class="n">fill_note</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">+</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">numnote</span><span class="o">++</span><span class="p">,</span>
			  <span class="s">&quot;LINUX&quot;</span><span class="p">,</span> <span class="n">ELF_CORE_XFPREG_TYPE</span><span class="p">,</span>
			  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">),</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">get_note_info_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">numnote</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">sz</span> <span class="o">+=</span> <span class="n">notesize</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">sz</span> <span class="o">+=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_status_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sz</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_note_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">foffset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">numnote</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writenote</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* write out the thread status notes section */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">elf_thread_status</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span>
				<span class="n">list_entry</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_thread_status</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">num_notes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writenote</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">file</span><span class="p">,</span> <span class="n">foffset</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_note_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_note_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">thread_list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_thread_status</span><span class="p">,</span> <span class="n">list</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">prstatus</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">psinfo</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">notes</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">fpu</span><span class="p">);</span>
<span class="cp">#ifdef ELF_CORE_COPY_XFPREGS</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">xfpu</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cp">#endif</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">first_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">tsk</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">gate_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="n">tsk</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">mmap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gate_vma</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Helper function for iterating across a vma list.  It ensures that the caller</span>
<span class="cm"> * will visit `gate_vma&#39; prior to terminating the search.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="nf">next_vma</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">this_vma</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">gate_vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">this_vma</span><span class="o">-&gt;</span><span class="n">vm_next</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this_vma</span> <span class="o">==</span> <span class="n">gate_vma</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">gate_vma</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_extnum_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span><span class="p">,</span> <span class="k">struct</span> <span class="n">elf_shdr</span> <span class="o">*</span><span class="n">shdr4extnum</span><span class="p">,</span>
			     <span class="n">elf_addr_t</span> <span class="n">e_shoff</span><span class="p">,</span> <span class="kt">int</span> <span class="n">segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shoff</span> <span class="o">=</span> <span class="n">e_shoff</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shentsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shdr4extnum</span><span class="p">);</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shnum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span> <span class="o">=</span> <span class="n">SHN_UNDEF</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">shdr4extnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shdr4extnum</span><span class="p">));</span>

	<span class="n">shdr4extnum</span><span class="o">-&gt;</span><span class="n">sh_type</span> <span class="o">=</span> <span class="n">SHT_NULL</span><span class="p">;</span>
	<span class="n">shdr4extnum</span><span class="o">-&gt;</span><span class="n">sh_size</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shnum</span><span class="p">;</span>
	<span class="n">shdr4extnum</span><span class="o">-&gt;</span><span class="n">sh_link</span> <span class="o">=</span> <span class="n">elf</span><span class="o">-&gt;</span><span class="n">e_shstrndx</span><span class="p">;</span>
	<span class="n">shdr4extnum</span><span class="o">-&gt;</span><span class="n">sh_info</span> <span class="o">=</span> <span class="n">segs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">elf_core_vma_data_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">gate_vma</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">mm_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">first_vma</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">gate_vma</span><span class="p">);</span> <span class="n">vma</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
	     <span class="n">vma</span> <span class="o">=</span> <span class="n">next_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">gate_vma</span><span class="p">))</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="n">vma_dump_size</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">mm_flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Actual dumper</span>
<span class="cm"> *</span>
<span class="cm"> * This is a two-pass process; first we find the offsets of the bits,</span>
<span class="cm"> * and then they are actually written out.  If we run out of core limit</span>
<span class="cm"> * we just truncate.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">elf_core_dump</span><span class="p">(</span><span class="k">struct</span> <span class="n">coredump_params</span> <span class="o">*</span><span class="n">cprm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">has_dumped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">fs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">segs</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="o">*</span><span class="n">gate_vma</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elfhdr</span> <span class="o">*</span><span class="n">elf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dataoff</span><span class="p">,</span> <span class="n">foffset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_note_info</span> <span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="o">*</span><span class="n">phdr4note</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">elf_shdr</span> <span class="o">*</span><span class="n">shdr4extnum</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">Elf_Half</span> <span class="n">e_phnum</span><span class="p">;</span>
	<span class="n">elf_addr_t</span> <span class="n">e_shoff</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We no longer stop all VM operations.</span>
<span class="cm">	 * </span>
<span class="cm">	 * This is because those proceses that could possibly change map_count</span>
<span class="cm">	 * or the mmap / vma pages are now blocked in do_exit on current</span>
<span class="cm">	 * finishing this core dump.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Only ptrace can touch these memory addresses, but it doesn&#39;t change</span>
<span class="cm">	 * the map_count or the pages allocated. So no possibility of crashing</span>
<span class="cm">	 * exists while dumping the mm-&gt;vm_next areas to the core file.</span>
<span class="cm">	 */</span>
  
	<span class="cm">/* alloc memory for large data structures: too large to be on stack */</span>
	<span class="n">elf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">elf</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The number of segs are recored into ELF header as 16bit value.</span>
<span class="cm">	 * Please check DEFAULT_MAX_MAP_COUNT definition when you modify here.</span>
<span class="cm">	 */</span>
	<span class="n">segs</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="o">-&gt;</span><span class="n">map_count</span><span class="p">;</span>
	<span class="n">segs</span> <span class="o">+=</span> <span class="n">elf_core_extra_phdrs</span><span class="p">();</span>

	<span class="n">gate_vma</span> <span class="o">=</span> <span class="n">get_gate_vma</span><span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">mm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gate_vma</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">segs</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* for notes section */</span>
	<span class="n">segs</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/* If segs &gt; PN_XNUM(0xffff), then e_phnum overflows. To avoid</span>
<span class="cm">	 * this, kernel supports extended numbering. Have a look at</span>
<span class="cm">	 * include/linux/elf.h for further information. */</span>
	<span class="n">e_phnum</span> <span class="o">=</span> <span class="n">segs</span> <span class="o">&gt;</span> <span class="n">PN_XNUM</span> <span class="o">?</span> <span class="n">PN_XNUM</span> <span class="o">:</span> <span class="n">segs</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Collect all the non-memory information about the process for the</span>
<span class="cm">	 * notes.  This also sets up the file header.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fill_note_info</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">e_phnum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">signr</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">regs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">cleanup</span><span class="p">;</span>

	<span class="n">has_dumped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_DUMPCORE</span><span class="p">;</span>
  
	<span class="n">fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">elf</span><span class="p">);</span>				<span class="cm">/* Elf header */</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="n">segs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">elf_phdr</span><span class="p">);</span>	<span class="cm">/* Program headers */</span>
	<span class="n">foffset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="cm">/* Write notes phdr entry */</span>
	<span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">get_note_info_size</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>

		<span class="n">sz</span> <span class="o">+=</span> <span class="n">elf_coredump_extra_notes_size</span><span class="p">();</span>

		<span class="n">phdr4note</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phdr4note</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">phdr4note</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

		<span class="n">fill_elf_note_phdr</span><span class="p">(</span><span class="n">phdr4note</span><span class="p">,</span> <span class="n">sz</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">sz</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dataoff</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">roundup</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">ELF_EXEC_PAGESIZE</span><span class="p">);</span>

	<span class="n">offset</span> <span class="o">+=</span> <span class="n">elf_core_vma_data_size</span><span class="p">(</span><span class="n">gate_vma</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">mm_flags</span><span class="p">);</span>
	<span class="n">offset</span> <span class="o">+=</span> <span class="n">elf_core_extra_data_size</span><span class="p">();</span>
	<span class="n">e_shoff</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e_phnum</span> <span class="o">==</span> <span class="n">PN_XNUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shdr4extnum</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shdr4extnum</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">shdr4extnum</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>
		<span class="n">fill_extnum_info</span><span class="p">(</span><span class="n">elf</span><span class="p">,</span> <span class="n">shdr4extnum</span><span class="p">,</span> <span class="n">e_shoff</span><span class="p">,</span> <span class="n">segs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">dataoff</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">elf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">limit</span> <span class="o">||</span> <span class="o">!</span><span class="n">dump_write</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">elf</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">elf</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phdr4note</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">limit</span>
	    <span class="o">||</span> <span class="o">!</span><span class="n">dump_write</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">phdr4note</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">phdr4note</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

	<span class="cm">/* Write program headers for segments dump */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">first_vma</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">gate_vma</span><span class="p">);</span> <span class="n">vma</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">next_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">gate_vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">elf_phdr</span> <span class="n">phdr</span><span class="p">;</span>

		<span class="n">phdr</span><span class="p">.</span><span class="n">p_type</span> <span class="o">=</span> <span class="n">PT_LOAD</span><span class="p">;</span>
		<span class="n">phdr</span><span class="p">.</span><span class="n">p_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">phdr</span><span class="p">.</span><span class="n">p_vaddr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">phdr</span><span class="p">.</span><span class="n">p_paddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">phdr</span><span class="p">.</span><span class="n">p_filesz</span> <span class="o">=</span> <span class="n">vma_dump_size</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">mm_flags</span><span class="p">);</span>
		<span class="n">phdr</span><span class="p">.</span><span class="n">p_memsz</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_end</span> <span class="o">-</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">phdr</span><span class="p">.</span><span class="n">p_filesz</span><span class="p">;</span>
		<span class="n">phdr</span><span class="p">.</span><span class="n">p_flags</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_READ</span> <span class="o">?</span> <span class="n">PF_R</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_WRITE</span><span class="p">)</span>
			<span class="n">phdr</span><span class="p">.</span><span class="n">p_flags</span> <span class="o">|=</span> <span class="n">PF_W</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">&amp;</span> <span class="n">VM_EXEC</span><span class="p">)</span>
			<span class="n">phdr</span><span class="p">.</span><span class="n">p_flags</span> <span class="o">|=</span> <span class="n">PF_X</span><span class="p">;</span>
		<span class="n">phdr</span><span class="p">.</span><span class="n">p_align</span> <span class="o">=</span> <span class="n">ELF_EXEC_PAGESIZE</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phdr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">limit</span>
		    <span class="o">||</span> <span class="o">!</span><span class="n">dump_write</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">phdr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">phdr</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_core_write_extra_phdrs</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

 	<span class="cm">/* write out the notes section */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write_note_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foffset</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">elf_coredump_extra_notes_write</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">foffset</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

	<span class="cm">/* Align to page */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dump_seek</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">dataoff</span> <span class="o">-</span> <span class="n">foffset</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">vma</span> <span class="o">=</span> <span class="n">first_vma</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="n">gate_vma</span><span class="p">);</span> <span class="n">vma</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">vma</span> <span class="o">=</span> <span class="n">next_vma</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">gate_vma</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">end</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span> <span class="o">+</span> <span class="n">vma_dump_size</span><span class="p">(</span><span class="n">vma</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">mm_flags</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_start</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">stop</span><span class="p">;</span>

			<span class="n">page</span> <span class="o">=</span> <span class="n">get_dump_page</span><span class="p">(</span><span class="n">addr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">stop</span> <span class="o">=</span> <span class="p">((</span><span class="n">size</span> <span class="o">+=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">)</span> <span class="o">||</span>
					<span class="o">!</span><span class="n">dump_write</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span>
						    <span class="n">PAGE_SIZE</span><span class="p">);</span>
				<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">stop</span> <span class="o">=</span> <span class="o">!</span><span class="n">dump_seek</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">stop</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">elf_core_write_extra_data</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">size</span><span class="p">,</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">limit</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">e_phnum</span> <span class="o">==</span> <span class="n">PN_XNUM</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shdr4extnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">cprm</span><span class="o">-&gt;</span><span class="n">limit</span>
		    <span class="o">||</span> <span class="o">!</span><span class="n">dump_write</span><span class="p">(</span><span class="n">cprm</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">,</span> <span class="n">shdr4extnum</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">shdr4extnum</span><span class="p">)))</span>
			<span class="k">goto</span> <span class="n">end_coredump</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">end_coredump:</span>
	<span class="n">set_fs</span><span class="p">(</span><span class="n">fs</span><span class="p">);</span>

<span class="nl">cleanup:</span>
	<span class="n">free_note_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">shdr4extnum</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">phdr4note</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">elf</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">has_dumped</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#endif		</span><span class="cm">/* CONFIG_ELF_CORE */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_elf_binfmt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">register_binfmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elf_format</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_elf_binfmt</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Remove the COFF and ELF loaders. */</span>
	<span class="n">unregister_binfmt</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elf_format</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">core_initcall</span><span class="p">(</span><span class="n">init_elf_binfmt</span><span class="p">);</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_elf_binfmt</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
