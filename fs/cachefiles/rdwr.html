<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › cachefiles › rdwr.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>rdwr.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/* Storage object read/write</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007 Red Hat, Inc. All Rights Reserved.</span>
<span class="cm"> * Written by David Howells (dhowells@redhat.com)</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public Licence</span>
<span class="cm"> * as published by the Free Software Foundation; either version</span>
<span class="cm"> * 2 of the Licence, or (at your option) any later version.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * detect wake up events generated by the unlocking of pages in which we&#39;re</span>
<span class="cm"> * interested</span>
<span class="cm"> * - we use this to detect read completion of backing pages</span>
<span class="cm"> * - the caller holds the waitqueue lock</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cachefiles_read_waiter</span><span class="p">(</span><span class="n">wait_queue_t</span> <span class="o">*</span><span class="n">wait</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">mode</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">sync</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_one_read</span> <span class="o">*</span><span class="n">monitor</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">wait</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cachefiles_one_read</span><span class="p">,</span> <span class="n">monitor</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wait_bit_key</span> <span class="o">*</span><span class="n">key</span> <span class="o">=</span> <span class="n">_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">wait</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;{%lu},%u,%d,{%p,%u}&quot;</span><span class="p">,</span>
	       <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">sync</span><span class="p">,</span>
	       <span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">bit_nr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">||</span>
	    <span class="n">key</span><span class="o">-&gt;</span><span class="n">bit_nr</span> <span class="o">!=</span> <span class="n">PG_locked</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;--- monitor %p %lx ---&quot;</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageError</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* unlocked, not uptodate and not erronous? */</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;page probably truncated&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* remove from the waitqueue */</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait</span><span class="o">-&gt;</span><span class="n">task_list</span><span class="p">);</span>

	<span class="cm">/* move onto the action list and queue for FS-Cache thread pool */</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">object</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op_link</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">to_do</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>

	<span class="n">fscache_enqueue_retrieval</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * handle a probably truncated page</span>
<span class="cm"> * - check to see if the page is still relevant and reissue the read if</span>
<span class="cm"> *   possible</span>
<span class="cm"> * - return -EIO on error, -ENODATA if the page is gone, -EINPROGRESS if we</span>
<span class="cm"> *   must wait again and 0 if successful</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cachefiles_read_reissue</span><span class="p">(</span><span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">cachefiles_one_read</span> <span class="o">*</span><span class="n">monitor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">bmapping</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">backpage</span> <span class="o">=</span> <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span><span class="p">,</span> <span class="o">*</span><span class="n">backpage2</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">kenter</span><span class="p">(</span><span class="s">&quot;{ino=%lx},{%lx,%lx}&quot;</span><span class="p">,</span>
	       <span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
	       <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* skip if the page was truncated away completely */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">backpage</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">bmapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -ENODATA [mapping]&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">backpage2</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">bmapping</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">backpage2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -ENODATA [gone]&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">backpage</span> <span class="o">!=</span> <span class="n">backpage2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">backpage2</span><span class="p">);</span>
		<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -ENODATA [different]&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* the page is still there and we already have a ref on it, so we don&#39;t</span>
<span class="cm">	 * need a second */</span>
	<span class="n">put_page</span><span class="p">(</span><span class="n">backpage2</span><span class="p">);</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op_link</span><span class="p">);</span>
	<span class="n">add_page_wait_queue</span><span class="p">(</span><span class="n">backpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageError</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlock_discard</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">unlock_discard</span><span class="p">;</span>

		<span class="n">kdebug</span><span class="p">(</span><span class="s">&quot;reissue read&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bmapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">backpage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">unlock_discard</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* but the page may have been read before the monitor was installed, so</span>
<span class="cm">	 * the monitor may miss the event - so we have to ensure that we do get</span>
<span class="cm">	 * one in such a case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;jumpstart %p {%lx}&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* it&#39;ll reappear on the todo list */</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = -EINPROGRESS&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>

<span class="nl">unlock_discard:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op_link</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">kleave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * copy data from backing pages to netfs pages to complete a read operation</span>
<span class="cm"> * - driven by FS-Cache&#39;s thread pool</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">cachefiles_read_copier</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_operation</span> <span class="o">*</span><span class="n">_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_one_read</span> <span class="o">*</span><span class="n">monitor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pagevec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

	<span class="n">op</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_op</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fscache_retrieval</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">object</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;{ino=%lu}&quot;</span><span class="p">,</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">max</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">to_do</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">monitor</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">to_do</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">cachefiles_one_read</span><span class="p">,</span> <span class="n">op_link</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op_link</span><span class="p">);</span>

		<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>

		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- copy {%lu}&quot;</span><span class="p">,</span> <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="nl">recheck:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">copy_highpage</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span><span class="p">,</span> <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span><span class="p">);</span>

			<span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span><span class="p">);</span>
			<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageError</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* the page has probably been truncated */</span>
			<span class="n">error</span> <span class="o">=</span> <span class="n">cachefiles_read_reissue</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">monitor</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">recheck</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cachefiles_io_error_obj</span><span class="p">(</span>
				<span class="n">object</span><span class="p">,</span>
				<span class="s">&quot;Readpage failed on backing file %lx&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span><span class="p">);</span>

		<span class="n">fscache_end_io</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span><span class="p">);</span>
		<span class="n">fscache_put_retrieval</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">monitor</span><span class="p">);</span>

	<span class="nl">next:</span>
		<span class="cm">/* let the thread pool have some air occasionally */</span>
		<span class="n">max</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">max</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">need_resched</span><span class="p">())</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">to_do</span><span class="p">))</span>
				<span class="n">fscache_enqueue_retrieval</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
			<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; [maxed out]&quot;</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">work_lock</span><span class="p">);</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read the corresponding page to the given set from the backing file</span>
<span class="cm"> * - an uncertain page is simply discarded, to be tried again another time</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cachefiles_read_backing_file_one</span><span class="p">(</span><span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">netpage</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">pagevec</span> <span class="o">*</span><span class="n">pagevec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_one_read</span> <span class="o">*</span><span class="n">monitor</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">bmapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">newpage</span><span class="p">,</span> <span class="o">*</span><span class="n">backpage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">pagevec_reinit</span><span class="p">(</span><span class="n">pagevec</span><span class="p">);</span>

	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;read back %p{%lu,%d}&quot;</span><span class="p">,</span>
	       <span class="n">netpage</span><span class="p">,</span> <span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">page_count</span><span class="p">(</span><span class="n">netpage</span><span class="p">));</span>

	<span class="n">monitor</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">monitor</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">monitor</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

	<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span> <span class="o">=</span> <span class="n">netpage</span><span class="p">;</span>
	<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">fscache_get_retrieval</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>

	<span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">,</span> <span class="n">cachefiles_read_waiter</span><span class="p">);</span>

	<span class="cm">/* attempt to get hold of the backing page */</span>
	<span class="n">bmapping</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="n">newpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">backpage</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">bmapping</span><span class="p">,</span> <span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">backpage</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">backing_page_already_present</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newpage</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">newpage</span> <span class="o">=</span> <span class="n">page_cache_alloc_cold</span><span class="p">(</span><span class="n">bmapping</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newpage</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem_monitor</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_to_page_cache</span><span class="p">(</span><span class="n">newpage</span><span class="p">,</span> <span class="n">bmapping</span><span class="p">,</span>
					<span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">installed_new_backing_page</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;ve installed a new backing page, so now we need to add it</span>
<span class="cm">	 * to the LRU list and start it reading */</span>
<span class="nl">installed_new_backing_page:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- new %p&quot;</span><span class="p">,</span> <span class="n">newpage</span><span class="p">);</span>

	<span class="n">backpage</span> <span class="o">=</span> <span class="n">newpage</span><span class="p">;</span>
	<span class="n">newpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="n">pagevec_add</span><span class="p">(</span><span class="n">pagevec</span><span class="p">,</span> <span class="n">backpage</span><span class="p">);</span>
	<span class="n">__pagevec_lru_add_file</span><span class="p">(</span><span class="n">pagevec</span><span class="p">);</span>

<span class="nl">read_backing_page:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">bmapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">backpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">read_error</span><span class="p">;</span>

	<span class="cm">/* set the monitor to transfer the data across */</span>
<span class="nl">monitor_backing_page:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- monitor add&quot;</span><span class="p">);</span>

	<span class="cm">/* install the monitor */</span>
	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span><span class="p">);</span>
	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span> <span class="o">=</span> <span class="n">backpage</span><span class="p">;</span>
	<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">backpage</span><span class="p">;</span>
	<span class="n">add_page_wait_queue</span><span class="p">(</span><span class="n">backpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">);</span>
	<span class="n">monitor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* but the page may have been read before the monitor was installed, so</span>
<span class="cm">	 * the monitor may miss the event - so we have to ensure that we do get</span>
<span class="cm">	 * one in such a case */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;jumpstart %p {%lx}&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">success</span><span class="p">;</span>

	<span class="cm">/* if the backing page is already present, it can be in one of</span>
<span class="cm">	 * three states: read in progress, read failed or read okay */</span>
<span class="nl">backing_page_already_present:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- present&quot;</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newpage</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
		<span class="n">newpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageError</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">backing_page_already_uptodate</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">monitor_backing_page</span><span class="p">;</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;read %p {%lx}&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">read_backing_page</span><span class="p">;</span>

	<span class="cm">/* the backing page is already up to date, attach the netfs</span>
<span class="cm">	 * page to the pagecache and LRU and copy the data across */</span>
<span class="nl">backing_page_already_uptodate:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- uptodate&quot;</span><span class="p">);</span>

	<span class="n">pagevec_add</span><span class="p">(</span><span class="n">pagevec</span><span class="p">,</span> <span class="n">netpage</span><span class="p">);</span>
	<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">pagevec</span><span class="p">);</span>

	<span class="n">copy_highpage</span><span class="p">(</span><span class="n">netpage</span><span class="p">,</span> <span class="n">backpage</span><span class="p">);</span>
	<span class="n">fscache_end_io</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">netpage</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

<span class="nl">success:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;success&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">backpage</span><span class="p">)</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">monitor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscache_put_retrieval</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">monitor</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">read_error:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;read error %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">io_error:</span>
	<span class="n">cachefiles_io_error_obj</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="s">&quot;Page read error on backing file&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">nomem_page:</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
<span class="nl">nomem_monitor:</span>
	<span class="n">fscache_put_retrieval</span><span class="p">(</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">monitor</span><span class="p">);</span>
<span class="nl">nomem:</span>
	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = -ENOMEM&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read a page from the cache or allocate a block in which to store it</span>
<span class="cm"> * - cache withdrawal is prevented by the caller</span>
<span class="cm"> * - returns -EINTR if interrupted</span>
<span class="cm"> * - returns -ENOMEM if ran out of memory</span>
<span class="cm"> * - returns -ENOBUFS if no buffers can be made available</span>
<span class="cm"> * - returns -ENOBUFS if page is beyond EOF</span>
<span class="cm"> * - if the page is backed by a block in the cache:</span>
<span class="cm"> *   - a read will be started which will call the callback on completion</span>
<span class="cm"> *   - 0 will be returned</span>
<span class="cm"> * - else if the page is unbacked:</span>
<span class="cm"> *   - the metadata will be retained</span>
<span class="cm"> *   - -ENODATA will be returned</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cachefiles_read_or_alloc_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				  <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cachefiles_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pagevec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">shift</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">object</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cachefiles_cache</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;{%p},{%lx},,,&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpages</span><span class="p">);</span>

	<span class="cm">/* calculate the shift required to use bmap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">FSCACHE_OP_KEEP_FLAGS</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FSCACHE_OP_ASYNC</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">processor</span> <span class="o">=</span> <span class="n">cachefiles_read_copier</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* we assume the absence or presence of the first block is a good</span>
<span class="cm">	 * enough indication for the page as a whole</span>
<span class="cm">	 * - TODO: don&#39;t use bmap() for this as it is _not_ actually good</span>
<span class="cm">	 *   enough for this as it doesn&#39;t indicate errors, but it&#39;s all we&#39;ve</span>
<span class="cm">	 *   got for the moment</span>
<span class="cm">	 */</span>
	<span class="n">block0</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">block0</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">block0</span><span class="p">);</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;%llx -&gt; %llx&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">block0</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* submit the apparently valid page to the backing fs to be</span>
<span class="cm">		 * read from disk */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cachefiles_read_backing_file_one</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cachefiles_has_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there&#39;s space in the cache we can use */</span>
		<span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read the corresponding pages to the given set from the backing file</span>
<span class="cm"> * - any uncertain pages are simply discarded, to be tried again another time</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cachefiles_read_backing_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">pagevec</span> <span class="o">*</span><span class="n">mark_pvec</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_one_read</span> <span class="o">*</span><span class="n">monitor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">bmapping</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">lru_pvec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">newpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">netpage</span><span class="p">,</span> <span class="o">*</span><span class="n">_n</span><span class="p">,</span> <span class="o">*</span><span class="n">backpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">netpage</span><span class="p">,</span> <span class="n">_n</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpage</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>

		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;read back %p{%lu,%d}&quot;</span><span class="p">,</span>
		       <span class="n">netpage</span><span class="p">,</span> <span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">page_count</span><span class="p">(</span><span class="n">netpage</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">monitor</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">monitor</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">monitor</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">monitor</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>

			<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">fscache_get_retrieval</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
			<span class="n">init_waitqueue_func_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">,</span>
						  <span class="n">cachefiles_read_waiter</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
			<span class="n">backpage</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">bmapping</span><span class="p">,</span> <span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">backpage</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">backing_page_already_present</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newpage</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">newpage</span> <span class="o">=</span> <span class="n">page_cache_alloc_cold</span><span class="p">(</span><span class="n">bmapping</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newpage</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_to_page_cache</span><span class="p">(</span><span class="n">newpage</span><span class="p">,</span> <span class="n">bmapping</span><span class="p">,</span>
						<span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">installed_new_backing_page</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we&#39;ve installed a new backing page, so now we need to add it</span>
<span class="cm">		 * to the LRU list and start it reading */</span>
	<span class="nl">installed_new_backing_page:</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- new %p&quot;</span><span class="p">,</span> <span class="n">newpage</span><span class="p">);</span>

		<span class="n">backpage</span> <span class="o">=</span> <span class="n">newpage</span><span class="p">;</span>
		<span class="n">newpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">,</span> <span class="n">backpage</span><span class="p">))</span>
			<span class="n">__pagevec_lru_add_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">);</span>

	<span class="nl">reread_backing_page:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">bmapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">backpage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">read_error</span><span class="p">;</span>

		<span class="cm">/* add the netfs page to the pagecache and LRU, and set the</span>
<span class="cm">		 * monitor to transfer the data across */</span>
	<span class="nl">monitor_backing_page:</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- monitor add&quot;</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_to_page_cache</span><span class="p">(</span><span class="n">netpage</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">,</span> <span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">,</span> <span class="n">netpage</span><span class="p">))</span>
			<span class="n">__pagevec_lru_add_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">);</span>

		<span class="cm">/* install a monitor */</span>
		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
		<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">netfs_page</span> <span class="o">=</span> <span class="n">netpage</span><span class="p">;</span>

		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
		<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">back_page</span> <span class="o">=</span> <span class="n">backpage</span><span class="p">;</span>
		<span class="n">monitor</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">.</span><span class="n">private</span> <span class="o">=</span> <span class="n">backpage</span><span class="p">;</span>
		<span class="n">add_page_wait_queue</span><span class="p">(</span><span class="n">backpage</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">monitor</span><span class="o">-&gt;</span><span class="n">monitor</span><span class="p">);</span>
		<span class="n">monitor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* but the page may have been read before the monitor was</span>
<span class="cm">		 * installed, so the monitor may miss the event - so we have to</span>
<span class="cm">		 * ensure that we do get one in such a case */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;2unlock %p {%lx}&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
		<span class="n">backpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
		<span class="n">netpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* if the backing page is already present, it can be in one of</span>
<span class="cm">		 * three states: read in progress, read failed or read okay */</span>
	<span class="nl">backing_page_already_present:</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- present %p&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageError</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">backing_page_already_uptodate</span><span class="p">;</span>

		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- not ready %p{%lx}&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trylock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">monitor_backing_page</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageError</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;error %lx&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">io_error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">backpage</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">backing_page_already_uptodate_unlock</span><span class="p">;</span>

		<span class="cm">/* we&#39;ve locked a page that&#39;s neither up to date nor erroneous,</span>
<span class="cm">		 * so we need to attempt to read it again */</span>
		<span class="k">goto</span> <span class="n">reread_backing_page</span><span class="p">;</span>

		<span class="cm">/* the backing page is already up to date, attach the netfs</span>
<span class="cm">		 * page to the pagecache and LRU and copy the data across */</span>
	<span class="nl">backing_page_already_uptodate_unlock:</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;uptodate %lx&quot;</span><span class="p">,</span> <span class="n">backpage</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="nl">backing_page_already_uptodate:</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;- uptodate&quot;</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_to_page_cache</span><span class="p">(</span><span class="n">netpage</span><span class="p">,</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">,</span> <span class="n">netpage</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">,</span>
					<span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">copy_highpage</span><span class="p">(</span><span class="n">netpage</span><span class="p">,</span> <span class="n">backpage</span><span class="p">);</span>

		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
		<span class="n">backpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pagevec_add</span><span class="p">(</span><span class="n">mark_pvec</span><span class="p">,</span> <span class="n">netpage</span><span class="p">))</span>
			<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">mark_pvec</span><span class="p">);</span>

		<span class="n">page_cache_get</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">,</span> <span class="n">netpage</span><span class="p">))</span>
			<span class="n">__pagevec_lru_add_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">);</span>

		<span class="n">fscache_end_io</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="n">netpage</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
		<span class="n">netpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">continue</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">netpage</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;out&quot;</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="cm">/* tidy up */</span>
	<span class="n">pagevec_lru_add_file</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lru_pvec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newpage</span><span class="p">)</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">newpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">netpage</span><span class="p">)</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">backpage</span><span class="p">)</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">backpage</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">monitor</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fscache_put_retrieval</span><span class="p">(</span><span class="n">op</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">monitor</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">netpage</span><span class="p">,</span> <span class="n">_n</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">netpage</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">netpage</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;nomem&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">read_error:</span>
	<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;read error %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="nl">io_error:</span>
	<span class="n">cachefiles_io_error_obj</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="s">&quot;Page read error on backing file&quot;</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read a list of pages from the cache or allocate blocks in which to store</span>
<span class="cm"> * them</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cachefiles_read_or_alloc_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">,</span>
				   <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cachefiles_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">backpages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pagevec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="o">*</span><span class="n">_n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">shift</span><span class="p">,</span> <span class="n">nrbackpages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ret2</span><span class="p">,</span> <span class="n">space</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">object</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cachefiles_cache</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;{OBJ%x,%d},,%d,,&quot;</span><span class="p">,</span>
	       <span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">debug_id</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">usage</span><span class="p">),</span>
	       <span class="o">*</span><span class="n">nr_pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">space</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cachefiles_has_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpages</span><span class="p">);</span>

	<span class="cm">/* calculate the shift required to use bmap */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&gt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>

	<span class="n">shift</span> <span class="o">=</span> <span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">FSCACHE_OP_KEEP_FLAGS</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">FSCACHE_OP_ASYNC</span><span class="p">;</span>
	<span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">processor</span> <span class="o">=</span> <span class="n">cachefiles_read_copier</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">backpages</span><span class="p">);</span>
	<span class="n">nrbackpages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">space</span> <span class="o">?</span> <span class="o">-</span><span class="n">ENODATA</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">_n</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sector_t</span> <span class="n">block0</span><span class="p">,</span> <span class="n">block</span><span class="p">;</span>

		<span class="cm">/* we assume the absence or presence of the first block is a</span>
<span class="cm">		 * good enough indication for the page as a whole</span>
<span class="cm">		 * - TODO: don&#39;t use bmap() for this as it is _not_ actually</span>
<span class="cm">		 *   good enough for this as it doesn&#39;t indicate errors, but</span>
<span class="cm">		 *   it&#39;s all we&#39;ve got for the moment</span>
<span class="cm">		 */</span>
		<span class="n">block0</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
		<span class="n">block0</span> <span class="o">&lt;&lt;=</span> <span class="n">shift</span><span class="p">;</span>

		<span class="n">block</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">bmap</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
						      <span class="n">block0</span><span class="p">);</span>
		<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;%llx -&gt; %llx&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">block0</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span> <span class="n">block</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we have data - add it to the list to give to the</span>
<span class="cm">			 * backing fs */</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">lru</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">backpages</span><span class="p">);</span>
			<span class="p">(</span><span class="o">*</span><span class="n">nr_pages</span><span class="p">)</span><span class="o">--</span><span class="p">;</span>
			<span class="n">nrbackpages</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">&amp;&amp;</span> <span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">pages</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* submit the apparently valid pages to the backing fs to be read from</span>
<span class="cm">	 * disk */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nrbackpages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret2</span> <span class="o">=</span> <span class="n">cachefiles_read_backing_file</span><span class="p">(</span><span class="n">object</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">backpages</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">||</span> <span class="n">ret2</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>

	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = %d [nr=%u%s]&quot;</span><span class="p">,</span>
	       <span class="n">ret</span><span class="p">,</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">,</span> <span class="n">list_empty</span><span class="p">(</span><span class="n">pages</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot; empty&quot;</span> <span class="o">:</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allocate a block in the cache in which to store a page</span>
<span class="cm"> * - cache withdrawal is prevented by the caller</span>
<span class="cm"> * - returns -EINTR if interrupted</span>
<span class="cm"> * - returns -ENOMEM if ran out of memory</span>
<span class="cm"> * - returns -ENOBUFS if no buffers can be made available</span>
<span class="cm"> * - returns -ENOBUFS if page is beyond EOF</span>
<span class="cm"> * - otherwise:</span>
<span class="cm"> *   - the metadata will be retained</span>
<span class="cm"> *   - 0 will be returned</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cachefiles_allocate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			     <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cachefiles_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pagevec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">object</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cachefiles_cache</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%p,{%lx},&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cachefiles_has_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allocate blocks in the cache in which to store a set of pages</span>
<span class="cm"> * - cache withdrawal is prevented by the caller</span>
<span class="cm"> * - returns -EINTR if interrupted</span>
<span class="cm"> * - returns -ENOMEM if ran out of memory</span>
<span class="cm"> * - returns -ENOBUFS if some buffers couldn&#39;t be made available</span>
<span class="cm"> * - returns -ENOBUFS if some pages are beyond EOF</span>
<span class="cm"> * - otherwise:</span>
<span class="cm"> *   - -ENODATA will be returned</span>
<span class="cm"> * - metadata will be retained for any page marked</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cachefiles_allocate_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_retrieval</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">,</span>
			      <span class="n">gfp_t</span> <span class="n">gfp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cachefiles_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pagevec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">object</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cachefiles_cache</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%p,,,%d,&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">cachefiles_has_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">lru</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pagevec_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">,</span> <span class="n">page</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pagevec</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">fscache_mark_pages_cached</span><span class="p">(</span><span class="n">op</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pagevec</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODATA</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * request a page be stored in the cache</span>
<span class="cm"> * - cache withdrawal is prevented by the caller</span>
<span class="cm"> * - this request may be ignored if there&#39;s no cache block available, in which</span>
<span class="cm"> *   case -ENOBUFS will be returned</span>
<span class="cm"> * - if the op is in progress, 0 will be returned</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">cachefiles_write_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_storage</span> <span class="o">*</span><span class="n">op</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cachefiles_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">mm_segment_t</span> <span class="n">old_fs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">eof</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">ASSERT</span><span class="p">(</span><span class="n">page</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">op</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">.</span><span class="n">object</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%p,%p{%lx},,,&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = -ENOBUFS&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ASSERT</span><span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cachefiles_cache</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="cm">/* write the page to the backing filesystem and let it store it in its</span>
<span class="cm">	 * own time */</span>
	<span class="n">dget</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="p">);</span>
	<span class="n">mntget</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">dentry_open</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">backer</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">,</span> <span class="n">O_RDWR</span><span class="p">,</span>
			   <span class="n">cache</span><span class="o">-&gt;</span><span class="n">cache_cred</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="p">(</span><span class="n">loff_t</span><span class="p">)</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>

			<span class="cm">/* we mustn&#39;t write more data than we have, so we have</span>
<span class="cm">			 * to beware of a partial page at EOF */</span>
			<span class="n">eof</span> <span class="o">=</span> <span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">store_limit_l</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">eof</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_MASK</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ASSERTCMP</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="o">&lt;</span><span class="p">,</span> <span class="n">eof</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">eof</span> <span class="o">-</span> <span class="n">pos</span> <span class="o">&lt;</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">_debug</span><span class="p">(</span><span class="s">&quot;cut short %llx to %llx&quot;</span><span class="p">,</span>
					       <span class="n">pos</span><span class="p">,</span> <span class="n">eof</span><span class="p">);</span>
					<span class="n">len</span> <span class="o">=</span> <span class="n">eof</span> <span class="o">-</span> <span class="n">pos</span><span class="p">;</span>
					<span class="n">ASSERTCMP</span><span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="o">==</span><span class="p">,</span> <span class="n">eof</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">data</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">old_fs</span> <span class="o">=</span> <span class="n">get_fs</span><span class="p">();</span>
			<span class="n">set_fs</span><span class="p">(</span><span class="n">KERNEL_DS</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">write</span><span class="p">(</span>
				<span class="n">file</span><span class="p">,</span> <span class="p">(</span><span class="k">const</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span> <span class="n">data</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">);</span>
			<span class="n">set_fs</span><span class="p">(</span><span class="n">old_fs</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span><span class="p">)</span>
			<span class="n">cachefiles_io_error_obj</span><span class="p">(</span>
				<span class="n">object</span><span class="p">,</span> <span class="s">&quot;Write page to backing file failed&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOBUFS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">_leave</span><span class="p">(</span><span class="s">&quot; = %d&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * detach a backing block from a page</span>
<span class="cm"> * - cache withdrawal is prevented by the caller</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">cachefiles_uncache_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">fscache_object</span> <span class="o">*</span><span class="n">_object</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">cachefiles_object</span> <span class="o">*</span><span class="n">object</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">cachefiles_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">object</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">_object</span><span class="p">,</span> <span class="k">struct</span> <span class="n">cachefiles_object</span><span class="p">,</span> <span class="n">fscache</span><span class="p">);</span>
	<span class="n">cache</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">cachefiles_cache</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">_enter</span><span class="p">(</span><span class="s">&quot;%p,{%lu}&quot;</span><span class="p">,</span> <span class="n">object</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">object</span><span class="o">-&gt;</span><span class="n">fscache</span><span class="p">.</span><span class="n">cookie</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
