f | daemon.c | s | 16K | 598 | Arnd Bergmann | arnd@arndb.de | 1287150807 |  | llseek: automatically add .llseek fop  All file_operations should get a .llseek operation so we can make nonseekable_open the default for future file operations without a .llseek pointer.  The three cases that we can automatically detect are no_llseek, seq_lseek and default_llseek. For cases where we can we can automatically prove that the file offset is always ignored, we use noop_llseek, which maintains the current behavior of not returning an error from a seek.  New drivers should normally not use noop_llseek but instead use no_llseek and call nonseekable_open at open time.  Existing drivers can be converted to do the same when the maintainer knows for certain that no user code relies on calling seek on the device file.  The generated code is often incorrectly indented and right now contains comments that clarify for each added line why a specific variant was chosen. In the version that gets submitted upstream, the comments will be gone and I will manually fix the indentation, because there does not seem to be a way to do that using coccinelle.  Some amount of new code is currently sitting in linux-next that should get the same modifications, which I will do at the end of the merge window.  Many thanks to Julia Lawall for helping me learn to write a semantic patch that does all this.  ===== begin semantic patch ===== // This adds an llseek= method to all file operations, // as a preparation for making no_llseek the default. // // The rules are // - use no_llseek explicitly if we do nonseekable_open // - use seq_lseek for sequential files // - use default_llseek if we know we access f_pos // - use noop_llseek if we know we don't access f_pos, //   but we still want to allow users to call lseek // @ open1 exists @ identifier nested_open; @@ nested_open(...) { <+... nonseekable_open(...) ...+> }  @ open exists@ identifier open_f; identifier i, f; identifier open1.nested_open; @@ int open_f(struct inode *i, struct file *f) { <+... ( nonseekable_open(...) || nested_open(...) ) ...+> }  @ read disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { <+... (    *off = E ||    *off += E ||    func(..., off, ...) ||    E = *off ) ...+> }  @ read_no_fpos disable optional_qualifier exists @ identifier read_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t read_f(struct file *f, char *p, size_t s, loff_t *off) { ... when != off }  @ write @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; expression E; identifier func; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { <+... (   *off = E ||   *off += E ||   func(..., off, ...) ||   E = *off ) ...+> }  @ write_no_fpos @ identifier write_f; identifier f, p, s, off; type ssize_t, size_t, loff_t; @@ ssize_t write_f(struct file *f, const char *p, size_t s, loff_t *off) { ... when != off }  @ fops0 @ identifier fops; @@ struct file_operations fops = {  ... };  @ has_llseek depends on fops0 @ identifier fops0.fops; identifier llseek_f; @@ struct file_operations fops = { ...  .llseek = llseek_f, ... };  @ has_read depends on fops0 @ identifier fops0.fops; identifier read_f; @@ struct file_operations fops = { ...  .read = read_f, ... };  @ has_write depends on fops0 @ identifier fops0.fops; identifier write_f; @@ struct file_operations fops = { ...  .write = write_f, ... };  @ has_open depends on fops0 @ identifier fops0.fops; identifier open_f; @@ struct file_operations fops = { ...  .open = open_f, ... };  // use no_llseek if we call nonseekable_open //////////////////////////////////////////// @ nonseekable1 depends on !has_llseek && has_open @ identifier fops0.fops; identifier nso ~= "nonseekable_open"; @@ struct file_operations fops = { ...  .open = nso, ... +.llseek = no_llseek, /* nonseekable */ };  @ nonseekable2 depends on !has_llseek @ identifier fops0.fops; identifier open.open_f; @@ struct file_operations fops = { ...  .open = open_f, ... +.llseek = no_llseek, /* open uses nonseekable */ };  // use seq_lseek for sequential files ///////////////////////////////////// @ seq depends on !has_llseek @ identifier fops0.fops; identifier sr ~= "seq_read"; @@ struct file_operations fops = { ...  .read = sr, ... +.llseek = seq_lseek, /* we have seq_read */ };  // use default_llseek if there is a readdir /////////////////////////////////////////// @ fops1 depends on !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier readdir_e; @@ // any other fop is used that changes pos struct file_operations fops = { ... .readdir = readdir_e, ... +.llseek = default_llseek, /* readdir is present */ };  // use default_llseek if at least one of read/write touches f_pos ///////////////////////////////////////////////////////////////// @ fops2 depends on !fops1 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read.read_f; @@ // read fops use offset struct file_operations fops = { ... .read = read_f, ... +.llseek = default_llseek, /* read accesses f_pos */ };  @ fops3 depends on !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write.write_f; @@ // write fops use offset struct file_operations fops = { ... .write = write_f, ... +	.llseek = default_llseek, /* write accesses f_pos */ };  // Use noop_llseek if neither read nor write accesses f_pos ///////////////////////////////////////////////////////////  @ fops4 depends on !fops1 && !fops2 && !fops3 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; identifier write_no_fpos.write_f; @@ // write fops use offset struct file_operations fops = { ...  .write = write_f,  .read = read_f, ... +.llseek = noop_llseek, /* read and write both use no f_pos */ };  @ depends on has_write && !has_read && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier write_no_fpos.write_f; @@ struct file_operations fops = { ... .write = write_f, ... +.llseek = noop_llseek, /* write uses no f_pos */ };  @ depends on has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; identifier read_no_fpos.read_f; @@ struct file_operations fops = { ... .read = read_f, ... +.llseek = noop_llseek, /* read uses no f_pos */ };  @ depends on !has_read && !has_write && !fops1 && !fops2 && !has_llseek && !nonseekable1 && !nonseekable2 && !seq @ identifier fops0.fops; @@ struct file_operations fops = { ... +.llseek = noop_llseek, /* no read or write fn */ }; ===== End semantic patch =====  Signed-off-by: Arnd Bergmann <arnd@arndb.de> Cc: Julia Lawall <julia@diku.dk> Cc: Christoph Hellwig <hch@infradead.org>
f | internal.h | s | 10K | 307 | David Howells | dhowells@redhat.com | 1281631895 |  | Add a dummy printk function for the maintenance of unused printks  Add a dummy printk function for the maintenance of unused printks through gcc format checking, and also so that side-effect checking is maintained too.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | proc.c | s | 3.1K | 116 | David Howells | dhowells@redhat.com | 1238773361 |  | CacheFiles: A cache that backs onto a mounted filesystem  Add an FS-Cache cache-backend that permits a mounted filesystem to be used as a backing store for the cache.  CacheFiles uses a userspace daemon to do some of the cache management - such as reaping stale nodes and culling.  This is called cachefilesd and lives in /sbin.  The source for the daemon can be downloaded from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.c  And an example configuration from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.conf  The filesystem and data integrity of the cache are only as good as those of the filesystem providing the backing services.  Note that CacheFiles does not attempt to journal anything since the journalling interfaces of the various filesystems are very specific in nature.  CacheFiles creates a misc character device - "/dev/cachefiles" - that is used to communication with the daemon.  Only one thing may have this open at once, and whilst it is open, a cache is at least partially in existence.  The daemon opens this and sends commands down it to control the cache.  CacheFiles is currently limited to a single cache.  CacheFiles attempts to maintain at least a certain percentage of free space on the filesystem, shrinking the cache by culling the objects it contains to make space if necessary - see the "Cache Culling" section.  This means it can be placed on the same medium as a live set of data, and will expand to make use of spare space and automatically contract when the set of data requires more space.  ============ REQUIREMENTS ============  The use of CacheFiles and its daemon requires the following features to be available in the system and in the cache filesystem:  	- dnotify.  	- extended attributes (xattrs).  	- openat() and friends.  	- bmap() support on files in the filesystem (FIBMAP ioctl).  	- The use of bmap() to detect a partial page at the end of the file.  It is strongly recommended that the "dir_index" option is enabled on Ext3 filesystems being used as a cache.  ============= CONFIGURATION =============  The cache is configured by a script in /etc/cachefilesd.conf.  These commands set up cache ready for use.  The following script commands are available:   (*) brun <N>%  (*) bcull <N>%  (*) bstop <N>%  (*) frun <N>%  (*) fcull <N>%  (*) fstop <N>%  	Configure the culling limits.  Optional.  See the section on culling 	The defaults are 7% (run), 5% (cull) and 1% (stop) respectively.  	The commands beginning with a 'b' are file space (block) limits, those 	beginning with an 'f' are file count limits.   (*) dir <path>  	Specify the directory containing the root of the cache.  Mandatory.   (*) tag <name>  	Specify a tag to FS-Cache to use in distinguishing multiple caches. 	Optional.  The default is "CacheFiles".   (*) debug <mask>  	Specify a numeric bitmask to control debugging in the kernel module. 	Optional.  The default is zero (all off).  The following values can be 	OR'd into the mask to collect various information:  		1	Turn on trace of function entry (_enter() macros) 		2	Turn on trace of function exit (_leave() macros) 		4	Turn on trace of internal debug points (_debug())  	This mask can also be set through sysfs, eg:  		echo 5 >/sys/modules/cachefiles/parameters/debug  ================== STARTING THE CACHE ==================  The cache is started by running the daemon.  The daemon opens the cache device, configures the cache and tells it to begin caching.  At that point the cache binds to fscache and the cache becomes live.  The daemon is run as follows:  	/sbin/cachefilesd [-d]* [-s] [-n] [-f <configfile>]  The flags are:   (*) -d  	Increase the debugging level.  This can be specified multiple times and 	is cumulative with itself.   (*) -s  	Send messages to stderr instead of syslog.   (*) -n  	Don't daemonise and go into background.   (*) -f <configfile>  	Use an alternative configuration file rather than the default one.  =============== THINGS TO AVOID ===============  Do not mount other things within the cache as this will cause problems.  The kernel module contains its own very cut-down path walking facility that ignores mountpoints, but the daemon can't avoid them.  Do not create, rename or unlink files and directories in the cache whilst the cache is active, as this may cause the state to become uncertain.  Renaming files in the cache might make objects appear to be other objects (the filename is part of the lookup key).  Do not change or remove the extended attributes attached to cache files by the cache as this will cause the cache state management to get confused.  Do not create files or directories in the cache, lest the cache get confused or serve incorrect data.  Do not chmod files in the cache.  The module creates things with minimal permissions to prevent random users being able to access them directly.  ============= CACHE CULLING =============  The cache may need culling occasionally to make space.  This involves discarding objects from the cache that have been used less recently than anything else.  Culling is based on the access time of data objects.  Empty directories are culled if not in use.  Cache culling is done on the basis of the percentage of blocks and the percentage of files available in the underlying filesystem.  There are six "limits":   (*) brun  (*) frun       If the amount of free space and the number of available files in the cache      rises above both these limits, then culling is turned off.   (*) bcull  (*) fcull       If the amount of available space or the number of available files in the      cache falls below either of these limits, then culling is started.   (*) bstop  (*) fstop       If the amount of available space or the number of available files in the      cache falls below either of these limits, then no further allocation of      disk space or files is permitted until culling has raised things above      these limits again.  These must be configured thusly:  	0 <= bstop < bcull < brun < 100 	0 <= fstop < fcull < frun < 100  Note that these are percentages of available space and available files, and do _not_ appear as 100 minus the percentage displayed by the "df" program.  The userspace daemon scans the cache to build up a table of cullable objects. These are then culled in least recently used order.  A new scan of the cache is started as soon as space is made in the table.  Objects will be skipped if their atimes have changed or if the kernel module says it is still using them.  =============== CACHE STRUCTURE ===============  The CacheFiles module will create two directories in the directory it was given:   (*) cache/   (*) graveyard/  The active cache objects all reside in the first directory.  The CacheFiles kernel module moves any retired or culled objects that it can't simply unlink to the graveyard from which the daemon will actually delete them.  The daemon uses dnotify to monitor the graveyard directory, and will delete anything that appears therein.  The module represents index objects as directories with the filename "I..." or "J...".  Note that the "cache/" directory is itself a special index.  Data objects are represented as files if they have no children, or directories if they do.  Their filenames all begin "D..." or "E...".  If represented as a directory, data objects will have a file in the directory called "data" that actually holds the data.  Special objects are similar to data objects, except their filenames begin "S..." or "T...".  If an object has children, then it will be represented as a directory. Immediately in the representative directory are a collection of directories named for hash values of the child object keys with an '@' prepended.  Into this directory, if possible, will be placed the representations of the child objects:  	INDEX     INDEX      INDEX                             DATA FILES 	========= ========== ================================= ================ 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...DB1ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...N22ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...FP1ry  If the key is so long that it exceeds NAME_MAX with the decorations added on to it, then it will be cut into pieces, the first few of which will be used to make a nest of directories, and the last one of which will be the objects inside the last directory.  The names of the intermediate directories will have '+' prepended:  	J1223/@23/+xy...z/+kl...m/Epqr  Note that keys are raw data, and not only may they exceed NAME_MAX in size, they may also contain things like '/' and NUL characters, and so they may not be suitable for turning directly into a filename.  To handle this, CacheFiles will use a suitably printable filename directly and "base-64" encode ones that aren't directly suitable.  The two versions of object filenames indicate the encoding:  	OBJECT TYPE	PRINTABLE	ENCODED 	===============	===============	=============== 	Index		"I..."		"J..." 	Data		"D..."		"E..." 	Special		"S..."		"T..."  Intermediate directories are always "@" or "+" as appropriate.  Each object in the cache has an extended attribute label that holds the object type ID (required to distinguish special objects) and the auxiliary data from the netfs.  The latter is used to detect stale objects in the cache and update or retire them.  Note that CacheFiles will erase from the cache any file it doesn't recognise or any file of an incorrect type (such as a FIFO file or a device file).  ========================== SECURITY MODEL AND SELINUX ==========================  CacheFiles is implemented to deal properly with the LSM security features of the Linux kernel and the SELinux facility.  One of the problems that CacheFiles faces is that it is generally acting on behalf of a process, and running in that process's context, and that includes a security context that is not appropriate for accessing the cache - either because the files in the cache are inaccessible to that process, or because if the process creates a file in the cache, that file may be inaccessible to other processes.  The way CacheFiles works is to temporarily change the security context (fsuid, fsgid and actor security label) that the process acts as - without changing the security context of the process when it the target of an operation performed by some other process (so signalling and suchlike still work correctly).  When the CacheFiles module is asked to bind to its cache, it:   (1) Finds the security label attached to the root cache directory and uses      that as the security label with which it will create files.  By default,      this is:  	cachefiles_var_t   (2) Finds the security label of the process which issued the bind request      (presumed to be the cachefilesd daemon), which by default will be:  	cachefilesd_t       and asks LSM to supply a security ID as which it should act given the      daemon's label.  By default, this will be:  	cachefiles_kernel_t       SELinux transitions the daemon's security ID to the module's security ID      based on a rule of this form in the policy.  	type_transition <daemon's-ID> kernel_t : process <module's-ID>;       For instance:  	type_transition cachefilesd_t kernel_t : process cachefiles_kernel_t;  The module's security ID gives it permission to create, move and remove files and directories in the cache, to find and access directories and files in the cache, to set and access extended attributes on cache objects, and to read and write files in the cache.  The daemon's security ID gives it only a very restricted set of permissions: it may scan directories, stat files and erase files and directories.  It may not read or write files in the cache, and so it is precluded from accessing the data cached therein; nor is it permitted to create new files in the cache.  There are policy source files available in:  	http://people.redhat.com/~dhowells/fscache/cachefilesd-0.8.tar.bz2  and later versions.  In that tarball, see the files:  	cachefilesd.te 	cachefilesd.fc 	cachefilesd.if  They are built and installed directly by the RPM.  If a non-RPM based system is being used, then copy the above files to their own directory and run:  	make -f /usr/share/selinux/devel/Makefile 	semodule -i cachefilesd.pp  You will need checkpolicy and selinux-policy-devel installed prior to the build.  By default, the cache is located in /var/fscache, but if it is desirable that it should be elsewhere, than either the above policy files must be altered, or an auxiliary policy must be installed to label the alternate location of the cache.  For instructions on how to add an auxiliary policy to enable the cache to be located elsewhere when SELinux is in enforcing mode, please see:  	/usr/share/doc/cachefilesd-*/move-cache.txt  When the cachefilesd rpm is installed; alternatively, the document can be found in the sources.  ================== A NOTE ON SECURITY ==================  CacheFiles makes use of the split security in the task_struct.  It allocates its own task_security structure, and redirects current->act_as to point to it when it acts on behalf of another process, in that process's context.  The reason it does this is that it calls vfs_mkdir() and suchlike rather than bypassing security and calling inode ops directly.  Therefore the VFS and LSM may deny the CacheFiles access to the cache data because under some circumstances the caching code is running in the security context of whatever process issued the original syscall on the netfs.  Furthermore, should CacheFiles create a file or directory, the security parameters with that object is created (UID, GID, security label) would be derived from that process that issued the system call, thus potentially preventing other processes from accessing the cache - including CacheFiles's cache management daemon (cachefilesd).  What is required is to temporarily override the security of the process that issued the system call.  We can't, however, just do an in-place change of the security data as that affects the process as an object, not just as a subject. This means it may lose signals or ptrace events for example, and affects what the process looks like in /proc.  So CacheFiles makes use of a logical split in the security between the objective security (task->sec) and the subjective security (task->act_as).  The objective security holds the intrinsic security properties of a process and is never overridden.  This is what appears in /proc, and is what is used when a process is the target of an operation by some other process (SIGKILL for example).  The subjective security holds the active security properties of a process, and may be overridden.  This is not seen externally, and is used whan a process acts upon another object, for example SIGKILLing another process or opening a file.  LSM hooks exist that allow SELinux (or Smack or whatever) to reject a request for CacheFiles to run in a context of a specific security label, or to create files and directories with another security label.  This documentation is added by the patch to:  	Documentation/filesystems/caching/cachefiles.txt  Signed-Off-By: David Howells <dhowells@redhat.com> Acked-by: Steve Dickson <steved@redhat.com> Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com> Acked-by: Al Viro <viro@zeniv.linux.org.uk> Tested-by: Daire Byrne <Daire.Byrne@framestore.com>
f | Makefile | g | 265B |  | David Howells | dhowells@redhat.com | 1238773361 |  | CacheFiles: A cache that backs onto a mounted filesystem  Add an FS-Cache cache-backend that permits a mounted filesystem to be used as a backing store for the cache.  CacheFiles uses a userspace daemon to do some of the cache management - such as reaping stale nodes and culling.  This is called cachefilesd and lives in /sbin.  The source for the daemon can be downloaded from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.c  And an example configuration from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.conf  The filesystem and data integrity of the cache are only as good as those of the filesystem providing the backing services.  Note that CacheFiles does not attempt to journal anything since the journalling interfaces of the various filesystems are very specific in nature.  CacheFiles creates a misc character device - "/dev/cachefiles" - that is used to communication with the daemon.  Only one thing may have this open at once, and whilst it is open, a cache is at least partially in existence.  The daemon opens this and sends commands down it to control the cache.  CacheFiles is currently limited to a single cache.  CacheFiles attempts to maintain at least a certain percentage of free space on the filesystem, shrinking the cache by culling the objects it contains to make space if necessary - see the "Cache Culling" section.  This means it can be placed on the same medium as a live set of data, and will expand to make use of spare space and automatically contract when the set of data requires more space.  ============ REQUIREMENTS ============  The use of CacheFiles and its daemon requires the following features to be available in the system and in the cache filesystem:  	- dnotify.  	- extended attributes (xattrs).  	- openat() and friends.  	- bmap() support on files in the filesystem (FIBMAP ioctl).  	- The use of bmap() to detect a partial page at the end of the file.  It is strongly recommended that the "dir_index" option is enabled on Ext3 filesystems being used as a cache.  ============= CONFIGURATION =============  The cache is configured by a script in /etc/cachefilesd.conf.  These commands set up cache ready for use.  The following script commands are available:   (*) brun <N>%  (*) bcull <N>%  (*) bstop <N>%  (*) frun <N>%  (*) fcull <N>%  (*) fstop <N>%  	Configure the culling limits.  Optional.  See the section on culling 	The defaults are 7% (run), 5% (cull) and 1% (stop) respectively.  	The commands beginning with a 'b' are file space (block) limits, those 	beginning with an 'f' are file count limits.   (*) dir <path>  	Specify the directory containing the root of the cache.  Mandatory.   (*) tag <name>  	Specify a tag to FS-Cache to use in distinguishing multiple caches. 	Optional.  The default is "CacheFiles".   (*) debug <mask>  	Specify a numeric bitmask to control debugging in the kernel module. 	Optional.  The default is zero (all off).  The following values can be 	OR'd into the mask to collect various information:  		1	Turn on trace of function entry (_enter() macros) 		2	Turn on trace of function exit (_leave() macros) 		4	Turn on trace of internal debug points (_debug())  	This mask can also be set through sysfs, eg:  		echo 5 >/sys/modules/cachefiles/parameters/debug  ================== STARTING THE CACHE ==================  The cache is started by running the daemon.  The daemon opens the cache device, configures the cache and tells it to begin caching.  At that point the cache binds to fscache and the cache becomes live.  The daemon is run as follows:  	/sbin/cachefilesd [-d]* [-s] [-n] [-f <configfile>]  The flags are:   (*) -d  	Increase the debugging level.  This can be specified multiple times and 	is cumulative with itself.   (*) -s  	Send messages to stderr instead of syslog.   (*) -n  	Don't daemonise and go into background.   (*) -f <configfile>  	Use an alternative configuration file rather than the default one.  =============== THINGS TO AVOID ===============  Do not mount other things within the cache as this will cause problems.  The kernel module contains its own very cut-down path walking facility that ignores mountpoints, but the daemon can't avoid them.  Do not create, rename or unlink files and directories in the cache whilst the cache is active, as this may cause the state to become uncertain.  Renaming files in the cache might make objects appear to be other objects (the filename is part of the lookup key).  Do not change or remove the extended attributes attached to cache files by the cache as this will cause the cache state management to get confused.  Do not create files or directories in the cache, lest the cache get confused or serve incorrect data.  Do not chmod files in the cache.  The module creates things with minimal permissions to prevent random users being able to access them directly.  ============= CACHE CULLING =============  The cache may need culling occasionally to make space.  This involves discarding objects from the cache that have been used less recently than anything else.  Culling is based on the access time of data objects.  Empty directories are culled if not in use.  Cache culling is done on the basis of the percentage of blocks and the percentage of files available in the underlying filesystem.  There are six "limits":   (*) brun  (*) frun       If the amount of free space and the number of available files in the cache      rises above both these limits, then culling is turned off.   (*) bcull  (*) fcull       If the amount of available space or the number of available files in the      cache falls below either of these limits, then culling is started.   (*) bstop  (*) fstop       If the amount of available space or the number of available files in the      cache falls below either of these limits, then no further allocation of      disk space or files is permitted until culling has raised things above      these limits again.  These must be configured thusly:  	0 <= bstop < bcull < brun < 100 	0 <= fstop < fcull < frun < 100  Note that these are percentages of available space and available files, and do _not_ appear as 100 minus the percentage displayed by the "df" program.  The userspace daemon scans the cache to build up a table of cullable objects. These are then culled in least recently used order.  A new scan of the cache is started as soon as space is made in the table.  Objects will be skipped if their atimes have changed or if the kernel module says it is still using them.  =============== CACHE STRUCTURE ===============  The CacheFiles module will create two directories in the directory it was given:   (*) cache/   (*) graveyard/  The active cache objects all reside in the first directory.  The CacheFiles kernel module moves any retired or culled objects that it can't simply unlink to the graveyard from which the daemon will actually delete them.  The daemon uses dnotify to monitor the graveyard directory, and will delete anything that appears therein.  The module represents index objects as directories with the filename "I..." or "J...".  Note that the "cache/" directory is itself a special index.  Data objects are represented as files if they have no children, or directories if they do.  Their filenames all begin "D..." or "E...".  If represented as a directory, data objects will have a file in the directory called "data" that actually holds the data.  Special objects are similar to data objects, except their filenames begin "S..." or "T...".  If an object has children, then it will be represented as a directory. Immediately in the representative directory are a collection of directories named for hash values of the child object keys with an '@' prepended.  Into this directory, if possible, will be placed the representations of the child objects:  	INDEX     INDEX      INDEX                             DATA FILES 	========= ========== ================================= ================ 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...DB1ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...N22ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...FP1ry  If the key is so long that it exceeds NAME_MAX with the decorations added on to it, then it will be cut into pieces, the first few of which will be used to make a nest of directories, and the last one of which will be the objects inside the last directory.  The names of the intermediate directories will have '+' prepended:  	J1223/@23/+xy...z/+kl...m/Epqr  Note that keys are raw data, and not only may they exceed NAME_MAX in size, they may also contain things like '/' and NUL characters, and so they may not be suitable for turning directly into a filename.  To handle this, CacheFiles will use a suitably printable filename directly and "base-64" encode ones that aren't directly suitable.  The two versions of object filenames indicate the encoding:  	OBJECT TYPE	PRINTABLE	ENCODED 	===============	===============	=============== 	Index		"I..."		"J..." 	Data		"D..."		"E..." 	Special		"S..."		"T..."  Intermediate directories are always "@" or "+" as appropriate.  Each object in the cache has an extended attribute label that holds the object type ID (required to distinguish special objects) and the auxiliary data from the netfs.  The latter is used to detect stale objects in the cache and update or retire them.  Note that CacheFiles will erase from the cache any file it doesn't recognise or any file of an incorrect type (such as a FIFO file or a device file).  ========================== SECURITY MODEL AND SELINUX ==========================  CacheFiles is implemented to deal properly with the LSM security features of the Linux kernel and the SELinux facility.  One of the problems that CacheFiles faces is that it is generally acting on behalf of a process, and running in that process's context, and that includes a security context that is not appropriate for accessing the cache - either because the files in the cache are inaccessible to that process, or because if the process creates a file in the cache, that file may be inaccessible to other processes.  The way CacheFiles works is to temporarily change the security context (fsuid, fsgid and actor security label) that the process acts as - without changing the security context of the process when it the target of an operation performed by some other process (so signalling and suchlike still work correctly).  When the CacheFiles module is asked to bind to its cache, it:   (1) Finds the security label attached to the root cache directory and uses      that as the security label with which it will create files.  By default,      this is:  	cachefiles_var_t   (2) Finds the security label of the process which issued the bind request      (presumed to be the cachefilesd daemon), which by default will be:  	cachefilesd_t       and asks LSM to supply a security ID as which it should act given the      daemon's label.  By default, this will be:  	cachefiles_kernel_t       SELinux transitions the daemon's security ID to the module's security ID      based on a rule of this form in the policy.  	type_transition <daemon's-ID> kernel_t : process <module's-ID>;       For instance:  	type_transition cachefilesd_t kernel_t : process cachefiles_kernel_t;  The module's security ID gives it permission to create, move and remove files and directories in the cache, to find and access directories and files in the cache, to set and access extended attributes on cache objects, and to read and write files in the cache.  The daemon's security ID gives it only a very restricted set of permissions: it may scan directories, stat files and erase files and directories.  It may not read or write files in the cache, and so it is precluded from accessing the data cached therein; nor is it permitted to create new files in the cache.  There are policy source files available in:  	http://people.redhat.com/~dhowells/fscache/cachefilesd-0.8.tar.bz2  and later versions.  In that tarball, see the files:  	cachefilesd.te 	cachefilesd.fc 	cachefilesd.if  They are built and installed directly by the RPM.  If a non-RPM based system is being used, then copy the above files to their own directory and run:  	make -f /usr/share/selinux/devel/Makefile 	semodule -i cachefilesd.pp  You will need checkpolicy and selinux-policy-devel installed prior to the build.  By default, the cache is located in /var/fscache, but if it is desirable that it should be elsewhere, than either the above policy files must be altered, or an auxiliary policy must be installed to label the alternate location of the cache.  For instructions on how to add an auxiliary policy to enable the cache to be located elsewhere when SELinux is in enforcing mode, please see:  	/usr/share/doc/cachefilesd-*/move-cache.txt  When the cachefilesd rpm is installed; alternatively, the document can be found in the sources.  ================== A NOTE ON SECURITY ==================  CacheFiles makes use of the split security in the task_struct.  It allocates its own task_security structure, and redirects current->act_as to point to it when it acts on behalf of another process, in that process's context.  The reason it does this is that it calls vfs_mkdir() and suchlike rather than bypassing security and calling inode ops directly.  Therefore the VFS and LSM may deny the CacheFiles access to the cache data because under some circumstances the caching code is running in the security context of whatever process issued the original syscall on the netfs.  Furthermore, should CacheFiles create a file or directory, the security parameters with that object is created (UID, GID, security label) would be derived from that process that issued the system call, thus potentially preventing other processes from accessing the cache - including CacheFiles's cache management daemon (cachefilesd).  What is required is to temporarily override the security of the process that issued the system call.  We can't, however, just do an in-place change of the security data as that affects the process as an object, not just as a subject. This means it may lose signals or ptrace events for example, and affects what the process looks like in /proc.  So CacheFiles makes use of a logical split in the security between the objective security (task->sec) and the subjective security (task->act_as).  The objective security holds the intrinsic security properties of a process and is never overridden.  This is what appears in /proc, and is what is used when a process is the target of an operation by some other process (SIGKILL for example).  The subjective security holds the active security properties of a process, and may be overridden.  This is not seen externally, and is used whan a process acts upon another object, for example SIGKILLing another process or opening a file.  LSM hooks exist that allow SELinux (or Smack or whatever) to reject a request for CacheFiles to run in a context of a specific security label, or to create files and directories with another security label.  This documentation is added by the patch to:  	Documentation/filesystems/caching/cachefiles.txt  Signed-Off-By: David Howells <dhowells@redhat.com> Acked-by: Steve Dickson <steved@redhat.com> Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com> Acked-by: Al Viro <viro@zeniv.linux.org.uk> Tested-by: Daire Byrne <Daire.Byrne@framestore.com>
f | bind.c | s | 7.0K | 229 | Al Viro | viro@zeniv.linux.org.uk | 1311140661 |  | kill useless checks for sb->s_op == NULL  never is...  Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | interface.c | s | 12K | 379 | Al Viro | viro@zeniv.linux.org.uk | 1325649247 |  | fs: move code out of buffer.c  Move invalidate_bdev, block_sync_page into fs/block_dev.c.  Export kill_bdev as well, so brd doesn't have to open code it.  Reduce buffer_head.h requirement accordingly.  Removed a rather large comment from invalidate_bdev, as it looked a bit obsolete to bother moving.  The small comment replacing it says enough.  Signed-off-by: Nick Piggin <npiggin@suse.de> Cc: Al Viro <viro@ZenIV.linux.org.uk> Cc: Christoph Hellwig <hch@lst.de> Signed-off-by: Andrew Morton <akpm@linux-foundation.org> Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | xattr.c | s | 6.4K | 238 | Tejun Heo | tj@kernel.org | 1269954152 |  | include cleanup: Update gfp.h and slab.h includes to prepare for breaking implicit slab.h inclusion from percpu.h  percpu.h is included by sched.h and module.h and thus ends up being included when building most .c files.  percpu.h includes slab.h which in turn includes gfp.h making everything defined by the two files universally available and complicating inclusion dependencies.  percpu.h -> slab.h dependency is about to be removed.  Prepare for this change by updating users of gfp and slab facilities include those headers directly instead of assuming availability.  As this conversion needs to touch large number of source files, the following script is used as the basis of conversion.    http://userweb.kernel.org/~tj/misc/slabh-sweep.py  The script does the followings.  * Scan files for gfp and slab usages and update includes such that   only the necessary includes are there.  ie. if only gfp is used,   gfp.h, if slab is used, slab.h.  * When the script inserts a new include, it looks at the include   blocks and try to put the new include such that its order conforms   to its surrounding.  It's put in the include block which contains   core kernel includes, in the same order that the rest are ordered -   alphabetical, Christmas tree, rev-Xmas-tree or at the end if there   doesn't seem to be any matching order.  * If the script can't find a place to put a new include (mostly   because the file doesn't have fitting include block), it prints out   an error message indicating which .h file needs to be added to the   file.  The conversion was done in the following steps.  1. The initial automatic conversion of all .c files updated slightly    over 4000 files, deleting around 700 includes and adding ~480 gfp.h    and ~3000 slab.h inclusions.  The script emitted errors for ~400    files.  2. Each error was manually checked.  Some didn't need the inclusion,    some needed manual addition while adding it to implementation .h or    embedding .c file was more appropriate for others.  This step added    inclusions to around 150 files.  3. The script was run again and the output was compared to the edits    from #2 to make sure no file was left behind.  4. Several build tests were done and a couple of problems were fixed.    e.g. lib/decompress_*.c used malloc/free() wrappers around slab    APIs requiring slab.h to be added manually.  5. The script was run on all .h files but without automatically    editing them as sprinkling gfp.h and slab.h inclusions around .h    files could easily lead to inclusion dependency hell.  Most gfp.h    inclusion directives were ignored as stuff from gfp.h was usually    wildly available and often used in preprocessor macros.  Each    slab.h inclusion directive was examined and added manually as    necessary.  6. percpu.h was updated not to include slab.h.  7. Build test were done on the following configurations and failures    were fixed.  CONFIG_GCOV_KERNEL was turned off for all tests (as my    distributed build env didn't work with gcov compiles) and a few    more options had to be turned off depending on archs to make things    build (like ipr on powerpc/64 which failed due to missing writeq).     * x86 and x86_64 UP and SMP allmodconfig and a custom test config.    * powerpc and powerpc64 SMP allmodconfig    * sparc and sparc64 SMP allmodconfig    * ia64 SMP allmodconfig    * s390 SMP allmodconfig    * alpha SMP allmodconfig    * um on x86_64 SMP allmodconfig  8. percpu.h modifications were reverted so that it could be applied as    a separate patch and serve as bisection point.  Given the fact that I had only a couple of failures from tests on step 6, I'm fairly confident about the coverage of this conversion patch. If there is a breakage, it's likely to be something in one of the arch headers which should be easily discoverable easily on most builds of the specific arch.  Signed-off-by: Tejun Heo <tj@kernel.org> Guess-its-ok-by: Christoph Lameter <cl@linux-foundation.org> Cc: Ingo Molnar <mingo@redhat.com> Cc: Lee Schermerhorn <Lee.Schermerhorn@hp.com>
f | key.c | s | 3.7K | 133 | David Howells | dhowells@redhat.com | 1238773361 |  | CacheFiles: A cache that backs onto a mounted filesystem  Add an FS-Cache cache-backend that permits a mounted filesystem to be used as a backing store for the cache.  CacheFiles uses a userspace daemon to do some of the cache management - such as reaping stale nodes and culling.  This is called cachefilesd and lives in /sbin.  The source for the daemon can be downloaded from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.c  And an example configuration from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.conf  The filesystem and data integrity of the cache are only as good as those of the filesystem providing the backing services.  Note that CacheFiles does not attempt to journal anything since the journalling interfaces of the various filesystems are very specific in nature.  CacheFiles creates a misc character device - "/dev/cachefiles" - that is used to communication with the daemon.  Only one thing may have this open at once, and whilst it is open, a cache is at least partially in existence.  The daemon opens this and sends commands down it to control the cache.  CacheFiles is currently limited to a single cache.  CacheFiles attempts to maintain at least a certain percentage of free space on the filesystem, shrinking the cache by culling the objects it contains to make space if necessary - see the "Cache Culling" section.  This means it can be placed on the same medium as a live set of data, and will expand to make use of spare space and automatically contract when the set of data requires more space.  ============ REQUIREMENTS ============  The use of CacheFiles and its daemon requires the following features to be available in the system and in the cache filesystem:  	- dnotify.  	- extended attributes (xattrs).  	- openat() and friends.  	- bmap() support on files in the filesystem (FIBMAP ioctl).  	- The use of bmap() to detect a partial page at the end of the file.  It is strongly recommended that the "dir_index" option is enabled on Ext3 filesystems being used as a cache.  ============= CONFIGURATION =============  The cache is configured by a script in /etc/cachefilesd.conf.  These commands set up cache ready for use.  The following script commands are available:   (*) brun <N>%  (*) bcull <N>%  (*) bstop <N>%  (*) frun <N>%  (*) fcull <N>%  (*) fstop <N>%  	Configure the culling limits.  Optional.  See the section on culling 	The defaults are 7% (run), 5% (cull) and 1% (stop) respectively.  	The commands beginning with a 'b' are file space (block) limits, those 	beginning with an 'f' are file count limits.   (*) dir <path>  	Specify the directory containing the root of the cache.  Mandatory.   (*) tag <name>  	Specify a tag to FS-Cache to use in distinguishing multiple caches. 	Optional.  The default is "CacheFiles".   (*) debug <mask>  	Specify a numeric bitmask to control debugging in the kernel module. 	Optional.  The default is zero (all off).  The following values can be 	OR'd into the mask to collect various information:  		1	Turn on trace of function entry (_enter() macros) 		2	Turn on trace of function exit (_leave() macros) 		4	Turn on trace of internal debug points (_debug())  	This mask can also be set through sysfs, eg:  		echo 5 >/sys/modules/cachefiles/parameters/debug  ================== STARTING THE CACHE ==================  The cache is started by running the daemon.  The daemon opens the cache device, configures the cache and tells it to begin caching.  At that point the cache binds to fscache and the cache becomes live.  The daemon is run as follows:  	/sbin/cachefilesd [-d]* [-s] [-n] [-f <configfile>]  The flags are:   (*) -d  	Increase the debugging level.  This can be specified multiple times and 	is cumulative with itself.   (*) -s  	Send messages to stderr instead of syslog.   (*) -n  	Don't daemonise and go into background.   (*) -f <configfile>  	Use an alternative configuration file rather than the default one.  =============== THINGS TO AVOID ===============  Do not mount other things within the cache as this will cause problems.  The kernel module contains its own very cut-down path walking facility that ignores mountpoints, but the daemon can't avoid them.  Do not create, rename or unlink files and directories in the cache whilst the cache is active, as this may cause the state to become uncertain.  Renaming files in the cache might make objects appear to be other objects (the filename is part of the lookup key).  Do not change or remove the extended attributes attached to cache files by the cache as this will cause the cache state management to get confused.  Do not create files or directories in the cache, lest the cache get confused or serve incorrect data.  Do not chmod files in the cache.  The module creates things with minimal permissions to prevent random users being able to access them directly.  ============= CACHE CULLING =============  The cache may need culling occasionally to make space.  This involves discarding objects from the cache that have been used less recently than anything else.  Culling is based on the access time of data objects.  Empty directories are culled if not in use.  Cache culling is done on the basis of the percentage of blocks and the percentage of files available in the underlying filesystem.  There are six "limits":   (*) brun  (*) frun       If the amount of free space and the number of available files in the cache      rises above both these limits, then culling is turned off.   (*) bcull  (*) fcull       If the amount of available space or the number of available files in the      cache falls below either of these limits, then culling is started.   (*) bstop  (*) fstop       If the amount of available space or the number of available files in the      cache falls below either of these limits, then no further allocation of      disk space or files is permitted until culling has raised things above      these limits again.  These must be configured thusly:  	0 <= bstop < bcull < brun < 100 	0 <= fstop < fcull < frun < 100  Note that these are percentages of available space and available files, and do _not_ appear as 100 minus the percentage displayed by the "df" program.  The userspace daemon scans the cache to build up a table of cullable objects. These are then culled in least recently used order.  A new scan of the cache is started as soon as space is made in the table.  Objects will be skipped if their atimes have changed or if the kernel module says it is still using them.  =============== CACHE STRUCTURE ===============  The CacheFiles module will create two directories in the directory it was given:   (*) cache/   (*) graveyard/  The active cache objects all reside in the first directory.  The CacheFiles kernel module moves any retired or culled objects that it can't simply unlink to the graveyard from which the daemon will actually delete them.  The daemon uses dnotify to monitor the graveyard directory, and will delete anything that appears therein.  The module represents index objects as directories with the filename "I..." or "J...".  Note that the "cache/" directory is itself a special index.  Data objects are represented as files if they have no children, or directories if they do.  Their filenames all begin "D..." or "E...".  If represented as a directory, data objects will have a file in the directory called "data" that actually holds the data.  Special objects are similar to data objects, except their filenames begin "S..." or "T...".  If an object has children, then it will be represented as a directory. Immediately in the representative directory are a collection of directories named for hash values of the child object keys with an '@' prepended.  Into this directory, if possible, will be placed the representations of the child objects:  	INDEX     INDEX      INDEX                             DATA FILES 	========= ========== ================================= ================ 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...DB1ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...N22ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...FP1ry  If the key is so long that it exceeds NAME_MAX with the decorations added on to it, then it will be cut into pieces, the first few of which will be used to make a nest of directories, and the last one of which will be the objects inside the last directory.  The names of the intermediate directories will have '+' prepended:  	J1223/@23/+xy...z/+kl...m/Epqr  Note that keys are raw data, and not only may they exceed NAME_MAX in size, they may also contain things like '/' and NUL characters, and so they may not be suitable for turning directly into a filename.  To handle this, CacheFiles will use a suitably printable filename directly and "base-64" encode ones that aren't directly suitable.  The two versions of object filenames indicate the encoding:  	OBJECT TYPE	PRINTABLE	ENCODED 	===============	===============	=============== 	Index		"I..."		"J..." 	Data		"D..."		"E..." 	Special		"S..."		"T..."  Intermediate directories are always "@" or "+" as appropriate.  Each object in the cache has an extended attribute label that holds the object type ID (required to distinguish special objects) and the auxiliary data from the netfs.  The latter is used to detect stale objects in the cache and update or retire them.  Note that CacheFiles will erase from the cache any file it doesn't recognise or any file of an incorrect type (such as a FIFO file or a device file).  ========================== SECURITY MODEL AND SELINUX ==========================  CacheFiles is implemented to deal properly with the LSM security features of the Linux kernel and the SELinux facility.  One of the problems that CacheFiles faces is that it is generally acting on behalf of a process, and running in that process's context, and that includes a security context that is not appropriate for accessing the cache - either because the files in the cache are inaccessible to that process, or because if the process creates a file in the cache, that file may be inaccessible to other processes.  The way CacheFiles works is to temporarily change the security context (fsuid, fsgid and actor security label) that the process acts as - without changing the security context of the process when it the target of an operation performed by some other process (so signalling and suchlike still work correctly).  When the CacheFiles module is asked to bind to its cache, it:   (1) Finds the security label attached to the root cache directory and uses      that as the security label with which it will create files.  By default,      this is:  	cachefiles_var_t   (2) Finds the security label of the process which issued the bind request      (presumed to be the cachefilesd daemon), which by default will be:  	cachefilesd_t       and asks LSM to supply a security ID as which it should act given the      daemon's label.  By default, this will be:  	cachefiles_kernel_t       SELinux transitions the daemon's security ID to the module's security ID      based on a rule of this form in the policy.  	type_transition <daemon's-ID> kernel_t : process <module's-ID>;       For instance:  	type_transition cachefilesd_t kernel_t : process cachefiles_kernel_t;  The module's security ID gives it permission to create, move and remove files and directories in the cache, to find and access directories and files in the cache, to set and access extended attributes on cache objects, and to read and write files in the cache.  The daemon's security ID gives it only a very restricted set of permissions: it may scan directories, stat files and erase files and directories.  It may not read or write files in the cache, and so it is precluded from accessing the data cached therein; nor is it permitted to create new files in the cache.  There are policy source files available in:  	http://people.redhat.com/~dhowells/fscache/cachefilesd-0.8.tar.bz2  and later versions.  In that tarball, see the files:  	cachefilesd.te 	cachefilesd.fc 	cachefilesd.if  They are built and installed directly by the RPM.  If a non-RPM based system is being used, then copy the above files to their own directory and run:  	make -f /usr/share/selinux/devel/Makefile 	semodule -i cachefilesd.pp  You will need checkpolicy and selinux-policy-devel installed prior to the build.  By default, the cache is located in /var/fscache, but if it is desirable that it should be elsewhere, than either the above policy files must be altered, or an auxiliary policy must be installed to label the alternate location of the cache.  For instructions on how to add an auxiliary policy to enable the cache to be located elsewhere when SELinux is in enforcing mode, please see:  	/usr/share/doc/cachefilesd-*/move-cache.txt  When the cachefilesd rpm is installed; alternatively, the document can be found in the sources.  ================== A NOTE ON SECURITY ==================  CacheFiles makes use of the split security in the task_struct.  It allocates its own task_security structure, and redirects current->act_as to point to it when it acts on behalf of another process, in that process's context.  The reason it does this is that it calls vfs_mkdir() and suchlike rather than bypassing security and calling inode ops directly.  Therefore the VFS and LSM may deny the CacheFiles access to the cache data because under some circumstances the caching code is running in the security context of whatever process issued the original syscall on the netfs.  Furthermore, should CacheFiles create a file or directory, the security parameters with that object is created (UID, GID, security label) would be derived from that process that issued the system call, thus potentially preventing other processes from accessing the cache - including CacheFiles's cache management daemon (cachefilesd).  What is required is to temporarily override the security of the process that issued the system call.  We can't, however, just do an in-place change of the security data as that affects the process as an object, not just as a subject. This means it may lose signals or ptrace events for example, and affects what the process looks like in /proc.  So CacheFiles makes use of a logical split in the security between the objective security (task->sec) and the subjective security (task->act_as).  The objective security holds the intrinsic security properties of a process and is never overridden.  This is what appears in /proc, and is what is used when a process is the target of an operation by some other process (SIGKILL for example).  The subjective security holds the active security properties of a process, and may be overridden.  This is not seen externally, and is used whan a process acts upon another object, for example SIGKILLing another process or opening a file.  LSM hooks exist that allow SELinux (or Smack or whatever) to reject a request for CacheFiles to run in a context of a specific security label, or to create files and directories with another security label.  This documentation is added by the patch to:  	Documentation/filesystems/caching/cachefiles.txt  Signed-Off-By: David Howells <dhowells@redhat.com> Acked-by: Steve Dickson <steved@redhat.com> Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com> Acked-by: Al Viro <viro@zeniv.linux.org.uk> Tested-by: Daire Byrne <Daire.Byrne@framestore.com>
f | namei.c | s | 24K | 824 | Al Viro | viro@zeniv.linux.org.uk | 1332293381 |  | switch touch_atime to struct path  Signed-off-by: Al Viro <viro@zeniv.linux.org.uk>
f | rdwr.c | s | 24K | 809 | Tejun Heo | tj@kernel.org | 1279832327 |  | fscache: convert operation to use workqueue instead of slow-work  Make fscache operation to use only workqueue instead of combination of workqueue and slow-work.  FSCACHE_OP_SLOW is dropped and FSCACHE_OP_FAST is renamed to FSCACHE_OP_ASYNC and uses newly added fscache_op_wq workqueue to execute op->processor(). fscache_operation_init_slow() is dropped and fscache_operation_init() now takes @processor argument directly.  * Unbound workqueue is used.  * fscache_retrieval_work() is no longer necessary as OP_ASYNC now does   the equivalent thing.  * sysctl fscache.operation_max_active added to control concurrency.   The default value is nr_cpus clamped between 2 and   WQ_UNBOUND_MAX_ACTIVE.  * debugfs support is dropped for now.  Tracing API based debug   facility is planned to be added.  Signed-off-by: Tejun Heo <tj@kernel.org> Acked-by: David Howells <dhowells@redhat.com>
f | security.c | s | 2.8K | 102 | David Howells | dhowells@redhat.com | 1273713838 |  | CacheFiles: Fix error handling in cachefiles_determine_cache_security()  cachefiles_determine_cache_security() is expected to return with a security override in place.  However, if set_create_files_as() fails, we fail to do this.  In this case, we should just reinstate the security override that was set by the caller.  Furthermore, if set_create_files_as() fails, we should dispose of the new credentials we were in the process of creating.  Signed-off-by: David Howells <dhowells@redhat.com> Signed-off-by: Linus Torvalds <torvalds@linux-foundation.org>
f | Kconfig | g | 1.4K |  | David Howells | dhowells@redhat.com | 1238773361 |  | CacheFiles: A cache that backs onto a mounted filesystem  Add an FS-Cache cache-backend that permits a mounted filesystem to be used as a backing store for the cache.  CacheFiles uses a userspace daemon to do some of the cache management - such as reaping stale nodes and culling.  This is called cachefilesd and lives in /sbin.  The source for the daemon can be downloaded from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.c  And an example configuration from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.conf  The filesystem and data integrity of the cache are only as good as those of the filesystem providing the backing services.  Note that CacheFiles does not attempt to journal anything since the journalling interfaces of the various filesystems are very specific in nature.  CacheFiles creates a misc character device - "/dev/cachefiles" - that is used to communication with the daemon.  Only one thing may have this open at once, and whilst it is open, a cache is at least partially in existence.  The daemon opens this and sends commands down it to control the cache.  CacheFiles is currently limited to a single cache.  CacheFiles attempts to maintain at least a certain percentage of free space on the filesystem, shrinking the cache by culling the objects it contains to make space if necessary - see the "Cache Culling" section.  This means it can be placed on the same medium as a live set of data, and will expand to make use of spare space and automatically contract when the set of data requires more space.  ============ REQUIREMENTS ============  The use of CacheFiles and its daemon requires the following features to be available in the system and in the cache filesystem:  	- dnotify.  	- extended attributes (xattrs).  	- openat() and friends.  	- bmap() support on files in the filesystem (FIBMAP ioctl).  	- The use of bmap() to detect a partial page at the end of the file.  It is strongly recommended that the "dir_index" option is enabled on Ext3 filesystems being used as a cache.  ============= CONFIGURATION =============  The cache is configured by a script in /etc/cachefilesd.conf.  These commands set up cache ready for use.  The following script commands are available:   (*) brun <N>%  (*) bcull <N>%  (*) bstop <N>%  (*) frun <N>%  (*) fcull <N>%  (*) fstop <N>%  	Configure the culling limits.  Optional.  See the section on culling 	The defaults are 7% (run), 5% (cull) and 1% (stop) respectively.  	The commands beginning with a 'b' are file space (block) limits, those 	beginning with an 'f' are file count limits.   (*) dir <path>  	Specify the directory containing the root of the cache.  Mandatory.   (*) tag <name>  	Specify a tag to FS-Cache to use in distinguishing multiple caches. 	Optional.  The default is "CacheFiles".   (*) debug <mask>  	Specify a numeric bitmask to control debugging in the kernel module. 	Optional.  The default is zero (all off).  The following values can be 	OR'd into the mask to collect various information:  		1	Turn on trace of function entry (_enter() macros) 		2	Turn on trace of function exit (_leave() macros) 		4	Turn on trace of internal debug points (_debug())  	This mask can also be set through sysfs, eg:  		echo 5 >/sys/modules/cachefiles/parameters/debug  ================== STARTING THE CACHE ==================  The cache is started by running the daemon.  The daemon opens the cache device, configures the cache and tells it to begin caching.  At that point the cache binds to fscache and the cache becomes live.  The daemon is run as follows:  	/sbin/cachefilesd [-d]* [-s] [-n] [-f <configfile>]  The flags are:   (*) -d  	Increase the debugging level.  This can be specified multiple times and 	is cumulative with itself.   (*) -s  	Send messages to stderr instead of syslog.   (*) -n  	Don't daemonise and go into background.   (*) -f <configfile>  	Use an alternative configuration file rather than the default one.  =============== THINGS TO AVOID ===============  Do not mount other things within the cache as this will cause problems.  The kernel module contains its own very cut-down path walking facility that ignores mountpoints, but the daemon can't avoid them.  Do not create, rename or unlink files and directories in the cache whilst the cache is active, as this may cause the state to become uncertain.  Renaming files in the cache might make objects appear to be other objects (the filename is part of the lookup key).  Do not change or remove the extended attributes attached to cache files by the cache as this will cause the cache state management to get confused.  Do not create files or directories in the cache, lest the cache get confused or serve incorrect data.  Do not chmod files in the cache.  The module creates things with minimal permissions to prevent random users being able to access them directly.  ============= CACHE CULLING =============  The cache may need culling occasionally to make space.  This involves discarding objects from the cache that have been used less recently than anything else.  Culling is based on the access time of data objects.  Empty directories are culled if not in use.  Cache culling is done on the basis of the percentage of blocks and the percentage of files available in the underlying filesystem.  There are six "limits":   (*) brun  (*) frun       If the amount of free space and the number of available files in the cache      rises above both these limits, then culling is turned off.   (*) bcull  (*) fcull       If the amount of available space or the number of available files in the      cache falls below either of these limits, then culling is started.   (*) bstop  (*) fstop       If the amount of available space or the number of available files in the      cache falls below either of these limits, then no further allocation of      disk space or files is permitted until culling has raised things above      these limits again.  These must be configured thusly:  	0 <= bstop < bcull < brun < 100 	0 <= fstop < fcull < frun < 100  Note that these are percentages of available space and available files, and do _not_ appear as 100 minus the percentage displayed by the "df" program.  The userspace daemon scans the cache to build up a table of cullable objects. These are then culled in least recently used order.  A new scan of the cache is started as soon as space is made in the table.  Objects will be skipped if their atimes have changed or if the kernel module says it is still using them.  =============== CACHE STRUCTURE ===============  The CacheFiles module will create two directories in the directory it was given:   (*) cache/   (*) graveyard/  The active cache objects all reside in the first directory.  The CacheFiles kernel module moves any retired or culled objects that it can't simply unlink to the graveyard from which the daemon will actually delete them.  The daemon uses dnotify to monitor the graveyard directory, and will delete anything that appears therein.  The module represents index objects as directories with the filename "I..." or "J...".  Note that the "cache/" directory is itself a special index.  Data objects are represented as files if they have no children, or directories if they do.  Their filenames all begin "D..." or "E...".  If represented as a directory, data objects will have a file in the directory called "data" that actually holds the data.  Special objects are similar to data objects, except their filenames begin "S..." or "T...".  If an object has children, then it will be represented as a directory. Immediately in the representative directory are a collection of directories named for hash values of the child object keys with an '@' prepended.  Into this directory, if possible, will be placed the representations of the child objects:  	INDEX     INDEX      INDEX                             DATA FILES 	========= ========== ================================= ================ 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...DB1ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...N22ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...FP1ry  If the key is so long that it exceeds NAME_MAX with the decorations added on to it, then it will be cut into pieces, the first few of which will be used to make a nest of directories, and the last one of which will be the objects inside the last directory.  The names of the intermediate directories will have '+' prepended:  	J1223/@23/+xy...z/+kl...m/Epqr  Note that keys are raw data, and not only may they exceed NAME_MAX in size, they may also contain things like '/' and NUL characters, and so they may not be suitable for turning directly into a filename.  To handle this, CacheFiles will use a suitably printable filename directly and "base-64" encode ones that aren't directly suitable.  The two versions of object filenames indicate the encoding:  	OBJECT TYPE	PRINTABLE	ENCODED 	===============	===============	=============== 	Index		"I..."		"J..." 	Data		"D..."		"E..." 	Special		"S..."		"T..."  Intermediate directories are always "@" or "+" as appropriate.  Each object in the cache has an extended attribute label that holds the object type ID (required to distinguish special objects) and the auxiliary data from the netfs.  The latter is used to detect stale objects in the cache and update or retire them.  Note that CacheFiles will erase from the cache any file it doesn't recognise or any file of an incorrect type (such as a FIFO file or a device file).  ========================== SECURITY MODEL AND SELINUX ==========================  CacheFiles is implemented to deal properly with the LSM security features of the Linux kernel and the SELinux facility.  One of the problems that CacheFiles faces is that it is generally acting on behalf of a process, and running in that process's context, and that includes a security context that is not appropriate for accessing the cache - either because the files in the cache are inaccessible to that process, or because if the process creates a file in the cache, that file may be inaccessible to other processes.  The way CacheFiles works is to temporarily change the security context (fsuid, fsgid and actor security label) that the process acts as - without changing the security context of the process when it the target of an operation performed by some other process (so signalling and suchlike still work correctly).  When the CacheFiles module is asked to bind to its cache, it:   (1) Finds the security label attached to the root cache directory and uses      that as the security label with which it will create files.  By default,      this is:  	cachefiles_var_t   (2) Finds the security label of the process which issued the bind request      (presumed to be the cachefilesd daemon), which by default will be:  	cachefilesd_t       and asks LSM to supply a security ID as which it should act given the      daemon's label.  By default, this will be:  	cachefiles_kernel_t       SELinux transitions the daemon's security ID to the module's security ID      based on a rule of this form in the policy.  	type_transition <daemon's-ID> kernel_t : process <module's-ID>;       For instance:  	type_transition cachefilesd_t kernel_t : process cachefiles_kernel_t;  The module's security ID gives it permission to create, move and remove files and directories in the cache, to find and access directories and files in the cache, to set and access extended attributes on cache objects, and to read and write files in the cache.  The daemon's security ID gives it only a very restricted set of permissions: it may scan directories, stat files and erase files and directories.  It may not read or write files in the cache, and so it is precluded from accessing the data cached therein; nor is it permitted to create new files in the cache.  There are policy source files available in:  	http://people.redhat.com/~dhowells/fscache/cachefilesd-0.8.tar.bz2  and later versions.  In that tarball, see the files:  	cachefilesd.te 	cachefilesd.fc 	cachefilesd.if  They are built and installed directly by the RPM.  If a non-RPM based system is being used, then copy the above files to their own directory and run:  	make -f /usr/share/selinux/devel/Makefile 	semodule -i cachefilesd.pp  You will need checkpolicy and selinux-policy-devel installed prior to the build.  By default, the cache is located in /var/fscache, but if it is desirable that it should be elsewhere, than either the above policy files must be altered, or an auxiliary policy must be installed to label the alternate location of the cache.  For instructions on how to add an auxiliary policy to enable the cache to be located elsewhere when SELinux is in enforcing mode, please see:  	/usr/share/doc/cachefilesd-*/move-cache.txt  When the cachefilesd rpm is installed; alternatively, the document can be found in the sources.  ================== A NOTE ON SECURITY ==================  CacheFiles makes use of the split security in the task_struct.  It allocates its own task_security structure, and redirects current->act_as to point to it when it acts on behalf of another process, in that process's context.  The reason it does this is that it calls vfs_mkdir() and suchlike rather than bypassing security and calling inode ops directly.  Therefore the VFS and LSM may deny the CacheFiles access to the cache data because under some circumstances the caching code is running in the security context of whatever process issued the original syscall on the netfs.  Furthermore, should CacheFiles create a file or directory, the security parameters with that object is created (UID, GID, security label) would be derived from that process that issued the system call, thus potentially preventing other processes from accessing the cache - including CacheFiles's cache management daemon (cachefilesd).  What is required is to temporarily override the security of the process that issued the system call.  We can't, however, just do an in-place change of the security data as that affects the process as an object, not just as a subject. This means it may lose signals or ptrace events for example, and affects what the process looks like in /proc.  So CacheFiles makes use of a logical split in the security between the objective security (task->sec) and the subjective security (task->act_as).  The objective security holds the intrinsic security properties of a process and is never overridden.  This is what appears in /proc, and is what is used when a process is the target of an operation by some other process (SIGKILL for example).  The subjective security holds the active security properties of a process, and may be overridden.  This is not seen externally, and is used whan a process acts upon another object, for example SIGKILLing another process or opening a file.  LSM hooks exist that allow SELinux (or Smack or whatever) to reject a request for CacheFiles to run in a context of a specific security label, or to create files and directories with another security label.  This documentation is added by the patch to:  	Documentation/filesystems/caching/cachefiles.txt  Signed-Off-By: David Howells <dhowells@redhat.com> Acked-by: Steve Dickson <steved@redhat.com> Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com> Acked-by: Al Viro <viro@zeniv.linux.org.uk> Tested-by: Daire Byrne <Daire.Byrne@framestore.com>
f | main.c | s | 2.5K | 89 | David Howells | dhowells@redhat.com | 1238773361 |  | CacheFiles: A cache that backs onto a mounted filesystem  Add an FS-Cache cache-backend that permits a mounted filesystem to be used as a backing store for the cache.  CacheFiles uses a userspace daemon to do some of the cache management - such as reaping stale nodes and culling.  This is called cachefilesd and lives in /sbin.  The source for the daemon can be downloaded from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.c  And an example configuration from:  	http://people.redhat.com/~dhowells/cachefs/cachefilesd.conf  The filesystem and data integrity of the cache are only as good as those of the filesystem providing the backing services.  Note that CacheFiles does not attempt to journal anything since the journalling interfaces of the various filesystems are very specific in nature.  CacheFiles creates a misc character device - "/dev/cachefiles" - that is used to communication with the daemon.  Only one thing may have this open at once, and whilst it is open, a cache is at least partially in existence.  The daemon opens this and sends commands down it to control the cache.  CacheFiles is currently limited to a single cache.  CacheFiles attempts to maintain at least a certain percentage of free space on the filesystem, shrinking the cache by culling the objects it contains to make space if necessary - see the "Cache Culling" section.  This means it can be placed on the same medium as a live set of data, and will expand to make use of spare space and automatically contract when the set of data requires more space.  ============ REQUIREMENTS ============  The use of CacheFiles and its daemon requires the following features to be available in the system and in the cache filesystem:  	- dnotify.  	- extended attributes (xattrs).  	- openat() and friends.  	- bmap() support on files in the filesystem (FIBMAP ioctl).  	- The use of bmap() to detect a partial page at the end of the file.  It is strongly recommended that the "dir_index" option is enabled on Ext3 filesystems being used as a cache.  ============= CONFIGURATION =============  The cache is configured by a script in /etc/cachefilesd.conf.  These commands set up cache ready for use.  The following script commands are available:   (*) brun <N>%  (*) bcull <N>%  (*) bstop <N>%  (*) frun <N>%  (*) fcull <N>%  (*) fstop <N>%  	Configure the culling limits.  Optional.  See the section on culling 	The defaults are 7% (run), 5% (cull) and 1% (stop) respectively.  	The commands beginning with a 'b' are file space (block) limits, those 	beginning with an 'f' are file count limits.   (*) dir <path>  	Specify the directory containing the root of the cache.  Mandatory.   (*) tag <name>  	Specify a tag to FS-Cache to use in distinguishing multiple caches. 	Optional.  The default is "CacheFiles".   (*) debug <mask>  	Specify a numeric bitmask to control debugging in the kernel module. 	Optional.  The default is zero (all off).  The following values can be 	OR'd into the mask to collect various information:  		1	Turn on trace of function entry (_enter() macros) 		2	Turn on trace of function exit (_leave() macros) 		4	Turn on trace of internal debug points (_debug())  	This mask can also be set through sysfs, eg:  		echo 5 >/sys/modules/cachefiles/parameters/debug  ================== STARTING THE CACHE ==================  The cache is started by running the daemon.  The daemon opens the cache device, configures the cache and tells it to begin caching.  At that point the cache binds to fscache and the cache becomes live.  The daemon is run as follows:  	/sbin/cachefilesd [-d]* [-s] [-n] [-f <configfile>]  The flags are:   (*) -d  	Increase the debugging level.  This can be specified multiple times and 	is cumulative with itself.   (*) -s  	Send messages to stderr instead of syslog.   (*) -n  	Don't daemonise and go into background.   (*) -f <configfile>  	Use an alternative configuration file rather than the default one.  =============== THINGS TO AVOID ===============  Do not mount other things within the cache as this will cause problems.  The kernel module contains its own very cut-down path walking facility that ignores mountpoints, but the daemon can't avoid them.  Do not create, rename or unlink files and directories in the cache whilst the cache is active, as this may cause the state to become uncertain.  Renaming files in the cache might make objects appear to be other objects (the filename is part of the lookup key).  Do not change or remove the extended attributes attached to cache files by the cache as this will cause the cache state management to get confused.  Do not create files or directories in the cache, lest the cache get confused or serve incorrect data.  Do not chmod files in the cache.  The module creates things with minimal permissions to prevent random users being able to access them directly.  ============= CACHE CULLING =============  The cache may need culling occasionally to make space.  This involves discarding objects from the cache that have been used less recently than anything else.  Culling is based on the access time of data objects.  Empty directories are culled if not in use.  Cache culling is done on the basis of the percentage of blocks and the percentage of files available in the underlying filesystem.  There are six "limits":   (*) brun  (*) frun       If the amount of free space and the number of available files in the cache      rises above both these limits, then culling is turned off.   (*) bcull  (*) fcull       If the amount of available space or the number of available files in the      cache falls below either of these limits, then culling is started.   (*) bstop  (*) fstop       If the amount of available space or the number of available files in the      cache falls below either of these limits, then no further allocation of      disk space or files is permitted until culling has raised things above      these limits again.  These must be configured thusly:  	0 <= bstop < bcull < brun < 100 	0 <= fstop < fcull < frun < 100  Note that these are percentages of available space and available files, and do _not_ appear as 100 minus the percentage displayed by the "df" program.  The userspace daemon scans the cache to build up a table of cullable objects. These are then culled in least recently used order.  A new scan of the cache is started as soon as space is made in the table.  Objects will be skipped if their atimes have changed or if the kernel module says it is still using them.  =============== CACHE STRUCTURE ===============  The CacheFiles module will create two directories in the directory it was given:   (*) cache/   (*) graveyard/  The active cache objects all reside in the first directory.  The CacheFiles kernel module moves any retired or culled objects that it can't simply unlink to the graveyard from which the daemon will actually delete them.  The daemon uses dnotify to monitor the graveyard directory, and will delete anything that appears therein.  The module represents index objects as directories with the filename "I..." or "J...".  Note that the "cache/" directory is itself a special index.  Data objects are represented as files if they have no children, or directories if they do.  Their filenames all begin "D..." or "E...".  If represented as a directory, data objects will have a file in the directory called "data" that actually holds the data.  Special objects are similar to data objects, except their filenames begin "S..." or "T...".  If an object has children, then it will be represented as a directory. Immediately in the representative directory are a collection of directories named for hash values of the child object keys with an '@' prepended.  Into this directory, if possible, will be placed the representations of the child objects:  	INDEX     INDEX      INDEX                             DATA FILES 	========= ========== ================================= ================ 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...DB1ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...N22ry 	cache/@4a/I03nfs/@30/Ji000000000000000--fHg8hi8400/@75/Es0g000w...FP1ry  If the key is so long that it exceeds NAME_MAX with the decorations added on to it, then it will be cut into pieces, the first few of which will be used to make a nest of directories, and the last one of which will be the objects inside the last directory.  The names of the intermediate directories will have '+' prepended:  	J1223/@23/+xy...z/+kl...m/Epqr  Note that keys are raw data, and not only may they exceed NAME_MAX in size, they may also contain things like '/' and NUL characters, and so they may not be suitable for turning directly into a filename.  To handle this, CacheFiles will use a suitably printable filename directly and "base-64" encode ones that aren't directly suitable.  The two versions of object filenames indicate the encoding:  	OBJECT TYPE	PRINTABLE	ENCODED 	===============	===============	=============== 	Index		"I..."		"J..." 	Data		"D..."		"E..." 	Special		"S..."		"T..."  Intermediate directories are always "@" or "+" as appropriate.  Each object in the cache has an extended attribute label that holds the object type ID (required to distinguish special objects) and the auxiliary data from the netfs.  The latter is used to detect stale objects in the cache and update or retire them.  Note that CacheFiles will erase from the cache any file it doesn't recognise or any file of an incorrect type (such as a FIFO file or a device file).  ========================== SECURITY MODEL AND SELINUX ==========================  CacheFiles is implemented to deal properly with the LSM security features of the Linux kernel and the SELinux facility.  One of the problems that CacheFiles faces is that it is generally acting on behalf of a process, and running in that process's context, and that includes a security context that is not appropriate for accessing the cache - either because the files in the cache are inaccessible to that process, or because if the process creates a file in the cache, that file may be inaccessible to other processes.  The way CacheFiles works is to temporarily change the security context (fsuid, fsgid and actor security label) that the process acts as - without changing the security context of the process when it the target of an operation performed by some other process (so signalling and suchlike still work correctly).  When the CacheFiles module is asked to bind to its cache, it:   (1) Finds the security label attached to the root cache directory and uses      that as the security label with which it will create files.  By default,      this is:  	cachefiles_var_t   (2) Finds the security label of the process which issued the bind request      (presumed to be the cachefilesd daemon), which by default will be:  	cachefilesd_t       and asks LSM to supply a security ID as which it should act given the      daemon's label.  By default, this will be:  	cachefiles_kernel_t       SELinux transitions the daemon's security ID to the module's security ID      based on a rule of this form in the policy.  	type_transition <daemon's-ID> kernel_t : process <module's-ID>;       For instance:  	type_transition cachefilesd_t kernel_t : process cachefiles_kernel_t;  The module's security ID gives it permission to create, move and remove files and directories in the cache, to find and access directories and files in the cache, to set and access extended attributes on cache objects, and to read and write files in the cache.  The daemon's security ID gives it only a very restricted set of permissions: it may scan directories, stat files and erase files and directories.  It may not read or write files in the cache, and so it is precluded from accessing the data cached therein; nor is it permitted to create new files in the cache.  There are policy source files available in:  	http://people.redhat.com/~dhowells/fscache/cachefilesd-0.8.tar.bz2  and later versions.  In that tarball, see the files:  	cachefilesd.te 	cachefilesd.fc 	cachefilesd.if  They are built and installed directly by the RPM.  If a non-RPM based system is being used, then copy the above files to their own directory and run:  	make -f /usr/share/selinux/devel/Makefile 	semodule -i cachefilesd.pp  You will need checkpolicy and selinux-policy-devel installed prior to the build.  By default, the cache is located in /var/fscache, but if it is desirable that it should be elsewhere, than either the above policy files must be altered, or an auxiliary policy must be installed to label the alternate location of the cache.  For instructions on how to add an auxiliary policy to enable the cache to be located elsewhere when SELinux is in enforcing mode, please see:  	/usr/share/doc/cachefilesd-*/move-cache.txt  When the cachefilesd rpm is installed; alternatively, the document can be found in the sources.  ================== A NOTE ON SECURITY ==================  CacheFiles makes use of the split security in the task_struct.  It allocates its own task_security structure, and redirects current->act_as to point to it when it acts on behalf of another process, in that process's context.  The reason it does this is that it calls vfs_mkdir() and suchlike rather than bypassing security and calling inode ops directly.  Therefore the VFS and LSM may deny the CacheFiles access to the cache data because under some circumstances the caching code is running in the security context of whatever process issued the original syscall on the netfs.  Furthermore, should CacheFiles create a file or directory, the security parameters with that object is created (UID, GID, security label) would be derived from that process that issued the system call, thus potentially preventing other processes from accessing the cache - including CacheFiles's cache management daemon (cachefilesd).  What is required is to temporarily override the security of the process that issued the system call.  We can't, however, just do an in-place change of the security data as that affects the process as an object, not just as a subject. This means it may lose signals or ptrace events for example, and affects what the process looks like in /proc.  So CacheFiles makes use of a logical split in the security between the objective security (task->sec) and the subjective security (task->act_as).  The objective security holds the intrinsic security properties of a process and is never overridden.  This is what appears in /proc, and is what is used when a process is the target of an operation by some other process (SIGKILL for example).  The subjective security holds the active security properties of a process, and may be overridden.  This is not seen externally, and is used whan a process acts upon another object, for example SIGKILLing another process or opening a file.  LSM hooks exist that allow SELinux (or Smack or whatever) to reject a request for CacheFiles to run in a context of a specific security label, or to create files and directories with another security label.  This documentation is added by the patch to:  	Documentation/filesystems/caching/cachefiles.txt  Signed-Off-By: David Howells <dhowells@redhat.com> Acked-by: Steve Dickson <steved@redhat.com> Acked-by: Trond Myklebust <Trond.Myklebust@netapp.com> Acked-by: Al Viro <viro@zeniv.linux.org.uk> Tested-by: Daire Byrne <Daire.Byrne@framestore.com>
