<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jffs2 › gc.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>gc.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * JFFS2 -- Journalling Flash File System, Version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2001-2007 Red Hat, Inc.</span>
<span class="cm"> * Copyright © 2004-2010 David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Created by David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * For licensing information, see the file &#39;LICENCE&#39; in this directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &quot;nodelist.h&quot;</span>
<span class="cp">#include &quot;compr.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">jffs2_garbage_collect_pristine</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">ic</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jffs2_garbage_collect_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jffs2_garbage_collect_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jffs2_garbage_collect_deletion_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jffs2_garbage_collect_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span>
				      <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">end</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jffs2_garbage_collect_dnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span>
				       <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">end</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">jffs2_garbage_collect_live</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">);</span>

<span class="cm">/* Called with erase_completion_lock held */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="nf">jffs2_find_gc_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">nextlist</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">%</span> <span class="mi">128</span><span class="p">;</span>

	<span class="cm">/* Pick an eraseblock to garbage collect next. This is where we&#39;ll</span>
<span class="cm">	   put the clever wear-levelling algorithms. Eventually.  */</span>
	<span class="cm">/* We possibly want to favour the dirtier blocks more when the</span>
<span class="cm">	   number of free blocks is low. */</span>
<span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bad_used_list</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_free_blocks</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">resv_blocks_gcbad</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from bad_used_list to GC next</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">bad_used_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">50</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erasable_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Note that most of them will have gone directly to be erased.</span>
<span class="cm">		   So don&#39;t favour the erasable_list _too_ much. */</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from erasable_list to GC next</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erasable_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">110</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">very_dirty_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Most of the time, pick one off the very_dirty list */</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from very_dirty_list to GC next</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">very_dirty_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">126</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from dirty_list to GC next</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from clean_list to GC next</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">clean_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from dirty_list to GC next (clean_list was empty)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">very_dirty_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from very_dirty_list to GC next (clean_list and dirty_list were empty)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">very_dirty_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erasable_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Picking block from erasable_list to GC next (clean_list and {very_,}dirty_list were empty)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="n">nextlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erasable_list</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erasable_pending_wbuf_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* There are blocks are wating for the wbuf sync */</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Synching wbuf in order to reuse erasable_pending_wbuf_list blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="n">jffs2_flush_wbuf_pad</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Eep. All were empty */</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;No clean, dirty _or_ erasable blocks to GC from! Where are they all?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">nextlist</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span><span class="o">-&gt;</span><span class="n">gc_node</span> <span class="o">=</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">first_node</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">gc_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Eep. ret-&gt;gc_node for block at 0x%08x is NULL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* Have we accidentally picked a clean block with wasted space ? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Converting wasted_size %08x to dirty_size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">ret</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">);</span>
		<span class="n">ret</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+=</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">wasted_size</span> <span class="o">-=</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+=</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">;</span>
		<span class="n">ret</span><span class="o">-&gt;</span><span class="n">wasted_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* jffs2_garbage_collect_pass</span>
<span class="cm"> * Make a single attempt to progress GC. Move one node, and possibly</span>
<span class="cm"> * start erasing one eraseblock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jffs2_garbage_collect_pass</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">ic</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">gcblock_dirty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="n">nlink</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">xattr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mutex_lock_interruptible</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">unchecked_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* We can&#39;t start doing GC yet. We haven&#39;t finished checking</span>
<span class="cm">		   the node CRCs etc. Do it now. */</span>

		<span class="cm">/* checked_ino is protected by the alloc_sem */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">checked_ino</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_ino</span> <span class="o">&amp;&amp;</span> <span class="n">xattr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Checked all inodes but still 0x%x bytes of unchecked space?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">c</span><span class="o">-&gt;</span><span class="n">unchecked_size</span><span class="p">);</span>
			<span class="n">jffs2_dbg_dump_block_lists_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xattr</span><span class="p">)</span>
			<span class="n">xattr</span> <span class="o">=</span> <span class="n">jffs2_verify_xattr</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>

		<span class="n">ic</span> <span class="o">=</span> <span class="n">jffs2_get_ino_cache</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">checked_ino</span><span class="o">++</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">pino_nlink</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Skipping check of ino #%d with nlink/pino zero</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
			<span class="n">jffs2_xattr_delete_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ic</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">INO_STATE_CHECKEDABSENT</span>:
		<span class="k">case</span> <span class="n">INO_STATE_PRESENT</span>:
			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Skipping ino #%u already checked</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">INO_STATE_GC</span>:
		<span class="k">case</span> <span class="n">INO_STATE_CHECKING</span>:
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Inode #%u is in state %d during CRC check phase!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>

		<span class="k">case</span> <span class="n">INO_STATE_READING</span>:
			<span class="cm">/* We need to wait for it to finish, lest we move on</span>
<span class="cm">			   and trigger the BUG() above while we haven&#39;t yet</span>
<span class="cm">			   finished checking all its nodes */</span>
			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Waiting for ino #%u to finish reading</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
			<span class="cm">/* We need to come back again for the _same_ inode. We&#39;ve</span>
<span class="cm">			 made no progress in this case, but that should be OK */</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">checked_ino</span><span class="o">--</span><span class="p">;</span>

			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
			<span class="n">sleep_on_spinunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>

		<span class="k">case</span> <span class="n">INO_STATE_UNCHECKED</span>:
			<span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">INO_STATE_CHECKING</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>

		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): triggering inode scan of ino#%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_do_crccheck_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ic</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Returned error for crccheck of ino #%u. Expect badness...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

		<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">INO_STATE_CHECKEDABSENT</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If there are any blocks which need erasing, erase them now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_complete_list</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_pending_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): erasing pending blocks</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jffs2_erase_pending_blocks</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;No progress from erasing block; doing GC anyway</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* First, work out which block we&#39;re garbage-collecting */</span>
	<span class="n">jeb</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jeb</span><span class="p">)</span>
		<span class="n">jeb</span> <span class="o">=</span> <span class="n">jffs2_find_gc_block</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jeb</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Couldn&#39;t find a free block. But maybe we can just erase one and make &#39;progress&#39;? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_erasing_blocks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t find erase block to garbage collect!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;GC from block %08x, used_size %08x, dirty_size %08x, free_size %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">);</span>
	<span class="n">D1</span><span class="p">(</span><span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nextblock</span><span class="p">)</span>
	   <span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;Nextblock at  %08x, used_size %08x, dirty_size %08x, wasted_size %08x, free_size %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nextblock</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nextblock</span><span class="o">-&gt;</span><span class="n">used_size</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nextblock</span><span class="o">-&gt;</span><span class="n">dirty_size</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nextblock</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nextblock</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">eraseit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">raw</span> <span class="o">=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">gc_node</span><span class="p">;</span>
	<span class="n">gcblock_dirty</span> <span class="o">=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">raw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Node at 0x%08x is obsolete... skipping</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>
		<span class="n">raw</span> <span class="o">=</span> <span class="n">ref_next</span><span class="p">(</span><span class="n">raw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">raw</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;eep. End of raw list while still supposedly nodes to GC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;erase block at 0x%08x. free_size 0x%08x, dirty_size 0x%08x, used_size 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">,</span>
				<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span><span class="p">);</span>
			<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">gc_node</span> <span class="o">=</span> <span class="n">raw</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">gc_node</span> <span class="o">=</span> <span class="n">raw</span><span class="p">;</span>

	<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Going to garbage collect node at 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Inode-less node. Clean marker, snapshot or something like that */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="o">==</span> <span class="n">REF_PRISTINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* It&#39;s an unknown node with JFFS2_FEATURE_RWCOMPAT_COPY */</span>
			<span class="n">jffs2_garbage_collect_pristine</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* Just mark it obsolete */</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">eraseit_lock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ic</span> <span class="o">=</span> <span class="n">jffs2_raw_ref_to_ic</span><span class="p">(</span><span class="n">raw</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_JFFS2_FS_XATTR</span>
	<span class="cm">/* When &#39;ic&#39; refers xattr_datum/xattr_ref, this node is GCed as xattr.</span>
<span class="cm">	 * We can decide whether this node is inode or xattr by ic-&gt;class.     */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">RAWNODE_CLASS_XATTR_DATUM</span>
	    <span class="o">||</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">RAWNODE_CLASS_XATTR_REF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">class</span> <span class="o">==</span> <span class="n">RAWNODE_CLASS_XATTR_DATUM</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_xattr_datum</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_xattr_datum</span> <span class="o">*</span><span class="p">)</span><span class="n">ic</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_xattr_ref</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_xattr_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">ic</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">test_gcnode</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>

	<span class="cm">/* We need to hold the inocache. Either the erase_completion_lock or</span>
<span class="cm">	   the inocache_lock are sufficient; we trade down since the inocache_lock</span>
<span class="cm">	   causes less contention. */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

	<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): collecting from block @0x%08x. Node @0x%08x(%d), ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">__func__</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">ref_flags</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span>
		  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

	<span class="cm">/* Three possibilities:</span>
<span class="cm">	   1. Inode is already in-core. We must iget it and do proper</span>
<span class="cm">	      updating to its fragtree, etc.</span>
<span class="cm">	   2. Inode is not in-core, node is REF_PRISTINE. We lock the</span>
<span class="cm">	      inocache to prevent a read_inode(), copy the node intact.</span>
<span class="cm">	   3. Inode is not in-core, node is not pristine. We must iget()</span>
<span class="cm">	      and take the slow path.</span>
<span class="cm">	*/</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">INO_STATE_CHECKEDABSENT</span>:
		<span class="cm">/* It&#39;s been checked, but it&#39;s not currently in-core.</span>
<span class="cm">		   We can just copy any pristine nodes, but have</span>
<span class="cm">		   to prevent anyone else from doing read_inode() while</span>
<span class="cm">		   we&#39;re at it, so we set the state accordingly */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="o">==</span> <span class="n">REF_PRISTINE</span><span class="p">)</span>
			<span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">INO_STATE_GC</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Ino #%u is absent but node not REF_PRISTINE. Reading.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INO_STATE_PRESENT</span>:
		<span class="cm">/* It&#39;s in-core. GC must iget() it. */</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">INO_STATE_UNCHECKED</span>:
	<span class="k">case</span> <span class="n">INO_STATE_CHECKING</span>:
	<span class="k">case</span> <span class="n">INO_STATE_GC</span>:
		<span class="cm">/* Should never happen. We should have finished checking</span>
<span class="cm">		   by the time we actually start doing any GC, and since</span>
<span class="cm">		   we&#39;re holding the alloc_sem, no other garbage collection</span>
<span class="cm">		   can happen.</span>
<span class="cm">		*/</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Inode #%u already in state %d in jffs2_garbage_collect_pass()!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>

	<span class="k">case</span> <span class="n">INO_STATE_READING</span>:
		<span class="cm">/* Someone&#39;s currently trying to read it. We must wait for</span>
<span class="cm">		   them to finish and then go through the full iget() route</span>
<span class="cm">		   to do the GC. However, sometimes read_inode() needs to get</span>
<span class="cm">		   the alloc_sem() (for marking nodes invalid) so we must</span>
<span class="cm">		   drop the alloc_sem before sleeping. */</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): waiting for ino #%u in state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
		<span class="n">sleep_on_spinunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
		<span class="cm">/* And because we dropped the alloc_sem we must start again from the</span>
<span class="cm">		   beginning. Ponder chance of livelock here -- we&#39;re returning success</span>
<span class="cm">		   without actually making any progress.</span>

<span class="cm">		   Q: What are the chances that the inode is back in INO_STATE_READING</span>
<span class="cm">		   again by the time we next enter this function? And that this happens</span>
<span class="cm">		   enough times to cause a real delay?</span>

<span class="cm">		   A: Small enough that I don&#39;t care :)</span>
<span class="cm">		*/</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* OK. Now if the inode is in state INO_STATE_GC, we are going to copy the</span>
<span class="cm">	   node intact, and we don&#39;t have to muck about with the fragtree etc.</span>
<span class="cm">	   because we know it&#39;s not in-core. If it _was_ in-core, we go through</span>
<span class="cm">	   all the iget() crap anyway */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">INO_STATE_GC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_pristine</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ic</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
		<span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">INO_STATE_CHECKEDABSENT</span><span class="p">;</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_wq</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">test_gcnode</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Fall through if it wanted us to, with inocache_lock held */</span>
	<span class="p">}</span>

	<span class="cm">/* Prevent the fairly unlikely race where the gcblock is</span>
<span class="cm">	   entirely obsoleted by the final close of a file which had</span>
<span class="cm">	   the only valid nodes in the block, followed by erasure,</span>
<span class="cm">	   followed by freeing of the ic because the erased block(s)</span>
<span class="cm">	   held _all_ the nodes of that inode.... never been seen but</span>
<span class="cm">	   it&#39;s vaguely possible. */</span>

	<span class="n">inum</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">;</span>
	<span class="n">nlink</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">pino_nlink</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>

	<span class="n">f</span> <span class="o">=</span> <span class="n">jffs2_gc_fetch_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="o">!</span><span class="n">nlink</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">release_sem</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">release_sem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_live</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">raw</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

	<span class="n">jffs2_gc_release_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>

 <span class="nl">test_gcnode:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">==</span> <span class="n">gcblock_dirty</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">gc_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Eep. This really should never happen. GC is broken */</span>
		<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;Error garbage collecting node at %08x!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ref_offset</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">gc_node</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">release_sem:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">alloc_sem</span><span class="p">);</span>

 <span class="nl">eraseit_lock:</span>
	<span class="cm">/* If we&#39;ve finished this block, start it erasing */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

 <span class="nl">eraseit:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span><span class="o">-&gt;</span><span class="n">used_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Block at 0x%08x completely obsoleted by GC. Moving to erase_pending_list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="cm">/* We&#39;re GC&#39;ing an empty block? */</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_pending_list</span><span class="p">);</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_erasing_blocks</span><span class="o">++</span><span class="p">;</span>
		<span class="n">jffs2_garbage_collect_trigger</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_garbage_collect_live</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nrfrags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="cm">/* Now we have the lock for this inode. Check that it&#39;s still the one at the head</span>
<span class="cm">	   of the list. */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span> <span class="o">!=</span> <span class="n">jeb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;GC block is no longer gcblock. Restart</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">upnout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">raw</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;node to be GC&#39;d was obsoleted in the meantime.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="cm">/* They&#39;ll call again */</span>
		<span class="k">goto</span> <span class="n">upnout</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

	<span class="cm">/* OK. Looks safe. And nobody can get us now because we have the semaphore. Move the block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="o">-&gt;</span><span class="n">raw</span> <span class="o">==</span> <span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fn</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_metadata</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fn</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">upnout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME. Read node and do lookup? */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="n">frag_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">);</span> <span class="n">frag</span><span class="p">;</span> <span class="n">frag</span> <span class="o">=</span> <span class="n">frag_next</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span> <span class="o">==</span> <span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fn</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nrfrags</span><span class="o">++</span><span class="p">)</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nrfrags</span> <span class="o">==</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* We&#39;ve found them all */</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">raw</span><span class="p">)</span> <span class="o">==</span> <span class="n">REF_PRISTINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_pristine</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* Urgh. Return it sensibly. */</span>
				<span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">upnout</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* We found a datanode. Do the GC */</span>
		<span class="k">if</span><span class="p">((</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">&lt;</span> <span class="p">((</span><span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* It crosses a page boundary. Therefore, it must be a hole. */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_hole</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* It could still be a hole. But we GC the page this way anyway */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_dnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">upnout</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Wasn&#39;t a dnode. Try dirent */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">fd</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">dents</span><span class="p">;</span> <span class="n">fd</span><span class="p">;</span> <span class="n">fd</span><span class="o">=</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">raw</span> <span class="o">==</span> <span class="n">raw</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">&amp;&amp;</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_dirent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_garbage_collect_deletion_dirent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Raw node at 0x%08x wasn&#39;t in node lists for ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">raw</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;But it&#39;s obsolete so we don&#39;t mind too much</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">jffs2_dbg_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
 <span class="nl">upnout:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_garbage_collect_pristine</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">ic</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">union</span> <span class="n">jffs2_node_union</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">phys_ofs</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retried</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Going to GC REF_PRISTINE node at 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>

	<span class="n">alloclen</span> <span class="o">=</span> <span class="n">rawlen</span> <span class="o">=</span> <span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>

	<span class="cm">/* Ask for a small amount of space (or the totlen if smaller) because we</span>
<span class="cm">	   don&#39;t want to force wastage of the end of a block if splitting would</span>
<span class="cm">	   work. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span> <span class="o">&amp;&amp;</span> <span class="n">alloclen</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_inode</span><span class="p">)</span> <span class="o">+</span> <span class="n">JFFS2_MIN_DATA_LEN</span><span class="p">)</span>
		<span class="n">alloclen</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_inode</span><span class="p">)</span> <span class="o">+</span> <span class="n">JFFS2_MIN_DATA_LEN</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_reserve_space_gc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">alloclen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloclen</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">);</span>
	<span class="cm">/* &#39;rawlen&#39; is not the exact summary size; it is only an upper estimation */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloclen</span> <span class="o">&lt;</span> <span class="n">rawlen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Doesn&#39;t fit untouched. We&#39;ll go the old route and split it */</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">rawlen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">rawlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">retlen</span> <span class="o">!=</span> <span class="n">rawlen</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_node</span><span class="p">;</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr_crc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Header CRC failed on REF_PRISTINE node at 0x%08x: Read 0x%08x, calculated 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr_crc</span><span class="p">),</span> <span class="n">crc</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">nodetype</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">JFFS2_NODETYPE_INODE</span>:
		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">node_crc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Node CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">node_crc</span><span class="p">),</span>
				<span class="n">crc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">dsize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">csize</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">data_crc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Data CRC failed on REF_PRISTINE data node at 0x%08x: Read 0x%08x, calculated 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span>
					<span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">.</span><span class="n">data_crc</span><span class="p">),</span> <span class="n">crc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">JFFS2_NODETYPE_DIRENT</span>:
		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">node_crc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Node CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span>
				<span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">node_crc</span><span class="p">),</span> <span class="n">crc</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">strnlen</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">nsize</span><span class="p">)</span> <span class="o">!=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">nsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Name in dirent node at 0x%08x contains zeroes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">nsize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">nsize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">name_crc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">crc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Name CRC failed on REF_PRISTINE dirent node at 0x%08x: Read 0x%08x, calculated 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span>
					<span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">.</span><span class="n">name_crc</span><span class="p">),</span> <span class="n">crc</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="cm">/* If it&#39;s inode-less, we don&#39;t _know_ what it is. Just copy it intact */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Unknown node type for REF_PRISTINE node at 0x%08x: 0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">nodetype</span><span class="p">));</span>
			<span class="k">goto</span> <span class="n">bail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* OK, all the CRCs are good; this node can just be copied as-is. */</span>
 <span class="nl">retry:</span>
	<span class="n">phys_ofs</span> <span class="o">=</span> <span class="n">write_ofs</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_flash_write</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">phys_ofs</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">rawlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Write of %d bytes at 0x%08x failed. returned %d, retlen %zd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">rawlen</span><span class="p">,</span> <span class="n">phys_ofs</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">retlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jffs2_add_physical_node_ref</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">phys_ofs</span> <span class="o">|</span> <span class="n">REF_OBSOLETE</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Not marking the space at 0x%08x as dirty because the flash driver returned retlen zero</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">phys_ofs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">retried</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Try to reallocate space and retry */</span>
			<span class="kt">uint32_t</span> <span class="n">dummy</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">phys_ofs</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>

			<span class="n">retried</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Retrying failed write of REF_PRISTINE node.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

			<span class="n">jffs2_dbg_acct_sanity_check</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">jeb</span><span class="p">);</span>
			<span class="n">jffs2_dbg_acct_paranoia_check</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_reserve_space_gc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">);</span>
						<span class="cm">/* this is not the exact summary size of it,</span>
<span class="cm">							it is only an upper estimation */</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Allocated space at 0x%08x to retry failed write.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">phys_ofs</span><span class="p">);</span>

				<span class="n">jffs2_dbg_acct_sanity_check</span><span class="p">(</span><span class="n">c</span><span class="p">,</span><span class="n">jeb</span><span class="p">);</span>
				<span class="n">jffs2_dbg_acct_paranoia_check</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">);</span>

				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Failed to allocate space to retry failed write: %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_node</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jffs2_add_physical_node_ref</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">phys_ofs</span> <span class="o">|</span> <span class="n">REF_PRISTINE</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">,</span> <span class="n">ic</span><span class="p">);</span>

	<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">raw</span><span class="p">);</span>
	<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;WHEEE! GC REF_PRISTINE node at 0x%08x succeeded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>

 <span class="nl">out_node:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
 <span class="nl">bail:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADFD</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out_node</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_garbage_collect_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">new_fn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_inode</span> <span class="n">ri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">last_frag</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">jffs2_device_node</span> <span class="n">dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">mdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mdatalen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">ilen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">JFFS2_F_I_MODE</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">S_ISCHR</span><span class="p">(</span><span class="n">JFFS2_F_I_MODE</span><span class="p">(</span><span class="n">f</span><span class="p">))</span> <span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* For these, we don&#39;t actually need to read the old node */</span>
		<span class="n">mdatalen</span> <span class="o">=</span> <span class="n">jffs2_encode_dev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">,</span> <span class="n">JFFS2_F_I_RDEV</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">mdata</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): Writing %d bytes of kdev_t</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">mdatalen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">JFFS2_F_I_MODE</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">mdatalen</span> <span class="o">=</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">mdata</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mdata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;kmalloc of mdata failed in jffs2_garbage_collect_metadata()</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_read_dnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">mdata</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mdatalen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;read of old metadata failed in jffs2_garbage_collect_metadata(): %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ret</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">mdata</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;%s(): Writing %d bites of symlink target</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">__func__</span><span class="p">,</span> <span class="n">mdatalen</span><span class="p">);</span>

	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_reserve_space_gc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span> <span class="o">+</span> <span class="n">mdatalen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloclen</span><span class="p">,</span>
				<span class="n">JFFS2_SUMMARY_INODE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;jffs2_reserve_space_gc of %zd bytes for garbage_collect_metadata failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span> <span class="o">+</span> <span class="n">mdatalen</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">last_frag</span> <span class="o">=</span> <span class="n">frag_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_frag</span><span class="p">)</span>
		<span class="cm">/* Fetch the inode length from the fragtree rather then</span>
<span class="cm">		 * from i_size since i_size may have not been updated yet */</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="n">last_frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">last_frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="n">JFFS2_F_I_SIZE</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_MAGIC_BITMASK</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">nodetype</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_NODETYPE_INODE</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span> <span class="o">+</span> <span class="n">mdatalen</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">));</span>

	<span class="n">ri</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_jemode</span><span class="p">(</span><span class="n">JFFS2_F_I_MODE</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_F_I_UID</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_F_I_GID</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">isize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">ilen</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">atime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_ATIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_CTIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_MTIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">csize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">mdatalen</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">mdatalen</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">compr</span> <span class="o">=</span> <span class="n">JFFS2_COMPR_NONE</span><span class="p">;</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">node_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">data_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">mdata</span><span class="p">,</span> <span class="n">mdatalen</span><span class="p">));</span>

	<span class="n">new_fn</span> <span class="o">=</span> <span class="n">jffs2_write_dnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="n">mdata</span><span class="p">,</span> <span class="n">mdatalen</span><span class="p">,</span> <span class="n">ALLOC_GC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Error writing new dnode: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">new_fn</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">JFFS2_F_I_MODE</span><span class="p">(</span><span class="n">f</span><span class="p">)))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mdata</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_garbage_collect_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">new_fd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_dirent</span> <span class="n">rd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloclen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">rd</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_MAGIC_BITMASK</span><span class="p">);</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">nodetype</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_NODETYPE_DIRENT</span><span class="p">);</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">nsize</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span> <span class="o">+</span> <span class="n">rd</span><span class="p">.</span><span class="n">nsize</span><span class="p">);</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">));</span>

	<span class="n">rd</span><span class="p">.</span><span class="n">pino</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">);</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="cm">/* If the times on this inode were set by explicit utime() they can be different,</span>
<span class="cm">	   so refrain from splatting them. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">JFFS2_F_I_MTIME</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="o">==</span> <span class="n">JFFS2_F_I_CTIME</span><span class="p">(</span><span class="n">f</span><span class="p">))</span>
		<span class="n">rd</span><span class="p">.</span><span class="n">mctime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_MTIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">rd</span><span class="p">.</span><span class="n">mctime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">node_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>
	<span class="n">rd</span><span class="p">.</span><span class="n">name_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rd</span><span class="p">.</span><span class="n">nsize</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_reserve_space_gc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span><span class="o">+</span><span class="n">rd</span><span class="p">.</span><span class="n">nsize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">alloclen</span><span class="p">,</span>
				<span class="n">JFFS2_SUMMARY_DIRENT_SIZE</span><span class="p">(</span><span class="n">rd</span><span class="p">.</span><span class="n">nsize</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;jffs2_reserve_space_gc of %zd bytes for garbage_collect_dirent failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">rd</span><span class="p">)</span><span class="o">+</span><span class="n">rd</span><span class="p">.</span><span class="n">nsize</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new_fd</span> <span class="o">=</span> <span class="n">jffs2_write_dirent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rd</span><span class="p">,</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rd</span><span class="p">.</span><span class="n">nsize</span><span class="p">,</span> <span class="n">ALLOC_GC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_fd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;jffs2_write_dirent in garbage_collect_dirent failed: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fd</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fd</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jffs2_add_fd_to_list</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new_fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dents</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_garbage_collect_deletion_dirent</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">**</span><span class="n">fdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">dents</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* On a medium where we can&#39;t actually mark nodes obsolete</span>
<span class="cm">	   pernamently, such as NAND flash, we need to work out</span>
<span class="cm">	   whether this deletion dirent is still needed to actively</span>
<span class="cm">	   delete a &#39;real&#39; dirent with the same name that&#39;s still</span>
<span class="cm">	   somewhere else on the flash. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jffs2_can_mark_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">jffs2_raw_dirent</span> <span class="o">*</span><span class="n">rd</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="kt">uint32_t</span> <span class="n">name_crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
		<span class="kt">uint32_t</span> <span class="n">rawlen</span> <span class="o">=</span> <span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>

		<span class="n">rd</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">rawlen</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rd</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/* Prevent the erase code from nicking the obsolete node refs while</span>
<span class="cm">		   we&#39;re looking at them. I really don&#39;t like this extra lock but</span>
<span class="cm">		   can&#39;t see any alternative. Suggestions on a postcard to... */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_free_sem</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">raw</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">;</span> <span class="n">raw</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">;</span> <span class="n">raw</span> <span class="o">=</span> <span class="n">raw</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">cond_resched</span><span class="p">();</span>

			<span class="cm">/* We only care about obsolete ones */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">raw</span><span class="p">)))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Any dirent with the same name is going to have the same length... */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">raw</span><span class="p">)</span> <span class="o">!=</span> <span class="n">rawlen</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* Doesn&#39;t matter if there&#39;s one in the same erase block. We&#39;re going to</span>
<span class="cm">			   delete it too at the same time. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">SECTOR_ADDR</span><span class="p">(</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">flash_offset</span><span class="p">)</span> <span class="o">==</span> <span class="n">SECTOR_ADDR</span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">flash_offset</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Check potential deletion dirent at %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>

			<span class="cm">/* This is an obsolete node belonging to the same directory, and it&#39;s of the right</span>
<span class="cm">			   length. We need to take a closer look...*/</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">rawlen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">rd</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): Read error (%d) reading obsolete node at %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>
				<span class="cm">/* If we can&#39;t read it, we don&#39;t need to continue to obsolete it. Continue */</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">rawlen</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): Short read (%zd not %u) reading header from obsolete node at %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">__func__</span><span class="p">,</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">rawlen</span><span class="p">,</span>
					<span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">)</span> <span class="o">!=</span> <span class="n">JFFS2_NODETYPE_DIRENT</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* If the name CRC doesn&#39;t match, skip */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">name_crc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">name_crc</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* If the name length doesn&#39;t match, or it&#39;s another deletion dirent, skip */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span> <span class="o">!=</span> <span class="n">name_len</span> <span class="o">||</span> <span class="o">!</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* OK, check the actual name now */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="cm">/* OK. The name really does match. There really is still an older node on</span>
<span class="cm">			   the flash which our deletion dirent obsoletes. So we have to write out</span>
<span class="cm">			   a new deletion dirent to replace it */</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_free_sem</span><span class="p">);</span>

			<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Deletion dirent at %08x still obsoletes real dirent </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> at %08x for ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">ref_offset</span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">));</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>

			<span class="k">return</span> <span class="n">jffs2_garbage_collect_dirent</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">fd</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_free_sem</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* FIXME: If we&#39;re deleting a dirent which contains the current mtime and ctime,</span>
<span class="cm">	   we should update the metadata node with those times accordingly */</span>

	<span class="cm">/* No need for it any more. Just mark it obsolete and remove it from the list */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">fdp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">fdp</span><span class="p">)</span> <span class="o">==</span> <span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="o">*</span><span class="n">fdp</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">fdp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">fdp</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Deletion dirent </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> not found in list for ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="n">jffs2_free_full_dirent</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_garbage_collect_hole</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span>
				      <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_inode</span> <span class="n">ri</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">new_fn</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">ilen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Writing replacement hole node for ino #%u from offset 0x%x to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">));</span>

	<span class="k">if</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">readlen</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>
		<span class="cm">/* It&#39;s partially obsoleted by a later write. So we have to</span>
<span class="cm">		   write it out again with the _same_ version as before */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">readlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ri</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">readlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span> <span class="o">||</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Node read failed in jffs2_garbage_collect_hole. Ret %d, retlen %zd. Data will be lost by writing new hole node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ret</span><span class="p">,</span> <span class="n">readlen</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fill</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">nodetype</span><span class="p">)</span> <span class="o">!=</span> <span class="n">JFFS2_NODETYPE_INODE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): Node at 0x%08x had node type 0x%04x instead of JFFS2_NODETYPE_INODE(0x%04x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span>
				<span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">nodetype</span><span class="p">),</span> <span class="n">JFFS2_NODETYPE_INODE</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">totlen</span><span class="p">)</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): Node at 0x%08x had totlen 0x%x instead of expected 0x%zx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span>
				<span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">totlen</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">));</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">node_crc</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s: Node at 0x%08x had CRC 0x%08x which doesn&#39;t match calculated CRC 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span>
				<span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">node_crc</span><span class="p">),</span> <span class="n">crc</span><span class="p">);</span>
			<span class="cm">/* FIXME: We could possibly deal with this by writing new holes for each frag */</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Data in the range 0x%08x to 0x%08x of inode #%u will be lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fill</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">compr</span> <span class="o">!=</span> <span class="n">JFFS2_COMPR_ZERO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): Node 0x%08x wasn&#39;t a hole node!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">));</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Data in the range 0x%08x to 0x%08x of inode #%u will be lost</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">fill</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
	<span class="nl">fill:</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_MAGIC_BITMASK</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">nodetype</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_NODETYPE_INODE</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">));</span>

		<span class="n">ri</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">start</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">csize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">compr</span> <span class="o">=</span> <span class="n">JFFS2_COMPR_ZERO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">frag</span> <span class="o">=</span> <span class="n">frag_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="p">)</span>
		<span class="cm">/* Fetch the inode length from the fragtree rather then</span>
<span class="cm">		 * from i_size since i_size may have not been updated yet */</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ilen</span> <span class="o">=</span> <span class="n">JFFS2_F_I_SIZE</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="n">ri</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_jemode</span><span class="p">(</span><span class="n">JFFS2_F_I_MODE</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_F_I_UID</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_F_I_GID</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">isize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">ilen</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">atime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_ATIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_CTIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_MTIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">data_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">ri</span><span class="p">.</span><span class="n">node_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_reserve_space_gc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">alloclen</span><span class="p">,</span>
				     <span class="n">JFFS2_SUMMARY_INODE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;jffs2_reserve_space_gc of %zd bytes for garbage_collect_hole failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">),</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new_fn</span> <span class="o">=</span> <span class="n">jffs2_write_dnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ALLOC_GC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Error writing new hole node: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">version</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jffs2_add_full_dnode_to_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">new_fn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
			<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">);</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We should only get here in the case where the node we are</span>
<span class="cm">	 * replacing had more than one frag, so we kept the same version</span>
<span class="cm">	 * number as before. (Except in case of error -- see &#39;goto fill;&#39;</span>
<span class="cm">	 * above.)</span>
<span class="cm">	 */</span>
	<span class="n">D1</span><span class="p">(</span><span class="k">if</span><span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): Replacing fn with %d frag(s) but new ver %d != highest_version %d of ino #%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">__func__</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">version</span><span class="p">),</span>
				<span class="n">f</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">ri</span><span class="p">.</span><span class="n">ino</span><span class="p">));</span>
	<span class="p">});</span>

	<span class="cm">/* This is a partially-overlapped hole node. Mark it REF_NORMAL not REF_PRISTINE */</span>
	<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">new_fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">frag</span> <span class="o">=</span> <span class="n">jffs2_lookup_node_frag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">);</span>
	     <span class="n">frag</span><span class="p">;</span> <span class="n">frag</span> <span class="o">=</span> <span class="n">frag_next</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">==</span> <span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">new_fn</span><span class="p">;</span>
			<span class="n">new_fn</span><span class="o">-&gt;</span><span class="n">frags</span><span class="o">++</span><span class="p">;</span>
			<span class="n">fn</span><span class="o">-&gt;</span><span class="n">frags</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): Old node still has frags!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_fn</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;%s(): New node has no frags!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">fn</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_garbage_collect_dnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">orig_jeb</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span>
				       <span class="kt">uint32_t</span> <span class="n">start</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">new_fn</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_inode</span> <span class="n">ri</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">alloclen</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">orig_end</span><span class="p">,</span> <span class="n">orig_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">comprbuf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">writebuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">pg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">pg_ptr</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">));</span>

	<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Writing replacement dnode for ino #%u from offset 0x%x to 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">orig_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">orig_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_free_blocks</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_erasing_blocks</span> <span class="o">&gt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">resv_blocks_gcmerge</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Attempt to do some merging. But only expand to cover logically</span>
<span class="cm">		   adjacent frags if the block containing them is already considered</span>
<span class="cm">		   to be dirty. Otherwise we end up with GC just going round in</span>
<span class="cm">		   circles dirtying the nodes it already wrote out, especially</span>
<span class="cm">		   on NAND where we have small eraseblocks and hence a much higher</span>
<span class="cm">		   chance of nodes having to be split to cross boundaries. */</span>

		<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">min</span><span class="p">,</span> <span class="n">max</span><span class="p">;</span>

		<span class="n">min</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">max</span> <span class="o">=</span> <span class="n">min</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>

		<span class="n">frag</span> <span class="o">=</span> <span class="n">jffs2_lookup_node_frag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>

		<span class="cm">/* BUG_ON(!frag) but that&#39;ll happen anyway... */</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">!=</span> <span class="n">start</span><span class="p">);</span>

		<span class="cm">/* First grow down... */</span>
		<span class="k">while</span><span class="p">((</span><span class="n">frag</span> <span class="o">=</span> <span class="n">frag_prev</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;=</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* If the previous frag doesn&#39;t even reach the beginning, there&#39;s</span>
<span class="cm">			   excessive fragmentation. Just merge. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">min</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expanding down to cover partial frag (0x%x-0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* OK. This frag holds the first byte of the page. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">||</span> <span class="o">!</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;First frag in page is hole (0x%x-0x%x). Not expanding down.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

				<span class="cm">/* OK, it&#39;s a frag which extends to the beginning of the page. Does it live</span>
<span class="cm">				   in a block which is still considered clean? If so, don&#39;t obsolete it.</span>
<span class="cm">				   If not, cover it anyway. */</span>

				<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">;</span>

				<span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">jeb</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expanding down to cover frag (0x%x-0x%x) in gcblock at %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>
					<span class="n">start</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ISDIRTY</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Not expanding down to cover frag (0x%x-0x%x) in clean block %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						  <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expanding down to cover frag (0x%x-0x%x) in dirty block %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					  <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
				<span class="n">start</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* ... then up */</span>

		<span class="cm">/* Find last frag which is actually part of the node we&#39;re to GC. */</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">jffs2_lookup_node_frag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">,</span> <span class="n">end</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

		<span class="k">while</span><span class="p">((</span><span class="n">frag</span> <span class="o">=</span> <span class="n">frag_next</span><span class="p">(</span><span class="n">frag</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>

			<span class="cm">/* If the previous frag doesn&#39;t even reach the beginning, there&#39;s lots</span>
<span class="cm">			   of fragmentation. Just merge. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">max</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expanding up to cover partial frag (0x%x-0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">||</span> <span class="o">!</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Last frag in page is hole (0x%x-0x%x). Not expanding up.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

				<span class="cm">/* OK, it&#39;s a frag which extends to the beginning of the page. Does it live</span>
<span class="cm">				   in a block which is still considered clean? If so, don&#39;t obsolete it.</span>
<span class="cm">				   If not, cover it anyway. */</span>

				<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">raw</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">;</span>

				<span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">jeb</span> <span class="o">==</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">gcblock</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expanding up to cover frag (0x%x-0x%x) in gcblock at %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						  <span class="n">ref_offset</span><span class="p">(</span><span class="n">raw</span><span class="p">));</span>
					<span class="n">end</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ISDIRTY</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Not expanding up to cover frag (0x%x-0x%x) in clean block %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
						  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						  <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expanding up to cover frag (0x%x-0x%x) in dirty block %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
					  <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
					  <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
				<span class="n">end</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">jffs2_dbg</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="s">&quot;Expanded dnode to write from (0x%x-0x%x) to (0x%x-0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">orig_start</span><span class="p">,</span> <span class="n">orig_end</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

		<span class="n">D1</span><span class="p">(</span><span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">frag_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">orig_end</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">orig_start</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* First, use readpage() to read the appropriate page into the page cache */</span>
	<span class="cm">/* Q: What happens if we actually try to GC the _same_ page for which commit_write()</span>
<span class="cm">	 *    triggered garbage collection in the first place?</span>
<span class="cm">	 * A: I _think_ it&#39;s OK. read_cache_page shouldn&#39;t deadlock, we&#39;ll write out the</span>
<span class="cm">	 *    page OK. We&#39;ll actually write it out again in commit_write, which is a little</span>
<span class="cm">	 *    suboptimal, but at least we&#39;re correct.</span>
<span class="cm">	 */</span>
	<span class="n">pg_ptr</span> <span class="o">=</span> <span class="n">jffs2_gc_fetch_page</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pg</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">pg_ptr</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;read_cache_page() returned error: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pg_ptr</span><span class="p">));</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">pg_ptr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">orig_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">datalen</span><span class="p">;</span>
		<span class="kt">uint32_t</span> <span class="n">cdatalen</span><span class="p">;</span>
		<span class="kt">uint16_t</span> <span class="n">comprtype</span> <span class="o">=</span> <span class="n">JFFS2_COMPR_NONE</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_reserve_space_gc</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span> <span class="o">+</span> <span class="n">JFFS2_MIN_DATA_LEN</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">alloclen</span><span class="p">,</span> <span class="n">JFFS2_SUMMARY_INODE_SIZE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;jffs2_reserve_space_gc of %zd bytes for garbage_collect_dnode failed: %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span> <span class="o">+</span> <span class="n">JFFS2_MIN_DATA_LEN</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cdatalen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">alloclen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">),</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">datalen</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">writebuf</span> <span class="o">=</span> <span class="n">pg_ptr</span> <span class="o">+</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span><span class="mi">1</span><span class="p">));</span>

		<span class="n">comprtype</span> <span class="o">=</span> <span class="n">jffs2_compress</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">writebuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">comprbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">datalen</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cdatalen</span><span class="p">);</span>

		<span class="n">ri</span><span class="p">.</span><span class="n">magic</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_MAGIC_BITMASK</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">nodetype</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_NODETYPE_INODE</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">totlen</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span> <span class="o">+</span> <span class="n">cdatalen</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">hdr_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">));</span>

		<span class="n">ri</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="o">++</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_jemode</span><span class="p">(</span><span class="n">JFFS2_F_I_MODE</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_F_I_UID</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_F_I_GID</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">isize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_SIZE</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">atime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_ATIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_CTIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">JFFS2_F_I_MTIME</span><span class="p">(</span><span class="n">f</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">csize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">cdatalen</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">dsize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">datalen</span><span class="p">);</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">compr</span> <span class="o">=</span> <span class="n">comprtype</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">usercompr</span> <span class="o">=</span> <span class="p">(</span><span class="n">comprtype</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">;</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">node_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ri</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">));</span>
		<span class="n">ri</span><span class="p">.</span><span class="n">data_crc</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">comprbuf</span><span class="p">,</span> <span class="n">cdatalen</span><span class="p">));</span>

		<span class="n">new_fn</span> <span class="o">=</span> <span class="n">jffs2_write_dnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ri</span><span class="p">,</span> <span class="n">comprbuf</span><span class="p">,</span> <span class="n">cdatalen</span><span class="p">,</span> <span class="n">ALLOC_GC</span><span class="p">);</span>

		<span class="n">jffs2_free_comprbuf</span><span class="p">(</span><span class="n">comprbuf</span><span class="p">,</span> <span class="n">writebuf</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;Error writing new dnode: %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">));</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_fn</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_add_full_dnode_to_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">new_fn</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">+=</span> <span class="n">datalen</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
			<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">);</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">jffs2_gc_release_page</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">pg_ptr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
