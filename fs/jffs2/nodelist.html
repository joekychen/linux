<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jffs2 › nodelist.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>nodelist.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * JFFS2 -- Journalling Flash File System, Version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2001-2007 Red Hat, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Created by David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * For licensing information, see the file &#39;LICENCE&#39; in this directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &quot;nodelist.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">jffs2_obsolete_node_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">this</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">jffs2_add_fd_to_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">**</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">**</span><span class="n">prev</span> <span class="o">=</span> <span class="n">list</span><span class="p">;</span>

	<span class="n">dbg_dentlist</span><span class="p">(</span><span class="s">&quot;add dirent </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nhash</span> <span class="o">&lt;=</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">nhash</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">nhash</span> <span class="o">==</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">nhash</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">strcmp</span><span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Duplicate. Free one */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dbg_dentlist</span><span class="p">(</span><span class="s">&quot;Eep! Marking new dirent node obsolete, old is </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
				<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
				<span class="n">jffs2_free_full_dirent</span><span class="p">(</span><span class="n">new</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dbg_dentlist</span><span class="p">(</span><span class="s">&quot;marking old dirent </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">, ino #%u obsolete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
				<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="cm">/* It may have been a &#39;placeholder&#39; deletion dirent, </span>
<span class="cm">				   if jffs2_can_mark_obsolete() (see jffs2_do_unlink()) */</span>
				<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span>
					<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">));</span>
				<span class="n">jffs2_free_full_dirent</span><span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">);</span>
				<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">jffs2_truncate_fragtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">list</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="n">jffs2_lookup_node_frag</span><span class="p">(</span><span class="n">list</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">dbg_fragtree</span><span class="p">(</span><span class="s">&quot;truncating fragtree to 0x%08x bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="cm">/* We know frag-&gt;ofs &lt;= size. That&#39;s what lookup does for us */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag</span> <span class="o">&amp;&amp;</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">!=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">frag_next</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">frag</span> <span class="o">&amp;&amp;</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">frag_next</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>

		<span class="n">frag_erase</span><span class="p">(</span><span class="n">frag</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">jffs2_obsolete_node_frag</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">frag</span><span class="p">);</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">frag</span> <span class="o">=</span> <span class="n">frag_last</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

	<span class="cm">/* Sanity check for truncation to longer than we started with... */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="cm">/* If the last fragment starts at the RAM page boundary, it is</span>
<span class="cm">	 * REF_PRISTINE irrespective of its size. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;marking the last fragment 0x%08x-0x%08x REF_PRISTINE.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">=</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span> <span class="o">|</span> <span class="n">REF_PRISTINE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jffs2_obsolete_node_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">this</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">frags</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The node has no valid frags left. It&#39;s totally obsoleted */</span>
			<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;marking old node @0x%08x (0x%04x-0x%04x) obsolete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
			<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;marking old node @0x%08x (0x%04x-0x%04x) REF_NORMAL. frags is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">);</span>
			<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="n">jffs2_free_node_frag</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jffs2_fragtree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">newfrag</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">base</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="p">;</span>

	<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;insert frag (0x%04x-0x%04x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
		<span class="n">base</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_node_frag</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span>
			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="n">base</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span>
			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;duplicate frag at %08x (%p,%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">newfrag</span><span class="p">,</span> <span class="n">base</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">base</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Allocate and initializes a new fragment.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span> <span class="nf">new_fragment</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">newfrag</span><span class="p">;</span>

	<span class="n">newfrag</span> <span class="o">=</span> <span class="n">jffs2_alloc_node_frag</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">newfrag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>
		<span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">=</span> <span class="n">fn</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;cannot allocate a jffs2_node_frag object</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">newfrag</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called when there is no overlapping fragment exist. Inserts a hole before the new</span>
<span class="cm"> * fragment and inserts the new fragment to the fragtree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">no_overlapping_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		 	       <span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">newfrag</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">lastend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastend</span> <span class="o">&lt;</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* put a hole in before the new fragment */</span>
		<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">holefrag</span><span class="p">;</span>

		<span class="n">holefrag</span><span class="o">=</span> <span class="n">new_fragment</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">lastend</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">-</span> <span class="n">lastend</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">holefrag</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">jffs2_free_node_frag</span><span class="p">(</span><span class="n">newfrag</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* By definition, the &#39;this&#39; node has no right-hand child,</span>
<span class="cm">			   because there are no frags with offset greater than it.</span>
<span class="cm">			   So that&#39;s where we want to put the hole */</span>
			<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;add hole frag %#04x-%#04x on the right of the new frag.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;Add hole frag %#04x-%#04x to the root of the tree.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">holefrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">holefrag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* By definition, the &#39;this&#39; node has no right-hand child,</span>
<span class="cm">		   because there are no frags with offset greater than it.</span>
<span class="cm">		   So that&#39;s where we want to put new fragment */</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;add the new node at the right</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;insert the new node at the root of the tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Doesn&#39;t set inode-&gt;i_size */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_add_frag_to_fragtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">newfrag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">lastend</span><span class="p">;</span>

	<span class="cm">/* Skip all the nodes which are completed before this one starts */</span>
	<span class="n">this</span> <span class="o">=</span> <span class="n">jffs2_lookup_node_frag</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;lookup gave frag 0x%04x-0x%04x; phys 0x%08x (*%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">?</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">))</span><span class="o">:</span><span class="mh">0xffffffff</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
		<span class="n">lastend</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;lookup gave no frag</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">lastend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* See if we ran off the end of the fragtree */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastend</span> <span class="o">&lt;=</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We did */</span>

		<span class="cm">/* Check if &#39;this&#39; node was on the same page as the new node.</span>
<span class="cm">		   If so, both &#39;this&#39; and the new node get marked REF_NORMAL so</span>
<span class="cm">		   the GC can take a look.</span>
<span class="cm">		*/</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">lastend</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">lastend</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span> <span class="o">==</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
				<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
			<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="n">no_overlapping_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">newfrag</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">lastend</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;dealing with frag %u-%u, phys %#08x(%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
		<span class="n">ref_offset</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span> <span class="n">ref_flags</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">));</span>
	<span class="k">else</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;dealing with hole frag %u-%u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

	<span class="cm">/* OK. &#39;this&#39; is pointing at the first frag that newfrag-&gt;ofs at least partially obsoletes,</span>
<span class="cm">	 * - i.e. newfrag-&gt;ofs &lt; this-&gt;ofs+this-&gt;size &amp;&amp; newfrag-&gt;ofs &gt;= this-&gt;ofs</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* This node isn&#39;t completely obsoleted. The start of it remains valid */</span>

		<span class="cm">/* Mark the new node and the partially covered node REF_NORMAL -- let</span>
<span class="cm">		   the GC take a look at them */</span>
		<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
			<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* The new node splits &#39;this&#39; frag into two */</span>
			<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">newfrag2</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
				<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;split old frag 0x%04x-0x%04x, phys 0x%08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">));</span>
			<span class="k">else</span>
				<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;split old hole frag 0x%04x-0x%04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

			<span class="cm">/* New second frag pointing to this&#39;s node */</span>
			<span class="n">newfrag2</span> <span class="o">=</span> <span class="n">new_fragment</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span>
						<span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">-</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">newfrag2</span><span class="p">))</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">frags</span><span class="o">++</span><span class="p">;</span>

			<span class="cm">/* Adjust size of original &#39;this&#39; */</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">-</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">;</span>

			<span class="cm">/* Now, we know there&#39;s no node with offset</span>
<span class="cm">			   greater than this-&gt;ofs but smaller than</span>
<span class="cm">			   newfrag2-&gt;ofs or newfrag-&gt;ofs, for obvious</span>
<span class="cm">			   reasons. So we can do a tree insert from</span>
<span class="cm">			   &#39;this&#39; to insert newfrag, and a tree insert</span>
<span class="cm">			   from newfrag to insert newfrag2. */</span>
			<span class="n">jffs2_fragtree_insert</span><span class="p">(</span><span class="n">newfrag</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
			<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

			<span class="n">jffs2_fragtree_insert</span><span class="p">(</span><span class="n">newfrag2</span><span class="p">,</span> <span class="n">newfrag</span><span class="p">);</span>
			<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfrag2</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* New node just reduces &#39;this&#39; frag in size, doesn&#39;t split it */</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">-</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">;</span>

		<span class="cm">/* Again, we know it lives down here in the tree */</span>
		<span class="n">jffs2_fragtree_insert</span><span class="p">(</span><span class="n">newfrag</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
		<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* New frag starts at the same point as &#39;this&#39; used to. Replace</span>
<span class="cm">		   it in the tree without doing a delete and insertion */</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;inserting newfrag (*%p),%d-%d in before &#39;this&#39; (*%p),%d-%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">newfrag</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

		<span class="n">rb_replace_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;obsoleting node frag %p (%x-%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
			<span class="n">jffs2_obsolete_node_frag</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+=</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
			<span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

			<span class="n">jffs2_fragtree_insert</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="n">newfrag</span><span class="p">);</span>
			<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* OK, now we have newfrag added in the correct place in the tree, but</span>
<span class="cm">	   frag_next(newfrag) may be a fragment which is overlapped by it</span>
<span class="cm">	*/</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">this</span> <span class="o">=</span> <span class="n">frag_next</span><span class="p">(</span><span class="n">newfrag</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* &#39;this&#39; frag is obsoleted completely. */</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;obsoleting node frag %p (%x-%x) and removing from tree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">jffs2_obsolete_node_frag</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* Now we&#39;re pointing at the first frag which isn&#39;t totally obsoleted by</span>
<span class="cm">	   the new frag */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span> <span class="o">||</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Still some overlap but we don&#39;t need to move it in the tree */</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="n">this</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">=</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="cm">/* And mark them REF_NORMAL so the GC takes a look at them */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
		<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given an inode, probably with existing tree of fragments, add the new node</span>
<span class="cm"> * to the fragment tree.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">jffs2_add_full_dnode_to_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_full_dnode</span> <span class="o">*</span><span class="n">fn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">newfrag</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">newfrag</span> <span class="o">=</span> <span class="n">new_fragment</span><span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">newfrag</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">frags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">dbg_fragtree</span><span class="p">(</span><span class="s">&quot;adding node %#04x-%#04x @0x%08x on flash, newfrag *%p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">),</span> <span class="n">newfrag</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_add_frag_to_fragtree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">,</span> <span class="n">newfrag</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* If we now share a page with other nodes, mark either previous</span>
<span class="cm">	   or next node REF_NORMAL, as appropriate.  */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">frag_prev</span><span class="p">(</span><span class="n">newfrag</span><span class="p">);</span>

		<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
		<span class="cm">/* If we don&#39;t start at zero there&#39;s _always_ a previous */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
			<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">newfrag</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">frag_next</span><span class="p">(</span><span class="n">newfrag</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
				<span class="n">mark_ref_normal</span><span class="p">(</span><span class="n">next</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">jffs2_dbg_fragtree_paranoia_check_nolock</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jffs2_set_inocache_state</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">ic</span><span class="p">,</span> <span class="kt">int</span> <span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
	<span class="n">ic</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_wq</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* During mount, this needs no locking. During normal operation, its</span>
<span class="cm">   callers want to do other stuff while still holding the inocache_lock.</span>
<span class="cm">   Rather than introducing special case get_ino_cache functions or</span>
<span class="cm">   callbacks, we just let the caller do the locking itself. */</span>

<span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="nf">jffs2_get_ino_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_list</span><span class="p">[</span><span class="n">ino</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_hashsize</span><span class="p">];</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">!=</span> <span class="n">ino</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jffs2_add_ino_cache</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">**</span><span class="n">prev</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span>
		<span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="o">++</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">highest_ino</span><span class="p">;</span>

	<span class="n">dbg_inocache</span><span class="p">(</span><span class="s">&quot;add %p (ino #%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_list</span><span class="p">[</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_hashsize</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">new</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">new</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jffs2_del_ino_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">old</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">**</span><span class="n">prev</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_JFFS2_FS_XATTR</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">xref</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">dbg_inocache</span><span class="p">(</span><span class="s">&quot;del %p (ino #%u)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_list</span><span class="p">[</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_hashsize</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">prev</span><span class="p">)</span> <span class="o">==</span> <span class="n">old</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Free it now unless it&#39;s in READING or CLEARING state, which</span>
<span class="cm">	   are the transitions upon read_inode() and clear_inode(). The</span>
<span class="cm">	   rest of the time we know nobody else is looking at it, and</span>
<span class="cm">	   if it&#39;s held by read_inode() or clear_inode() they&#39;ll free it</span>
<span class="cm">	   for themselves. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">INO_STATE_READING</span> <span class="o">&amp;&amp;</span> <span class="n">old</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">INO_STATE_CLEARING</span><span class="p">)</span>
		<span class="n">jffs2_free_inode_cache</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jffs2_free_ino_caches</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_hashsize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_list</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">jffs2_xattr_free_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
			<span class="n">jffs2_free_inode_cache</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_list</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jffs2_free_raw_node_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">nr_blocks</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first_node</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">[</span><span class="n">REFS_PER_BLOCK</span><span class="p">].</span><span class="n">flash_offset</span> <span class="o">==</span> <span class="n">REF_LINK_NODE</span><span class="p">)</span>
				<span class="n">next</span> <span class="o">=</span> <span class="n">this</span><span class="p">[</span><span class="n">REFS_PER_BLOCK</span><span class="p">].</span><span class="n">next_in_ino</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

			<span class="n">jffs2_free_refblock</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first_node</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">last_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="nf">jffs2_lookup_node_frag</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">fragtree</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* The common case in lookup is that there will be a node</span>
<span class="cm">	   which precisely matches. So we go looking for that first */</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">frag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;root %p, offset %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fragtree</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">fragtree</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_node_frag</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Remember the closest smaller match on the way down */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev</span> <span class="o">||</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span>
				<span class="n">prev</span> <span class="o">=</span> <span class="n">frag</span><span class="p">;</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">frag</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Exact match not found. Go back up looking at each parent,</span>
<span class="cm">	   and return the closest smaller one */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;no match. Returning frag %#04x-%#04x, closest previous</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">prev</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">dbg_fragtree2</span><span class="p">(</span><span class="s">&quot;returning NULL, empty fragtree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">prev</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Pass &#39;c&#39; argument to indicate that nodes should be marked obsolete as</span>
<span class="cm">   they&#39;re killed. */</span>
<span class="kt">void</span> <span class="nf">jffs2_kill_fragtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">frag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_node_frag</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">dbg_fragtree</span><span class="p">(</span><span class="s">&quot;killing</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="n">frag</span> <span class="o">=</span> <span class="p">(</span><span class="n">rb_entry</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_node_frag</span><span class="p">,</span> <span class="n">rb</span><span class="p">));</span>
	<span class="k">while</span><span class="p">(</span><span class="n">frag</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_left</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frag</span> <span class="o">=</span> <span class="n">frag_left</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">frag</span> <span class="o">=</span> <span class="n">frag_right</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="o">--</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">frags</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* Not a hole, and it&#39;s the final remaining frag</span>
<span class="cm">			   of this node. Free the node */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">c</span><span class="p">)</span>
				<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>

			<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">frag</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">frag_parent</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">frag_left</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="o">==</span> <span class="n">frag</span><span class="p">)</span>
				<span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">jffs2_free_node_frag</span><span class="p">(</span><span class="n">frag</span><span class="p">);</span>
		<span class="n">frag</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="nf">jffs2_link_node_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
					       <span class="kt">uint32_t</span> <span class="n">ofs</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">len</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">ic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">allocated_refs</span><span class="p">);</span>
	<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">allocated_refs</span><span class="o">--</span><span class="p">;</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">;</span>

	<span class="n">dbg_noderef</span><span class="p">(</span><span class="s">&quot;Last node at %p is (%08x,%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span><span class="p">,</span>
		    <span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">!=</span> <span class="n">REF_EMPTY_NODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">==</span> <span class="n">REF_LINK_NODE</span><span class="p">)</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ref</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_noderef</span><span class="p">(</span><span class="s">&quot;New ref is %p (%08x becomes %08x,%p) len 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> 
		    <span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">=</span> <span class="n">ofs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">first_node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">first_node</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">-</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">last_len</span> <span class="o">=</span> <span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">);</span>

		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Adding new ref %p at (0x%08x-0x%08x) not immediately after previous (0x%08x-0x%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">ref</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
			    <span class="n">ref_offset</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">),</span> 
			    <span class="n">ref_offset</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">)</span><span class="o">+</span><span class="n">last_len</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ic</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span> <span class="o">=</span> <span class="n">ic</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">;</span>
		<span class="n">ic</span><span class="o">-&gt;</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">REF_UNCHECKED</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REF_NORMAL</span>:
	<span class="k">case</span> <span class="n">REF_PRISTINE</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">REF_OBSOLETE</span>:
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

<span class="cp">#ifdef TEST_TOTLEN</span>
	<span class="cm">/* Set (and test) __totlen field... for now */</span>
	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">__totlen</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">ref</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* No locking, no reservation of &#39;ref&#39;. Do not use on a live file system */</span>
<span class="kt">int</span> <span class="nf">jffs2_scan_dirty_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
			   <span class="kt">uint32_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Dirty space 0x%x larger then free_size 0x%x (wasted 0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">size</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="cm">/* REF_EMPTY_NODE is !obsolete, so that works OK */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span> <span class="o">&amp;&amp;</span> <span class="n">ref_obsolete</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef TEST_TOTLEN</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="o">-&gt;</span><span class="n">__totlen</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">uint32_t</span> <span class="n">ofs</span> <span class="o">=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">-</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">;</span>
		<span class="n">ofs</span> <span class="o">|=</span> <span class="n">REF_OBSOLETE</span><span class="p">;</span>

		<span class="n">jffs2_link_node_ref</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Calculate totlen from surrounding nodes or eraseblock */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">uint32_t</span> <span class="nf">__ref_totlen</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">ref_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">next_ref</span> <span class="o">=</span> <span class="n">ref_next</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next_ref</span><span class="p">)</span>
		<span class="n">ref_end</span> <span class="o">=</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">next_ref</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jeb</span><span class="p">)</span>
			<span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>

		<span class="cm">/* Last node in block. Use free_space */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ref</span> <span class="o">!=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;ref %p @0x%08x is not jeb-&gt;last_node (%p @0x%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">,</span>
				<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span> <span class="o">?</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
		<span class="n">ref_end</span> <span class="o">=</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">-</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ref_end</span> <span class="o">-</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint32_t</span> <span class="nf">__jffs2_ref_totlen</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

<span class="cp">#ifdef TEST_TOTLEN</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">__totlen</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">jeb</span><span class="p">)</span>
			<span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>

		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;Totlen for ref at %p (0x%08x-0x%08x) miscalculated as 0x%x instead of %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ref</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">+</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">__totlen</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">__totlen</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref_next</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;next %p (0x%08x-0x%08x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">ref_next</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref_next</span><span class="p">(</span><span class="n">ref</span><span class="p">)),</span>
				<span class="n">ref_offset</span><span class="p">(</span><span class="n">ref_next</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span> <span class="o">+</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">__totlen</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> 
			<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;No next ref. jeb-&gt;last_node is %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">last_node</span><span class="p">);</span>

		<span class="n">pr_crit</span><span class="p">(</span><span class="s">&quot;jeb-&gt;wasted_size %x, dirty_size %x, used_size %x, free_size %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">wasted_size</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">dirty_size</span><span class="p">,</span> <span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span><span class="p">,</span>
			<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">free_size</span><span class="p">);</span>

<span class="cp">#if defined(JFFS2_DBG_DUMPS) || defined(JFFS2_DBG_PARANOIA_CHECKS)</span>
		<span class="n">__jffs2_dbg_dump_node_refs_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">);</span>
<span class="cp">#endif</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">__totlen</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif </span><span class="cm">/* TEST_TOTLEN */</span><span class="cp"></span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
