<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › jffs2 › readinode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>readinode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * JFFS2 -- Journalling Flash File System, Version 2.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright © 2001-2007 Red Hat, Inc.</span>
<span class="cm"> *</span>
<span class="cm"> * Created by David Woodhouse &lt;dwmw2@infradead.org&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * For licensing information, see the file &#39;LICENCE&#39; in this directory.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#define pr_fmt(fmt) KBUILD_MODNAME &quot;: &quot; fmt</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/mtd/mtd.h&gt;</span>
<span class="cp">#include &lt;linux/compiler.h&gt;</span>
<span class="cp">#include &quot;nodelist.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * Check the data CRC of the node.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 if the data CRC is correct;</span>
<span class="cm"> * 	    1 - if incorrect;</span>
<span class="cm"> *	    error code if an error occurred.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_node_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pointed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">csize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* Calculate how many bytes were already checked */</span>
	<span class="n">ofs</span> <span class="o">=</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_inode</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jffs2_is_writebuffered</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">adj</span> <span class="o">=</span> <span class="n">ofs</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">wbuf_pagesize</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">adj</span><span class="p">))</span>
			<span class="n">adj</span> <span class="o">=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">wbuf_pagesize</span> <span class="o">-</span> <span class="n">adj</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">adj</span> <span class="o">&gt;=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;no need to check node at %#08x, data length %u, data starts at %#08x - it has already been checked.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">,</span> <span class="n">ofs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">adj_acc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ofs</span> <span class="o">+=</span> <span class="n">adj</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">adj</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;check node at %#08x, data length %u, partial CRC %#08x, correct CRC %#08x, data starts at %#08x, start checking from %#08x - %u bytes.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		<span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">partial_crc</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">,</span> <span class="n">ofs</span> <span class="o">-</span> <span class="n">len</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

<span class="cp">#ifndef __ECOS</span>
	<span class="cm">/* TODO: instead, incapsulate point() stuff to jffs2_flash_read(),</span>
<span class="cm">	 * adding and jffs2_flash_read_end() interface. */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">mtd_point</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">**</span><span class="p">)</span><span class="o">&amp;</span><span class="n">buffer</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">retlen</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_WARNING</span><span class="p">(</span><span class="s">&quot;MTD point returned len too short: %zu instead of %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">);</span>
		<span class="n">mtd_unpoint</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">retlen</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
			<span class="n">JFFS2_WARNING</span><span class="p">(</span><span class="s">&quot;MTD point failed: error code %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">pointed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* succefully pointed to device */</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pointed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">buffer</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

		<span class="cm">/* TODO: this is very frequent pattern, make it a separate</span>
<span class="cm">		 * routine */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buffer</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;can not read %d bytes from 0x%08x, error code: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;short read at %#08x: %zd instead of %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Continue calculating CRC */</span>
	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">partial_crc</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pointed</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="cp">#ifndef __ECOS</span>
	<span class="k">else</span>
		<span class="n">mtd_unpoint</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">,</span> <span class="n">crc</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">adj_acc:</span>
	<span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
	<span class="cm">/* If it should be REF_NORMAL, it&#39;ll get marked as such when</span>
<span class="cm">	   we build the fragtree, shortly. No need to worry about GC</span>
<span class="cm">	   moving it while it&#39;s marked REF_PRISTINE -- GC won&#39;t happen</span>
<span class="cm">	   till we&#39;ve finished checking every inode anyway. */</span>
	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">|=</span> <span class="n">REF_PRISTINE</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * Mark the node as having been checked and fix the</span>
<span class="cm">	 * accounting accordingly.</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
	<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">c</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">jffs2_dbg_acct_paranoia_check_nolock</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_out:</span>
	<span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">pointed</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
<span class="cp">#ifndef __ECOS</span>
	<span class="k">else</span>
		<span class="n">mtd_unpoint</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">mtd</span><span class="p">,</span> <span class="n">ofs</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for jffs2_add_older_frag_to_fragtree().</span>
<span class="cm"> *</span>
<span class="cm"> * Checks the node if we are in the checking stage.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_tn_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">));</span>

	<span class="cm">/* We only check the data CRC of unchecked nodes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">)</span> <span class="o">!=</span> <span class="n">REF_UNCHECKED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;check node %#04x-%#04x, phys offs %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_node_data</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;check_node_data() returned error: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;CRC error, mark it obsolete.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="nf">jffs2_lookup_tn</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">tn_root</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;root %p, offset %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tn_root</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">tn_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;=</span> <span class="n">offset</span><span class="p">)</span>
			<span class="n">next</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">tn</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">jffs2_kill_tn</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
	<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">);</span>
	<span class="n">jffs2_free_tmp_dnode_info</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * This function is used when we read an inode. Data nodes arrive in</span>
<span class="cm"> * arbitrary order -- they may be older or newer than the nodes which</span>
<span class="cm"> * are already in the tree. Where overlaps occur, the older node can</span>
<span class="cm"> * be discarded as long as the newer passes the CRC check. We don&#39;t</span>
<span class="cm"> * bother to keep track of holes in this rbtree, and neither do we deal</span>
<span class="cm"> * with frags -- we can have multiple entries starting at the same</span>
<span class="cm"> * offset, and the one with the smallest length will come first in the</span>
<span class="cm"> * ordering.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 if the node was handled (including marking it obsolete)</span>
<span class="cm"> *	 &lt; 0 an if error occurred</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_add_tn_to_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">jffs2_readinode_info</span> <span class="o">*</span><span class="n">rii</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">fn_end</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">this</span><span class="p">,</span> <span class="o">*</span><span class="n">ptn</span><span class="p">;</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;insert fragment %#04x-%#04x, ver %u at %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">fn_end</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">));</span>

	<span class="cm">/* If a node has zero dsize, we only have to keep if it if it might be the</span>
<span class="cm">	   node with highest version -- i.e. the one which will end up as f-&gt;metadata.</span>
<span class="cm">	   Note that such nodes won&#39;t be REF_UNCHECKED since there are no data to</span>
<span class="cm">	   check anyway. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* We had a candidate mdata node already */</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;kill old mdata with ver %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
				<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;kill new mdata with ver %d (older than existing %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					      <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
				<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span> <span class="o">=</span> <span class="n">tn</span><span class="p">;</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;keep new mdata with ver %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Find the earliest node which _may_ be relevant to this one */</span>
	<span class="n">this</span> <span class="o">=</span> <span class="n">jffs2_lookup_tn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* If the node is coincident with another at a lower address,</span>
<span class="cm">		   back up until the other node is found. It may be relevant */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">overlapped</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptn</span> <span class="o">=</span> <span class="n">tn_prev</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptn</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We killed a node which set the overlapped</span>
<span class="cm">				 * flags during the scan. Fix it up.</span>
<span class="cm">				 */</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">overlapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">ptn</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;&#39;this&#39; found %#04x-%#04x (%s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">?</span> <span class="s">&quot;data&quot;</span> <span class="o">:</span> <span class="s">&quot;hole&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">fn_end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Ponder this ver %d, 0x%x-0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">==</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Version number collision means REF_PRISTINE GC. Accept either of them</span>
<span class="cm">			   as long as the CRC is correct. Check the one we have already...  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_tn_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/* The one we already had was OK. Keep it and throw away the new one */</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Like old node. Throw away new</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Who cares if the new one is good; keep it for now anyway. */</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Like new node. Throw away old</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">rb_replace_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
				<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
				<span class="cm">/* Same overlapping from in front and behind */</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&amp;&amp;</span>
		    <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&amp;&amp;</span>
		    <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">fn_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* New node entirely overlaps &#39;this&#39; */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">check_tn_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;new node bad CRC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* ... and is good. Kill &#39;this&#39; and any subsequent nodes which are also overlapped */</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">this</span> <span class="o">&amp;&amp;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">fn_end</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">tn_next</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&lt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">tn_erase</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
					<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Kill overlapped ver %d, 0x%x-0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
						      <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
						      <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
					<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">this</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Done killing overlapped nodes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&amp;&amp;</span>
		    <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&lt;=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&amp;&amp;</span>
		    <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">fn_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* New node entirely overlapped by &#39;this&#39; */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_tn_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Good CRC on old node. Kill new</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* ... but &#39;this&#39; was bad. Replace it... */</span>
			<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Bad CRC on old overlapping node. Kill it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">tn_erase</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
			<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">this</span> <span class="o">=</span> <span class="n">tn_next</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* We neither completely obsoleted nor were completely</span>
<span class="cm">	   obsoleted by an earlier node. Insert into the tree */</span>
	<span class="p">{</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">insert_point</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
			<span class="n">insert_point</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&gt;</span> <span class="n">insert_point</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span>
				<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">insert_point</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="n">insert_point</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">||</span>
				 <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">insert_point</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
				<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">insert_point</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_left</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">insert_point</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">.</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">insert_point</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
		<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* If there&#39;s anything behind that overlaps us, note it */</span>
	<span class="n">this</span> <span class="o">=</span> <span class="n">tn_prev</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">+</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Node is overlapped by %p (v %d, 0x%x-0x%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					      <span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
					      <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
				<span class="n">tn</span><span class="o">-&gt;</span><span class="n">overlapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">overlapped</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ptn</span> <span class="o">=</span> <span class="n">tn_prev</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ptn</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We killed a node which set the overlapped</span>
<span class="cm">				 * flags during the scan. Fix it up.</span>
<span class="cm">				 */</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">overlapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">ptn</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* If the new node overlaps anything ahead, note it */</span>
	<span class="n">this</span> <span class="o">=</span> <span class="n">tn_next</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">this</span> <span class="o">&amp;&amp;</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">&lt;</span> <span class="n">fn_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">this</span><span class="o">-&gt;</span><span class="n">overlapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Node ver %d, 0x%x-0x%x is overlapped</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			      <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
			      <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">tn_next</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Trivial function to remove the last node in the tree. Which by definition</span>
<span class="cm">   has no right-hand -- so can be removed just by making its only child (if</span>
<span class="cm">   any) take its place under its parent. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">eat_last</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">link</span><span class="p">;</span>

	<span class="cm">/* LAST! */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">==</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
		<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>

	<span class="o">*</span><span class="n">link</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
	<span class="cm">/* Colour doesn&#39;t matter now. Only the parent pointer. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="o">-&gt;</span><span class="n">rb_parent_color</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_parent_color</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* We put this in reverse order, so we can just use eat_last */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ver_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">ver_root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ver_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">this_tn</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">link</span><span class="p">;</span>
		<span class="n">this_tn</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;</span> <span class="n">this_tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">)</span>
			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">link</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Link new node at %p (root is %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">link</span><span class="p">,</span> <span class="n">ver_root</span><span class="p">);</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">link</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">,</span> <span class="n">ver_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Build final, normal fragtree from tn tree. It doesn&#39;t matter which order</span>
<span class="cm">   we add nodes to the real fragtree, as long as they don&#39;t overlap. And</span>
<span class="cm">   having thrown away the majority of overlapped nodes as we went, there</span>
<span class="cm">   really shouldn&#39;t be many sets of nodes which do overlap. If we start at</span>
<span class="cm">   the end, we can use the overlap markers -- we can just eat nodes which</span>
<span class="cm">   aren&#39;t overlapped, and when we encounter nodes which _do_ overlap we</span>
<span class="cm">   sort them all into a temporary tree in version order before replaying them. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_build_inode_fragtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">jffs2_readinode_info</span> <span class="o">*</span><span class="n">rii</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">pen</span><span class="p">,</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="n">ver_root</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">high_ver</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;potential mdata is ver %d at %p</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="p">);</span>
		<span class="n">high_ver</span> <span class="o">=</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">;</span>
		<span class="n">rii</span><span class="o">-&gt;</span><span class="n">latest_ref</span> <span class="o">=</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef JFFS2_DBG_READINODE_MESSAGES</span>
	<span class="n">this</span> <span class="o">=</span> <span class="n">tn_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;tn %p ver %d range 0x%x-0x%x ov %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
			      <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">overlapped</span><span class="p">);</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">tn_prev</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">pen</span> <span class="o">=</span> <span class="n">tn_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">last</span> <span class="o">=</span> <span class="n">pen</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">pen</span> <span class="o">=</span> <span class="n">tn_prev</span><span class="p">(</span><span class="n">last</span><span class="p">);</span>

		<span class="n">eat_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
		<span class="n">ver_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ver_root</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">last</span><span class="o">-&gt;</span><span class="n">overlapped</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pen</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * We killed a node which set the overlapped</span>
<span class="cm">			 * flags during the scan. Fix it up.</span>
<span class="cm">			 */</span>
			<span class="n">last</span><span class="o">-&gt;</span><span class="n">overlapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Now we have a bunch of nodes in reverse version</span>
<span class="cm">		   order, in the tree at ver_root. Most of the time,</span>
<span class="cm">		   there&#39;ll actually be only one node in the &#39;tree&#39;,</span>
<span class="cm">		   in fact. */</span>
		<span class="n">this</span> <span class="o">=</span> <span class="n">tn_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ver_root</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">vers_next</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
			<span class="n">vers_next</span> <span class="o">=</span> <span class="n">tn_prev</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="n">eat_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ver_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">check_tn_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;node ver %d, 0x%x-0x%x failed CRC</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
					     <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">);</span>
				<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;</span> <span class="n">high_ver</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Note that this is different from the other</span>
<span class="cm">					   highest_version, because this one is only</span>
<span class="cm">					   counting _valid_ nodes which could give the</span>
<span class="cm">					   latest inode metadata */</span>
					<span class="n">high_ver</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">;</span>
					<span class="n">rii</span><span class="o">-&gt;</span><span class="n">latest_ref</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Add %p (v %d, 0x%x-0x%x, ov %d) to fragtree</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					     <span class="n">this</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
					     <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">overlapped</span><span class="p">);</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_add_full_dnode_to_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* Free the nodes in vers_root; let the caller</span>
<span class="cm">					   deal with the rest */</span>
					<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Add node to tree failed %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
					<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">vers_next</span> <span class="o">=</span> <span class="n">tn_prev</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
						<span class="k">if</span> <span class="p">(</span><span class="n">check_tn_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="p">))</span>
							<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
						<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">);</span>
						<span class="n">jffs2_free_tmp_dnode_info</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
						<span class="n">this</span> <span class="o">=</span> <span class="n">vers_next</span><span class="p">;</span>
						<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="p">)</span>
							<span class="k">break</span><span class="p">;</span>
						<span class="n">eat_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ver_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vers_next</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">jffs2_free_tmp_dnode_info</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">vers_next</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jffs2_free_tmp_dnode_info_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">this</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span><span class="p">;</span>

	<span class="n">this</span> <span class="o">=</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="cm">/* Now at bottom of tree */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">this</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">)</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">)</span>
			<span class="n">this</span> <span class="o">=</span> <span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">tn</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">this</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span><span class="p">,</span> <span class="n">rb</span><span class="p">);</span>
			<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">);</span>
			<span class="n">jffs2_free_tmp_dnode_info</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>

			<span class="n">this</span> <span class="o">=</span> <span class="n">rb_parent</span><span class="p">(</span><span class="n">this</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">this</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">rb</span><span class="p">)</span>
				<span class="n">this</span><span class="o">-&gt;</span><span class="n">rb_right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">else</span> <span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">list</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">jffs2_free_full_dirent_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">fd</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">jffs2_free_full_dirent</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="n">fd</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/* Returns first valid node after &#39;ref&#39;. May return &#39;ref&#39; */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="nf">jffs2_first_valid_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">ref</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">ref</span><span class="p">;</span>
		<span class="n">dbg_noderef</span><span class="p">(</span><span class="s">&quot;node at 0x%08x is obsoleted. Ignoring.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for jffs2_get_inode_nodes().</span>
<span class="cm"> * It is called every time an directory entry node is found.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success;</span>
<span class="cm"> * 	    negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">read_direntry</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">jffs2_raw_dirent</span> <span class="o">*</span><span class="n">rd</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">read</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">jffs2_readinode_info</span> <span class="o">*</span><span class="n">rii</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="cm">/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">node_crc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;header CRC failed on dirent node at %#08x: read %#08x, calculated %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">node_crc</span><span class="p">),</span> <span class="n">crc</span><span class="p">);</span>
		<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* If we&#39;ve never checked the CRCs on this node, check them now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">==</span> <span class="n">REF_UNCHECKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>

		<span class="cm">/* Sanity check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">PAD</span><span class="p">((</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">)))</span> <span class="o">!=</span> <span class="n">PAD</span><span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;illegal nsize in node at %#08x: nsize %#02x, totlen %#04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				    <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">));</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">c</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">=</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">|</span> <span class="n">dirent_node_state</span><span class="p">(</span><span class="n">rd</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">fd</span> <span class="o">=</span> <span class="n">jffs2_alloc_full_dirent</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">fd</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fd</span><span class="o">-&gt;</span><span class="n">raw</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
	<span class="n">fd</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
	<span class="n">fd</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="n">fd</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">)</span>
		<span class="n">rii</span><span class="o">-&gt;</span><span class="n">highest_version</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">;</span>

	<span class="cm">/* Pick out the mctime of the latest dirent */</span>
	<span class="k">if</span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mctime_ver</span> <span class="o">&amp;&amp;</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">mctime</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rii</span><span class="o">-&gt;</span><span class="n">mctime_ver</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">;</span>
		<span class="n">rii</span><span class="o">-&gt;</span><span class="n">latest_mctime</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">mctime</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Copy as much of the name as possible from the raw</span>
<span class="cm">	 * dirent we&#39;ve already read from the flash.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">read</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">))</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
		       <span class="n">min_t</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span><span class="p">,</span> <span class="p">(</span><span class="n">read</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">))</span> <span class="p">));</span>

	<span class="cm">/* Do we need to copy any more of the name directly from the flash? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">read</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* FIXME: point() */</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">already</span> <span class="o">=</span> <span class="n">read</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="p">(</span><span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span> <span class="o">+</span> <span class="n">read</span><span class="p">,</span>
				<span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span> <span class="o">-</span> <span class="n">already</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">already</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">read</span> <span class="o">!=</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span> <span class="o">-</span> <span class="n">already</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;read remainder of name: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
			<span class="n">jffs2_free_full_dirent</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">fd</span><span class="o">-&gt;</span><span class="n">nhash</span> <span class="o">=</span> <span class="n">full_name_hash</span><span class="p">(</span><span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span><span class="p">);</span>
	<span class="n">fd</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">fd</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">nsize</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Wheee. We now have a complete jffs2_full_dirent structure, with</span>
<span class="cm">	 * the name in it and everything. Link it into the list</span>
<span class="cm">	 */</span>
	<span class="n">jffs2_add_fd_to_list</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for jffs2_get_inode_nodes().</span>
<span class="cm"> * It is called every time an inode node is found.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success (possibly after marking a bad node obsolete);</span>
<span class="cm"> * 	    negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">read_dnode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">jffs2_raw_inode</span> <span class="o">*</span><span class="n">rd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rdlen</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">jffs2_readinode_info</span> <span class="o">*</span><span class="n">rii</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_tmp_dnode_info</span> <span class="o">*</span><span class="n">tn</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">len</span><span class="p">,</span> <span class="n">csize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">;</span>

	<span class="cm">/* Obsoleted. This cannot happen, surely? dwmw2 20020308 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ref_obsolete</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rd</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">)</span> <span class="o">-</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">node_crc</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;node CRC failed on dnode at %#08x: read %#08x, calculated %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">node_crc</span><span class="p">),</span> <span class="n">crc</span><span class="p">);</span>
		<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tn</span> <span class="o">=</span> <span class="n">jffs2_alloc_tmp_dnode_info</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;failed to allocate tn (%zu bytes).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tn</span><span class="p">));</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">partial_crc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">csize</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">);</span>

	<span class="cm">/* If we&#39;ve never checked the CRCs on this node, check them now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">==</span> <span class="n">REF_UNCHECKED</span><span class="p">)</span> <span class="p">{</span>

		<span class="cm">/* Sanity checks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">isize</span><span class="p">))</span> <span class="o">||</span>
		    <span class="n">unlikely</span><span class="p">(</span><span class="n">PAD</span><span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">))</span> <span class="o">!=</span> <span class="n">PAD</span><span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">))))</span> <span class="p">{</span>
			<span class="n">JFFS2_WARNING</span><span class="p">(</span><span class="s">&quot;inode node header CRC is corrupted at %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
			<span class="n">jffs2_dbg_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">jffs2_is_writebuffered</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">csize</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* At this point we are supposed to check the data CRC</span>
<span class="cm">			 * of our unchecked node. But thus far, we do not</span>
<span class="cm">			 * know whether the node is valid or obsolete. To</span>
<span class="cm">			 * figure this out, we need to walk all the nodes of</span>
<span class="cm">			 * the inode and build the inode fragtree. We don&#39;t</span>
<span class="cm">			 * want to spend time checking data of nodes which may</span>
<span class="cm">			 * later be found to be obsolete. So we put off the full</span>
<span class="cm">			 * data CRC checking until we have read all the inode</span>
<span class="cm">			 * nodes and have started building the fragtree.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The fragtree is being built starting with nodes</span>
<span class="cm">			 * having the highest version number, so we&#39;ll be able</span>
<span class="cm">			 * to detect whether a node is valid (i.e., it is not</span>
<span class="cm">			 * overlapped by a node with higher version) or not.</span>
<span class="cm">			 * And we&#39;ll be able to check only those nodes, which</span>
<span class="cm">			 * are not obsolete.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Of course, this optimization only makes sense in case</span>
<span class="cm">			 * of NAND flashes (or other flashes with</span>
<span class="cm">			 * !jffs2_can_mark_obsolete()), since on NOR flashes</span>
<span class="cm">			 * nodes are marked obsolete physically.</span>
<span class="cm">			 *</span>
<span class="cm">			 * Since NAND flashes (or other flashes with</span>
<span class="cm">			 * jffs2_is_writebuffered(c)) are anyway read by</span>
<span class="cm">			 * fractions of c-&gt;wbuf_pagesize, and we have just read</span>
<span class="cm">			 * the node header, it is likely that the starting part</span>
<span class="cm">			 * of the node data is also read when we read the</span>
<span class="cm">			 * header. So we don&#39;t mind to check the CRC of the</span>
<span class="cm">			 * starting part of the data of the node now, and check</span>
<span class="cm">			 * the second part later (in jffs2_check_node_data()).</span>
<span class="cm">			 * Of course, we will not need to re-read and re-check</span>
<span class="cm">			 * the NAND page which we have just read. This is why we</span>
<span class="cm">			 * read the whole NAND page at jffs2_get_inode_nodes(),</span>
<span class="cm">			 * while we needed only the node header.</span>
<span class="cm">			 */</span>
			<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

			<span class="cm">/* &#39;buf&#39; will point to the start of data */</span>
			<span class="n">buf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">rd</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">);</span>
			<span class="cm">/* len will be the read data length */</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">,</span> <span class="n">rdlen</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rd</span><span class="p">),</span> <span class="n">csize</span><span class="p">);</span>
			<span class="n">tn</span><span class="o">-&gt;</span><span class="n">partial_crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

			<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;Calculates CRC (%#08x) for %d bytes, csize %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">partial_crc</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">csize</span><span class="p">);</span>

			<span class="cm">/* If we actually calculated the whole data CRC</span>
<span class="cm">			 * and it is wrong, drop the node. */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">csize</span> <span class="o">&amp;&amp;</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">partial_crc</span> <span class="o">!=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;wrong data CRC in data node at 0x%08x: read %#08x, calculated %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					<span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">partial_crc</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">));</span>
				<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">csize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We checked the header CRC. If the node has no data, adjust</span>
<span class="cm">			 * the space accounting now. For other nodes this will be done</span>
<span class="cm">			 * later either when the node is marked obsolete or when its</span>
<span class="cm">			 * data is checked.</span>
<span class="cm">			 */</span>
			<span class="k">struct</span> <span class="n">jffs2_eraseblock</span> <span class="o">*</span><span class="n">jeb</span><span class="p">;</span>

			<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;the node has no data.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">jeb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">blocks</span><span class="p">[</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">/</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">];</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">ref_totlen</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">jeb</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>

			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
			<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">jeb</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">used_size</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">c</span><span class="o">-&gt;</span><span class="n">unchecked_size</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">ref</span><span class="o">-&gt;</span><span class="n">flash_offset</span> <span class="o">=</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">|</span> <span class="n">REF_NORMAL</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span> <span class="o">=</span> <span class="n">jffs2_alloc_full_dnode</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;alloc fn failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">);</span>
	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">data_crc</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">data_crc</span><span class="p">);</span>
	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">csize</span> <span class="o">=</span> <span class="n">csize</span><span class="p">;</span>
	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span> <span class="o">=</span> <span class="n">ref</span><span class="p">;</span>
	<span class="n">tn</span><span class="o">-&gt;</span><span class="n">overlapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">&gt;</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">)</span>
		<span class="n">rii</span><span class="o">-&gt;</span><span class="n">highest_version</span> <span class="o">=</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">;</span>

	<span class="cm">/* There was a bug where we wrote hole nodes out with</span>
<span class="cm">	   csize/dsize swapped. Deal with it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">compr</span> <span class="o">==</span> <span class="n">JFFS2_COMPR_ZERO</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">csize</span><span class="p">)</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">csize</span><span class="p">;</span>
	<span class="k">else</span> <span class="c1">// normal case...</span>
		<span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">);</span>

	<span class="n">dbg_readinode2</span><span class="p">(</span><span class="s">&quot;dnode @%08x: ver %u, offset %#04x, dsize %#04x, csize %#04x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">),</span>
		       <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">),</span> <span class="n">csize</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_add_tn_to_tree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">rii</span><span class="p">,</span> <span class="n">tn</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">);</span>
	<span class="nl">free_out:</span>
		<span class="n">jffs2_free_tmp_dnode_info</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef JFFS2_DBG_READINODE2_MESSAGES</span>
	<span class="n">dbg_readinode2</span><span class="p">(</span><span class="s">&quot;After adding ver %d:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">rd</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">));</span>
	<span class="n">tn</span> <span class="o">=</span> <span class="n">tn_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tn</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dbg_readinode2</span><span class="p">(</span><span class="s">&quot;%p: v %d r 0x%x-0x%x ov %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">tn</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="p">,</span>
			       <span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">ofs</span><span class="o">+</span><span class="n">tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">tn</span><span class="o">-&gt;</span><span class="n">overlapped</span><span class="p">);</span>
		<span class="n">tn</span> <span class="o">=</span> <span class="n">tn_next</span><span class="p">(</span><span class="n">tn</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for jffs2_get_inode_nodes().</span>
<span class="cm"> * It is called every time an unknown node is found.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success;</span>
<span class="cm"> * 	    negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">read_unknown</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_unknown_node</span> <span class="o">*</span><span class="n">un</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* We don&#39;t mark unknown nodes as REF_UNCHECKED */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref_flags</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">==</span> <span class="n">REF_UNCHECKED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;REF_UNCHECKED but unknown node at %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Node is {%04x,%04x,%08x,%08x}. Please report this error.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">),</span> <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">),</span>
			    <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">totlen</span><span class="p">),</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">hdr_crc</span><span class="p">));</span>
		<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="n">JFFS2_NODE_ACCURATE</span> <span class="o">|</span> <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">));</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">JFFS2_COMPAT_MASK</span><span class="p">)</span> <span class="p">{</span>

	<span class="k">case</span> <span class="n">JFFS2_FEATURE_INCOMPAT</span>:
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;unknown INCOMPAT nodetype %#04X at %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
		<span class="cm">/* EEP */</span>
		<span class="n">BUG</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">JFFS2_FEATURE_ROCOMPAT</span>:
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;unknown ROCOMPAT nodetype %#04X at %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">JFFS2_SB_FLAG_RO</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">JFFS2_FEATURE_RWCOMPAT_COPY</span>:
		<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;unknown RWCOMPAT_COPY nodetype %#04X at %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">JFFS2_FEATURE_RWCOMPAT_DELETE</span>:
		<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;unknown RWCOMPAT_DELETE nodetype %#04X at %#08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			     <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">un</span><span class="o">-&gt;</span><span class="n">nodetype</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
		<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Helper function for jffs2_get_inode_nodes().</span>
<span class="cm"> * The function detects whether more data should be read and reads it if yes.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns: 0 on success;</span>
<span class="cm"> * 	    negative error code on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">read_more</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">needed_len</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">rdlen</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">to_read</span> <span class="o">=</span> <span class="n">needed_len</span> <span class="o">-</span> <span class="o">*</span><span class="n">rdlen</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">offs</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">jffs2_is_writebuffered</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">rem</span> <span class="o">=</span> <span class="n">to_read</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">wbuf_pagesize</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">rem</span><span class="p">)</span>
			<span class="n">to_read</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">wbuf_pagesize</span> <span class="o">-</span> <span class="n">rem</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We need to read more data */</span>
	<span class="n">offs</span> <span class="o">=</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">+</span> <span class="o">*</span><span class="n">rdlen</span><span class="p">;</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;read more %d bytes</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to_read</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">to_read</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="o">*</span><span class="n">rdlen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;can not read %d bytes from 0x%08x, &quot;</span>
			<span class="s">&quot;error code: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">to_read</span><span class="p">,</span> <span class="n">offs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">&lt;</span> <span class="n">to_read</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;short read at %#08x: %zu instead of %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">offs</span><span class="p">,</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">to_read</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">rdlen</span> <span class="o">+=</span> <span class="n">to_read</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get tmp_dnode_info and full_dirent for all non-obsolete nodes associated</span>
<span class="cm">   with this ino. Perform a preliminary ordering on data nodes, throwing away</span>
<span class="cm">   those which are completely obsoleted by newer ones. The naïve approach we</span>
<span class="cm">   use to take of just returning them _all_ in version order will cause us to</span>
<span class="cm">   run out of memory in certain degenerate cases. */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_get_inode_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">jffs2_readinode_info</span> <span class="o">*</span><span class="n">rii</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span> <span class="o">*</span><span class="n">valid_ref</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">jffs2_node_union</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">rii</span><span class="o">-&gt;</span><span class="n">mctime_ver</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>

	<span class="cm">/* FIXME: in case of NOR and available -&gt;point() this</span>
<span class="cm">	 * needs to be fixed. */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">union</span> <span class="n">jffs2_node_union</span><span class="p">)</span> <span class="o">+</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">wbuf_pagesize</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
	<span class="n">valid_ref</span> <span class="o">=</span> <span class="n">jffs2_first_valid_node</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid_ref</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">JFFS2_WARNING</span><span class="p">(</span><span class="s">&quot;Eep. No valid nodes for ino #%u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">valid_ref</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We can hold a pointer to a non-obsolete node without the spinlock,</span>
<span class="cm">		   but _obsolete_ nodes may disappear at any time, if the block</span>
<span class="cm">		   they&#39;re in gets erased. So if we mark &#39;ref&#39; obsolete while we&#39;re</span>
<span class="cm">		   not holding the lock, it can go away immediately. For that reason,</span>
<span class="cm">		   we find the next valid node first, before processing &#39;ref&#39;.</span>
<span class="cm">		*/</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">valid_ref</span><span class="p">;</span>
		<span class="n">valid_ref</span> <span class="o">=</span> <span class="n">jffs2_first_valid_node</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">next_in_ino</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="cm">/*</span>
<span class="cm">		 * At this point we don&#39;t know the type of the node we&#39;re going</span>
<span class="cm">		 * to read, so we do not know the size of its header. In order</span>
<span class="cm">		 * to minimize the amount of flash IO we assume the header is</span>
<span class="cm">		 * of size = JFFS2_MIN_NODE_HEADER.</span>
<span class="cm">		 */</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">JFFS2_MIN_NODE_HEADER</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">jffs2_is_writebuffered</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">end</span><span class="p">,</span> <span class="n">rem</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * We are about to read JFFS2_MIN_NODE_HEADER bytes,</span>
<span class="cm">			 * but this flash has some minimal I/O unit. It is</span>
<span class="cm">			 * possible that we&#39;ll need to read more soon, so read</span>
<span class="cm">			 * up to the next min. I/O unit, in order not to</span>
<span class="cm">			 * re-read the same min. I/O unit twice.</span>
<span class="cm">			 */</span>
			<span class="n">end</span> <span class="o">=</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">rem</span> <span class="o">=</span> <span class="n">end</span> <span class="o">%</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">wbuf_pagesize</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">rem</span><span class="p">)</span>
				<span class="n">end</span> <span class="o">+=</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">wbuf_pagesize</span> <span class="o">-</span> <span class="n">rem</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;read %d bytes at %#08x(%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">ref_flags</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>

		<span class="cm">/* FIXME: point() */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;can not read %d bytes from 0x%08x, error code: %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">err</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;short read at %#08x: %zu instead of %d.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">node</span> <span class="o">=</span> <span class="p">(</span><span class="k">union</span> <span class="n">jffs2_node_union</span> <span class="o">*</span><span class="p">)</span><span class="n">buf</span><span class="p">;</span>

		<span class="cm">/* No need to mask in the valid bit; it shouldn&#39;t be invalid */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr_crc</span><span class="p">)</span> <span class="o">!=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">)</span><span class="o">-</span><span class="mi">4</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;Node header CRC failed at %#08x. {%04x,%04x,%08x,%08x}</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">),</span> <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">magic</span><span class="p">),</span>
				     <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">nodetype</span><span class="p">),</span>
				     <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">totlen</span><span class="p">),</span>
				     <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">hdr_crc</span><span class="p">));</span>
			<span class="n">jffs2_dbg_dump_node</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cont</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">magic</span><span class="p">)</span> <span class="o">!=</span> <span class="n">JFFS2_MAGIC_BITMASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Not a JFFS2 node, whinge and move on */</span>
			<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;Wrong magic bitmask 0x%04x in node header at %#08x.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">magic</span><span class="p">),</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">ref</span><span class="p">));</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">cont</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">je16_to_cpu</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">.</span><span class="n">nodetype</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">case</span> <span class="n">JFFS2_NODETYPE_DIRENT</span>:

			<span class="k">if</span> <span class="p">(</span><span class="n">JFFS2_MIN_NODE_HEADER</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_dirent</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_dirent</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">read_more</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_dirent</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">read_direntry</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">d</span><span class="p">,</span> <span class="n">retlen</span><span class="p">,</span> <span class="n">rii</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">JFFS2_NODETYPE_INODE</span>:

			<span class="k">if</span> <span class="p">(</span><span class="n">JFFS2_MIN_NODE_HEADER</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_inode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">read_more</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_inode</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">read_dnode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">rii</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>

			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">JFFS2_MIN_NODE_HEADER</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			    <span class="n">len</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">read_more</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_unknown_node</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
					<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">read_unknown</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">u</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">free_out</span><span class="p">;</span>

		<span class="p">}</span>
	<span class="nl">cont:</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">erase_completion_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">f</span><span class="o">-&gt;</span><span class="n">highest_version</span> <span class="o">=</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">;</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;nodes of inode #%u were read, the highest version is %u, latest_mctime %u, mctime_ver %u.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">highest_version</span><span class="p">,</span> <span class="n">rii</span><span class="o">-&gt;</span><span class="n">latest_mctime</span><span class="p">,</span>
		      <span class="n">rii</span><span class="o">-&gt;</span><span class="n">mctime_ver</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">free_out:</span>
	<span class="n">jffs2_free_tmp_dnode_info_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">tn_root</span><span class="p">);</span>
	<span class="n">jffs2_free_full_dirent_list</span><span class="p">(</span><span class="n">rii</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">);</span>
	<span class="n">rii</span><span class="o">-&gt;</span><span class="n">fds</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">jffs2_do_read_inode_internal</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">jffs2_raw_inode</span> <span class="o">*</span><span class="n">latest_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_readinode_info</span> <span class="n">rii</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">crc</span><span class="p">,</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">retlen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;ino #%u pino/nlink is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span>
		      <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">pino_nlink</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">rii</span><span class="p">));</span>

	<span class="cm">/* Grab all nodes relevant to this ino */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_get_inode_nodes</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rii</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;cannot read nodes for ino %u, returned error is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">INO_STATE_READING</span><span class="p">)</span>
			<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">INO_STATE_CHECKEDABSENT</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_build_inode_fragtree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rii</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Failed to build final fragtree for inode #%u: error %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			    <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">INO_STATE_READING</span><span class="p">)</span>
			<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">INO_STATE_CHECKEDABSENT</span><span class="p">);</span>
		<span class="n">jffs2_free_tmp_dnode_info_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rii</span><span class="p">.</span><span class="n">tn_root</span><span class="p">);</span>
		<span class="cm">/* FIXME: We could at least crc-check them all */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">);</span>
			<span class="n">jffs2_free_tmp_dnode_info</span><span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="p">);</span>
			<span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="o">-&gt;</span><span class="n">raw</span> <span class="o">==</span> <span class="n">rii</span><span class="p">.</span><span class="n">latest_ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="o">-&gt;</span><span class="n">fn</span><span class="p">;</span>
			<span class="n">jffs2_free_tmp_dnode_info</span><span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">jffs2_kill_tn</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">rii</span><span class="p">.</span><span class="n">mdata_tn</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">f</span><span class="o">-&gt;</span><span class="n">dents</span> <span class="o">=</span> <span class="n">rii</span><span class="p">.</span><span class="n">fds</span><span class="p">;</span>

	<span class="n">jffs2_dbg_fragtree_paranoia_check_nolock</span><span class="p">(</span><span class="n">f</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">rii</span><span class="p">.</span><span class="n">latest_ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* No data nodes for this inode. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JFFS2_WARNING</span><span class="p">(</span><span class="s">&quot;no data nodes found for ino #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rii</span><span class="p">.</span><span class="n">fds</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">INO_STATE_READING</span><span class="p">)</span>
					<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">INO_STATE_CHECKEDABSENT</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">JFFS2_NOTICE</span><span class="p">(</span><span class="s">&quot;but it has children so we fake some modes for it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_jemode</span><span class="p">(</span><span class="n">S_IFDIR</span><span class="o">|</span><span class="n">S_IRUGO</span><span class="o">|</span><span class="n">S_IWUSR</span><span class="o">|</span><span class="n">S_IXUGO</span><span class="p">);</span>
		<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">version</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">atime</span> <span class="o">=</span> <span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">isize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">cpu_to_je16</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">INO_STATE_READING</span><span class="p">)</span>
			<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">INO_STATE_PRESENT</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">latest_ref</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">latest_node</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">latest_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">retlen</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">latest_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;failed to read from flash: error %d, %zd of %zd bytes read</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">ret</span><span class="p">,</span> <span class="n">retlen</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">latest_node</span><span class="p">));</span>
		<span class="cm">/* FIXME: If this fails, there seems to be a memory leak. Find it. */</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
		<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="o">?</span><span class="n">ret</span><span class="o">:-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">latest_node</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">latest_node</span><span class="p">)</span><span class="o">-</span><span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">crc</span> <span class="o">!=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">node_crc</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;CRC failed for read_inode of inode %u at physical location 0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">latest_ref</span><span class="p">));</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
		<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">switch</span><span class="p">(</span><span class="n">jemode_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">mctime_ver</span> <span class="o">&gt;</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">version</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* The times in the latest_node are actually older than</span>
<span class="cm">			   mctime in the latest dirent. Cheat. */</span>
			<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">ctime</span> <span class="o">=</span> <span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">mtime</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">latest_mctime</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>


	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="cm">/* If it was a regular file, truncate it to the latest node&#39;s isize */</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="n">jffs2_truncate_fragtree</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">isize</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">!=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">isize</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">JFFS2_WARNING</span><span class="p">(</span><span class="s">&quot;Truncating ino #%u to %d bytes failed because it only had %d bytes to start with!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">isize</span><span class="p">),</span> <span class="n">new_size</span><span class="p">);</span>
			<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">isize</span> <span class="o">=</span> <span class="n">cpu_to_je32</span><span class="p">(</span><span class="n">new_size</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>

	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="cm">/* Hack to work around broken isize in old symlink code.</span>
<span class="cm">		   Remove this when dwmw2 comes to his senses and stops</span>
<span class="cm">		   symlinks from being an entirely gratuitous special</span>
<span class="cm">		   case. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">isize</span><span class="p">))</span>
			<span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">isize</span> <span class="o">=</span> <span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">dsize</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">INO_STATE_CHECKING</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Symlink&#39;s inode data is the target path. Read it and</span>
<span class="cm">			 * keep in RAM to facilitate quick follow symlink</span>
<span class="cm">			 * operation. */</span>
			<span class="kt">uint32_t</span> <span class="n">csize</span> <span class="o">=</span> <span class="n">je32_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">csize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">csize</span> <span class="o">&gt;</span> <span class="n">JFFS2_MAX_NAME_LEN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
				<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">csize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;can&#39;t allocate %u bytes of memory for the symlink target path cache</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">csize</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
				<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_flash_read</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ref_offset</span><span class="p">(</span><span class="n">rii</span><span class="p">.</span><span class="n">latest_ref</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">latest_node</span><span class="p">),</span>
					       <span class="n">csize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">retlen</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">retlen</span> <span class="o">!=</span> <span class="n">csize</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">retlen</span> <span class="o">!=</span> <span class="n">csize</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>
				<span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
				<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">[</span><span class="n">csize</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
			<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;symlink&#39;s target &#39;%s&#39; cached</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* fall through... */</span>

	<span class="k">case</span> <span class="n">S_IFBLK</span>:
	<span class="k">case</span> <span class="n">S_IFCHR</span>:
		<span class="cm">/* Certain inode types should have only one data node, and it&#39;s</span>
<span class="cm">		   kept as the metadata node */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Argh. Special inode #%u with mode 0%o had metadata node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">jemode_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">));</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
			<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">frag_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Argh. Special inode #%u with mode 0%o has no fragments</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">jemode_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">));</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
			<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* ASSERT: f-&gt;fraglist != NULL */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">frag_next</span><span class="p">(</span><span class="n">frag_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Argh. Special inode #%u with mode 0x%x had more than one node</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">,</span> <span class="n">jemode_to_cpu</span><span class="p">(</span><span class="n">latest_node</span><span class="o">-&gt;</span><span class="n">mode</span><span class="p">));</span>
			<span class="cm">/* FIXME: Deal with it - check crc32, check for duplicate node, check times and discard the older one */</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
			<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* OK. We&#39;re happy */</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span> <span class="o">=</span> <span class="n">frag_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
		<span class="n">jffs2_free_node_frag</span><span class="p">(</span><span class="n">frag_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">));</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span> <span class="o">=</span> <span class="n">RB_ROOT</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">==</span> <span class="n">INO_STATE_READING</span><span class="p">)</span>
		<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">INO_STATE_PRESENT</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Scan the list of all nodes present for this ino, build map of versions, etc. */</span>
<span class="kt">int</span> <span class="nf">jffs2_do_read_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">,</span>
			<span class="kt">uint32_t</span> <span class="n">ino</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_raw_inode</span> <span class="o">*</span><span class="n">latest_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;read inode #%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>

 <span class="nl">retry_inocache:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">=</span> <span class="n">jffs2_get_ino_cache</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check its state. We may need to wait before we can use it */</span>
		<span class="k">switch</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">INO_STATE_UNCHECKED</span>:
		<span class="k">case</span> <span class="n">INO_STATE_CHECKEDABSENT</span>:
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">INO_STATE_READING</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">INO_STATE_CHECKING</span>:
		<span class="k">case</span> <span class="n">INO_STATE_GC</span>:
			<span class="cm">/* If it&#39;s in either of these states, we need</span>
<span class="cm">			   to wait for whoever&#39;s got it to finish and</span>
<span class="cm">			   put it back. */</span>
			<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;waiting for ino #%u in state %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="n">sleep_on_spinunlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry_inocache</span><span class="p">;</span>

		<span class="k">case</span> <span class="n">INO_STATE_READING</span>:
		<span class="k">case</span> <span class="n">INO_STATE_PRESENT</span>:
			<span class="cm">/* Eep. This should never happen. It can</span>
<span class="cm">			happen if Linux calls read_inode() again</span>
<span class="cm">			before clear_inode() has finished though. */</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;Eep. Trying to read_inode #%u when it&#39;s already in state %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
			<span class="cm">/* Fail. That&#39;s probably better than allowing it to succeed */</span>
			<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="nl">default:</span>
			<span class="n">BUG</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">c</span><span class="o">-&gt;</span><span class="n">inocache_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">&amp;&amp;</span> <span class="n">ino</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Special case - no root inode on medium */</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">=</span> <span class="n">jffs2_alloc_inode_cache</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;cannot allocate inocache for root inode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dbg_readinode</span><span class="p">(</span><span class="s">&quot;creating inocache for root inode</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_inode_cache</span><span class="p">));</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">pino_nlink</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">nodes</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_raw_node_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">;</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">INO_STATE_READING</span><span class="p">;</span>
		<span class="n">jffs2_add_ino_cache</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">JFFS2_ERROR</span><span class="p">(</span><span class="s">&quot;requestied to read an nonexistent ino %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">jffs2_do_read_inode_internal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="n">latest_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">jffs2_do_crccheck_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_cache</span> <span class="o">*</span><span class="n">ic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_raw_inode</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">f</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">=</span> <span class="n">ic</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">jffs2_do_read_inode_internal</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
		<span class="n">jffs2_do_clear_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">jffs2_xattr_do_crccheck_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">ic</span><span class="p">);</span>
	<span class="n">kfree</span> <span class="p">(</span><span class="n">f</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">jffs2_do_clear_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">jffs2_sb_info</span> <span class="o">*</span><span class="n">c</span><span class="p">,</span> <span class="k">struct</span> <span class="n">jffs2_inode_info</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">jffs2_full_dirent</span> <span class="o">*</span><span class="n">fd</span><span class="p">,</span> <span class="o">*</span><span class="n">fds</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">deleted</span><span class="p">;</span>

	<span class="n">jffs2_xattr_delete_inode</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
	<span class="n">deleted</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">pino_nlink</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">INO_STATE_CHECKING</span><span class="p">)</span>
		<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">INO_STATE_CLEARING</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">deleted</span><span class="p">)</span>
			<span class="n">jffs2_mark_node_obsolete</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="o">-&gt;</span><span class="n">raw</span><span class="p">);</span>
		<span class="n">jffs2_free_full_dnode</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">metadata</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">jffs2_kill_fragtree</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">fragtree</span><span class="p">,</span> <span class="n">deleted</span><span class="o">?</span><span class="n">c</span><span class="o">:</span><span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span><span class="p">);</span>
		<span class="n">f</span><span class="o">-&gt;</span><span class="n">target</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fds</span> <span class="o">=</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">dents</span><span class="p">;</span>
	<span class="k">while</span><span class="p">(</span><span class="n">fds</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fd</span> <span class="o">=</span> <span class="n">fds</span><span class="p">;</span>
		<span class="n">fds</span> <span class="o">=</span> <span class="n">fd</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
		<span class="n">jffs2_free_full_dirent</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span> <span class="o">&amp;&amp;</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">!=</span> <span class="n">INO_STATE_CHECKING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">jffs2_set_inocache_state</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">,</span> <span class="n">INO_STATE_CHECKEDABSENT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="o">-&gt;</span><span class="n">nodes</span> <span class="o">==</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">)</span>
			<span class="n">jffs2_del_ino_cache</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">f</span><span class="o">-&gt;</span><span class="n">inocache</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">f</span><span class="o">-&gt;</span><span class="n">sem</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
