<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › befs › datastream.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>datastream.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * linux/fs/befs/datastream.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2001 Will Dyson &lt;will_dyson@pobox.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Based on portions of file.c by Makoto Kato &lt;m_kato@ga2.so-net.ne.jp&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * Many thanks to Dominic Giampaolo, author of &quot;Practical File System</span>
<span class="cm"> * Design with the Be File System&quot;, for such a helpful book.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>

<span class="cp">#include &quot;befs.h&quot;</span>
<span class="cp">#include &quot;datastream.h&quot;</span>
<span class="cp">#include &quot;io.h&quot;</span>

<span class="k">const</span> <span class="n">befs_inode_addr</span> <span class="n">BAD_IADDR</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span> <span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">befs_find_brun_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
				 <span class="n">befs_blocknr_t</span> <span class="n">blockno</span><span class="p">,</span> <span class="n">befs_block_run</span> <span class="o">*</span> <span class="n">run</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">befs_find_brun_indirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
				   <span class="n">befs_blocknr_t</span> <span class="n">blockno</span><span class="p">,</span>
				   <span class="n">befs_block_run</span> <span class="o">*</span> <span class="n">run</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">befs_find_brun_dblindirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				      <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
				      <span class="n">befs_blocknr_t</span> <span class="n">blockno</span><span class="p">,</span>
				      <span class="n">befs_block_run</span> <span class="o">*</span> <span class="n">run</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * befs_read_datastream - get buffer_head containing data, starting from pos.</span>
<span class="cm"> * @sb: Filesystem superblock</span>
<span class="cm"> * @ds: datastrem to find data with</span>
<span class="cm"> * @pos: start of data</span>
<span class="cm"> * @off: offset of data in buffer_head-&gt;b_data</span>
<span class="cm"> *</span>
<span class="cm"> * Returns pointer to buffer_head containing data starting with offset @off,</span>
<span class="cm"> * if you don&#39;t need to know offset just set @off = NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span>
<span class="nf">befs_read_datastream</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">ds</span><span class="p">,</span>
		     <span class="n">befs_off_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">uint</span> <span class="o">*</span> <span class="n">off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">befs_block_run</span> <span class="n">run</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">block</span><span class="p">;</span>	<span class="cm">/* block coresponding to pos */</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_read_datastream() %Lu&quot;</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="n">block</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span><span class="p">)</span>
		<span class="o">*</span><span class="n">off</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">-</span> <span class="p">(</span><span class="n">block</span> <span class="o">&lt;&lt;</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">befs_fblock2brun</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">run</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BEFS_OK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;BeFS: Error finding disk addr of block %lu&quot;</span><span class="p">,</span>
			   <span class="n">block</span><span class="p">);</span>
		<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;&lt;--- befs_read_datastream() ERROR&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">befs_bread_iaddr</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">run</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;BeFS: Error reading block %lu from datastream&quot;</span><span class="p">,</span>
			   <span class="n">block</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;&lt;--- befs_read_datastream() read data, starting at %Lu&quot;</span><span class="p">,</span>
		   <span class="n">pos</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bh</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Takes a file position and gives back a brun who&#39;s starting block</span>
<span class="cm"> * is block number fblock of the file.</span>
<span class="cm"> * </span>
<span class="cm"> * Returns BEFS_OK or BEFS_ERR.</span>
<span class="cm"> * </span>
<span class="cm"> * Calls specialized functions for each of the three possible</span>
<span class="cm"> * datastream regions.</span>
<span class="cm"> *</span>
<span class="cm"> * 2001-11-15 Will Dyson</span>
<span class="cm"> */</span>
<span class="kt">int</span>
<span class="nf">befs_fblock2brun</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
		 <span class="n">befs_blocknr_t</span> <span class="n">fblock</span><span class="p">,</span> <span class="n">befs_block_run</span> <span class="o">*</span> <span class="n">run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">befs_off_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">fblock</span> <span class="o">&lt;&lt;</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">max_direct_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">befs_find_brun_direct</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fblock</span><span class="p">,</span> <span class="n">run</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">max_indirect_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">befs_find_brun_indirect</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fblock</span><span class="p">,</span> <span class="n">run</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&lt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">max_double_indirect_range</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">befs_find_brun_dblindirect</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">fblock</span><span class="p">,</span> <span class="n">run</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
			   <span class="s">&quot;befs_fblock2brun() was asked to find block %lu, &quot;</span>
			   <span class="s">&quot;which is not mapped by the datastream</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fblock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * befs_read_lsmylink - read long symlink from datastream.</span>
<span class="cm"> * @sb: Filesystem superblock </span>
<span class="cm"> * @ds: Datastrem to read from</span>
<span class="cm"> * @buf: Buffer in which to place long symlink data</span>
<span class="cm"> * @len: Length of the long symlink in bytes</span>
<span class="cm"> *</span>
<span class="cm"> * Returns the number of bytes read</span>
<span class="cm"> */</span>
<span class="kt">size_t</span>
<span class="nf">befs_read_lsymlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span> <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">ds</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">buff</span><span class="p">,</span>
		   <span class="n">befs_off_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">befs_off_t</span> <span class="n">bytes_read</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* bytes readed */</span>
	<span class="n">u16</span> <span class="n">plen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_read_lsymlink() length: %Lu&quot;</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bytes_read</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">befs_read_datastream</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ds</span><span class="p">,</span> <span class="n">bytes_read</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;BeFS: Error reading datastream block &quot;</span>
				   <span class="s">&quot;starting from %Lu&quot;</span><span class="p">,</span> <span class="n">bytes_read</span><span class="p">);</span>
			<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;&lt;--- befs_read_lsymlink() ERROR&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">bytes_read</span><span class="p">;</span>

		<span class="p">}</span>
		<span class="n">plen</span> <span class="o">=</span> <span class="p">((</span><span class="n">bytes_read</span> <span class="o">+</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">block_size</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="o">?</span>
		    <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">:</span> <span class="n">len</span> <span class="o">-</span> <span class="n">bytes_read</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buff</span> <span class="o">+</span> <span class="n">bytes_read</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="n">plen</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">bytes_read</span> <span class="o">+=</span> <span class="n">plen</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;&lt;--- befs_read_lsymlink() read %u bytes&quot;</span><span class="p">,</span> <span class="n">bytes_read</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">bytes_read</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * befs_count_blocks - blocks used by a file</span>
<span class="cm"> * @sb: Filesystem superblock</span>
<span class="cm"> * @ds: Datastream of the file</span>
<span class="cm"> *</span>
<span class="cm"> * Counts the number of fs blocks that the file represented by</span>
<span class="cm"> * inode occupies on the filesystem, counting both regular file</span>
<span class="cm"> * data and filesystem metadata (and eventually attribute data</span>
<span class="cm"> * when we support attributes)</span>
<span class="cm">*/</span>

<span class="n">befs_blocknr_t</span>
<span class="nf">befs_count_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span> <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">befs_blocknr_t</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">datablocks</span><span class="p">;</span>	<span class="cm">/* File data blocks */</span>
	<span class="n">befs_blocknr_t</span> <span class="n">metablocks</span><span class="p">;</span>	<span class="cm">/* FS metadata blocks */</span>
	<span class="n">befs_sb_info</span> <span class="o">*</span><span class="n">befs_sb</span> <span class="o">=</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_count_blocks()&quot;</span><span class="p">);</span>

	<span class="n">datablocks</span> <span class="o">=</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;&gt;</span> <span class="n">befs_sb</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">befs_sb</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
		<span class="n">datablocks</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">metablocks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>		<span class="cm">/* Start with 1 block for inode */</span>

	<span class="cm">/* Size of indirect block */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">max_direct_range</span><span class="p">)</span>
		<span class="n">metablocks</span> <span class="o">+=</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">indirect</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	   Double indir block, plus all the indirect blocks it mapps</span>
<span class="cm">	   In the double-indirect range, all block runs of data are</span>
<span class="cm">	   BEFS_DBLINDIR_BRUN_LEN blocks long. Therefore, we know </span>
<span class="cm">	   how many data block runs are in the double-indirect region,</span>
<span class="cm">	   and from that we know how many indirect blocks it takes to</span>
<span class="cm">	   map them. We assume that the indirect blocks are also</span>
<span class="cm">	   BEFS_DBLINDIR_BRUN_LEN blocks long.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">max_indirect_range</span> <span class="o">&amp;&amp;</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">max_indirect_range</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uint</span> <span class="n">dbl_bytes</span><span class="p">;</span>
		<span class="n">uint</span> <span class="n">dbl_bruns</span><span class="p">;</span>
		<span class="n">uint</span> <span class="n">indirblocks</span><span class="p">;</span>

		<span class="n">dbl_bytes</span> <span class="o">=</span>
		    <span class="n">ds</span><span class="o">-&gt;</span><span class="n">max_double_indirect_range</span> <span class="o">-</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">max_indirect_range</span><span class="p">;</span>
		<span class="n">dbl_bruns</span> <span class="o">=</span>
		    <span class="n">dbl_bytes</span> <span class="o">/</span> <span class="p">(</span><span class="n">befs_sb</span><span class="o">-&gt;</span><span class="n">block_size</span> <span class="o">*</span> <span class="n">BEFS_DBLINDIR_BRUN_LEN</span><span class="p">);</span>
		<span class="n">indirblocks</span> <span class="o">=</span> <span class="n">dbl_bruns</span> <span class="o">/</span> <span class="n">befs_iaddrs_per_block</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="n">metablocks</span> <span class="o">+=</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">double_indirect</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
		<span class="n">metablocks</span> <span class="o">+=</span> <span class="n">indirblocks</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">blocks</span> <span class="o">=</span> <span class="n">datablocks</span> <span class="o">+</span> <span class="n">metablocks</span><span class="p">;</span>
	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;&lt;--- befs_count_blocks() %u blocks&quot;</span><span class="p">,</span> <span class="n">blocks</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">blocks</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">	Finds the block run that starts at file block number blockno</span>
<span class="cm">	in the file represented by the datastream data, if that </span>
<span class="cm">	blockno is in the direct region of the datastream.</span>
<span class="cm">	</span>
<span class="cm">	sb: the superblock</span>
<span class="cm">	data: the datastream</span>
<span class="cm">	blockno: the blocknumber to find</span>
<span class="cm">	run: The found run is passed back through this pointer</span>
<span class="cm">	</span>
<span class="cm">	Return value is BEFS_OK if the blockrun is found, BEFS_ERR</span>
<span class="cm">	otherwise.</span>
<span class="cm">	</span>
<span class="cm">	Algorithm:</span>
<span class="cm">	Linear search. Checks each element of array[] to see if it</span>
<span class="cm">	contains the blockno-th filesystem block. This is necessary</span>
<span class="cm">	because the block runs map variable amounts of data. Simply</span>
<span class="cm">	keeps a count of the number of blocks searched so far (sum),</span>
<span class="cm">	incrementing this by the length of each block run as we come</span>
<span class="cm">	across it. Adds sum to *count before returning (this is so</span>
<span class="cm">	you can search multiple arrays that are logicaly one array,</span>
<span class="cm">	as in the indirect region code).</span>
<span class="cm">	</span>
<span class="cm">	When/if blockno is found, if blockno is inside of a block </span>
<span class="cm">	run as stored on disk, we offset the start and length members</span>
<span class="cm">	of the block run, so that blockno is the start and len is</span>
<span class="cm">	still valid (the run ends in the same place).</span>
<span class="cm">	</span>
<span class="cm">	2001-11-15 Will Dyson</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">befs_find_brun_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span>
		      <span class="n">befs_blocknr_t</span> <span class="n">blockno</span><span class="p">,</span> <span class="n">befs_block_run</span> <span class="o">*</span> <span class="n">run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">befs_block_run</span> <span class="o">*</span><span class="n">array</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">direct</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">sum</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">max_block</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">max_direct_range</span> <span class="o">&gt;&gt;</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_find_brun_direct(), find %lu&quot;</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">blockno</span> <span class="o">&gt;</span> <span class="n">max_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;befs_find_brun_direct() passed block outside of&quot;</span>
			   <span class="s">&quot;direct region&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BEFS_NUM_DIRECT_BLOCKS</span><span class="p">;</span>
	     <span class="n">sum</span> <span class="o">+=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">,</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blockno</span> <span class="o">&gt;=</span> <span class="n">sum</span> <span class="o">&amp;&amp;</span> <span class="n">blockno</span> <span class="o">&lt;</span> <span class="n">sum</span> <span class="o">+</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">blockno</span> <span class="o">-</span> <span class="n">sum</span><span class="p">;</span>
			<span class="n">run</span><span class="o">-&gt;</span><span class="n">allocation_group</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">allocation_group</span><span class="p">;</span>
			<span class="n">run</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
			<span class="n">run</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">len</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

			<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_find_brun_direct(), &quot;</span>
				   <span class="s">&quot;found %lu at direct[%d]&quot;</span><span class="p">,</span> <span class="n">blockno</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">BEFS_OK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_find_brun_direct() ERROR&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">	Finds the block run that starts at file block number blockno</span>
<span class="cm">	in the file represented by the datastream data, if that </span>
<span class="cm">	blockno is in the indirect region of the datastream.</span>
<span class="cm">	</span>
<span class="cm">	sb: the superblock</span>
<span class="cm">	data: the datastream</span>
<span class="cm">	blockno: the blocknumber to find</span>
<span class="cm">	run: The found run is passed back through this pointer</span>
<span class="cm">	</span>
<span class="cm">	Return value is BEFS_OK if the blockrun is found, BEFS_ERR</span>
<span class="cm">	otherwise.</span>
<span class="cm">	</span>
<span class="cm">	Algorithm:</span>
<span class="cm">	For each block in the indirect run of the datastream, read</span>
<span class="cm">	it in and search through it for	search_blk.</span>
<span class="cm">	</span>
<span class="cm">	XXX:</span>
<span class="cm">	Really should check to make sure blockno is inside indirect</span>
<span class="cm">	region.</span>
<span class="cm">	</span>
<span class="cm">	2001-11-15 Will Dyson</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">befs_find_brun_indirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			<span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">befs_blocknr_t</span> <span class="n">blockno</span><span class="p">,</span>
			<span class="n">befs_block_run</span> <span class="o">*</span> <span class="n">run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">indir_start_blk</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">search_blk</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">indirblock</span><span class="p">;</span>
	<span class="n">befs_disk_block_run</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>

	<span class="n">befs_block_run</span> <span class="n">indirect</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">indirect</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">indirblockno</span> <span class="o">=</span> <span class="n">iaddr2blockno</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">indirect</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">arraylen</span> <span class="o">=</span> <span class="n">befs_iaddrs_per_block</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_find_brun_indirect(), find %lu&quot;</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span>

	<span class="n">indir_start_blk</span> <span class="o">=</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">max_direct_range</span> <span class="o">&gt;&gt;</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>
	<span class="n">search_blk</span> <span class="o">=</span> <span class="n">blockno</span> <span class="o">-</span> <span class="n">indir_start_blk</span><span class="p">;</span>

	<span class="cm">/* Examine blocks of the indirect run one at a time */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">indirect</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">indirblock</span> <span class="o">=</span> <span class="n">befs_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">indirblockno</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">indirblock</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				   <span class="s">&quot;---&gt; befs_find_brun_indirect() failed to &quot;</span>
				   <span class="s">&quot;read disk block %lu from the indirect brun&quot;</span><span class="p">,</span>
				   <span class="n">indirblockno</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">array</span> <span class="o">=</span> <span class="p">(</span><span class="n">befs_disk_block_run</span> <span class="o">*</span><span class="p">)</span> <span class="n">indirblock</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">arraylen</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">fs16_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">len</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">search_blk</span> <span class="o">&gt;=</span> <span class="n">sum</span> <span class="o">&amp;&amp;</span> <span class="n">search_blk</span> <span class="o">&lt;</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">search_blk</span> <span class="o">-</span> <span class="n">sum</span><span class="p">;</span>
				<span class="n">run</span><span class="o">-&gt;</span><span class="n">allocation_group</span> <span class="o">=</span>
				    <span class="n">fs32_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">allocation_group</span><span class="p">);</span>
				<span class="n">run</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span>
				    <span class="n">fs16_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">start</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
				<span class="n">run</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span>
				    <span class="n">fs16_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">].</span><span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

				<span class="n">brelse</span><span class="p">(</span><span class="n">indirblock</span><span class="p">);</span>
				<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					   <span class="s">&quot;&lt;--- befs_find_brun_indirect() found &quot;</span>
					   <span class="s">&quot;file block %lu at indirect[%d]&quot;</span><span class="p">,</span>
					   <span class="n">blockno</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="n">arraylen</span><span class="p">));</span>
				<span class="k">return</span> <span class="n">BEFS_OK</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sum</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">brelse</span><span class="p">(</span><span class="n">indirblock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Only fallthrough is an error */</span>
	<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;BeFS: befs_find_brun_indirect() failed to find &quot;</span>
		   <span class="s">&quot;file block %lu&quot;</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;&lt;--- befs_find_brun_indirect() ERROR&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm">	Finds the block run that starts at file block number blockno</span>
<span class="cm">	in the file represented by the datastream data, if that </span>
<span class="cm">	blockno is in the double-indirect region of the datastream.</span>
<span class="cm">	</span>
<span class="cm">	sb: the superblock</span>
<span class="cm">	data: the datastream</span>
<span class="cm">	blockno: the blocknumber to find</span>
<span class="cm">	run: The found run is passed back through this pointer</span>
<span class="cm">	</span>
<span class="cm">	Return value is BEFS_OK if the blockrun is found, BEFS_ERR</span>
<span class="cm">	otherwise.</span>
<span class="cm">	</span>
<span class="cm">	Algorithm:</span>
<span class="cm">	The block runs in the double-indirect region are different.</span>
<span class="cm">	They are always allocated 4 fs blocks at a time, so each</span>
<span class="cm">	block run maps a constant amount of file data. This means</span>
<span class="cm">	that we can directly calculate how many block runs into the</span>
<span class="cm">	double-indirect region we need to go to get to the one that</span>
<span class="cm">	maps a particular filesystem block.</span>
<span class="cm">	</span>
<span class="cm">	We do this in two stages. First we calculate which of the</span>
<span class="cm">	inode addresses in the double-indirect block will point us</span>
<span class="cm">	to the indirect block that contains the mapping for the data,</span>
<span class="cm">	then we calculate which of the inode addresses in that </span>
<span class="cm">	indirect block maps the data block we are after.</span>
<span class="cm">	</span>
<span class="cm">	Oh, and once we&#39;ve done that, we actually read in the blocks </span>
<span class="cm">	that contain the inode addresses we calculated above. Even </span>
<span class="cm">	though the double-indirect run may be several blocks long, </span>
<span class="cm">	we can calculate which of those blocks will contain the index</span>
<span class="cm">	we are after and only read that one. We then follow it to </span>
<span class="cm">	the indirect block and perform a  similar process to find</span>
<span class="cm">	the actual block run that maps the data block we are interested</span>
<span class="cm">	in.</span>
<span class="cm">	</span>
<span class="cm">	Then we offset the run as in befs_find_brun_array() and we are </span>
<span class="cm">	done.</span>
<span class="cm">	</span>
<span class="cm">	2001-11-15 Will Dyson</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">befs_find_brun_dblindirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			   <span class="n">befs_data_stream</span> <span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="n">befs_blocknr_t</span> <span class="n">blockno</span><span class="p">,</span>
			   <span class="n">befs_block_run</span> <span class="o">*</span> <span class="n">run</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">dblindir_indx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">indir_indx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dbl_which_block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">which_block</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dbl_block_indx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block_indx</span><span class="p">;</span>
	<span class="kt">off_t</span> <span class="n">dblindir_leftover</span><span class="p">;</span>
	<span class="n">befs_blocknr_t</span> <span class="n">blockno_at_run_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">dbl_indir_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">indir_block</span><span class="p">;</span>
	<span class="n">befs_block_run</span> <span class="n">indir_run</span><span class="p">;</span>
	<span class="n">befs_disk_inode_addr</span> <span class="o">*</span><span class="n">iaddr_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">befs_sb_info</span> <span class="o">*</span><span class="n">befs_sb</span> <span class="o">=</span> <span class="n">BEFS_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">befs_blocknr_t</span> <span class="n">indir_start_blk</span> <span class="o">=</span>
	    <span class="n">data</span><span class="o">-&gt;</span><span class="n">max_indirect_range</span> <span class="o">&gt;&gt;</span> <span class="n">befs_sb</span><span class="o">-&gt;</span><span class="n">block_shift</span><span class="p">;</span>

	<span class="kt">off_t</span> <span class="n">dbl_indir_off</span> <span class="o">=</span> <span class="n">blockno</span> <span class="o">-</span> <span class="n">indir_start_blk</span><span class="p">;</span>

	<span class="cm">/* number of data blocks mapped by each of the iaddrs in</span>
<span class="cm">	 * the indirect block pointed to by the double indirect block</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span> <span class="n">iblklen</span> <span class="o">=</span> <span class="n">BEFS_DBLINDIR_BRUN_LEN</span><span class="p">;</span>

	<span class="cm">/* number of data blocks mapped by each of the iaddrs in</span>
<span class="cm">	 * the double indirect block</span>
<span class="cm">	 */</span>
	<span class="kt">size_t</span> <span class="n">diblklen</span> <span class="o">=</span> <span class="n">iblklen</span> <span class="o">*</span> <span class="n">befs_iaddrs_per_block</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span>
	    <span class="o">*</span> <span class="n">BEFS_DBLINDIR_BRUN_LEN</span><span class="p">;</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;---&gt; befs_find_brun_dblindirect() find %lu&quot;</span><span class="p">,</span> <span class="n">blockno</span><span class="p">);</span>

	<span class="cm">/* First, discover which of the double_indir-&gt;indir blocks</span>
<span class="cm">	 * contains pos. Then figure out how much of pos that</span>
<span class="cm">	 * accounted for. Then discover which of the iaddrs in</span>
<span class="cm">	 * the indirect block contains pos.</span>
<span class="cm">	 */</span>

	<span class="n">dblindir_indx</span> <span class="o">=</span> <span class="n">dbl_indir_off</span> <span class="o">/</span> <span class="n">diblklen</span><span class="p">;</span>
	<span class="n">dblindir_leftover</span> <span class="o">=</span> <span class="n">dbl_indir_off</span> <span class="o">%</span> <span class="n">diblklen</span><span class="p">;</span>
	<span class="n">indir_indx</span> <span class="o">=</span> <span class="n">dblindir_leftover</span> <span class="o">/</span> <span class="n">diblklen</span><span class="p">;</span>

	<span class="cm">/* Read double indirect block */</span>
	<span class="n">dbl_which_block</span> <span class="o">=</span> <span class="n">dblindir_indx</span> <span class="o">/</span> <span class="n">befs_iaddrs_per_block</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbl_which_block</span> <span class="o">&gt;</span> <span class="n">data</span><span class="o">-&gt;</span><span class="n">double_indirect</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;The double-indirect index calculated by &quot;</span>
			   <span class="s">&quot;befs_read_brun_dblindirect(), %d, is outside the range &quot;</span>
			   <span class="s">&quot;of the double-indirect block&quot;</span><span class="p">,</span> <span class="n">dblindir_indx</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbl_indir_block</span> <span class="o">=</span>
	    <span class="n">befs_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">iaddr2blockno</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">double_indirect</span><span class="p">)</span> <span class="o">+</span>
					<span class="n">dbl_which_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dbl_indir_block</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;befs_read_brun_dblindirect() couldn&#39;t read the &quot;</span>
			   <span class="s">&quot;double-indirect block at blockno %lu&quot;</span><span class="p">,</span>
			   <span class="n">iaddr2blockno</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">data</span><span class="o">-&gt;</span><span class="n">double_indirect</span><span class="p">)</span> <span class="o">+</span>
			   <span class="n">dbl_which_block</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">dbl_indir_block</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dbl_block_indx</span> <span class="o">=</span>
	    <span class="n">dblindir_indx</span> <span class="o">-</span> <span class="p">(</span><span class="n">dbl_which_block</span> <span class="o">*</span> <span class="n">befs_iaddrs_per_block</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="n">iaddr_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">befs_disk_inode_addr</span> <span class="o">*</span><span class="p">)</span> <span class="n">dbl_indir_block</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">indir_run</span> <span class="o">=</span> <span class="n">fsrun_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">iaddr_array</span><span class="p">[</span><span class="n">dbl_block_indx</span><span class="p">]);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">dbl_indir_block</span><span class="p">);</span>
	<span class="n">iaddr_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Read indirect block */</span>
	<span class="n">which_block</span> <span class="o">=</span> <span class="n">indir_indx</span> <span class="o">/</span> <span class="n">befs_iaddrs_per_block</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">which_block</span> <span class="o">&gt;</span> <span class="n">indir_run</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;The indirect index calculated by &quot;</span>
			   <span class="s">&quot;befs_read_brun_dblindirect(), %d, is outside the range &quot;</span>
			   <span class="s">&quot;of the indirect block&quot;</span><span class="p">,</span> <span class="n">indir_indx</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">indir_block</span> <span class="o">=</span>
	    <span class="n">befs_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">iaddr2blockno</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">indir_run</span><span class="p">)</span> <span class="o">+</span> <span class="n">which_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">indir_block</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">befs_error</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;befs_read_brun_dblindirect() couldn&#39;t read the &quot;</span>
			   <span class="s">&quot;indirect block at blockno %lu&quot;</span><span class="p">,</span>
			   <span class="n">iaddr2blockno</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">indir_run</span><span class="p">)</span> <span class="o">+</span> <span class="n">which_block</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">indir_block</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">BEFS_ERR</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_indx</span> <span class="o">=</span> <span class="n">indir_indx</span> <span class="o">-</span> <span class="p">(</span><span class="n">which_block</span> <span class="o">*</span> <span class="n">befs_iaddrs_per_block</span><span class="p">(</span><span class="n">sb</span><span class="p">));</span>
	<span class="n">iaddr_array</span> <span class="o">=</span> <span class="p">(</span><span class="n">befs_disk_inode_addr</span> <span class="o">*</span><span class="p">)</span> <span class="n">indir_block</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="o">*</span><span class="n">run</span> <span class="o">=</span> <span class="n">fsrun_to_cpu</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">iaddr_array</span><span class="p">[</span><span class="n">block_indx</span><span class="p">]);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">indir_block</span><span class="p">);</span>
	<span class="n">iaddr_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">blockno_at_run_start</span> <span class="o">=</span> <span class="n">indir_start_blk</span><span class="p">;</span>
	<span class="n">blockno_at_run_start</span> <span class="o">+=</span> <span class="n">diblklen</span> <span class="o">*</span> <span class="n">dblindir_indx</span><span class="p">;</span>
	<span class="n">blockno_at_run_start</span> <span class="o">+=</span> <span class="n">iblklen</span> <span class="o">*</span> <span class="n">indir_indx</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">blockno</span> <span class="o">-</span> <span class="n">blockno_at_run_start</span><span class="p">;</span>

	<span class="n">run</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">run</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">befs_debug</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Found file block %lu in double_indirect[%d][%d],&quot;</span>
		   <span class="s">&quot; double_indirect_leftover = %lu&quot;</span><span class="p">,</span>
		   <span class="n">blockno</span><span class="p">,</span> <span class="n">dblindir_indx</span><span class="p">,</span> <span class="n">indir_indx</span><span class="p">,</span> <span class="n">dblindir_leftover</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">BEFS_OK</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
