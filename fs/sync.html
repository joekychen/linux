<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › sync.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>sync.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * High-level sync()-related operations</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/syscalls.h&gt;</span>
<span class="cp">#include &lt;linux/linkage.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/quotaops.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cp">#define VALID_FLAGS (SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE| \</span>
<span class="cp">			SYNC_FILE_RANGE_WAIT_AFTER)</span>

<span class="cm">/*</span>
<span class="cm"> * Do the filesystem syncing work. For simple filesystems</span>
<span class="cm"> * writeback_inodes_sb(sb) just dirties buffers with inodes so we have to</span>
<span class="cm"> * submit IO for these buffers via __sync_blockdev(). This also speeds up the</span>
<span class="cm"> * wait == 1 case since in that case write_inode() functions do</span>
<span class="cm"> * sync_dirty_buffer() and thus effectively write one block at a time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__sync_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * This should be safe, as we require bdi backing to actually</span>
<span class="cm">	 * write out data in the first place</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">noop_backing_dev_info</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_qcop</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_qcop</span><span class="o">-&gt;</span><span class="n">quota_sync</span><span class="p">)</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_qcop</span><span class="o">-&gt;</span><span class="n">quota_sync</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
		<span class="n">sync_inodes_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">writeback_inodes_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">WB_REASON_SYNC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">sync_fs</span><span class="p">)</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">sync_fs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">__sync_blockdev</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">,</span> <span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out and wait upon all dirty data associated with this</span>
<span class="cm"> * superblock.  Filesystem data as well as the underlying block</span>
<span class="cm"> * device.  Takes the superblock lock.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sync_filesystem</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to be protected against the filesystem going from</span>
<span class="cm">	 * r/o to r/w or vice versa.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rwsem_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">));</span>

	<span class="cm">/*</span>
<span class="cm">	 * No point in syncing out anything if the filesystem is read-only.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__sync_filesystem</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__sync_filesystem</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL_GPL</span><span class="p">(</span><span class="n">sync_filesystem</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_one_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="n">__sync_filesystem</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * Sync all the data for all the filesystems (called by sys_sync() and</span>
<span class="cm"> * emergency sync)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">sync_filesystems</span><span class="p">(</span><span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">iterate_supers</span><span class="p">(</span><span class="n">sync_one_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sync everything.  Start out by waking pdflush, because that writes back</span>
<span class="cm"> * all queues in parallel.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE0</span><span class="p">(</span><span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">wakeup_flusher_threads</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">WB_REASON_SYNC</span><span class="p">);</span>
	<span class="n">sync_filesystems</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">sync_filesystems</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">laptop_mode</span><span class="p">))</span>
		<span class="n">laptop_sync_completion</span><span class="p">();</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">do_sync_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Sync twice to reduce the possibility we skipped some inodes / pages</span>
<span class="cm">	 * because they were temporarily locked</span>
<span class="cm">	 */</span>
	<span class="n">sync_filesystems</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">sync_filesystems</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="s">&quot;Emergency Sync complete</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">emergency_sync</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="n">work</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_WORK</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="n">do_sync_work</span><span class="p">);</span>
		<span class="n">schedule_work</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * sync a single super</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">syncfs</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">sb</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">sync_filesystem</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>

	<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_fsync_range - helper to sync a range of data &amp; metadata to disk</span>
<span class="cm"> * @file:		file to sync</span>
<span class="cm"> * @start:		offset in bytes of the beginning of data range to sync</span>
<span class="cm"> * @end:		offset in bytes of the end of data range (inclusive)</span>
<span class="cm"> * @datasync:		perform only datasync</span>
<span class="cm"> *</span>
<span class="cm"> * Write back data in range @start..@end and metadata for @file to disk.  If</span>
<span class="cm"> * @datasync is set only metadata needed to access modified file data is</span>
<span class="cm"> * written.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">vfs_fsync_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fsync</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_op</span><span class="o">-&gt;</span><span class="n">fsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_fsync_range</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * vfs_fsync - perform a fsync or fdatasync on a file</span>
<span class="cm"> * @file:		file to sync</span>
<span class="cm"> * @datasync:		only perform a fdatasync operation</span>
<span class="cm"> *</span>
<span class="cm"> * Write back data and metadata for @file to disk.  If @datasync is</span>
<span class="cm"> * set only metadata needed to access modified file data is written.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">vfs_fsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">vfs_fsync_range</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LLONG_MAX</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">vfs_fsync</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_fsync</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>

	<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">vfs_fsync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>
		<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">fsync</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SYSCALL_DEFINE1</span><span class="p">(</span><span class="n">fdatasync</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">do_fsync</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * generic_write_sync - perform syncing after a write if file / inode is sync</span>
<span class="cm"> * @file:	file to which the write happened</span>
<span class="cm"> * @pos:	offset where the write started</span>
<span class="cm"> * @count:	length of the write</span>
<span class="cm"> *</span>
<span class="cm"> * This is just a simple wrapper about our general syncing function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">generic_write_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DSYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">vfs_fsync_range</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">__O_SYNC</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">generic_write_sync</span><span class="p">);</span>

<span class="cm">/*</span>
<span class="cm"> * sys_sync_file_range() permits finely controlled syncing over a segment of</span>
<span class="cm"> * a file in the range offset .. (offset+nbytes-1) inclusive.  If nbytes is</span>
<span class="cm"> * zero then sys_sync_file_range() will operate from offset out to EOF.</span>
<span class="cm"> *</span>
<span class="cm"> * The flag bits are:</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WAIT_BEFORE: wait upon writeout of all pages in the range</span>
<span class="cm"> * before performing the write.</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WRITE: initiate writeout of all those dirty pages in the</span>
<span class="cm"> * range which are not presently under writeback. Note that this may block for</span>
<span class="cm"> * significant periods due to exhaustion of disk request structures.</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WAIT_AFTER: wait upon writeout of all pages in the range</span>
<span class="cm"> * after performing the write.</span>
<span class="cm"> *</span>
<span class="cm"> * Useful combinations of the flag bits are:</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE: ensures that all pages</span>
<span class="cm"> * in the range which were dirty on entry to sys_sync_file_range() are placed</span>
<span class="cm"> * under writeout.  This is a start-write-for-data-integrity operation.</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WRITE: start writeout of all dirty pages in the range which</span>
<span class="cm"> * are not presently under writeout.  This is an asynchronous flush-to-disk</span>
<span class="cm"> * operation.  Not suitable for data integrity operations.</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WAIT_BEFORE (or SYNC_FILE_RANGE_WAIT_AFTER): wait for</span>
<span class="cm"> * completion of writeout of all pages in the range.  This will be used after an</span>
<span class="cm"> * earlier SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE operation to wait</span>
<span class="cm"> * for that operation to complete and to return the result.</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WAIT_BEFORE|SYNC_FILE_RANGE_WRITE|SYNC_FILE_RANGE_WAIT_AFTER:</span>
<span class="cm"> * a traditional sync() operation.  This is a write-for-data-integrity operation</span>
<span class="cm"> * which will ensure that all pages in the range which were dirty on entry to</span>
<span class="cm"> * sys_sync_file_range() are committed to disk.</span>
<span class="cm"> *</span>
<span class="cm"> *</span>
<span class="cm"> * SYNC_FILE_RANGE_WAIT_BEFORE and SYNC_FILE_RANGE_WAIT_AFTER will detect any</span>
<span class="cm"> * I/O errors or ENOSPC conditions and will return those to the caller, after</span>
<span class="cm"> * clearing the EIO and ENOSPC flags in the address_space.</span>
<span class="cm"> *</span>
<span class="cm"> * It should be noted that none of these operations write out the file&#39;s</span>
<span class="cm"> * metadata.  So unless the application is strictly performing overwrites of</span>
<span class="cm"> * already-instantiated disk blocks, there are no guarantees here that the data</span>
<span class="cm"> * will be available after a crash.</span>
<span class="cm"> */</span>
<span class="n">SYSCALL_DEFINE</span><span class="p">(</span><span class="n">sync_file_range</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">nbytes</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">endbyte</span><span class="p">;</span>			<span class="cm">/* inclusive */</span>
	<span class="kt">int</span> <span class="n">fput_needed</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">i_mode</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">VALID_FLAGS</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">endbyte</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">nbytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">s64</span><span class="p">)</span><span class="n">endbyte</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">endbyte</span> <span class="o">&lt;</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">pgoff_t</span><span class="p">)</span> <span class="o">==</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mh">0x100000000ULL</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * The range starts outside a 32 bit machine&#39;s</span>
<span class="cm">			 * pagecache addressing capabilities.  Let it &quot;succeed&quot;</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">endbyte</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="mh">0x100000000ULL</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Out to EOF</span>
<span class="cm">			 */</span>
			<span class="n">nbytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nbytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">endbyte</span> <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">endbyte</span><span class="o">--</span><span class="p">;</span>		<span class="cm">/* inclusive */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
	<span class="n">file</span> <span class="o">=</span> <span class="n">fget_light</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fput_needed</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">i_mode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ESPIPE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			<span class="o">!</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">mapping</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SYNC_FILE_RANGE_WAIT_BEFORE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">filemap_fdatawait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">endbyte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SYNC_FILE_RANGE_WRITE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">filemap_fdatawrite_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">endbyte</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">SYNC_FILE_RANGE_WAIT_AFTER</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">filemap_fdatawait_range</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">endbyte</span><span class="p">);</span>

<span class="nl">out_put:</span>
	<span class="n">fput_light</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">fput_needed</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_HAVE_SYSCALL_WRAPPERS</span>
<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">SyS_sync_file_range</span><span class="p">(</span><span class="kt">long</span> <span class="n">fd</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">nbytes</span><span class="p">,</span>
				    <span class="kt">long</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SYSC_sync_file_range</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">fd</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span>
				    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SYSCALL_ALIAS</span><span class="p">(</span><span class="n">sys_sync_file_range</span><span class="p">,</span> <span class="n">SyS_sync_file_range</span><span class="p">);</span>
<span class="cp">#endif</span>

<span class="cm">/* It would be nice if people remember that not all the world&#39;s an i386</span>
<span class="cm">   when they introduce new system calls */</span>
<span class="n">SYSCALL_DEFINE</span><span class="p">(</span><span class="n">sync_file_range2</span><span class="p">)(</span><span class="kt">int</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">sys_sync_file_range</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>
<span class="cp">#ifdef CONFIG_HAVE_SYSCALL_WRAPPERS</span>
<span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">SyS_sync_file_range2</span><span class="p">(</span><span class="kt">long</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">,</span>
				     <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">nbytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">SYSC_sync_file_range2</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span> <span class="n">fd</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span> <span class="n">flags</span><span class="p">,</span>
				     <span class="n">offset</span><span class="p">,</span> <span class="n">nbytes</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">SYSCALL_ALIAS</span><span class="p">(</span><span class="n">sys_sync_file_range2</span><span class="p">,</span> <span class="n">SyS_sync_file_range2</span><span class="p">);</span>
<span class="cp">#endif</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
