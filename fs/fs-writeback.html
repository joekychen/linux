<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › fs-writeback.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>fs-writeback.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * fs/fs-writeback.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2002, Linus Torvalds.</span>
<span class="cm"> *</span>
<span class="cm"> * Contains all the functions related to writing back and waiting</span>
<span class="cm"> * upon dirty inodes against superblocks, and writing back dirty</span>
<span class="cm"> * pages against inodes.  ie: data writeback.  Writeout of the</span>
<span class="cm"> * inode itself is not handled here.</span>
<span class="cm"> *</span>
<span class="cm"> * 10Apr2002	Andrew Morton</span>
<span class="cm"> *		Split out of fs/inode.c</span>
<span class="cm"> *		Additions for address_space-based writeback</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/mm.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/tracepoint.h&gt;</span>
<span class="cp">#include &quot;internal.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * 4MB minimal write chunk size</span>
<span class="cm"> */</span>
<span class="cp">#define MIN_WRITEBACK_PAGES	(4096UL &gt;&gt; (PAGE_CACHE_SHIFT - 10))</span>

<span class="cm">/*</span>
<span class="cm"> * Passed into wb_writeback(), essentially a subset of writeback_control</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="p">{</span>
	<span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">older_than_this</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">writeback_sync_modes</span> <span class="n">sync_mode</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">tagged_writepages</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">for_kupdate</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">range_cyclic</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">for_background</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">;</span>		<span class="cm">/* why was writeback initiated? */</span>

	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>		<span class="cm">/* pending work list */</span>
	<span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="n">done</span><span class="p">;</span>	<span class="cm">/* set if the caller waits */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * We don&#39;t actually have pdflush, but this one is exported though /proc...</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="n">nr_pdflush_threads</span><span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * writeback_in_progress - determine whether there is writeback in progress</span>
<span class="cm"> * @bdi: the device&#39;s backing_dev_info structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Determine whether there is writeback waiting to be handled against a</span>
<span class="cm"> * backing device.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">writeback_in_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BDI_writeback_running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="nf">inode_to_bdi</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_type</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;bdev&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">wb_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_wb_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Include the creation of the trace points after defining the</span>
<span class="cm"> * wb_writeback_work structure and inline functions so that the definition</span>
<span class="cm"> * remains local to this file.</span>
<span class="cm"> */</span>
<span class="cp">#define CREATE_TRACE_POINTS</span>
<span class="cp">#include &lt;trace/events/writeback.h&gt;</span>

<span class="cm">/* Wakeup flusher thread or forker thread to fork it. Requires bdi-&gt;wb_lock. */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_wakeup_flusher</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * The bdi thread isn&#39;t there, wake up the forker thread which</span>
<span class="cm">		 * will create and run it.</span>
<span class="cm">		 */</span>
		<span class="n">wake_up_process</span><span class="p">(</span><span class="n">default_backing_dev_info</span><span class="p">.</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">bdi_queue_work</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">trace_writeback_queue</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">)</span>
		<span class="n">trace_writeback_nothread</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">bdi_wakeup_flusher</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__bdi_start_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
		      <span class="n">bool</span> <span class="n">range_cyclic</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is WB_SYNC_NONE writeback, so if allocation fails just</span>
<span class="cm">	 * wakeup the thread for old dirty data writeback</span>
<span class="cm">	 */</span>
	<span class="n">work</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">work</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">work</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trace_writeback_nowork</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
			<span class="n">wake_up_process</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">task</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">work</span><span class="o">-&gt;</span><span class="n">sync_mode</span>	<span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">;</span>
	<span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span>	<span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">work</span><span class="o">-&gt;</span><span class="n">range_cyclic</span> <span class="o">=</span> <span class="n">range_cyclic</span><span class="p">;</span>
	<span class="n">work</span><span class="o">-&gt;</span><span class="n">reason</span>	<span class="o">=</span> <span class="n">reason</span><span class="p">;</span>

	<span class="n">bdi_queue_work</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bdi_start_writeback - start writeback</span>
<span class="cm"> * @bdi: the backing device to write from</span>
<span class="cm"> * @nr_pages: the number of pages to write</span>
<span class="cm"> * @reason: reason why some writeback work was initiated</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   This does WB_SYNC_NONE opportunistic writeback. The IO is only</span>
<span class="cm"> *   started when this function returns, we make no guarantees on</span>
<span class="cm"> *   completion. Caller need not hold sb s_umount semaphore.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bdi_start_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
			<span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__bdi_start_writeback</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bdi_start_background_writeback - start background writeback</span>
<span class="cm"> * @bdi: the backing device to write from</span>
<span class="cm"> *</span>
<span class="cm"> * Description:</span>
<span class="cm"> *   This makes sure WB_SYNC_NONE background writeback happens. When</span>
<span class="cm"> *   this function returns, it is only guaranteed that for given BDI</span>
<span class="cm"> *   some IO is happening if we are over background dirty threshold.</span>
<span class="cm"> *   Caller need not hold sb s_umount semaphore.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bdi_start_background_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * We just wake up the flusher thread. It will perform background</span>
<span class="cm">	 * writeback as soon as there is no other work to do.</span>
<span class="cm">	 */</span>
	<span class="n">trace_writeback_wake_background</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
	<span class="n">bdi_wakeup_flusher</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Remove the inode from the writeback list it is on.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inode_wb_list_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">inode_to_bdi</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">list_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Redirty an inode: set its when-it-was dirtied timestamp and move it to the</span>
<span class="cm"> * furthest end of its superblock&#39;s dirty-inode list.</span>
<span class="cm"> *</span>
<span class="cm"> * Before stamping the inode&#39;s -&gt;dirtied_when, we check to see whether it is</span>
<span class="cm"> * already the most-recently-dirtied inode on the b_dirty list.  If that is</span>
<span class="cm"> * the case then the inode must have been redirtied while it was being written</span>
<span class="cm"> * out and we don&#39;t reset its dirtied_when.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">redirty_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_dirty</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>

		<span class="n">tail</span> <span class="o">=</span> <span class="n">wb_inode</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_dirty</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">dirtied_when</span><span class="p">,</span> <span class="n">tail</span><span class="o">-&gt;</span><span class="n">dirtied_when</span><span class="p">))</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">dirtied_when</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_dirty</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * requeue inode for re-scanning after bdi-&gt;b_io list is exhausted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">requeue_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_sync_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I_SYNC</span><span class="p">;</span>
	<span class="cm">/* Waiters must see I_SYNC cleared before being woken up */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">wake_up_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_SYNC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">inode_dirtied_after</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">time_after</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">dirtied_when</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="cp">#ifndef CONFIG_64BIT</span>
	<span class="cm">/*</span>
<span class="cm">	 * For inodes being constantly redirtied, dirtied_when can get stuck.</span>
<span class="cm">	 * It _appears_ to be in the future, but is actually in distant past.</span>
<span class="cm">	 * This test is necessary to prevent such wrapped-around relative times</span>
<span class="cm">	 * from permanently stopping the whole bdi writeback.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">time_before_eq</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">dirtied_when</span><span class="p">,</span> <span class="n">jiffies</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Move expired (dirtied after work-&gt;older_than_this) dirty inodes from</span>
<span class="cm"> * @delaying_queue to @dispatch_queue.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">move_expired_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">delaying_queue</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dispatch_queue</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">,</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">do_sb_sort</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">moved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">delaying_queue</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">wb_inode</span><span class="p">(</span><span class="n">delaying_queue</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">older_than_this</span> <span class="o">&amp;&amp;</span>
		    <span class="n">inode_dirtied_after</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">older_than_this</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span> <span class="o">&amp;&amp;</span> <span class="n">sb</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span>
			<span class="n">do_sb_sort</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">);</span>
		<span class="n">moved</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* just one sb in list, splice to dispatch_queue and we&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">do_sb_sort</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_splice</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">dispatch_queue</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Move inodes from one superblock together */</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sb</span> <span class="o">=</span> <span class="n">wb_inode</span><span class="p">(</span><span class="n">tmp</span><span class="p">.</span><span class="n">prev</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
		<span class="n">list_for_each_prev_safe</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">wb_inode</span><span class="p">(</span><span class="n">pos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">==</span> <span class="n">sb</span><span class="p">)</span>
				<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">,</span> <span class="n">dispatch_queue</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">moved</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Queue all expired dirty inodes for io, eldest first.</span>
<span class="cm"> * Before</span>
<span class="cm"> *         newly dirtied     b_dirty    b_io    b_more_io</span>
<span class="cm"> *         =============&gt;    gf         edc     BA</span>
<span class="cm"> * After</span>
<span class="cm"> *         newly dirtied     b_dirty    b_io    b_more_io</span>
<span class="cm"> *         =============&gt;    g          fBAedc</span>
<span class="cm"> *                                           |</span>
<span class="cm"> *                                           +--&gt; dequeue for IO</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">queue_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">moved</span><span class="p">;</span>
	<span class="n">assert_spin_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">);</span>
	<span class="n">moved</span> <span class="o">=</span> <span class="n">move_expired_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">trace_writeback_queue_io</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">,</span> <span class="n">moved</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_inode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for writeback on an inode to complete. Called with i_lock held.</span>
<span class="cm"> * Caller must make sure inode cannot go away when we drop i_lock.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__inode_wait_for_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT_BIT</span><span class="p">(</span><span class="n">wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_SYNC</span><span class="p">);</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span><span class="p">;</span>

	<span class="n">wqh</span> <span class="o">=</span> <span class="n">bit_waitqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_SYNC</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">__wait_on_bit</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wq</span><span class="p">,</span> <span class="n">inode_wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Wait for writeback on an inode to complete. Caller must have inode pinned.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">inode_wait_for_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="n">__inode_wait_for_writeback</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Sleep until I_SYNC is cleared. This function must be called with i_lock</span>
<span class="cm"> * held and drops it. It is aimed for callers not holding any inode reference</span>
<span class="cm"> * so once i_lock is dropped, inode can go away.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_sleep_on_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">wait_queue_head_t</span> <span class="o">*</span><span class="n">wqh</span> <span class="o">=</span> <span class="n">bit_waitqueue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">,</span> <span class="n">__I_SYNC</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">sleep</span><span class="p">;</span>

	<span class="n">prepare_to_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">sleep</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sleep</span><span class="p">)</span>
		<span class="n">schedule</span><span class="p">();</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="n">wqh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find proper writeback list for the inode depending on its current state and</span>
<span class="cm"> * possibly also change of its state while we were doing writeback.  Here we</span>
<span class="cm"> * handle things such as livelock prevention or fairness of writeback among</span>
<span class="cm"> * inodes. This function can be called only by flusher thread - noone else</span>
<span class="cm"> * processes all inodes in writeback lists and requeueing inodes behind flusher</span>
<span class="cm"> * thread&#39;s back can have unexpected consequences.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">requeue_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_FREEING</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Sync livelock prevention. Each inode is tagged and synced in one</span>
<span class="cm">	 * shot. If still dirty, it will be redirty_tail()&#39;ed below.  Update</span>
<span class="cm">	 * the dirty time to prevent enqueue and sync it again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">dirtied_when</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">pages_skipped</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * writeback is not making progress due to locked</span>
<span class="cm">		 * buffers. Skip this inode for now.</span>
<span class="cm">		 */</span>
		<span class="n">redirty_tail</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mapping_tagged</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We didn&#39;t write back all the pages.  nfs_writepages()</span>
<span class="cm">		 * sometimes bales out without doing anything.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Slice used up. Queue for next turn. */</span>
			<span class="n">requeue_io</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Writeback blocked by something other than</span>
<span class="cm">			 * congestion. Delay the inode for some time to</span>
<span class="cm">			 * avoid spinning on the CPU (100% iowait)</span>
<span class="cm">			 * retrying writeback of the dirty page/inode</span>
<span class="cm">			 * that cannot be performed immediately.</span>
<span class="cm">			 */</span>
			<span class="n">redirty_tail</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Filesystems can dirty the inode during writeback operations,</span>
<span class="cm">		 * such as delayed allocation during submission or metadata</span>
<span class="cm">		 * updates after data IO completion.</span>
<span class="cm">		 */</span>
		<span class="n">redirty_tail</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* The inode is clean. Remove from writeback lists. */</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out an inode and its dirty pages. Do not update the writeback list</span>
<span class="cm"> * linkage. That is left to the caller. The caller is also responsible for</span>
<span class="cm"> * setting I_SYNC flag and calling inode_sync_complete() to clear it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">__writeback_single_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">nr_to_write</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">dirty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_writepages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure to wait on the data before writing out the metadata.</span>
<span class="cm">	 * This is important for filesystems that modify metadata on data</span>
<span class="cm">	 * I/O completion.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">filemap_fdatawait</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Some filesystems may redirty the inode during the writeback</span>
<span class="cm">	 * due to delalloc, clear dirty metadata flags right before</span>
<span class="cm">	 * write_inode()</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="cm">/* Clear I_DIRTY_PAGES if we&#39;ve written out all dirty pages */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping_tagged</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">))</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">I_DIRTY_PAGES</span><span class="p">;</span>
	<span class="n">dirty</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">I_DIRTY_SYNC</span> <span class="o">|</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="cm">/* Don&#39;t write the inode if only I_DIRTY_PAGES was set */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dirty</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_DIRTY_SYNC</span> <span class="o">|</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">write_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">trace_writeback_single_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wbc</span><span class="p">,</span> <span class="n">nr_to_write</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write out an inode&#39;s dirty pages. Either the caller has an active reference</span>
<span class="cm"> * on the inode or the inode has I_WILL_FREE set.</span>
<span class="cm"> *</span>
<span class="cm"> * This function is designed to be called for writing back one inode which</span>
<span class="cm"> * we go e.g. from filesystem. Flusher thread uses __writeback_single_inode()</span>
<span class="cm"> * and does more profound writeback list handling in writeback_sb_inodes().</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">writeback_single_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">))</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_WILL_FREE</span><span class="o">|</span><span class="n">I_FREEING</span><span class="p">)));</span>
	<span class="k">else</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_WILL_FREE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * It&#39;s a data-integrity sync. We must wait. Since callers hold</span>
<span class="cm">		 * inode reference or inode has I_WILL_FREE set, it cannot go</span>
<span class="cm">		 * away under us.</span>
<span class="cm">		 */</span>
		<span class="n">__inode_wait_for_writeback</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Skip inode if it is clean. We don&#39;t want to mess with writeback</span>
<span class="cm">	 * lists in this function since flusher thread may be doing for example</span>
<span class="cm">	 * sync in parallel and if we move the inode, it could get skipped. So</span>
<span class="cm">	 * here we make sure inode is on some writeback list and leave it there</span>
<span class="cm">	 * unless we have completely cleaned the inode.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_SYNC</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__writeback_single_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * If inode is clean, remove it from writeback lists. Otherwise don&#39;t</span>
<span class="cm">	 * touch it. See comment above for explanation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">))</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">inode_sync_complete</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">writeback_chunk_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">pages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * WB_SYNC_ALL mode does livelock avoidance by syncing dirty</span>
<span class="cm">	 * inodes/pages in one big loop. Setting wbc.nr_to_write=LONG_MAX</span>
<span class="cm">	 * here avoids calling into writeback_inodes_wb() more than once.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The intended call sequence for WB_SYNC_ALL writeback is:</span>
<span class="cm">	 *</span>
<span class="cm">	 *      wb_writeback()</span>
<span class="cm">	 *          writeback_sb_inodes()       &lt;== called only once</span>
<span class="cm">	 *              write_cache_pages()     &lt;== called once for each inode</span>
<span class="cm">	 *                   (quickly) tag currently dirty pages</span>
<span class="cm">	 *                   (maybe slowly) sync all tagged pages</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span> <span class="o">||</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">)</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">avg_write_bandwidth</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span>
			    <span class="n">global_dirty_limit</span> <span class="o">/</span> <span class="n">DIRTY_SCOPE</span><span class="p">);</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">);</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">pages</span> <span class="o">+</span> <span class="n">MIN_WRITEBACK_PAGES</span><span class="p">,</span>
				   <span class="n">MIN_WRITEBACK_PAGES</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Write a portion of b_io inodes which belong to @sb.</span>
<span class="cm"> *</span>
<span class="cm"> * If @only_this_sb is true, then find and write all such</span>
<span class="cm"> * inodes. Otherwise write only ones which go sequentially</span>
<span class="cm"> * in reverse order.</span>
<span class="cm"> *</span>
<span class="cm"> * Return the number of pages and/or inodes written.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">writeback_sb_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sync_mode</span>		<span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">sync_mode</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tagged_writepages</span>	<span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">tagged_writepages</span><span class="p">,</span>
		<span class="p">.</span><span class="n">for_kupdate</span>		<span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">for_kupdate</span><span class="p">,</span>
		<span class="p">.</span><span class="n">for_background</span>		<span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">for_background</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_cyclic</span>		<span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">range_cyclic</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_start</span>		<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_end</span>		<span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">,</span>
	<span class="p">};</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">write_chunk</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">wrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* count both pages and inodes */</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">wb_inode</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * We only want to write back data for this</span>
<span class="cm">				 * superblock, move all inodes not belonging</span>
<span class="cm">				 * to it back onto the dirty list.</span>
<span class="cm">				 */</span>
				<span class="n">redirty_tail</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * The inode belongs to a different superblock.</span>
<span class="cm">			 * Bounce back to the caller to unpin this and</span>
<span class="cm">			 * pin the next superblock.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Don&#39;t bother with new inodes or inodes beeing freed, first</span>
<span class="cm">		 * kind does not need peridic writeout yet, and for the latter</span>
<span class="cm">		 * kind writeout is handled by the freer.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_NEW</span> <span class="o">|</span> <span class="n">I_FREEING</span> <span class="o">|</span> <span class="n">I_WILL_FREE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">redirty_tail</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">wbc</span><span class="p">.</span><span class="n">sync_mode</span> <span class="o">!=</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If this inode is locked for writeback and we are not</span>
<span class="cm">			 * doing writeback-for-data-integrity, move it to</span>
<span class="cm">			 * b_more_io so that writeback can proceed with the</span>
<span class="cm">			 * other inodes on s_io.</span>
<span class="cm">			 *</span>
<span class="cm">			 * We&#39;ll have another go at writing back this inode</span>
<span class="cm">			 * when we completed a full scan of b_io.</span>
<span class="cm">			 */</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">requeue_io</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
			<span class="n">trace_writeback_sb_inodes_requeue</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We already requeued the inode if it had I_SYNC set and we</span>
<span class="cm">		 * are doing WB_SYNC_NONE writeback. So this catches only the</span>
<span class="cm">		 * WB_SYNC_ALL case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Wait for I_SYNC. This function drops i_lock... */</span>
			<span class="n">inode_sleep_on_writeback</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="cm">/* Inode may be gone, start again */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">I_SYNC</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

		<span class="n">write_chunk</span> <span class="o">=</span> <span class="n">writeback_chunk_size</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="n">wbc</span><span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">write_chunk</span><span class="p">;</span>
		<span class="n">wbc</span><span class="p">.</span><span class="n">pages_skipped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * We use I_SYNC to pin the inode in memory. While it is set</span>
<span class="cm">		 * evict_inode() will wait so the inode cannot be freed.</span>
<span class="cm">		 */</span>
		<span class="n">__writeback_single_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>

		<span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">-=</span> <span class="n">write_chunk</span> <span class="o">-</span> <span class="n">wbc</span><span class="p">.</span><span class="n">nr_to_write</span><span class="p">;</span>
		<span class="n">wrote</span> <span class="o">+=</span> <span class="n">write_chunk</span> <span class="o">-</span> <span class="n">wbc</span><span class="p">.</span><span class="n">nr_to_write</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">))</span>
			<span class="n">wrote</span><span class="o">++</span><span class="p">;</span>
		<span class="n">requeue_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
		<span class="n">inode_sync_complete</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">cond_resched_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * bail out to wb_writeback() often enough to check</span>
<span class="cm">		 * background threshold and other termination conditions.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wrote</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_jiffies</span><span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10UL</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">wrote</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">__writeback_inodes_wb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">wrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">wb_inode</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">grab_super_passive</span><span class="p">(</span><span class="n">sb</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * grab_super_passive() may fail consistently due to</span>
<span class="cm">			 * s_umount being grabbed by someone else. Don&#39;t use</span>
<span class="cm">			 * requeue_io() to avoid busy retrying the inode/sb.</span>
<span class="cm">			 */</span>
			<span class="n">redirty_tail</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wrote</span> <span class="o">+=</span> <span class="n">writeback_sb_inodes</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="n">drop_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="cm">/* refer to the same tests at the end of writeback_sb_inodes */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wrote</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_is_before_jiffies</span><span class="p">(</span><span class="n">start_time</span> <span class="o">+</span> <span class="n">HZ</span> <span class="o">/</span> <span class="mi">10UL</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* Leave any unwritten inodes on b_io */</span>
	<span class="k">return</span> <span class="n">wrote</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">writeback_inodes_wb</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
				<span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="n">work</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">nr_pages</span>	<span class="o">=</span> <span class="n">nr_pages</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sync_mode</span>	<span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_cyclic</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">reason</span>		<span class="o">=</span> <span class="n">reason</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">))</span>
		<span class="n">queue_io</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">__writeback_inodes_wb</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_pages</span> <span class="o">-</span> <span class="n">work</span><span class="p">.</span><span class="n">nr_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">over_bground_thresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">background_thresh</span><span class="p">,</span> <span class="n">dirty_thresh</span><span class="p">;</span>

	<span class="n">global_dirty_limits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">background_thresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dirty_thresh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_DIRTY</span><span class="p">)</span> <span class="o">+</span>
	    <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_UNSTABLE_NFS</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">background_thresh</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bdi_stat</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">BDI_RECLAIMABLE</span><span class="p">)</span> <span class="o">&gt;</span>
				<span class="n">bdi_dirty_limit</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">background_thresh</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called under wb-&gt;list_lock. If there are multiple wb per bdi,</span>
<span class="cm"> * only the flusher working on the first wb should do it.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">wb_update_bandwidth</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_time</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__bdi_update_bandwidth</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start_time</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Explicit flushing or periodic writeback of &quot;old&quot; data.</span>
<span class="cm"> *</span>
<span class="cm"> * Define &quot;old&quot;: the first time one of an inode&#39;s pages is dirtied, we mark the</span>
<span class="cm"> * dirtying-time in the inode&#39;s address_space.  So this periodic writeback code</span>
<span class="cm"> * just walks the superblock inode list, writing back any inodes which are</span>
<span class="cm"> * older than a specific point in time.</span>
<span class="cm"> *</span>
<span class="cm"> * Try to run once per dirty_writeback_interval.  But if a writeback event</span>
<span class="cm"> * takes longer than a dirty_writeback_interval interval, then leave a</span>
<span class="cm"> * one-second gap.</span>
<span class="cm"> *</span>
<span class="cm"> * older_than_this takes precedence over nr_to_write.  So we&#39;ll only write back</span>
<span class="cm"> * all dirty pages if they are all attached to &quot;old&quot; mappings.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">wb_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">wb_start</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">oldest_jif</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">progress</span><span class="p">;</span>

	<span class="n">oldest_jif</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">work</span><span class="o">-&gt;</span><span class="n">older_than_this</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">oldest_jif</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Stop writeback when nr_pages has been consumed</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Background writeout and kupdate-style writeback may</span>
<span class="cm">		 * run forever. Stop them if there is other work to do</span>
<span class="cm">		 * so that e.g. sync can proceed. They&#39;ll be restarted</span>
<span class="cm">		 * after the other works are all done.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">for_background</span> <span class="o">||</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">for_kupdate</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * For background writeout, stop when we are below the</span>
<span class="cm">		 * background dirty threshold</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">for_background</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">over_bground_thresh</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Kupdate and background works are special and we want to</span>
<span class="cm">		 * include all inodes that need writing. Livelock avoidance is</span>
<span class="cm">		 * handled by these works yielding to any other work so we are</span>
<span class="cm">		 * safe.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">for_kupdate</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">oldest_jif</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">-</span>
				<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_expire_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">for_background</span><span class="p">)</span>
			<span class="n">oldest_jif</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="n">trace_writeback_start</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_io</span><span class="p">))</span>
			<span class="n">queue_io</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">)</span>
			<span class="n">progress</span> <span class="o">=</span> <span class="n">writeback_sb_inodes</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">progress</span> <span class="o">=</span> <span class="n">__writeback_inodes_wb</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
		<span class="n">trace_writeback_written</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

		<span class="n">wb_update_bandwidth</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">wb_start</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Did we write something? Try for more</span>
<span class="cm">		 *</span>
<span class="cm">		 * Dirty inodes are moved to b_io for writeback in batches.</span>
<span class="cm">		 * The completion of the current batch does not necessarily</span>
<span class="cm">		 * mean the overall work is done. So we keep looping as long</span>
<span class="cm">		 * as made some progress on cleaning pages or inodes.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">progress</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * No more inodes for IO, bail</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Nothing written. Wait for some inode to</span>
<span class="cm">		 * become available for writeback. Otherwise</span>
<span class="cm">		 * we&#39;ll just busyloop.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">))</span>  <span class="p">{</span>
			<span class="n">trace_writeback_wait</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">wb_inode</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">b_more_io</span><span class="p">.</span><span class="n">prev</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
			<span class="cm">/* This function drops i_lock... */</span>
			<span class="n">inode_sleep_on_writeback</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">nr_pages</span> <span class="o">-</span> <span class="n">work</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Return the next wb_writeback_work struct that hasn&#39;t been processed yet.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span>
<span class="nf">get_next_work_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">spin_lock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">work</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">wb_writeback_work</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_bh</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">work</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add in the number of potentially dirty inodes, because each inode</span>
<span class="cm"> * write can dirty pagecache in the underlying blockdev.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="nf">get_nr_dirty_pages</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_DIRTY</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_UNSTABLE_NFS</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">get_nr_dirty_inodes</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">wb_check_background_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">over_bground_thresh</span><span class="p">(</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">))</span> <span class="p">{</span>

		<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="n">work</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">nr_pages</span>	<span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">,</span>
			<span class="p">.</span><span class="n">sync_mode</span>	<span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
			<span class="p">.</span><span class="n">for_background</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">range_cyclic</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">reason</span>		<span class="o">=</span> <span class="n">WB_REASON_BACKGROUND</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="k">return</span> <span class="n">wb_writeback</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">wb_check_old_data_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expired</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * When set to zero, disable periodic writeback</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dirty_writeback_interval</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">expired</span> <span class="o">=</span> <span class="n">wb</span><span class="o">-&gt;</span><span class="n">last_old_flush</span> <span class="o">+</span>
			<span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">expired</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wb</span><span class="o">-&gt;</span><span class="n">last_old_flush</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">get_nr_dirty_pages</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="n">work</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">nr_pages</span>	<span class="o">=</span> <span class="n">nr_pages</span><span class="p">,</span>
			<span class="p">.</span><span class="n">sync_mode</span>	<span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
			<span class="p">.</span><span class="n">for_kupdate</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">range_cyclic</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
			<span class="p">.</span><span class="n">reason</span>		<span class="o">=</span> <span class="n">WB_REASON_PERIODIC</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="k">return</span> <span class="n">wb_writeback</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Retrieve work items and do the writeback they describe</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">wb_do_writeback</span><span class="p">(</span><span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="o">*</span><span class="n">work</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">wrote</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">BDI_writeback_running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">work</span> <span class="o">=</span> <span class="n">get_next_work_item</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Override sync mode, in case we must wait for completion</span>
<span class="cm">		 * because this thread is exiting now.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">force_wait</span><span class="p">)</span>
			<span class="n">work</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">WB_SYNC_ALL</span><span class="p">;</span>

		<span class="n">trace_writeback_exec</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

		<span class="n">wrote</span> <span class="o">+=</span> <span class="n">wb_writeback</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Notify the caller of completion if this is a synchronous</span>
<span class="cm">		 * work item, otherwise just free it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span>
			<span class="n">complete</span><span class="p">(</span><span class="n">work</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">work</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check for periodic writeback, kupdated() style</span>
<span class="cm">	 */</span>
	<span class="n">wrote</span> <span class="o">+=</span> <span class="n">wb_check_old_data_flush</span><span class="p">(</span><span class="n">wb</span><span class="p">);</span>
	<span class="n">wrote</span> <span class="o">+=</span> <span class="n">wb_check_background_flush</span><span class="p">(</span><span class="n">wb</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">BDI_writeback_running</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">wrote</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Handle writeback of dirty data for the device backed by this bdi. Also</span>
<span class="cm"> * wakes up periodically and does kupdated style flushing.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bdi_writeback_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="n">wb</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">pages_written</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">PF_SWAPWRITE</span><span class="p">;</span>
	<span class="n">set_freezable</span><span class="p">();</span>
	<span class="n">wb</span><span class="o">-&gt;</span><span class="n">last_active</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Our parent may run at a different priority, just set us to normal</span>
<span class="cm">	 */</span>
	<span class="n">set_user_nice</span><span class="p">(</span><span class="n">current</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">trace_writeback_thread_start</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">kthread_freezable_should_stop</span><span class="p">(</span><span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Remove own delayed wake-up timer, since we are already awake</span>
<span class="cm">		 * and we&#39;ll take care of the preriodic write-back.</span>
<span class="cm">		 */</span>
		<span class="n">del_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wb</span><span class="o">-&gt;</span><span class="n">wakeup_timer</span><span class="p">);</span>

		<span class="n">pages_written</span> <span class="o">=</span> <span class="n">wb_do_writeback</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">trace_writeback_pages_written</span><span class="p">(</span><span class="n">pages_written</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">pages_written</span><span class="p">)</span>
			<span class="n">wb</span><span class="o">-&gt;</span><span class="n">last_active</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">)</span> <span class="o">||</span> <span class="n">kthread_should_stop</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">__set_current_state</span><span class="p">(</span><span class="n">TASK_RUNNING</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wb_has_dirty_io</span><span class="p">(</span><span class="n">wb</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">dirty_writeback_interval</span><span class="p">)</span>
			<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">msecs_to_jiffies</span><span class="p">(</span><span class="n">dirty_writeback_interval</span> <span class="o">*</span> <span class="mi">10</span><span class="p">));</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We have nothing to do, so can go sleep without any</span>
<span class="cm">			 * timeout and save power. When a work is queued or</span>
<span class="cm">			 * something is made dirty - we will be woken up.</span>
<span class="cm">			 */</span>
			<span class="n">schedule</span><span class="p">();</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* Flush any work that raced with us exiting */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">work_list</span><span class="p">))</span>
		<span class="n">wb_do_writeback</span><span class="p">(</span><span class="n">wb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">trace_writeback_thread_stop</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * Start writeback of `nr_pages&#39; pages.  If `nr_pages&#39; is zero, write back</span>
<span class="cm"> * the whole world.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">wakeup_flusher_threads</span><span class="p">(</span><span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr_pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_FILE_DIRTY</span><span class="p">)</span> <span class="o">+</span>
				<span class="n">global_page_state</span><span class="p">(</span><span class="n">NR_UNSTABLE_NFS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi_list</span><span class="p">,</span> <span class="n">bdi_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bdi_has_dirty_io</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">__bdi_start_writeback</span><span class="p">(</span><span class="n">bdi</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">block_dump___mark_inode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">||</span> <span class="n">strcmp</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="s">&quot;bdev&quot;</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;?&quot;</span><span class="p">;</span>

		<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span>
		       <span class="s">&quot;%s(%d): dirtied inode %lu (%s) on %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">current</span><span class="o">-&gt;</span><span class="n">comm</span><span class="p">,</span> <span class="n">task_pid_nr</span><span class="p">(</span><span class="n">current</span><span class="p">),</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
		       <span class="n">name</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
			<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> *	__mark_inode_dirty -	internal function</span>
<span class="cm"> *	@inode: inode to mark</span>
<span class="cm"> *	@flags: what kind of dirty (i.e. I_DIRTY_SYNC)</span>
<span class="cm"> *	Mark an inode as dirty. Callers should use mark_inode_dirty or</span>
<span class="cm"> *  	mark_inode_dirty_sync.</span>
<span class="cm"> *</span>
<span class="cm"> * Put the inode on the super block&#39;s dirty list.</span>
<span class="cm"> *</span>
<span class="cm"> * CAREFUL! We mark it dirty unconditionally, but move it onto the</span>
<span class="cm"> * dirty list only if it is hashed or if it refers to a blockdev.</span>
<span class="cm"> * If it was not hashed, it will never be added to the dirty list</span>
<span class="cm"> * even if it is later hashed, as it will have been marked dirty already.</span>
<span class="cm"> *</span>
<span class="cm"> * In short, make sure you hash any inodes _before_ you start marking</span>
<span class="cm"> * them dirty.</span>
<span class="cm"> *</span>
<span class="cm"> * Note that for blockdevs, inode-&gt;dirtied_when represents the dirtying time of</span>
<span class="cm"> * the block-special inode (/dev/hda1) itself.  And the -&gt;dirtied_when field of</span>
<span class="cm"> * the kernel-internal blockdev inode represents the dirtying time of the</span>
<span class="cm"> * blockdev&#39;s pages.  This is why for I_DIRTY_PAGES we always use</span>
<span class="cm"> * page-&gt;mapping-&gt;host, so the page-dirtying time is recorded in the internal</span>
<span class="cm"> * blockdev inode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">__mark_inode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t do this for I_DIRTY_PAGES - that doesn&#39;t actually</span>
<span class="cm">	 * dirty the inode itself</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_DIRTY_SYNC</span> <span class="o">|</span> <span class="n">I_DIRTY_DATASYNC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">dirty_inode</span><span class="p">)</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span><span class="o">-&gt;</span><span class="n">dirty_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure that changes are seen by all cpus before we test i_state</span>
<span class="cm">	 * -- mikulas</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>

	<span class="cm">/* avoid the locking if we can */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">==</span> <span class="n">flags</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">block_dump</span><span class="p">))</span>
		<span class="n">block_dump___mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="o">!=</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="kt">int</span> <span class="n">was_dirty</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_DIRTY</span><span class="p">;</span>

		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">|=</span> <span class="n">flags</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the inode is being synced, just update its dirty state.</span>
<span class="cm">		 * The unlocker will place the inode on the appropriate</span>
<span class="cm">		 * superblock list, based upon its state.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_SYNC</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock_inode</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Only add valid (hashed) inodes to the superblock&#39;s</span>
<span class="cm">		 * dirty list.  Add blockdev inodes as well.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">inode_unhashed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_unlock_inode</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_FREEING</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock_inode</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If the inode was already on b_dirty/b_io/b_more_io, don&#39;t</span>
<span class="cm">		 * reposition it (that would break b_dirty time-ordering).</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">was_dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bool</span> <span class="n">wakeup_bdi</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">bdi</span> <span class="o">=</span> <span class="n">inode_to_bdi</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">bdi_cap_writeback_dirty</span><span class="p">(</span><span class="n">bdi</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">WARN</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BDI_registered</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">),</span>
				     <span class="s">&quot;bdi-%s not registered</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">bdi</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * If this is the first dirty inode for this</span>
<span class="cm">				 * bdi, we have to wake-up the corresponding</span>
<span class="cm">				 * bdi thread to make sure background</span>
<span class="cm">				 * write-back happens later.</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wb_has_dirty_io</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">))</span>
					<span class="n">wakeup_bdi</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">list_lock</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">dirtied_when</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_wb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">b_dirty</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bdi</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">.</span><span class="n">list_lock</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wakeup_bdi</span><span class="p">)</span>
				<span class="n">bdi_wakeup_thread_delayed</span><span class="p">(</span><span class="n">bdi</span><span class="p">);</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_unlock_inode:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>

<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">__mark_inode_dirty</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">wait_sb_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="o">*</span><span class="n">old_inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to be protected against the filesystem going from</span>
<span class="cm">	 * r/o to r/w or vice versa.</span>
<span class="cm">	 */</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rwsem_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">));</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Data integrity sync. Must wait for all pages under writeback,</span>
<span class="cm">	 * because there may have been pages dirtied before our sync</span>
<span class="cm">	 * call, but which had writeout started before we write it out.</span>
<span class="cm">	 * In which case, the inode may not be on the dirty list, but</span>
<span class="cm">	 * we still have to wait for that writeout.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_inodes</span><span class="p">,</span> <span class="n">i_sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">I_FREEING</span><span class="o">|</span><span class="n">I_WILL_FREE</span><span class="o">|</span><span class="n">I_NEW</span><span class="p">))</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">nrpages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">__iget</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We hold a reference to &#39;inode&#39; so it couldn&#39;t have been</span>
<span class="cm">		 * removed from s_inodes list while we dropped the</span>
<span class="cm">		 * inode_sb_list_lock.  We cannot iput the inode now as we can</span>
<span class="cm">		 * be holding the last reference and we cannot iput it under</span>
<span class="cm">		 * inode_sb_list_lock. So we keep the reference and iput it</span>
<span class="cm">		 * later.</span>
<span class="cm">		 */</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>
		<span class="n">old_inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>

		<span class="n">filemap_fdatawait</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode_sb_list_lock</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * writeback_inodes_sb_nr -	writeback dirty inodes from given super_block</span>
<span class="cm"> * @sb: the superblock</span>
<span class="cm"> * @nr: the number of pages to write</span>
<span class="cm"> * @reason: reason why some writeback work initiated</span>
<span class="cm"> *</span>
<span class="cm"> * Start writeback on some inodes on this super_block. No guarantees are made</span>
<span class="cm"> * on how many (if any) will be written, and this function does not wait</span>
<span class="cm"> * for IO completion of submitted IO.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">writeback_inodes_sb_nr</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
			    <span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="n">work</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sb</span>			<span class="o">=</span> <span class="n">sb</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sync_mode</span>		<span class="o">=</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">tagged_writepages</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
		<span class="p">.</span><span class="n">done</span>			<span class="o">=</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_pages</span>		<span class="o">=</span> <span class="n">nr</span><span class="p">,</span>
		<span class="p">.</span><span class="n">reason</span>			<span class="o">=</span> <span class="n">reason</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rwsem_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">));</span>
	<span class="n">bdi_queue_work</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">writeback_inodes_sb_nr</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * writeback_inodes_sb	-	writeback dirty inodes from given super_block</span>
<span class="cm"> * @sb: the superblock</span>
<span class="cm"> * @reason: reason why some writeback work was initiated</span>
<span class="cm"> *</span>
<span class="cm"> * Start writeback on some inodes on this super_block. No guarantees are made</span>
<span class="cm"> * on how many (if any) will be written, and this function does not wait</span>
<span class="cm"> * for IO completion of submitted IO.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">writeback_inodes_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">writeback_inodes_sb_nr</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">get_nr_dirty_pages</span><span class="p">(),</span> <span class="n">reason</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">writeback_inodes_sb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * writeback_inodes_sb_if_idle	-	start writeback if none underway</span>
<span class="cm"> * @sb: the superblock</span>
<span class="cm"> * @reason: reason why some writeback work was initiated</span>
<span class="cm"> *</span>
<span class="cm"> * Invoke writeback_inodes_sb if no writeback is currently underway.</span>
<span class="cm"> * Returns 1 if writeback was started, 0 if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">writeback_inodes_sb_if_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writeback_in_progress</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">writeback_inodes_sb</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">writeback_inodes_sb_if_idle</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * writeback_inodes_sb_nr_if_idle	-	start writeback if none underway</span>
<span class="cm"> * @sb: the superblock</span>
<span class="cm"> * @nr: the number of pages to write</span>
<span class="cm"> * @reason: reason why some writeback work was initiated</span>
<span class="cm"> *</span>
<span class="cm"> * Invoke writeback_inodes_sb if no writeback is currently underway.</span>
<span class="cm"> * Returns 1 if writeback was started, 0 if not.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">writeback_inodes_sb_nr_if_idle</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">,</span>
				   <span class="k">enum</span> <span class="n">wb_reason</span> <span class="n">reason</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">writeback_in_progress</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="n">writeback_inodes_sb_nr</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">reason</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">writeback_inodes_sb_nr_if_idle</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sync_inodes_sb	-	sync sb inode pages</span>
<span class="cm"> * @sb: the superblock</span>
<span class="cm"> *</span>
<span class="cm"> * This function writes and waits on any dirty inode belonging to this</span>
<span class="cm"> * super_block.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">sync_inodes_sb</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">done</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">wb_writeback_work</span> <span class="n">work</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sb</span>		<span class="o">=</span> <span class="n">sb</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sync_mode</span>	<span class="o">=</span> <span class="n">WB_SYNC_ALL</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_pages</span>	<span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_cyclic</span>	<span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">done</span>		<span class="o">=</span> <span class="o">&amp;</span><span class="n">done</span><span class="p">,</span>
		<span class="p">.</span><span class="n">reason</span>		<span class="o">=</span> <span class="n">WB_REASON_SYNC</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">rwsem_is_locked</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_umount</span><span class="p">));</span>

	<span class="n">bdi_queue_work</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">work</span><span class="p">);</span>
	<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">done</span><span class="p">);</span>

	<span class="n">wait_sb_inodes</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sync_inodes_sb</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * write_inode_now	-	write an inode to disk</span>
<span class="cm"> * @inode: inode to write to disk</span>
<span class="cm"> * @sync: whether the write should be synchronous or not</span>
<span class="cm"> *</span>
<span class="cm"> * This function commits an inode to disk immediately if it is dirty. This is</span>
<span class="cm"> * primarily needed by knfsd.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must either have a ref on the inode or must have set I_WILL_FREE.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">write_inode_now</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bdi_writeback</span> <span class="o">*</span><span class="n">wb</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">inode_to_bdi</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="n">LONG_MAX</span><span class="p">,</span>
		<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">sync</span> <span class="o">?</span> <span class="n">WB_SYNC_ALL</span> <span class="o">:</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
		<span class="p">.</span><span class="n">range_end</span> <span class="o">=</span> <span class="n">LLONG_MAX</span><span class="p">,</span>
	<span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping_cap_writeback_dirty</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">))</span>
		<span class="n">wbc</span><span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">might_sleep</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">writeback_single_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">wb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">write_inode_now</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sync_inode - write an inode and its pages to disk.</span>
<span class="cm"> * @inode: the inode to sync</span>
<span class="cm"> * @wbc: controls the writeback mode</span>
<span class="cm"> *</span>
<span class="cm"> * sync_inode() will write an inode and its pages to disk.  It will also</span>
<span class="cm"> * correctly update the inode on its superblock&#39;s dirty inode lists and will</span>
<span class="cm"> * update inode-&gt;i_state.</span>
<span class="cm"> *</span>
<span class="cm"> * The caller must have a ref on the inode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sync_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">writeback_single_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode_to_bdi</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">wb</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sync_inode</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * sync_inode_metadata - write an inode to disk</span>
<span class="cm"> * @inode: the inode to sync</span>
<span class="cm"> * @wait: wait for I/O to complete.</span>
<span class="cm"> *</span>
<span class="cm"> * Write an inode to disk and adjust its dirty state after completion.</span>
<span class="cm"> *</span>
<span class="cm"> * Note: only writes the actual inode, no associated data or other metadata.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">sync_inode_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">writeback_control</span> <span class="n">wbc</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">sync_mode</span> <span class="o">=</span> <span class="n">wait</span> <span class="o">?</span> <span class="n">WB_SYNC_ALL</span> <span class="o">:</span> <span class="n">WB_SYNC_NONE</span><span class="p">,</span>
		<span class="p">.</span><span class="n">nr_to_write</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="cm">/* metadata-only */</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">sync_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">sync_inode_metadata</span><span class="p">);</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
