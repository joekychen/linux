<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › bio-integrity.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../index.html"></a><h1>bio-integrity.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * bio-integrity.c - bio data integrity extensions</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2007, 2008, 2009 Oracle Corporation</span>
<span class="cm"> * Written by: Martin K. Petersen &lt;martin.petersen@oracle.com&gt;</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public License version</span>
<span class="cm"> * 2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful, but</span>
<span class="cm"> * WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; see the file COPYING.  If not, write to</span>
<span class="cm"> * the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139,</span>
<span class="cm"> * USA.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/mempool.h&gt;</span>
<span class="cp">#include &lt;linux/export.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/workqueue.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>

<span class="k">struct</span> <span class="n">integrity_slab</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">slab</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">nr_vecs</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="mi">8</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define IS(x) { .nr_vecs = x, .name = &quot;bip-&quot;__stringify(x) }</span>
<span class="k">struct</span> <span class="n">integrity_slab</span> <span class="n">bip_slab</span><span class="p">[</span><span class="n">BIOVEC_NR_POOLS</span><span class="p">]</span> <span class="n">__read_mostly</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">IS</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">IS</span><span class="p">(</span><span class="mi">4</span><span class="p">),</span> <span class="n">IS</span><span class="p">(</span><span class="mi">16</span><span class="p">),</span> <span class="n">IS</span><span class="p">(</span><span class="mi">64</span><span class="p">),</span> <span class="n">IS</span><span class="p">(</span><span class="mi">128</span><span class="p">),</span> <span class="n">IS</span><span class="p">(</span><span class="n">BIO_MAX_PAGES</span><span class="p">),</span>
<span class="p">};</span>
<span class="cp">#undef IS</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">workqueue_struct</span> <span class="o">*</span><span class="n">kintegrityd_wq</span><span class="p">;</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">vecs_to_idx</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">1</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">2</span> <span class="p">...</span> <span class="mi">4</span>:
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">5</span> <span class="p">...</span> <span class="mi">16</span>:
		<span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">17</span> <span class="p">...</span> <span class="mi">64</span>:
		<span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">65</span> <span class="p">...</span> <span class="mi">128</span>:
		<span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">129</span> <span class="p">...</span> <span class="n">BIO_MAX_PAGES</span>:
		<span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">use_bip_pool</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">idx</span> <span class="o">==</span> <span class="n">BIOVEC_MAX_IDX</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_alloc_bioset - Allocate integrity payload and attach it to bio</span>
<span class="cm"> * @bio:	bio to attach integrity metadata to</span>
<span class="cm"> * @gfp_mask:	Memory allocation mask</span>
<span class="cm"> * @nr_vecs:	Number of integrity metadata scatter-gather elements</span>
<span class="cm"> * @bs:		bio_set to allocate from</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This function prepares a bio for attaching integrity</span>
<span class="cm"> * metadata.  nr_vecs specifies the maximum number of pages containing</span>
<span class="cm"> * integrity metadata that can be attached.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="nf">bio_integrity_alloc_bioset</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
							 <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
							 <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_vecs</span><span class="p">,</span>
							 <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">vecs_to_idx</span><span class="p">(</span><span class="n">nr_vecs</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bio</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">bip</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Lower order allocations come straight from slab */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">use_bip_pool</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
		<span class="n">bip</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">bip_slab</span><span class="p">[</span><span class="n">idx</span><span class="p">].</span><span class="n">slab</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

	<span class="cm">/* Use mempool if lower order alloc failed or max vecs were requested */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">idx</span> <span class="o">=</span> <span class="n">BIOVEC_MAX_IDX</span><span class="p">;</span>  <span class="cm">/* so we free the payload properly later */</span>
		<span class="n">bip</span> <span class="o">=</span> <span class="n">mempool_alloc</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_integrity_pool</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: could not alloc bip</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">bip</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bip</span><span class="p">));</span>

	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_slab</span> <span class="o">=</span> <span class="n">idx</span><span class="p">;</span>
	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span> <span class="o">=</span> <span class="n">bip</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bip</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_alloc_bioset</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_alloc - Allocate integrity payload and attach it to bio</span>
<span class="cm"> * @bio:	bio to attach integrity metadata to</span>
<span class="cm"> * @gfp_mask:	Memory allocation mask</span>
<span class="cm"> * @nr_vecs:	Number of integrity metadata scatter-gather elements</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This function prepares a bio for attaching integrity</span>
<span class="cm"> * metadata.  nr_vecs specifies the maximum number of pages containing</span>
<span class="cm"> * integrity metadata that can be attached.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="nf">bio_integrity_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
						  <span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span>
						  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_vecs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bio_integrity_alloc_bioset</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">nr_vecs</span><span class="p">,</span> <span class="n">fs_bio_set</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_alloc</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_free - Free bio integrity payload</span>
<span class="cm"> * @bio:	bio containing bip to be freed</span>
<span class="cm"> * @bs:		bio_set this bio was allocated from</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Used to free the integrity portion of a bio. Usually</span>
<span class="cm"> * called from bio_free().</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_integrity_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/* A cloned bio doesn&#39;t own the integrity metadata */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_CLONED</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_FS_INTEGRITY</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_buf</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">use_bip_pool</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_slab</span><span class="p">))</span>
		<span class="n">mempool_free</span><span class="p">(</span><span class="n">bip</span><span class="p">,</span> <span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_integrity_pool</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">bip_slab</span><span class="p">[</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_slab</span><span class="p">].</span><span class="n">slab</span><span class="p">,</span> <span class="n">bip</span><span class="p">);</span>

	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_free</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_add_page - Attach integrity metadata</span>
<span class="cm"> * @bio:	bio to update</span>
<span class="cm"> * @page:	page containing integrity metadata</span>
<span class="cm"> * @len:	number of bytes of integrity metadata in page</span>
<span class="cm"> * @offset:	start offset within page</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Attach a page containing integrity metadata to bio.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_integrity_add_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
			   <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">iv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span> <span class="o">&gt;=</span> <span class="n">bvec_nr_vecs</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_slab</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: bip_vec full</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">__func__</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">iv</span> <span class="o">=</span> <span class="n">bip_vec_idx</span><span class="p">(</span><span class="n">bip</span><span class="p">,</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iv</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_add_page</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">bdev_integrity_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">READ</span> <span class="o">&amp;&amp;</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">verify_fn</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INTEGRITY_FLAG_READ</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span> <span class="o">&amp;&amp;</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">generate_fn</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">INTEGRITY_FLAG_WRITE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_enabled - Check whether integrity can be passed</span>
<span class="cm"> * @bio:	bio to check</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Determines whether bio_integrity_prep() can be called</span>
<span class="cm"> * on this bio or not.	bio data direction and target device must be</span>
<span class="cm"> * set prior to calling.  The functions honors the write_generate and</span>
<span class="cm"> * read_verify flags in sysfs.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_integrity_enabled</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Already protected? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">bdev_integrity_enabled</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span> <span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_enabled</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_hw_sectors - Convert 512b sectors to hardware ditto</span>
<span class="cm"> * @bi:		blk_integrity profile for device</span>
<span class="cm"> * @sectors:	Number of 512 sectors to convert</span>
<span class="cm"> *</span>
<span class="cm"> * Description: The block layer calculates everything in 512 byte</span>
<span class="cm"> * sectors but integrity metadata is done in terms of the hardware</span>
<span class="cm"> * sector size of the storage device.  Convert the block layer sectors</span>
<span class="cm"> * to physical sectors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bio_integrity_hw_sectors</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* At this point there are only 512b or 4096b DIF/EPP devices */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">sector_size</span> <span class="o">==</span> <span class="mi">4096</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">sectors</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">sectors</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_tag_size - Retrieve integrity tag space</span>
<span class="cm"> * @bio:	bio to inspect</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Returns the maximum number of tag bytes that can be</span>
<span class="cm"> * attached to this bio. Filesystems can use this to determine how</span>
<span class="cm"> * much metadata to attach to an I/O.</span>
<span class="cm"> */</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">bio_integrity_tag_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tag_size</span> <span class="o">*</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span> <span class="o">/</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_tag_size</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bio_integrity_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tag_buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">set</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sectors</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="o">-&gt;</span><span class="n">tag_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">nr_sectors</span> <span class="o">=</span> <span class="n">bio_integrity_hw_sectors</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span>
					<span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tag_size</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span> <span class="o">&gt;</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;%s: tag too big for bio: %u &gt; %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">__func__</span><span class="p">,</span> <span class="n">nr_sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">,</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_size</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">set</span><span class="p">)</span>
		<span class="n">bi</span><span class="o">-&gt;</span><span class="n">set_tag_fn</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_buf</span><span class="p">,</span> <span class="n">tag_buf</span><span class="p">,</span> <span class="n">nr_sectors</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bi</span><span class="o">-&gt;</span><span class="n">get_tag_fn</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_buf</span><span class="p">,</span> <span class="n">tag_buf</span><span class="p">,</span> <span class="n">nr_sectors</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_set_tag - Attach a tag buffer to a bio</span>
<span class="cm"> * @bio:	bio to attach buffer to</span>
<span class="cm"> * @tag_buf:	Pointer to a buffer containing tag data</span>
<span class="cm"> * @len:	Length of the included buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Use this function to tag a bio by leveraging the extra</span>
<span class="cm"> * space provided by devices formatted with integrity protection.  The</span>
<span class="cm"> * size of the integrity buffer must be &lt;= to the size reported by</span>
<span class="cm"> * bio_integrity_tag_size().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_integrity_set_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tag_buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">!=</span> <span class="n">WRITE</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bio_integrity_tag</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">tag_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_set_tag</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_get_tag - Retrieve a tag buffer from a bio</span>
<span class="cm"> * @bio:	bio to retrieve buffer from</span>
<span class="cm"> * @tag_buf:	Pointer to a buffer for the tag data</span>
<span class="cm"> * @len:	Length of the target buffer</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Use this function to retrieve the tag buffer from a</span>
<span class="cm"> * completed I/O. The size of the integrity buffer must be &lt;= to the</span>
<span class="cm"> * size reported by bio_integrity_tag_size().</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_integrity_get_tag</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">tag_buf</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">!=</span> <span class="n">READ</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bio_integrity_tag</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">tag_buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_get_tag</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_generate - Generate integrity metadata for a bio</span>
<span class="cm"> * @bio:	bio to generate integrity metadata for</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Generates integrity metadata for a bio by calling the</span>
<span class="cm"> * block device&#39;s generation callback function.  The bio must have a</span>
<span class="cm"> * bip attached with enough room to accommodate the generated</span>
<span class="cm"> * integrity metadata.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_integrity_generate</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">blk_integrity_exchg</span> <span class="n">bix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">sectors</span><span class="p">,</span> <span class="n">total</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">prot_buf</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="o">-&gt;</span><span class="n">bip_buf</span><span class="p">;</span>

	<span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bix</span><span class="p">.</span><span class="n">disk_name</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">;</span>
	<span class="n">bix</span><span class="p">.</span><span class="n">sector_size</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>

	<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">data_buf</span> <span class="o">=</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">;</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">prot_buf</span> <span class="o">=</span> <span class="n">prot_buf</span><span class="p">;</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>

		<span class="n">bi</span><span class="o">-&gt;</span><span class="n">generate_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bix</span><span class="p">);</span>

		<span class="n">sectors</span> <span class="o">=</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">/</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
		<span class="n">sector</span> <span class="o">+=</span> <span class="n">sectors</span><span class="p">;</span>
		<span class="n">prot_buf</span> <span class="o">+=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="o">-&gt;</span><span class="n">bip_size</span><span class="p">);</span>

		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">short</span> <span class="nf">blk_integrity_tuple_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bi</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_prep - Prepare bio for integrity I/O</span>
<span class="cm"> * @bio:	bio to prepare</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Allocates a buffer for integrity metadata, maps the</span>
<span class="cm"> * pages and attaches them to a bio.  The bio must have data</span>
<span class="cm"> * direction, target device and start sector set priot to calling.  In</span>
<span class="cm"> * the WRITE case, integrity metadata will be generated using the</span>
<span class="cm"> * block device&#39;s integrity function.  In the READ case, the buffer</span>
<span class="cm"> * will be prepared for DMA and a suitable end_io handler set up.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_integrity_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">;</span>

	<span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>

	<span class="n">sectors</span> <span class="o">=</span> <span class="n">bio_integrity_hw_sectors</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">bio_sectors</span><span class="p">(</span><span class="n">bio</span><span class="p">));</span>

	<span class="cm">/* Allocate kernel buffer for protection data */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">blk_integrity_tuple_size</span><span class="p">(</span><span class="n">bi</span><span class="p">);</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">GFP_NOIO</span> <span class="o">|</span> <span class="n">q</span><span class="o">-&gt;</span><span class="n">bounce_gfp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;could not allocate integrity buffer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">end</span> <span class="o">=</span> <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buf</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">start</span> <span class="o">=</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">buf</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/* Allocate bio integrity payload and integrity vectors */</span>
	<span class="n">bip</span> <span class="o">=</span> <span class="n">bio_integrity_alloc</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">GFP_NOIO</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">bip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;could not allocate data integrity bioset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_buf</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>

	<span class="cm">/* Map it */</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">offset_in_page</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">bytes</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">len</span><span class="p">)</span>
			<span class="n">bytes</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_integrity_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">virt_to_page</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span>
					     <span class="n">bytes</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">buf</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Install custom I/O completion handler if read verify is enabled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">READ</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_end_io</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bio_integrity_endio</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Auto-generate integrity metadata if this is a write */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_data_dir</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="n">bio_integrity_generate</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_prep</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_verify - Verify integrity metadata for a bio</span>
<span class="cm"> * @bio:	bio to verify</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This function is called to verify the integrity of a</span>
<span class="cm"> * bio.	 The data in the bio io_vec is compared to the integrity</span>
<span class="cm"> * metadata returned by the HBA.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bio_integrity_verify</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">blk_integrity_exchg</span> <span class="n">bix</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bv</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="o">-&gt;</span><span class="n">bip_sector</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">sectors</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">prot_buf</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="o">-&gt;</span><span class="n">bip_buf</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bix</span><span class="p">.</span><span class="n">disk_name</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="o">-&gt;</span><span class="n">bd_disk</span><span class="o">-&gt;</span><span class="n">disk_name</span><span class="p">;</span>
	<span class="n">bix</span><span class="p">.</span><span class="n">sector_size</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>

	<span class="n">bio_for_each_segment</span><span class="p">(</span><span class="n">bv</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">void</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">data_buf</span> <span class="o">=</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">;</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">data_size</span> <span class="o">=</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">prot_buf</span> <span class="o">=</span> <span class="n">prot_buf</span><span class="p">;</span>
		<span class="n">bix</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">verify_fn</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bix</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sectors</span> <span class="o">=</span> <span class="n">bv</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">/</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">sector_size</span><span class="p">;</span>
		<span class="n">sector</span> <span class="o">+=</span> <span class="n">sectors</span><span class="p">;</span>
		<span class="n">prot_buf</span> <span class="o">+=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>
		<span class="n">total</span> <span class="o">+=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">total</span> <span class="o">&gt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="o">-&gt;</span><span class="n">bip_size</span><span class="p">);</span>

		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_verify_fn - Integrity I/O completion worker</span>
<span class="cm"> * @work:	Work struct stored in bio to be verified</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This workqueue function is called to complete a READ</span>
<span class="cm"> * request.  The function verifies the transferred integrity metadata</span>
<span class="cm"> * and then calls the original bio end_io function.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">bio_integrity_verify_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">work_struct</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span>
		<span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_integrity_payload</span><span class="p">,</span> <span class="n">bip_work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_bio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">bio_integrity_verify</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="cm">/* Restore original bio completion handler */</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_end_io</span><span class="p">;</span>
	<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_endio - Integrity I/O completion function</span>
<span class="cm"> * @bio:	Protected bio</span>
<span class="cm"> * @error:	Pointer to errno</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Completion for integrity I/O</span>
<span class="cm"> *</span>
<span class="cm"> * Normally I/O completion is done in interrupt context.  However,</span>
<span class="cm"> * verifying I/O integrity is a time-consuming task which must be run</span>
<span class="cm"> * in process context.	This function postpones completion</span>
<span class="cm"> * accordingly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_integrity_endio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">error</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_bio</span> <span class="o">!=</span> <span class="n">bio</span><span class="p">);</span>

	<span class="cm">/* In case of an I/O error there is no point in verifying the</span>
<span class="cm">	 * integrity metadata.  Restore original bio end_io handler</span>
<span class="cm">	 * and run it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_end_io</span><span class="p">;</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">error</span><span class="p">);</span>

		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">INIT_WORK</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_work</span><span class="p">,</span> <span class="n">bio_integrity_verify_fn</span><span class="p">);</span>
	<span class="n">queue_work</span><span class="p">(</span><span class="n">kintegrityd_wq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_work</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_endio</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_mark_head - Advance bip_vec skip bytes</span>
<span class="cm"> * @bip:	Integrity vector to advance</span>
<span class="cm"> * @skip:	Number of bytes to advance it</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_integrity_mark_head</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">skip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">iv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bip_for_each_vec</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">bip</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">skip</span> <span class="o">&gt;=</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skip</span> <span class="o">-=</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* skip &lt; iv-&gt;bv_len) */</span>
			<span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">+=</span> <span class="n">skip</span><span class="p">;</span>
			<span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">-=</span> <span class="n">skip</span><span class="p">;</span>
			<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_mark_tail - Truncate bip_vec to be len bytes long</span>
<span class="cm"> * @bip:	Integrity vector to truncate</span>
<span class="cm"> * @len:	New length of integrity vector</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_integrity_mark_tail</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span><span class="p">,</span>
			     <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">iv</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">bip_for_each_vec</span><span class="p">(</span><span class="n">iv</span><span class="p">,</span> <span class="n">bip</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">return</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">-=</span> <span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="cm">/* len &lt; iv-&gt;bv_len) */</span>
			<span class="n">iv</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_advance - Advance integrity vector</span>
<span class="cm"> * @bio:	bio whose integrity vector to update</span>
<span class="cm"> * @bytes_done:	number of data bytes that have been completed</span>
<span class="cm"> *</span>
<span class="cm"> * Description: This function calculates how many integrity bytes the</span>
<span class="cm"> * number of completed data bytes correspond to and advances the</span>
<span class="cm"> * integrity vector accordingly.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_integrity_advance</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bytes_done</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sectors</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">nr_sectors</span> <span class="o">=</span> <span class="n">bio_integrity_hw_sectors</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">bytes_done</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">);</span>
	<span class="n">bio_integrity_mark_head</span><span class="p">(</span><span class="n">bip</span><span class="p">,</span> <span class="n">nr_sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_advance</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_trim - Trim integrity vector</span>
<span class="cm"> * @bio:	bio whose integrity vector to update</span>
<span class="cm"> * @offset:	offset to first data sector</span>
<span class="cm"> * @sectors:	number of data sectors</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Used to trim the integrity vector in a cloned bio.</span>
<span class="cm"> * The ivec will be advanced corresponding to &#39;offset&#39; data sectors</span>
<span class="cm"> * and the length will be truncated corresponding to &#39;len&#39; data</span>
<span class="cm"> * sectors.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_integrity_trim</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sectors</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_CLONED</span><span class="p">));</span>

	<span class="n">nr_sectors</span> <span class="o">=</span> <span class="n">bio_integrity_hw_sectors</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">sectors</span><span class="p">);</span>
	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_sector</span> <span class="o">=</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_sector</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">bio_integrity_mark_head</span><span class="p">(</span><span class="n">bip</span><span class="p">,</span> <span class="n">offset</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">);</span>
	<span class="n">bio_integrity_mark_tail</span><span class="p">(</span><span class="n">bip</span><span class="p">,</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_trim</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_split - Split integrity metadata</span>
<span class="cm"> * @bio:	Protected bio</span>
<span class="cm"> * @bp:		Resulting bio_pair</span>
<span class="cm"> * @sectors:	Offset</span>
<span class="cm"> *</span>
<span class="cm"> * Description: Splits an integrity page into a bio_pair.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">bio_integrity_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_pair</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sectors</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">blk_integrity</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">nr_sectors</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_integrity</span><span class="p">(</span><span class="n">bio</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">bi</span> <span class="o">=</span> <span class="n">bdev_get_integrity</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bi</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">nr_sectors</span> <span class="o">=</span> <span class="n">bio_integrity_hw_sectors</span><span class="p">(</span><span class="n">bi</span><span class="p">,</span> <span class="n">sectors</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio1</span><span class="p">.</span><span class="n">bi_integrity</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bio2</span><span class="p">.</span><span class="n">bi_integrity</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip2</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">iv1</span> <span class="o">=</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">iv2</span> <span class="o">=</span> <span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip1</span><span class="p">.</span><span class="n">bip_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">iv1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip2</span><span class="p">.</span><span class="n">bip_vec</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">iv2</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">iv1</span><span class="p">.</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">iv2</span><span class="p">.</span><span class="n">bv_offset</span> <span class="o">+=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">iv2</span><span class="p">.</span><span class="n">bv_len</span> <span class="o">-=</span> <span class="n">sectors</span> <span class="o">*</span> <span class="n">bi</span><span class="o">-&gt;</span><span class="n">tuple_size</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip1</span><span class="p">.</span><span class="n">bip_sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="o">-&gt;</span><span class="n">bip_sector</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip2</span><span class="p">.</span><span class="n">bip_sector</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="o">-&gt;</span><span class="n">bip_sector</span> <span class="o">+</span> <span class="n">nr_sectors</span><span class="p">;</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip1</span><span class="p">.</span><span class="n">bip_vcnt</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip2</span><span class="p">.</span><span class="n">bip_vcnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip1</span><span class="p">.</span><span class="n">bip_idx</span> <span class="o">=</span> <span class="n">bp</span><span class="o">-&gt;</span><span class="n">bip2</span><span class="p">.</span><span class="n">bip_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_split</span><span class="p">);</span>

<span class="cm">/**</span>
<span class="cm"> * bio_integrity_clone - Callback for cloning bios with integrity metadata</span>
<span class="cm"> * @bio:	New bio</span>
<span class="cm"> * @bio_src:	Original bio</span>
<span class="cm"> * @gfp_mask:	Memory allocation mask</span>
<span class="cm"> * @bs:		bio_set to allocate bip from</span>
<span class="cm"> *</span>
<span class="cm"> * Description:	Called to allocate a bip when cloning a bio</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">bio_integrity_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio_src</span><span class="p">,</span>
			<span class="n">gfp_t</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip_src</span> <span class="o">=</span> <span class="n">bio_src</span><span class="o">-&gt;</span><span class="n">bi_integrity</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_integrity_payload</span> <span class="o">*</span><span class="n">bip</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bip_src</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="n">bip</span> <span class="o">=</span> <span class="n">bio_integrity_alloc_bioset</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">gfp_mask</span><span class="p">,</span> <span class="n">bip_src</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span><span class="p">,</span> <span class="n">bs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bip</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vec</span><span class="p">,</span> <span class="n">bip_src</span><span class="o">-&gt;</span><span class="n">bip_vec</span><span class="p">,</span>
	       <span class="n">bip_src</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">));</span>

	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_sector</span> <span class="o">=</span> <span class="n">bip_src</span><span class="o">-&gt;</span><span class="n">bip_sector</span><span class="p">;</span>
	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span> <span class="o">=</span> <span class="n">bip_src</span><span class="o">-&gt;</span><span class="n">bip_vcnt</span><span class="p">;</span>
	<span class="n">bip</span><span class="o">-&gt;</span><span class="n">bip_idx</span> <span class="o">=</span> <span class="n">bip_src</span><span class="o">-&gt;</span><span class="n">bip_idx</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bio_integrity_clone</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">bioset_integrity_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pool_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">max_slab</span> <span class="o">=</span> <span class="n">vecs_to_idx</span><span class="p">(</span><span class="n">BIO_MAX_PAGES</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_integrity_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_integrity_pool</span> <span class="o">=</span>
		<span class="n">mempool_create_slab_pool</span><span class="p">(</span><span class="n">pool_size</span><span class="p">,</span> <span class="n">bip_slab</span><span class="p">[</span><span class="n">max_slab</span><span class="p">].</span><span class="n">slab</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_integrity_pool</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bioset_integrity_create</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">bioset_integrity_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_set</span> <span class="o">*</span><span class="n">bs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_integrity_pool</span><span class="p">)</span>
		<span class="n">mempool_destroy</span><span class="p">(</span><span class="n">bs</span><span class="o">-&gt;</span><span class="n">bio_integrity_pool</span><span class="p">);</span>
<span class="p">}</span>
<span class="n">EXPORT_SYMBOL</span><span class="p">(</span><span class="n">bioset_integrity_free</span><span class="p">);</span>

<span class="kt">void</span> <span class="n">__init</span> <span class="nf">bio_integrity_init</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * kintegrityd won&#39;t block much but may burn a lot of CPU cycles.</span>
<span class="cm">	 * Make it highpri CPU intensive wq with max concurrency of 1.</span>
<span class="cm">	 */</span>
	<span class="n">kintegrityd_wq</span> <span class="o">=</span> <span class="n">alloc_workqueue</span><span class="p">(</span><span class="s">&quot;kintegrityd&quot;</span><span class="p">,</span> <span class="n">WQ_MEM_RECLAIM</span> <span class="o">|</span>
					 <span class="n">WQ_HIGHPRI</span> <span class="o">|</span> <span class="n">WQ_CPU_INTENSIVE</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kintegrityd_wq</span><span class="p">)</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;Failed to create kintegrityd</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BIOVEC_NR_POOLS</span> <span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_integrity_payload</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">bip_slab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nr_vecs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio_vec</span><span class="p">);</span>

		<span class="n">bip_slab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slab</span> <span class="o">=</span>
			<span class="n">kmem_cache_create</span><span class="p">(</span><span class="n">bip_slab</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">SLAB_HWCACHE_ALIGN</span><span class="o">|</span><span class="n">SLAB_PANIC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:1}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../javascript/docco.min.js"></script>
</html>
