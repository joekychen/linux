<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nilfs2 › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * inode.c - NILFS inode operations.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2008 Nippon Telegraph and Telephone Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Ryusuke Konishi &lt;ryusuke@osrg.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/gfp.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/uio.h&gt;</span>
<span class="cp">#include &quot;nilfs.h&quot;</span>
<span class="cp">#include &quot;btnode.h&quot;</span>
<span class="cp">#include &quot;segment.h&quot;</span>
<span class="cp">#include &quot;page.h&quot;</span>
<span class="cp">#include &quot;mdt.h&quot;</span>
<span class="cp">#include &quot;cpfile.h&quot;</span>
<span class="cp">#include &quot;ifile.h&quot;</span>

<span class="k">struct</span> <span class="n">nilfs_iget_args</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">cno</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">for_gc</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">nilfs_inode_add_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">;</span>

	<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">blocks_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_inode_sub_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">;</span>

	<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">)</span> <span class="o">*</span> <span class="n">n</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span>
		<span class="n">atomic_sub</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">blocks_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_get_block() - get a file block on the filesystem (callback function)</span>
<span class="cm"> * @inode - inode struct of the target file</span>
<span class="cm"> * @blkoff - file block number</span>
<span class="cm"> * @bh_result - buffer head to be mapped on</span>
<span class="cm"> * @create - indicate whether allocating the block or not when it has not</span>
<span class="cm"> *      been allocated yet.</span>
<span class="cm"> *</span>
<span class="cm"> * This function does not issue actual read request of the specified data</span>
<span class="cm"> * block. It is done by VFS.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_get_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">blkoff</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">blknum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">maxblocks</span> <span class="o">=</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_bmap_lookup_contig</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">blkoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blknum</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>	<span class="cm">/* found */</span>
		<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">blknum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* data block was not found */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">&amp;&amp;</span> <span class="n">create</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>

		<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_transaction_begin</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_bmap_insert</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">blkoff</span><span class="p">,</span>
					<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * The get_block() function could be called</span>
<span class="cm">				 * from multiple callers for an inode.</span>
<span class="cm">				 * However, the page having this block must</span>
<span class="cm">				 * be locked in this case.</span>
<span class="cm">				 */</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				       <span class="s">&quot;nilfs_get_block: a race condition &quot;</span>
				       <span class="s">&quot;while inserting a data block. &quot;</span>
				       <span class="s">&quot;(inode number=%lu, file block &quot;</span>
				       <span class="s">&quot;offset=%llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">blkoff</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">nilfs_transaction_abort</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nilfs_mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">nilfs_transaction_commit</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span> <span class="cm">/* never fails */</span>
		<span class="cm">/* Error handling should be detailed */</span>
		<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="n">set_buffer_delay</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
		<span class="n">map_bh</span><span class="p">(</span><span class="n">bh_result</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* dbn must be changed</span>
<span class="cm">						      to proper value */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not found is not error (e.g. hole); must return without</span>
<span class="cm">		   the mapped state flag. */</span>
		<span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_readpage() - implement readpage() method of nilfs_aops {}</span>
<span class="cm"> * address_space_operations.</span>
<span class="cm"> * @file - file struct of the file to be read</span>
<span class="cm"> * @page - the page to be read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">nilfs_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_readpages() - implement readpages() method of nilfs_aops {}</span>
<span class="cm"> * address_space_operations.</span>
<span class="cm"> * @file - file struct of the file to be read</span>
<span class="cm"> * @mapping - address_space struct used for reading multiple pages</span>
<span class="cm"> * @pages - the pages to be read</span>
<span class="cm"> * @nr_pages - number of pages to be read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mpage_readpages</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">nilfs_get_block</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_construct_dsync_segment</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_start</span><span class="p">,</span>
						    <span class="n">wbc</span><span class="o">-&gt;</span><span class="n">range_end</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_construct_segment</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">for_reclaim</span><span class="p">)</span>
		<span class="n">nilfs_flush_segment</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">__set_page_dirty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">nr_dirty</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">PAGE_SHIFT</span> <span class="o">-</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">);</span>

		<span class="n">nilfs_set_file_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nr_dirty</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_write_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			     <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">flags</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagep</span><span class="p">,</span> <span class="kt">void</span> <span class="o">**</span><span class="n">fsdata</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_transaction_begin</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">block_write_begin</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">pagep</span><span class="p">,</span>
				<span class="n">nilfs_get_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
			<span class="n">vmtruncate</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>

		<span class="n">nilfs_transaction_abort</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_write_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
			   <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">len</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">copied</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">fsdata</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">start</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="n">nr_dirty</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">nr_dirty</span> <span class="o">=</span> <span class="n">nilfs_page_count_clean_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
						  <span class="n">start</span> <span class="o">+</span> <span class="n">copied</span><span class="p">);</span>
	<span class="n">copied</span> <span class="o">=</span> <span class="n">generic_write_end</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
				   <span class="n">fsdata</span><span class="p">);</span>
	<span class="n">nilfs_set_file_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">nr_dirty</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_transaction_commit</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span> <span class="o">?</span> <span class="o">:</span> <span class="n">copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span>
<span class="nf">nilfs_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
		<span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">==</span> <span class="n">WRITE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Needs synchronization with the cleaner */</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
				  <span class="n">nilfs_get_block</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * In case of error extending write may have instantiated a few</span>
<span class="cm">	 * blocks outside i_size. Trim these off again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">((</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
			<span class="n">vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">nilfs_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">writepage</span>		<span class="o">=</span> <span class="n">nilfs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpage</span>		<span class="o">=</span> <span class="n">nilfs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span>		<span class="o">=</span> <span class="n">nilfs_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span>		<span class="o">=</span> <span class="n">nilfs_set_page_dirty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>		<span class="o">=</span> <span class="n">nilfs_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_begin</span>		<span class="o">=</span> <span class="n">nilfs_write_begin</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_end</span>		<span class="o">=</span> <span class="n">nilfs_write_end</span><span class="p">,</span>
	<span class="cm">/* .releasepage		= nilfs_releasepage, */</span>
	<span class="p">.</span><span class="n">invalidatepage</span>		<span class="o">=</span> <span class="n">block_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>		<span class="o">=</span> <span class="n">nilfs_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">is_partially_uptodate</span>  <span class="o">=</span> <span class="n">block_is_partially_uptodate</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nilfs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
			     <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_FS</span><span class="p">);</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">;</span>
	<span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">NILFS_I_NEW</span><span class="p">;</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_ifile_create_inode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">failed_ifile_create_inode</span><span class="p">;</span>
	<span class="cm">/* reference count of i_bh inherits from nilfs_mdt_read_block() */</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inodes_count</span><span class="p">);</span>
	<span class="n">inode_init_owner</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_bmap_read</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed_bmap</span><span class="p">;</span>

		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_BMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
		<span class="cm">/* No lock is needed; iget() ensures it. */</span>
	<span class="p">}</span>

	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">nilfs_mask_flags</span><span class="p">(</span>
		<span class="n">mode</span><span class="p">,</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;</span> <span class="n">NILFS_FL_INHERITED</span><span class="p">);</span>

	<span class="cm">/* ii-&gt;i_file_acl = 0; */</span>
	<span class="cm">/* ii-&gt;i_dir_acl = 0; */</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nilfs_set_inode_flags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_next_gen_lock</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_next_generation</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_next_gen_lock</span><span class="p">);</span>
	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_init_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">failed_acl</span><span class="p">;</span> <span class="cm">/* never occur. When supporting</span>
<span class="cm">				    nilfs_init_acl(), proper cancellation of</span>
<span class="cm">				    above jobs should be considered */</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

 <span class="nl">failed_acl:</span>
 <span class="nl">failed_bmap:</span>
	<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>  <span class="cm">/* raw_inode will be deleted through</span>
<span class="cm">			 generic_delete_inode() */</span>
	<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

 <span class="nl">failed_ifile_create_inode:</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>  <span class="cm">/* if i_nlink == 1, generic_forget_inode() will be</span>
<span class="cm">			 called */</span>
 <span class="nl">failed:</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_set_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_SYNC</span> <span class="o">|</span> <span class="n">S_APPEND</span> <span class="o">|</span> <span class="n">S_IMMUTABLE</span> <span class="o">|</span> <span class="n">S_NOATIME</span> <span class="o">|</span>
			    <span class="n">S_DIRSYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_SYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_APPEND_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_APPEND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_IMMUTABLE_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_IMMUTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_NOATIME_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_DIRSYNC_FL</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DIRSYNC</span><span class="p">;</span>
	<span class="n">mapping_set_gfp_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
			     <span class="n">mapping_gfp_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">__GFP_FS</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_read_inode_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="p">(</span><span class="n">uid_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="p">(</span><span class="n">gid_t</span><span class="p">)</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span><span class="p">));</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime_nsec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime_nsec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime_nsec</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span> <span class="cm">/* this inode is deleted */</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	ii-&gt;i_file_acl = le32_to_cpu(raw_inode-&gt;i_file_acl);</span>
<span class="c">	ii-&gt;i_dir_acl = S_ISREG(inode-&gt;i_mode) ?</span>
<span class="c">		0 : le32_to_cpu(raw_inode-&gt;i_dir_acl);</span>
<span class="cp">#endif</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dir_start_lookup</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_bmap_read</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_BMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
		<span class="cm">/* No lock is needed; iget() ensures it. */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__nilfs_read_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_sem</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_ifile_get_inode_block</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">bad_inode</span><span class="p">;</span>

	<span class="n">raw_inode</span> <span class="o">=</span> <span class="n">nilfs_ifile_map_inode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_read_inode_common</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed_unmap</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_file_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_file_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_aops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_dir_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_dir_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_aops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISLNK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_symlink_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_aops</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_special_inode_operations</span><span class="p">;</span>
		<span class="n">init_special_inode</span><span class="p">(</span>
			<span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span>
			<span class="n">huge_decode_dev</span><span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_device_code</span><span class="p">)));</span>
	<span class="p">}</span>
	<span class="n">nilfs_ifile_unmap_inode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_sem</span><span class="p">);</span>
	<span class="n">nilfs_set_inode_flags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed_unmap:</span>
	<span class="n">nilfs_ifile_unmap_inode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

 <span class="nl">bad_inode:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_iget_test</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_iget_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">||</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_GCINODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">!</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">for_gc</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">for_gc</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cno</span> <span class="o">==</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_cno</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_iget_set</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_iget_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">for_gc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">NILFS_I_GCINODE</span><span class="p">;</span>
		<span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_cno</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">cno</span><span class="p">;</span>
		<span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">&amp;&amp;</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">==</span> <span class="n">NILFS_ROOT_INO</span><span class="p">)</span>
			<span class="n">nilfs_get_root</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nilfs_ilookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_iget_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">,</span> <span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">,</span> <span class="p">.</span><span class="n">cno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">for_gc</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">ilookup5</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">nilfs_iget_test</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nilfs_iget_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_iget_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">,</span> <span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">,</span> <span class="p">.</span><span class="n">cno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="p">.</span><span class="n">for_gc</span> <span class="o">=</span> <span class="mi">0</span>
	<span class="p">};</span>

	<span class="k">return</span> <span class="n">iget5_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">nilfs_iget_test</span><span class="p">,</span> <span class="n">nilfs_iget_set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nilfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">nilfs_iget_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">__nilfs_read_inode</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nilfs_iget_for_gc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ino</span><span class="p">,</span>
				<span class="n">__u64</span> <span class="n">cno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_iget_args</span> <span class="n">args</span> <span class="o">=</span> <span class="p">{</span>
		<span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">,</span> <span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="p">.</span><span class="n">cno</span> <span class="o">=</span> <span class="n">cno</span><span class="p">,</span> <span class="p">.</span><span class="n">for_gc</span> <span class="o">=</span> <span class="mi">1</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget5_locked</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">nilfs_iget_test</span><span class="p">,</span> <span class="n">nilfs_iget_set</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_init_gcinode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">iget_failed</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_write_inode_common</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">has_bmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_links_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_ctime_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_mtime_nsec</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span><span class="p">);</span>

	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">);</span>
	<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NILFS_ROOT_METADATA_FILE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

		<span class="cm">/* zero-fill unused portion in the case of super root block */</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_xattr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_inode</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">raw_inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">raw_inode</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">has_bmap</span><span class="p">)</span>
		<span class="n">nilfs_bmap_write</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISCHR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">raw_inode</span><span class="o">-&gt;</span><span class="n">i_device_code</span> <span class="o">=</span>
			<span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">huge_encode_dev</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">));</span>
	<span class="cm">/* When extending inode, nilfs-&gt;ns_inode_size should be checked</span>
<span class="cm">	   for substitutions of appended fields */</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ibh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ifile</span> <span class="o">=</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">;</span>

	<span class="n">raw_inode</span> <span class="o">=</span> <span class="n">nilfs_ifile_map_inode</span><span class="p">(</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">ibh</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NILFS_I_NEW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">raw_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">ifile</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_entry_size</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_INODE_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>

	<span class="n">nilfs_write_inode_common</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/* XXX: call with has_bmap = 0 is a workaround to avoid</span>
<span class="cm">		   deadlock of bmap. This delays update of i_bmap to just</span>
<span class="cm">		   before writing */</span>
	<span class="n">nilfs_ifile_unmap_inode</span><span class="p">(</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span> <span class="n">ibh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define NILFS_MAX_TRUNCATE_BLOCKS	16384  </span><span class="cm">/* 64MB for 4KB block */</span><span class="cp"></span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_truncate_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
<span class="nl">repeat:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_bmap_last_key</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="n">from</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">-=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">NILFS_MAX_TRUNCATE_BLOCKS</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="n">from</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_bmap_truncate</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
	<span class="n">nilfs_relax_pressure_in_lock</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">||</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span> <span class="o">&amp;&amp;</span>
		     <span class="n">nilfs_bmap_truncate</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>

<span class="nl">failed:</span>
	<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
		      <span class="s">&quot;failed to truncate bmap (ino=%lu, err=%d)&quot;</span><span class="p">,</span>
		      <span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">blkoff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">blkoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">nilfs_transaction_begin</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* never fails */</span>

	<span class="n">block_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">nilfs_get_block</span><span class="p">);</span>

	<span class="n">nilfs_truncate_bmap</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">blkoff</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">nilfs_set_transaction_flag</span><span class="p">(</span><span class="n">NILFS_TI_SYNC</span><span class="p">);</span>

	<span class="n">nilfs_mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">nilfs_set_file_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">nilfs_transaction_commit</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="cm">/* May construct a logical segment and may fail in sync mode.</span>
<span class="cm">	   But truncate has no return value. */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_clear_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nilfs_mdt_info</span> <span class="o">*</span><span class="n">mdi</span> <span class="o">=</span> <span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free resources allocated in nilfs_read_inode(), here.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">));</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">);</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mdi</span> <span class="o">&amp;&amp;</span> <span class="n">mdi</span><span class="o">-&gt;</span><span class="n">mi_palloc_cache</span><span class="p">)</span>
		<span class="n">nilfs_palloc_destroy_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
		<span class="n">nilfs_bmap_clear</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">);</span>

	<span class="n">nilfs_btnode_cache_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_btnode_cache</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">==</span> <span class="n">NILFS_ROOT_INO</span><span class="p">)</span>
		<span class="n">nilfs_put_root</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">||</span> <span class="o">!</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span> <span class="o">||</span> <span class="n">unlikely</span><span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">)</span>
			<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">nilfs_clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nilfs_transaction_begin</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* never fails */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">)</span>
		<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* TODO: some of the following operations may fail.  */</span>
	<span class="n">nilfs_truncate_bmap</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">nilfs_mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_ifile_delete_inode</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="o">-&gt;</span><span class="n">inodes_count</span><span class="p">);</span>

	<span class="n">nilfs_clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_SYNC</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="n">nilfs_set_transaction_flag</span><span class="p">(</span><span class="n">NILFS_TI_SYNC</span><span class="p">);</span>
	<span class="n">nilfs_transaction_commit</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="cm">/* May construct a logical segment and may fail in sync mode.</span>
<span class="cm">	   But delete_inode has no return value. */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">iattr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_transaction_begin</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_size</span> <span class="o">!=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">inode_dio_wait</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">vmtruncate</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">iattr</span><span class="p">);</span>
	<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">iattr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">nilfs_transaction_commit</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

<span class="nl">out_err:</span>
	<span class="n">nilfs_transaction_abort</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">&amp;&amp;</span>
	    <span class="n">root</span><span class="o">-&gt;</span><span class="n">cno</span> <span class="o">!=</span> <span class="n">NILFS_CPTREE_CURRENT_CNO</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span> <span class="cm">/* snapshot is not writable */</span>

	<span class="k">return</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_load_inode_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">pbh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_ifile_get_inode_block</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span>
						  <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">pbh</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
			<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">=</span> <span class="o">*</span><span class="n">pbh</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="o">*</span><span class="n">pbh</span><span class="p">);</span>
			<span class="o">*</span><span class="n">pbh</span> <span class="o">=</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="o">*</span><span class="n">pbh</span> <span class="o">=</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">;</span>

	<span class="n">get_bh</span><span class="p">(</span><span class="o">*</span><span class="n">pbh</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_inode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">)</span> <span class="o">||</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_set_file_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_dirty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">atomic_add</span><span class="p">(</span><span class="n">nr_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_ndirtyblks</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">NILFS_I_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Because this routine may race with nilfs_dispose_list(),</span>
<span class="cm">		   we have to check NILFS_I_QUEUED here, too. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">igrab</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* This will happen when somebody is freeing</span>
<span class="cm">			   this inode. */</span>
			<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
				      <span class="s">&quot;cannot get inode (ino=%lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span> <span class="cm">/* NILFS_I_DIRTY may remain for</span>
<span class="cm">					   freeing inode */</span>
		<span class="p">}</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dirty_files</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_mark_inode_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ibh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_load_inode_block</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			      <span class="s">&quot;failed to reget inode block.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nilfs_update_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ibh</span><span class="p">);</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">ibh</span><span class="p">);</span>
	<span class="n">nilfs_mdt_mark_dirty</span><span class="p">(</span><span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">ibh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_dirty_inode - reflect changes on given inode to an inode block.</span>
<span class="cm"> * @inode: inode of the file to be registered.</span>
<span class="cm"> *</span>
<span class="cm"> * nilfs_dirty_inode() loads a inode block containing the specified</span>
<span class="cm"> * @inode and copies data from a nilfs_inode to a corresponding inode</span>
<span class="cm"> * entry in the inode block. This operation is excluded from the segment</span>
<span class="cm"> * construction. This function can be called both as a single operation</span>
<span class="cm"> * and as a part of indivisible file operations.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nilfs_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_mdt_info</span> <span class="o">*</span><span class="n">mdi</span> <span class="o">=</span> <span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			      <span class="s">&quot;tried to mark bad_inode dirty. ignored.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">dump_stack</span><span class="p">();</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nilfs_mdt_mark_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nilfs_transaction_begin</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">nilfs_mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">nilfs_transaction_commit</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span> <span class="cm">/* never fails */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
		 <span class="n">__u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">logical</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">isize</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">blkoff</span><span class="p">,</span> <span class="n">end_blkoff</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">delalloc_blkoff</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">delalloc_blklen</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blkbits</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">n</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_check_flags</span><span class="p">(</span><span class="n">fieinfo</span><span class="p">,</span> <span class="n">FIEMAP_FLAG_SYNC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">blkoff</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>
	<span class="n">end_blkoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">blkbits</span><span class="p">;</span>

	<span class="n">delalloc_blklen</span> <span class="o">=</span> <span class="n">nilfs_find_uncommitted_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">blkoff</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">delalloc_blkoff</span><span class="p">);</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">__u64</span> <span class="n">blkphy</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">maxblocks</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delalloc_blklen</span> <span class="o">&amp;&amp;</span> <span class="n">blkoff</span> <span class="o">==</span> <span class="n">delalloc_blkoff</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* End of the current extent */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span>
					<span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blkoff</span> <span class="o">&gt;</span> <span class="n">end_blkoff</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">flags</span> <span class="o">=</span> <span class="n">FIEMAP_EXTENT_MERGED</span> <span class="o">|</span> <span class="n">FIEMAP_EXTENT_DELALLOC</span><span class="p">;</span>
			<span class="n">logical</span> <span class="o">=</span> <span class="n">blkoff</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
			<span class="n">phys</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">delalloc_blklen</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>

			<span class="n">blkoff</span> <span class="o">=</span> <span class="n">delalloc_blkoff</span> <span class="o">+</span> <span class="n">delalloc_blklen</span><span class="p">;</span>
			<span class="n">delalloc_blklen</span> <span class="o">=</span> <span class="n">nilfs_find_uncommitted_extent</span><span class="p">(</span>
				<span class="n">inode</span><span class="p">,</span> <span class="n">blkoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delalloc_blkoff</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Limit the number of blocks that we look up so as</span>
<span class="cm">		 * not to get into the next delayed allocation extent.</span>
<span class="cm">		 */</span>
		<span class="n">maxblocks</span> <span class="o">=</span> <span class="n">INT_MAX</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">delalloc_blklen</span><span class="p">)</span>
			<span class="n">maxblocks</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">sector_t</span><span class="p">,</span> <span class="n">delalloc_blkoff</span> <span class="o">-</span> <span class="n">blkoff</span><span class="p">,</span>
					  <span class="n">maxblocks</span><span class="p">);</span>
		<span class="n">blkphy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_sem</span><span class="p">);</span>
		<span class="n">n</span> <span class="o">=</span> <span class="n">nilfs_bmap_lookup_contig</span><span class="p">(</span>
			<span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">blkoff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">blkphy</span><span class="p">,</span> <span class="n">maxblocks</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">mi_sem</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">past_eof</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">n</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* error */</span>

			<span class="cm">/* HOLE */</span>
			<span class="n">blkoff</span><span class="o">++</span><span class="p">;</span>
			<span class="n">past_eof</span> <span class="o">=</span> <span class="p">((</span><span class="n">blkoff</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">isize</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* End of the current extent */</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">past_eof</span><span class="p">)</span>
					<span class="n">flags</span> <span class="o">|=</span> <span class="n">FIEMAP_EXTENT_LAST</span><span class="p">;</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span>
					<span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">blkoff</span> <span class="o">&gt;</span> <span class="n">end_blkoff</span> <span class="o">||</span> <span class="n">past_eof</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">phys</span> <span class="o">&amp;&amp;</span> <span class="n">blkphy</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span> <span class="o">==</span> <span class="n">phys</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* The current extent goes on */</span>
					<span class="n">size</span> <span class="o">+=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="cm">/* Terminate the current extent */</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">fiemap_fill_next_extent</span><span class="p">(</span>
						<span class="n">fieinfo</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">phys</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span>
						<span class="n">flags</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">blkoff</span> <span class="o">&gt;</span> <span class="n">end_blkoff</span><span class="p">)</span>
						<span class="k">break</span><span class="p">;</span>

					<span class="cm">/* Start another extent */</span>
					<span class="n">flags</span> <span class="o">=</span> <span class="n">FIEMAP_EXTENT_MERGED</span><span class="p">;</span>
					<span class="n">logical</span> <span class="o">=</span> <span class="n">blkoff</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
					<span class="n">phys</span> <span class="o">=</span> <span class="n">blkphy</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
					<span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* Start a new extent */</span>
				<span class="n">flags</span> <span class="o">=</span> <span class="n">FIEMAP_EXTENT_MERGED</span><span class="p">;</span>
				<span class="n">logical</span> <span class="o">=</span> <span class="n">blkoff</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
				<span class="n">phys</span> <span class="o">=</span> <span class="n">blkphy</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
				<span class="n">size</span> <span class="o">=</span> <span class="n">n</span> <span class="o">&lt;&lt;</span> <span class="n">blkbits</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">blkoff</span> <span class="o">+=</span> <span class="n">n</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">);</span>

	<span class="cm">/* If ret is 1 then we just hit the end of the extent array */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
