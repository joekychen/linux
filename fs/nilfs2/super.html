<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nilfs2 › super.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>super.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * super.c - NILFS module and super block management.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2008 Nippon Telegraph and Telephone Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Ryusuke Konishi &lt;ryusuke@osrg.net&gt;</span>
<span class="cm"> */</span>
<span class="cm">/*</span>
<span class="cm"> *  linux/fs/ext2/super.c</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 1992, 1993, 1994, 1995</span>
<span class="cm"> * Remy Card (card@masi.ibp.fr)</span>
<span class="cm"> * Laboratoire MASI - Institut Blaise Pascal</span>
<span class="cm"> * Universite Pierre et Marie Curie (Paris VI)</span>
<span class="cm"> *</span>
<span class="cm"> *  from</span>
<span class="cm"> *</span>
<span class="cm"> *  linux/fs/minix/inode.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991, 1992  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  Big-endian to little-endian byte-swapping/bitmaps by</span>
<span class="cm"> *        David S. Miller (davem@caip.rutgers.edu), 1995</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/parser.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/vfs.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &quot;nilfs.h&quot;</span>
<span class="cp">#include &quot;export.h&quot;</span>
<span class="cp">#include &quot;mdt.h&quot;</span>
<span class="cp">#include &quot;alloc.h&quot;</span>
<span class="cp">#include &quot;btree.h&quot;</span>
<span class="cp">#include &quot;btnode.h&quot;</span>
<span class="cp">#include &quot;page.h&quot;</span>
<span class="cp">#include &quot;cpfile.h&quot;</span>
<span class="cp">#include &quot;sufile.h&quot; </span><span class="cm">/* nilfs_sufile_resize(), nilfs_sufile_set_alloc_range() */</span><span class="cp"></span>
<span class="cp">#include &quot;ifile.h&quot;</span>
<span class="cp">#include &quot;dat.h&quot;</span>
<span class="cp">#include &quot;segment.h&quot;</span>
<span class="cp">#include &quot;segbuf.h&quot;</span>

<span class="n">MODULE_AUTHOR</span><span class="p">(</span><span class="s">&quot;NTT Corp.&quot;</span><span class="p">);</span>
<span class="n">MODULE_DESCRIPTION</span><span class="p">(</span><span class="s">&quot;A New Implementation of the Log-structured Filesystem &quot;</span>
		   <span class="s">&quot;(NILFS)&quot;</span><span class="p">);</span>
<span class="n">MODULE_LICENSE</span><span class="p">(</span><span class="s">&quot;GPL&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">nilfs_inode_cachep</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">nilfs_transaction_cachep</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">nilfs_segbuf_cachep</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">nilfs_btree_path_cache</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">nilfs_setup_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_mount</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">nilfs_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_set_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_mount_state</span> <span class="o">&amp;</span> <span class="n">NILFS_ERROR_FS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_mount_state</span> <span class="o">|=</span> <span class="n">NILFS_ERROR_FS</span><span class="p">;</span>
		<span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs_prepare_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sbp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NILFS_ERROR_FS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
				<span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">|=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NILFS_ERROR_FS</span><span class="p">);</span>
			<span class="n">nilfs_commit_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">NILFS_SB_COMMIT_ALL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_error() - report failure condition on a filesystem</span>
<span class="cm"> *</span>
<span class="cm"> * nilfs_error() sets an ERROR_FS flag on the superblock as well as</span>
<span class="cm"> * reporting an error message.  It should be called when NILFS detects</span>
<span class="cm"> * incoherences or defects of meta data on disk.  As for sustainable</span>
<span class="cm"> * errors such as a single-shot I/O error, nilfs_warning() or the printk()</span>
<span class="cm"> * function should be used instead.</span>
<span class="cm"> *</span>
<span class="cm"> * The segment constructor must not call this function because it can</span>
<span class="cm"> * kill itself.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nilfs_error</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span>
		 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NILFS error (device %s): %s: %pV</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_set_error</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">ERRORS_RO</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;Remounting filesystem read-only</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">ERRORS_PANIC</span><span class="p">))</span>
		<span class="n">panic</span><span class="p">(</span><span class="s">&quot;NILFS (device %s): panic forced after error</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_warning</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NILFS warning (device %s): %s: %pV</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">nilfs_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>

	<span class="n">ii</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">nilfs_inode_cachep</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ii</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_cno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_version</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">nilfs_mapping_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_btnode_cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">nilfs_mdt_info</span> <span class="o">*</span><span class="n">mdi</span> <span class="o">=</span> <span class="n">NILFS_MDT</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mdi</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mdi</span><span class="o">-&gt;</span><span class="n">mi_bgl</span><span class="p">);</span> <span class="cm">/* kfree(NULL) is safe */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mdi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">nilfs_inode_cachep</span><span class="p">,</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">nilfs_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_sync_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">BARRIER</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__sync_dirty_buffer</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					  <span class="n">WRITE_SYNC</span> <span class="o">|</span> <span class="n">WRITE_FLUSH_FUA</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;NILFS: unable to write superblock (err=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">&amp;&amp;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * sbp[0] points to newer log than sbp[1],</span>
<span class="cm">			 * so copy sbp[0] to sbp[1] to take over sbp[0].</span>
<span class="cm">			 */</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			       <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">);</span>
			<span class="n">nilfs_fall_back_super_block</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbwcount</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * The latest segment becomes trailable from the position</span>
<span class="cm">		 * written in superblock.</span>
<span class="cm">		 */</span>
		<span class="n">clear_nilfs_discontinued</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>

		<span class="cm">/* update GC protection for recent segments */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">NILFS_SB_COMMIT_ALL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_buffer_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sync_dirty_buffer</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_last_cno</span><span class="p">)</span> <span class="o">&lt;</span>
			    <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_last_cno</span><span class="p">))</span>
				<span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_last_segment_lock</span><span class="p">);</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_prot_seq</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_last_seq</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_last_segment_lock</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_set_log_cursor</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="n">sbp</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">nfreeblocks</span><span class="p">;</span>

	<span class="cm">/* nilfs-&gt;ns_sem must be locked by the caller. */</span>
	<span class="n">nilfs_count_free_blocks</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfreeblocks</span><span class="p">);</span>
	<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_free_blocks_count</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nfreeblocks</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_last_segment_lock</span><span class="p">);</span>
	<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_last_seq</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_last_seq</span><span class="p">);</span>
	<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_last_pseg</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_last_pseg</span><span class="p">);</span>
	<span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_last_cno</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_last_cno</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_last_segment_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="nf">nilfs_prepare_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					       <span class="kt">int</span> <span class="n">flip</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">;</span>

	<span class="cm">/* nilfs-&gt;ns_sem must be locked by the caller. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">!=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NILFS_SUPER_MAGIC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">==</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NILFS_SUPER_MAGIC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;NILFS: superblock broke on dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		   <span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">!=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NILFS_SUPER_MAGIC</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flip</span> <span class="o">&amp;&amp;</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">nilfs_swap_super_block</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">sbp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_commit_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">;</span>
	<span class="kt">time_t</span> <span class="n">t</span><span class="p">;</span>

	<span class="cm">/* nilfs-&gt;ns_sem must be locked by the caller. */</span>
	<span class="n">t</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbwtime</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
	<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_wtime</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
	<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_sum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">crc32_le</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_crc_seed</span><span class="p">,</span>
					     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					     <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">==</span> <span class="n">NILFS_SB_COMMIT_ALL</span> <span class="o">&amp;&amp;</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_wtime</span> <span class="o">=</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_wtime</span><span class="p">;</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_sum</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">crc32_le</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_crc_seed</span><span class="p">,</span>
					    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
					    <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">clear_nilfs_sb_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nilfs_sync_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_cleanup_super() - write filesystem state for cleanup</span>
<span class="cm"> * @sb: super block instance to be unmounted or degraded to read-only</span>
<span class="cm"> *</span>
<span class="cm"> * This function restores state flags in the on-disk super block.</span>
<span class="cm"> * This will set &quot;clean&quot; flag (i.e. NILFS_VALID_FS) unless the</span>
<span class="cm"> * filesystem was not clean previously.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_cleanup_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">NILFS_SB_COMMIT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs_prepare_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_mount_state</span><span class="p">);</span>
		<span class="n">nilfs_set_log_cursor</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_last_cno</span> <span class="o">==</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_last_cno</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * make the &quot;clean&quot; flag also to the opposite</span>
<span class="cm">			 * super block if both super blocks point to</span>
<span class="cm">			 * the same checkpoint.</span>
<span class="cm">			 */</span>
			<span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">=</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span><span class="p">;</span>
			<span class="n">flag</span> <span class="o">=</span> <span class="n">NILFS_SB_COMMIT_ALL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_commit_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">flag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_move_2nd_super - relocate secondary super block</span>
<span class="cm"> * @sb: super block instance</span>
<span class="cm"> * @sb2off: new offset of the secondary super block (in bytes)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_move_2nd_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">sb2off</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">nsbh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="n">nsbp</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">newblocknr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sb2i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>  <span class="cm">/* array index of the secondary superblock */</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* nilfs-&gt;ns_sem must be locked by the caller. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
	    <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">&gt;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_first_data_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb2i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">&gt;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_first_data_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sb2i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb2i</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">blocknr</span> <span class="o">&lt;&lt;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocksize_bits</span> <span class="o">==</span> <span class="n">sb2off</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>  <span class="cm">/* super block location is unchanged */</span>

	<span class="cm">/* Get new super block buffer */</span>
	<span class="n">newblocknr</span> <span class="o">=</span> <span class="n">sb2off</span> <span class="o">&gt;&gt;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocksize_bits</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="n">sb2off</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">nsbh</span> <span class="o">=</span> <span class="n">sb_getblk</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">newblocknr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nsbh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;NILFS warning: unable to move secondary superblock &quot;</span>
		       <span class="s">&quot;to block %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">newblocknr</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nsbp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">nsbh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">nsbp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocksize</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb2i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">nsbp</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="n">sb2i</span><span class="p">],</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="n">sb2i</span><span class="p">]);</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="n">sb2i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsbh</span><span class="p">;</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="n">sb2i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsbp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">&lt;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_first_data_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* secondary super block will be restored to index 1 */</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsbh</span><span class="p">;</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsbp</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">nsbh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_resize_fs - resize the filesystem</span>
<span class="cm"> * @sb: super block instance</span>
<span class="cm"> * @newsize: new size of the filesystem (in bytes)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_resize_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">devsize</span><span class="p">,</span> <span class="n">newnsegs</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">sb2off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERANGE</span><span class="p">;</span>
	<span class="n">devsize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&gt;</span> <span class="n">devsize</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Write lock is required to protect some functions depending</span>
<span class="cm">	 * on the number of segments, the number of reserved segments,</span>
<span class="cm">	 * and so forth.</span>
<span class="cm">	 */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>

	<span class="n">sb2off</span> <span class="o">=</span> <span class="n">NILFS_SB2_OFFSET_BYTES</span><span class="p">(</span><span class="n">newsize</span><span class="p">);</span>
	<span class="n">newnsegs</span> <span class="o">=</span> <span class="n">sb2off</span> <span class="o">&gt;&gt;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocksize_bits</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">newnsegs</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocks_per_segment</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_resize</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span> <span class="n">newnsegs</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_construct_segment</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="n">nilfs_move_2nd_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sb2off</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs_prepare_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sbp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_set_log_cursor</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * Drop NILFS_RESIZE_FS flag for compatibility with</span>
<span class="cm">		 * mount-time resize which may be implemented in a</span>
<span class="cm">		 * future release.</span>
<span class="cm">		 */</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span><span class="p">)</span> <span class="o">&amp;</span>
					      <span class="o">~</span><span class="n">NILFS_RESIZE_FS</span><span class="p">);</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_dev_size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">newsize</span><span class="p">);</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_nsegments</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nsegments</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_commit_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">NILFS_SB_COMMIT_ALL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Reset the range of allocatable segments last.  This order</span>
<span class="cm">	 * is important in the case of expansion because the secondary</span>
<span class="cm">	 * superblock must be protected from log write until migration</span>
<span class="cm">	 * completes.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">nilfs_sufile_set_alloc_range</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">newnsegs</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">nilfs_detach_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
		<span class="n">nilfs_cleanup_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">iput</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">);</span>

	<span class="n">destroy_nilfs</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_sync_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* This function is called when super block should be written back */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_construct_segment</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_sb_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs_prepare_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">nilfs_sb_will_flip</span><span class="p">(</span><span class="n">nilfs</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sbp</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nilfs_set_log_cursor</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nilfs</span><span class="p">);</span>
			<span class="n">nilfs_commit_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">NILFS_SB_COMMIT</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_attach_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">cno</span><span class="p">,</span> <span class="kt">int</span> <span class="n">curr_mnt</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">**</span><span class="n">rootp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_checkpoint</span> <span class="o">*</span><span class="n">raw_cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">nilfs_find_or_create_root</span><span class="p">(</span>
		<span class="n">nilfs</span><span class="p">,</span> <span class="n">curr_mnt</span> <span class="o">?</span> <span class="n">NILFS_CPTREE_CURRENT_CNO</span> <span class="o">:</span> <span class="n">cno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">reuse</span><span class="p">;</span> <span class="cm">/* already attached checkpoint */</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_cpfile_get_checkpoint</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">cno</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">raw_cp</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">bh_cp</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;NILFS: Invalid checkpoint &quot;</span>
			       <span class="s">&quot;(checkpoint number=%llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cno</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_ifile_read</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_size</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_ifile_inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed_bh</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inodes_count</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_inodes_count</span><span class="p">));</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">blocks_count</span><span class="p">,</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_blocks_count</span><span class="p">));</span>

	<span class="n">nilfs_cpfile_put_checkpoint</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">cno</span><span class="p">,</span> <span class="n">bh_cp</span><span class="p">);</span>

 <span class="nl">reuse:</span>
	<span class="o">*</span><span class="n">rootp</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed_bh:</span>
	<span class="n">nilfs_cpfile_put_checkpoint</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">cno</span><span class="p">,</span> <span class="n">bh_cp</span><span class="p">);</span>
 <span class="nl">failed:</span>
	<span class="n">nilfs_put_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_freeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* Mark super block clean */</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_cleanup_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_unfreeze</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="n">nilfs_setup_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">nilfs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">id</span> <span class="o">=</span> <span class="n">huge_encode_dev</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">blocks</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">overhead</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nrsvblocks</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">nfreeblocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute all of the segment blocks</span>
<span class="cm">	 *</span>
<span class="cm">	 * The blocks before first segment and after last segment</span>
<span class="cm">	 * are excluded.</span>
<span class="cm">	 */</span>
	<span class="n">blocks</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocks_per_segment</span> <span class="o">*</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nsegments</span>
		<span class="o">-</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_first_data_block</span><span class="p">;</span>
	<span class="n">nrsvblocks</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nrsvsegs</span> <span class="o">*</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocks_per_segment</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Compute the overhead</span>
<span class="cm">	 *</span>
<span class="cm">	 * When distributing meta data blocks outside segment structure,</span>
<span class="cm">	 * We must count them as the overhead.</span>
<span class="cm">	 */</span>
	<span class="n">overhead</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_count_free_blocks</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nfreeblocks</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_type</span> <span class="o">=</span> <span class="n">NILFS_SUPER_MAGIC</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bsize</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_blocks</span> <span class="o">=</span> <span class="n">blocks</span> <span class="o">-</span> <span class="n">overhead</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span> <span class="o">=</span> <span class="n">nfreeblocks</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bavail</span> <span class="o">=</span> <span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span> <span class="o">&gt;=</span> <span class="n">nrsvblocks</span><span class="p">)</span> <span class="o">?</span>
		<span class="p">(</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span> <span class="o">-</span> <span class="n">nrsvblocks</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_files</span> <span class="o">=</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inodes_count</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_ffree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* nilfs_count_free_inodes(sb); */</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_namelen</span> <span class="o">=</span> <span class="n">NILFS_NAME_LEN</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">id</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">BARRIER</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,nobarrier&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">cno</span> <span class="o">!=</span> <span class="n">NILFS_CPTREE_CURRENT_CNO</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,cp=%llu&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">cno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">ERRORS_PANIC</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,errors=panic&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">ERRORS_CONT</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,errors=continue&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">STRICT_ORDER</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,order=strict&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">NORECOVERY</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,norecovery&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">DISCARD</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,discard&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">nilfs_sops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span>    <span class="o">=</span> <span class="n">nilfs_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span>  <span class="o">=</span> <span class="n">nilfs_destroy_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">dirty_inode</span>    <span class="o">=</span> <span class="n">nilfs_dirty_inode</span><span class="p">,</span>
	<span class="cm">/* .write_inode    = nilfs_write_inode, */</span>
	<span class="cm">/* .put_inode      = nilfs_put_inode, */</span>
	<span class="cm">/* .drop_inode	  = nilfs_drop_inode, */</span>
	<span class="p">.</span><span class="n">evict_inode</span>    <span class="o">=</span> <span class="n">nilfs_evict_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_super</span>      <span class="o">=</span> <span class="n">nilfs_put_super</span><span class="p">,</span>
	<span class="cm">/* .write_super    = nilfs_write_super, */</span>
	<span class="p">.</span><span class="n">sync_fs</span>        <span class="o">=</span> <span class="n">nilfs_sync_fs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">freeze_fs</span>	<span class="o">=</span> <span class="n">nilfs_freeze</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unfreeze_fs</span>	<span class="o">=</span> <span class="n">nilfs_unfreeze</span><span class="p">,</span>
	<span class="cm">/* .write_super_lockfs */</span>
	<span class="cm">/* .unlockfs */</span>
	<span class="p">.</span><span class="n">statfs</span>         <span class="o">=</span> <span class="n">nilfs_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remount_fs</span>     <span class="o">=</span> <span class="n">nilfs_remount</span><span class="p">,</span>
	<span class="cm">/* .umount_begin */</span>
	<span class="p">.</span><span class="n">show_options</span> <span class="o">=</span> <span class="n">nilfs_show_options</span>
<span class="p">};</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">Opt_err_cont</span><span class="p">,</span> <span class="n">Opt_err_panic</span><span class="p">,</span> <span class="n">Opt_err_ro</span><span class="p">,</span>
	<span class="n">Opt_barrier</span><span class="p">,</span> <span class="n">Opt_nobarrier</span><span class="p">,</span> <span class="n">Opt_snapshot</span><span class="p">,</span> <span class="n">Opt_order</span><span class="p">,</span> <span class="n">Opt_norecovery</span><span class="p">,</span>
	<span class="n">Opt_discard</span><span class="p">,</span> <span class="n">Opt_nodiscard</span><span class="p">,</span> <span class="n">Opt_err</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">match_table_t</span> <span class="n">tokens</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">Opt_err_cont</span><span class="p">,</span> <span class="s">&quot;errors=continue&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_err_panic</span><span class="p">,</span> <span class="s">&quot;errors=panic&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_err_ro</span><span class="p">,</span> <span class="s">&quot;errors=remount-ro&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_barrier</span><span class="p">,</span> <span class="s">&quot;barrier&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_nobarrier</span><span class="p">,</span> <span class="s">&quot;nobarrier&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_snapshot</span><span class="p">,</span> <span class="s">&quot;cp=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_order</span><span class="p">,</span> <span class="s">&quot;order=%s&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_norecovery</span><span class="p">,</span> <span class="s">&quot;norecovery&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_discard</span><span class="p">,</span> <span class="s">&quot;discard&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_nodiscard</span><span class="p">,</span> <span class="s">&quot;nodiscard&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_err</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">parse_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_remount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">substring_t</span> <span class="n">args</span><span class="p">[</span><span class="n">MAX_OPT_ARGS</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">options</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">token</span> <span class="o">=</span> <span class="n">match_token</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Opt_barrier</span>:
			<span class="n">nilfs_set_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">BARRIER</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_nobarrier</span>:
			<span class="n">nilfs_clear_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">BARRIER</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_order</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from</span><span class="p">,</span> <span class="s">&quot;relaxed&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="cm">/* Ordered data semantics */</span>
				<span class="n">nilfs_clear_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">STRICT_ORDER</span><span class="p">);</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from</span><span class="p">,</span> <span class="s">&quot;strict&quot;</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="cm">/* Strict in-order semantics */</span>
				<span class="n">nilfs_set_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">STRICT_ORDER</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_err_panic</span>:
			<span class="n">nilfs_write_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">ERROR_MODE</span><span class="p">,</span> <span class="n">ERRORS_PANIC</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_err_ro</span>:
			<span class="n">nilfs_write_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">ERROR_MODE</span><span class="p">,</span> <span class="n">ERRORS_RO</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_err_cont</span>:
			<span class="n">nilfs_write_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">ERROR_MODE</span><span class="p">,</span> <span class="n">ERRORS_CONT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_snapshot</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">is_remount</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;NILFS: </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> option is invalid &quot;</span>
				       <span class="s">&quot;for remount.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_norecovery</span>:
			<span class="n">nilfs_set_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">NORECOVERY</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_discard</span>:
			<span class="n">nilfs_set_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">DISCARD</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_nodiscard</span>:
			<span class="n">nilfs_clear_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">DISCARD</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
			       <span class="s">&quot;NILFS: Unrecognized mount option </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">nilfs_set_default_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="n">sbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_mount_opt</span> <span class="o">=</span>
		<span class="n">NILFS_MOUNT_ERRORS_RO</span> <span class="o">|</span> <span class="n">NILFS_MOUNT_BARRIER</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_setup_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_mount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_mnt_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mnt_count</span><span class="p">;</span>

	<span class="cm">/* nilfs-&gt;ns_sem must be locked by the caller. */</span>
	<span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs_prepare_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_mount</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">skip_mount_setup</span><span class="p">;</span>

	<span class="n">max_mnt_count</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_max_mnt_count</span><span class="p">);</span>
	<span class="n">mnt_count</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_mnt_count</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_mount_state</span> <span class="o">&amp;</span> <span class="n">NILFS_ERROR_FS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
		       <span class="s">&quot;NILFS warning: mounting fs with errors</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">	} else if (max_mnt_count &gt;= 0 &amp;&amp; mnt_count &gt;= max_mnt_count) {</span>
<span class="c">		printk(KERN_WARNING</span>
<span class="c">		       &quot;NILFS warning: maximal mount count reached\n&quot;);</span>
<span class="cp">#endif</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_mnt_count</span><span class="p">)</span>
		<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_max_mnt_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">NILFS_DFL_MAX_MNT_COUNT</span><span class="p">);</span>

	<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_mnt_count</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">mnt_count</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_mtime</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">get_seconds</span><span class="p">());</span>

<span class="nl">skip_mount_setup:</span>
	<span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span> <span class="o">=</span>
		<span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_state</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">NILFS_VALID_FS</span><span class="p">);</span>
	<span class="cm">/* synchronize sbp[1] with sbp[0] */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbsize</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nilfs_commit_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">NILFS_SB_COMMIT_ALL</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="nf">nilfs_read_super_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
						 <span class="n">u64</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">,</span>
						 <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="n">pbh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">sb_index</span> <span class="o">=</span> <span class="n">pos</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">offset</span> <span class="o">=</span> <span class="n">do_div</span><span class="p">(</span><span class="n">sb_index</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="o">*</span><span class="n">pbh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sb_index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">pbh</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">*</span><span class="n">pbh</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_store_magic_and_option</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="n">sbp</span><span class="p">,</span>
				 <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_magic</span><span class="p">);</span>

	<span class="cm">/* FS independent flags */</span>
<span class="cp">#ifdef NILFS_ATIME_DISABLE</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_NOATIME</span><span class="p">;</span>
<span class="cp">#endif</span>

	<span class="n">nilfs_set_default_options</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sbp</span><span class="p">);</span>

	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_resuid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_def_resuid</span><span class="p">);</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_resgid</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_def_resgid</span><span class="p">);</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_interval</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_c_interval</span><span class="p">);</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_watermark</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_c_block_max</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">!</span><span class="n">parse_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="mi">0</span> <span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_check_feature_compatibility</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">*</span><span class="n">sbp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__u64</span> <span class="n">features</span><span class="p">;</span>

	<span class="n">features</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_feature_incompat</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="n">NILFS_FEATURE_INCOMPAT_SUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: couldn&#39;t mount because of unsupported &quot;</span>
		       <span class="s">&quot;optional features (%llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">features</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">features</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sbp</span><span class="o">-&gt;</span><span class="n">s_feature_compat_ro</span><span class="p">)</span> <span class="o">&amp;</span>
		<span class="o">~</span><span class="n">NILFS_FEATURE_COMPAT_RO_SUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">features</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: couldn&#39;t mount RDWR because of &quot;</span>
		       <span class="s">&quot;unsupported optional features (%llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">features</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_get_root_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">root_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">nilfs_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">NILFS_ROOT_INO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: get root inode failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blocks</span> <span class="o">||</span> <span class="o">!</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: corrupt root inode.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">cno</span> <span class="o">==</span> <span class="n">NILFS_CPTREE_CURRENT_CNO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">failed_dentry</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_obtain_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">failed_dentry</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">root_dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

 <span class="nl">failed_dentry:</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: get root dentry failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_attach_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">cno</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">**</span><span class="n">root_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_cpfile_is_snapshot</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">cno</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="o">?</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: The specified checkpoint is &quot;</span>
		       <span class="s">&quot;not a snapshot (checkpoint number=%llu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cno</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_attach_checkpoint</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">cno</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: error loading snapshot &quot;</span>
		       <span class="s">&quot;(checkpoint number=%llu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cno</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_get_root_dentry</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">root_dentry</span><span class="p">);</span>
	<span class="n">nilfs_put_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_tree_was_touched</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">root_dentry</span><span class="o">-&gt;</span><span class="n">d_count</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_try_to_shrink_tree() - try to shrink dentries of a checkpoint</span>
<span class="cm"> * @root_dentry: root dentry of the tree to be shrunk</span>
<span class="cm"> *</span>
<span class="cm"> * This function returns true if the tree was in-use.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_try_to_shrink_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">have_submounts</span><span class="p">(</span><span class="n">root_dentry</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">shrink_dcache_parent</span><span class="p">(</span><span class="n">root_dentry</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nilfs_tree_was_touched</span><span class="p">(</span><span class="n">root_dentry</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_checkpoint_is_mounted</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">cno</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cno</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">cno</span> <span class="o">&gt;</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cno</span> <span class="o">&gt;=</span> <span class="n">nilfs_last_cno</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">true</span><span class="p">;</span>	<span class="cm">/* protect recent checkpoints */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">nilfs_lookup_root</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">cno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">nilfs_ilookup</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">NILFS_ROOT_INO</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dentry</span> <span class="o">=</span> <span class="n">d_find_alias</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_tree_was_touched</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_try_to_shrink_tree</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
				<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nilfs_put_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_fill_super() - initialize a super block instance</span>
<span class="cm"> * @sb: super_block</span>
<span class="cm"> * @data: mount options</span>
<span class="cm"> * @silent: silent mode flag</span>
<span class="cm"> *</span>
<span class="cm"> * This function is called exclusively by nilfs-&gt;ns_mount_mutex.</span>
<span class="cm"> * So, the recovery process is protected from other simultaneous mounts.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nilfs_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">fsroot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">backing_dev_info</span> <span class="o">*</span><span class="n">bdi</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">cno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">nilfs</span> <span class="o">=</span> <span class="n">alloc_nilfs</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">nilfs</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">init_nilfs</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed_nilfs</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_sops</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_export_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_export_ops</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_max_links</span> <span class="o">=</span> <span class="n">NILFS_LINK_MAX</span><span class="p">;</span>

	<span class="n">bdi</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdi</span> <span class="o">=</span> <span class="n">bdi</span> <span class="o">?</span> <span class="o">:</span> <span class="o">&amp;</span><span class="n">default_backing_dev_info</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">load_nilfs</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed_nilfs</span><span class="p">;</span>

	<span class="n">cno</span> <span class="o">=</span> <span class="n">nilfs_last_cno</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_attach_checkpoint</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">cno</span><span class="p">,</span> <span class="nb">true</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fsroot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: error loading last checkpoint &quot;</span>
		       <span class="s">&quot;(checkpoint number=%llu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cno</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_unload</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_attach_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fsroot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed_checkpoint</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_get_root_dentry</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fsroot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed_segctor</span><span class="p">;</span>

	<span class="n">nilfs_put_root</span><span class="p">(</span><span class="n">fsroot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
		<span class="n">nilfs_setup_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed_segctor:</span>
	<span class="n">nilfs_detach_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

 <span class="nl">failed_checkpoint:</span>
	<span class="n">nilfs_put_root</span><span class="p">(</span><span class="n">fsroot</span><span class="p">);</span>

 <span class="nl">failed_unload:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">);</span>

 <span class="nl">failed_nilfs:</span>
	<span class="n">destroy_nilfs</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_remount</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_sb_flags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">old_mount_opt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">old_sb_flags</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">;</span>
	<span class="n">old_mount_opt</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_mount_opt</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parse_options</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">restore_opts</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">MS_POSIXACL</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_valid_fs</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NILFS (device %s): couldn&#39;t &quot;</span>
		       <span class="s">&quot;remount because the filesystem is in an &quot;</span>
		       <span class="s">&quot;incomplete recovery state.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">restore_opts</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Shutting down log writer */</span>
		<span class="n">nilfs_detach_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Remounting a valid RW partition RDONLY, so set</span>
<span class="cm">		 * the RDONLY flag and then mark the partition as valid again.</span>
<span class="cm">		 */</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
		<span class="n">nilfs_cleanup_super</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__u64</span> <span class="n">features</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mounting a RDONLY partition read-write, so reread and</span>
<span class="cm">		 * store the current valid flag.  (It may have been changed</span>
<span class="cm">		 * by fsck since we originally mounted the partition.)</span>
<span class="cm">		 */</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
		<span class="n">features</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">s_feature_compat_ro</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="n">NILFS_FEATURE_COMPAT_RO_SUPP</span><span class="p">;</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">features</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;NILFS (device %s): couldn&#39;t &quot;</span>
			       <span class="s">&quot;remount RDWR because of unsupported optional &quot;</span>
			       <span class="s">&quot;features (%llx)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">features</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">restore_opts</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">MS_RDONLY</span><span class="p">;</span>

		<span class="n">root</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_attach_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">restore_opts</span><span class="p">;</span>

		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
		<span class="n">nilfs_setup_super</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">restore_opts:</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">old_sb_flags</span><span class="p">;</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_mount_opt</span> <span class="o">=</span> <span class="n">old_mount_opt</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nilfs_super_data</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">cno</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_identify - pre-read mount options needed to identify mount instance</span>
<span class="cm"> * @data: mount options</span>
<span class="cm"> * @sd: nilfs_super_data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_identify</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nilfs_super_data</span> <span class="o">*</span><span class="n">sd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="o">*</span><span class="n">options</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">substring_t</span> <span class="n">args</span><span class="p">[</span><span class="n">MAX_OPT_ARGS</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">token</span> <span class="o">=</span> <span class="n">match_token</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">token</span> <span class="o">==</span> <span class="n">Opt_snapshot</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">sd</span><span class="o">-&gt;</span><span class="n">cno</span> <span class="o">=</span> <span class="n">simple_strtoull</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from</span><span class="p">,</span>
								  <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
					<span class="cm">/*</span>
<span class="cm">					 * No need to see the end pointer;</span>
<span class="cm">					 * match_token() has done syntax</span>
<span class="cm">					 * checking.</span>
<span class="cm">					 */</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="o">-&gt;</span><span class="n">cno</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
						<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;NILFS: invalid mount option: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">options</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">options</span> <span class="o">==</span> <span class="n">data</span><span class="p">);</span>
		<span class="o">*</span><span class="p">(</span><span class="n">options</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;,&#39;</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_set_bdev_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">=</span> <span class="n">data</span><span class="p">;</span>
	<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_dev</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_test_bdev_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_bdev</span> <span class="o">==</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span>
<span class="nf">nilfs_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span>
	     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_super_data</span> <span class="n">sd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="n">fmode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">FMODE_READ</span> <span class="o">|</span> <span class="n">FMODE_EXCL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root_dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">s_new</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="n">mode</span> <span class="o">|=</span> <span class="n">FMODE_WRITE</span><span class="p">;</span>

	<span class="n">sd</span><span class="p">.</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">blkdev_get_by_path</span><span class="p">(</span><span class="n">dev_name</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="p">);</span>

	<span class="n">sd</span><span class="p">.</span><span class="n">cno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sd</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_identify</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sd</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * once the super is inserted into the list by sget, s_umount</span>
<span class="cm">	 * will protect the lockfs code from trying to start a snapshot</span>
<span class="cm">	 * while we are mounting</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">s</span> <span class="o">=</span> <span class="n">sget</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">nilfs_test_bdev_super</span><span class="p">,</span> <span class="n">nilfs_set_bdev_super</span><span class="p">,</span> <span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_fsfreeze_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>

		<span class="n">s_new</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

		<span class="cm">/* New superblock instance created */</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="p">;</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">bdevname</span><span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">));</span>
		<span class="n">sb_set_blocksize</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">block_size</span><span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="p">));</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_fill_super</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_SILENT</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed_super</span><span class="p">;</span>

		<span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_ACTIVE</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sd</span><span class="p">.</span><span class="n">cno</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">busy</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_tree_was_touched</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">busy</span> <span class="o">=</span> <span class="n">nilfs_try_to_shrink_tree</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">busy</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">^</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: the device already &quot;</span>
				       <span class="s">&quot;has a %s mount.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">?</span>
				       <span class="s">&quot;read-only&quot;</span> <span class="o">:</span> <span class="s">&quot;read/write&quot;</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">failed_super</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">busy</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Try remount to setup mount states if the current</span>
<span class="cm">			 * tree is not mounted and only snapshots use this sb.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_remount</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">failed_super</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">cno</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_attach_snapshot</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">sd</span><span class="p">.</span><span class="n">cno</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_dentry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed_super</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">root_dentry</span> <span class="o">=</span> <span class="n">dget</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s_new</span><span class="p">)</span>
		<span class="n">blkdev_put</span><span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">root_dentry</span><span class="p">;</span>

 <span class="nl">failed_super:</span>
	<span class="n">deactivate_locked_super</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

 <span class="nl">failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s_new</span><span class="p">)</span>
		<span class="n">blkdev_put</span><span class="p">(</span><span class="n">sd</span><span class="p">.</span><span class="n">bdev</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">nilfs_fs_type</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>    <span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>     <span class="o">=</span> <span class="s">&quot;nilfs2&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>    <span class="o">=</span> <span class="n">nilfs_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>  <span class="o">=</span> <span class="n">kill_block_super</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fs_flags</span> <span class="o">=</span> <span class="n">FS_REQUIRES_DEV</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_inode_init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">);</span>
<span class="cp">#ifdef CONFIG_NILFS_XATTR</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">xattr_sem</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="n">address_space_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_btnode_cache</span><span class="p">);</span>
	<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap_data</span><span class="p">;</span>
	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segbuf_init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">obj</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_segment_buffer</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_destroy_cachep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_inode_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">nilfs_inode_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_transaction_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">nilfs_transaction_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_segbuf_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">nilfs_segbuf_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_btree_path_cache</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">nilfs_btree_path_cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">nilfs_init_cachep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nilfs_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;nilfs2_inode_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_inode_info</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">,</span> <span class="n">nilfs_inode_init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_inode_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">nilfs_transaction_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;nilfs2_transaction_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_transaction_info</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_transaction_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">nilfs_segbuf_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;nilfs2_segbuf_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_segment_buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span><span class="p">,</span> <span class="n">nilfs_segbuf_init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_segbuf_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">nilfs_btree_path_cache</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;nilfs2_btree_path_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_btree_path</span><span class="p">)</span> <span class="o">*</span> <span class="n">NILFS_BTREE_LEVEL_MAX</span><span class="p">,</span>
			<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_btree_path_cache</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">fail:</span>
	<span class="n">nilfs_destroy_cachep</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_nilfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_init_cachep</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs_fs_type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free_cachep</span><span class="p">;</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;NILFS version 2 loaded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">free_cachep:</span>
	<span class="n">nilfs_destroy_cachep</span><span class="p">();</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_nilfs_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nilfs_destroy_cachep</span><span class="p">();</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs_fs_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_nilfs_fs</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_nilfs_fs</span><span class="p">)</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
