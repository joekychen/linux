<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › nilfs2 › segment.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>segment.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * segment.c - NILFS segment constructor.</span>
<span class="cm"> *</span>
<span class="cm"> * Copyright (C) 2005-2008 Nippon Telegraph and Telephone Corporation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or modify</span>
<span class="cm"> * it under the terms of the GNU General Public License as published by</span>
<span class="cm"> * the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm"> * (at your option) any later version.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm"> * GNU General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public License</span>
<span class="cm"> * along with this program; if not, write to the Free Software</span>
<span class="cm"> * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA</span>
<span class="cm"> *</span>
<span class="cm"> * Written by Ryusuke Konishi &lt;ryusuke@osrg.net&gt;</span>
<span class="cm"> *</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/completion.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/freezer.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/crc32.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;nilfs.h&quot;</span>
<span class="cp">#include &quot;btnode.h&quot;</span>
<span class="cp">#include &quot;page.h&quot;</span>
<span class="cp">#include &quot;segment.h&quot;</span>
<span class="cp">#include &quot;sufile.h&quot;</span>
<span class="cp">#include &quot;cpfile.h&quot;</span>
<span class="cp">#include &quot;ifile.h&quot;</span>
<span class="cp">#include &quot;segbuf.h&quot;</span>


<span class="cm">/*</span>
<span class="cm"> * Segment constructor</span>
<span class="cm"> */</span>
<span class="cp">#define SC_N_INODEVEC	16   </span><span class="cm">/* Size of locally allocated inode vector */</span><span class="cp"></span>

<span class="cp">#define SC_MAX_SEGDELTA 64   </span><span class="cm">/* Upper limit of the number of segments</span>
<span class="cm">				appended in collection retry loop */</span><span class="cp"></span>

<span class="cm">/* Construction mode */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">SC_LSEG_SR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>	<span class="cm">/* Make a logical segment having a super root */</span>
	<span class="n">SC_LSEG_DSYNC</span><span class="p">,</span>	<span class="cm">/* Flush data blocks of a given file and make</span>
<span class="cm">			   a logical segment without a super root */</span>
	<span class="n">SC_FLUSH_FILE</span><span class="p">,</span>	<span class="cm">/* Flush data files, leads to segment writes without</span>
<span class="cm">			   creating a checkpoint */</span>
	<span class="n">SC_FLUSH_DAT</span><span class="p">,</span>	<span class="cm">/* Flush DAT file. This also creates segments without</span>
<span class="cm">			   a checkpoint */</span>
<span class="p">};</span>

<span class="cm">/* Stage numbers of dirty block collection */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">NILFS_ST_INIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">NILFS_ST_GC</span><span class="p">,</span>		<span class="cm">/* Collecting dirty blocks for GC */</span>
	<span class="n">NILFS_ST_FILE</span><span class="p">,</span>
	<span class="n">NILFS_ST_IFILE</span><span class="p">,</span>
	<span class="n">NILFS_ST_CPFILE</span><span class="p">,</span>
	<span class="n">NILFS_ST_SUFILE</span><span class="p">,</span>
	<span class="n">NILFS_ST_DAT</span><span class="p">,</span>
	<span class="n">NILFS_ST_SR</span><span class="p">,</span>		<span class="cm">/* Super root */</span>
	<span class="n">NILFS_ST_DSYNC</span><span class="p">,</span>		<span class="cm">/* Data sync blocks */</span>
	<span class="n">NILFS_ST_DONE</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/* State flags of collection */</span>
<span class="cp">#define NILFS_CF_NODE		0x0001	</span><span class="cm">/* Collecting node blocks */</span><span class="cp"></span>
<span class="cp">#define NILFS_CF_IFILE_STARTED	0x0002	</span><span class="cm">/* IFILE stage has started */</span><span class="cp"></span>
<span class="cp">#define NILFS_CF_SUFREED	0x0004	</span><span class="cm">/* segment usages has been freed */</span><span class="cp"></span>
<span class="cp">#define NILFS_CF_HISTORY_MASK	(NILFS_CF_IFILE_STARTED | NILFS_CF_SUFREED)</span>

<span class="cm">/* Operations depending on the construction mode and file type */</span>
<span class="k">struct</span> <span class="n">nilfs_sc_operations</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">collect_data</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">collect_node</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">collect_bmap</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_data_binfo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="o">*</span><span class="p">);</span>
	<span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">write_node_binfo</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="p">,</span>
				 <span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="o">*</span><span class="p">);</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Other definitions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nilfs_segctor_start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nilfs_segctor_do_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nilfs_segctor_do_immediate_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">nilfs_dispose_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="cp">#define nilfs_cnt32_gt(a, b)   \</span>
<span class="cp">	(typecheck(__u32, a) &amp;&amp; typecheck(__u32, b) &amp;&amp; \</span>
<span class="cp">	 ((__s32)(b) - (__s32)(a) &lt; 0))</span>
<span class="cp">#define nilfs_cnt32_ge(a, b)   \</span>
<span class="cp">	(typecheck(__u32, a) &amp;&amp; typecheck(__u32, b) &amp;&amp; \</span>
<span class="cp">	 ((__s32)(a) - (__s32)(b) &gt;= 0))</span>
<span class="cp">#define nilfs_cnt32_lt(a, b)  nilfs_cnt32_gt(b, a)</span>
<span class="cp">#define nilfs_cnt32_le(a, b)  nilfs_cnt32_ge(b, a)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_prepare_segment_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">cur_ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">save</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_ti</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_ti</span><span class="o">-&gt;</span><span class="n">ti_magic</span> <span class="o">==</span> <span class="n">NILFS_TI_MAGIC</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">++</span><span class="n">cur_ti</span><span class="o">-&gt;</span><span class="n">ti_count</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * If journal_info field is occupied by other FS,</span>
<span class="cm">			 * it is saved and will be restored on</span>
<span class="cm">			 * nilfs_transaction_commit().</span>
<span class="cm">			 */</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;NILFS warning: journal info from a different &quot;</span>
			       <span class="s">&quot;FS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">save</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">nilfs_transaction_cachep</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ti</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">=</span> <span class="n">NILFS_TI_DYNAMIC_ALLOC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_save</span> <span class="o">=</span> <span class="n">save</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_magic</span> <span class="o">=</span> <span class="n">NILFS_TI_MAGIC</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_transaction_begin - start indivisible file operations.</span>
<span class="cm"> * @sb: super block</span>
<span class="cm"> * @ti: nilfs_transaction_info</span>
<span class="cm"> * @vacancy_check: flags for vacancy rate checks</span>
<span class="cm"> *</span>
<span class="cm"> * nilfs_transaction_begin() acquires a reader/writer semaphore, called</span>
<span class="cm"> * the segment semaphore, to make a segment construction and write tasks</span>
<span class="cm"> * exclusive.  The function is used with nilfs_transaction_commit() in pairs.</span>
<span class="cm"> * The region enclosed by these two functions can be nested.  To avoid a</span>
<span class="cm"> * deadlock, the semaphore is only acquired or released in the outermost call.</span>
<span class="cm"> *</span>
<span class="cm"> * This function allocates a nilfs_transaction_info struct to keep context</span>
<span class="cm"> * information on it.  It is initialized and hooked onto the current task in</span>
<span class="cm"> * the outermost call.  If a pre-allocated struct is given to @ti, it is used</span>
<span class="cm"> * instead; otherwise a new struct is assigned from a slab.</span>
<span class="cm"> *</span>
<span class="cm"> * When @vacancy_check flag is set, this function will check the amount of</span>
<span class="cm"> * free space, and will wait for the GC to reclaim disk space if low capacity.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value: On success, 0 is returned. On error, one of the following</span>
<span class="cm"> * negative error code is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * %-ENOMEM - Insufficient memory available.</span>
<span class="cm"> *</span>
<span class="cm"> * %-ENOSPC - No space left on device</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_transaction_begin</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">vacancy_check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_prepare_segment_lock</span><span class="p">(</span><span class="n">ti</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vfs_check_frozen</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>

	<span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vacancy_check</span> <span class="o">&amp;&amp;</span> <span class="n">nilfs_near_disk_full</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed:</span>
	<span class="n">ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_save</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">&amp;</span> <span class="n">NILFS_TI_DYNAMIC_ALLOC</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">nilfs_transaction_cachep</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_transaction_commit - commit indivisible file operations.</span>
<span class="cm"> * @sb: super block</span>
<span class="cm"> *</span>
<span class="cm"> * nilfs_transaction_commit() releases the read semaphore which is</span>
<span class="cm"> * acquired by nilfs_transaction_begin(). This is only performed</span>
<span class="cm"> * in outermost call of this function.  If a commit flag is set,</span>
<span class="cm"> * nilfs_transaction_commit() sets a timer to start the segment</span>
<span class="cm"> * constructor.  If a sync flag is set, it starts construction</span>
<span class="cm"> * directly.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_transaction_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ti</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_magic</span> <span class="o">!=</span> <span class="n">NILFS_TI_MAGIC</span><span class="p">);</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">|=</span> <span class="n">NILFS_TI_COMMIT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">&amp;</span> <span class="n">NILFS_TI_COMMIT</span><span class="p">)</span>
			<span class="n">nilfs_segctor_start_timer</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_ndirtyblks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_watermark</span><span class="p">)</span>
			<span class="n">nilfs_segctor_do_flush</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_save</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">&amp;</span> <span class="n">NILFS_TI_SYNC</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_construct_segment</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">&amp;</span> <span class="n">NILFS_TI_DYNAMIC_ALLOC</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">nilfs_transaction_cachep</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_transaction_abort</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ti</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_magic</span> <span class="o">!=</span> <span class="n">NILFS_TI_MAGIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_count</span><span class="o">--</span><span class="p">;</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_save</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">&amp;</span> <span class="n">NILFS_TI_DYNAMIC_ALLOC</span><span class="p">)</span>
		<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">nilfs_transaction_cachep</span><span class="p">,</span> <span class="n">ti</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">nilfs_relax_pressure_in_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci</span> <span class="o">||</span> <span class="o">!</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_SC_PRIOR_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_PRIOR_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>

		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">|=</span> <span class="n">NILFS_TI_WRITER</span><span class="p">;</span>
		<span class="n">nilfs_segctor_do_immediate_flush</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NILFS_TI_WRITER</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">downgrade_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_transaction_lock</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">gcflag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">cur_ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cur_ti</span><span class="p">);</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">=</span> <span class="n">NILFS_TI_WRITER</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_save</span> <span class="o">=</span> <span class="n">cur_ti</span><span class="p">;</span>
	<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_magic</span> <span class="o">=</span> <span class="n">NILFS_TI_MAGIC</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_garbage</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">ti</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_PRIOR_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">nilfs_segctor_do_immediate_flush</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
		<span class="n">yield</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gcflag</span><span class="p">)</span>
		<span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_flags</span> <span class="o">|=</span> <span class="n">NILFS_TI_GC</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_transaction_unlock</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ti</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_magic</span> <span class="o">!=</span> <span class="n">NILFS_TI_MAGIC</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span> <span class="o">=</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_save</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_garbage</span><span class="p">))</span>
		<span class="n">nilfs_dispose_list</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_garbage</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="o">*</span><span class="nf">nilfs_segctor_map_segsum_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span>
					    <span class="kt">unsigned</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">blocksize</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">NILFS_SEGBUF_BH_IS_LAST</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segsum_buffers</span><span class="p">));</span>
		<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">bh</span> <span class="o">=</span> <span class="n">NILFS_SEGBUF_NEXT_BH</span><span class="p">(</span><span class="n">ssp</span><span class="o">-&gt;</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">p</span> <span class="o">=</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">ssp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">p</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_reset_segment_buffer - reset the current segment buffer</span>
<span class="cm"> * @sci: nilfs_sc_info</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_reset_segment_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">sumbh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">sumbytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_doing_gc</span><span class="p">())</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">NILFS_SS_GC</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segbuf_reset</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seg_ctime</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_cno</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sumbh</span> <span class="o">=</span> <span class="n">NILFS_SEGBUF_FIRST_BH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segsum_buffers</span><span class="p">);</span>
	<span class="n">sumbytes</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">sumbytes</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_finfo_ptr</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="n">sumbh</span><span class="p">;</span>  <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_finfo_ptr</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sumbytes</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="n">sumbh</span><span class="p">;</span>  <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sumbytes</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_blk_cnt</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_datablk_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_feed_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_this_inc</span> <span class="o">+=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nblocks</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">NILFS_SEGBUF_IS_LAST</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">;</span> <span class="cm">/* The current segment is filled up</span>
<span class="cm">				  (internal code) */</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span> <span class="o">=</span> <span class="n">NILFS_NEXT_SEGBUF</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">nilfs_segctor_reset_segment_buffer</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_add_super_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nblocks</span> <span class="o">&gt;=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_rest_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_feed_segment</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">segbuf</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segbuf_extend_payload</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_super_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span>
		<span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NILFS_SS_SR</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Functions for making segment summary and payloads</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_segsum_block_required</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span>
	<span class="kt">unsigned</span> <span class="n">binfo_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="cm">/* Size of finfo and binfo is enough small against blocksize */</span>

	<span class="k">return</span> <span class="n">ssp</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="n">binfo_size</span> <span class="o">+</span>
		<span class="p">(</span><span class="o">!</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_blk_cnt</span> <span class="o">?</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_finfo</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span>
		<span class="n">blocksize</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_begin_finfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nfinfo</span><span class="o">++</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_finfo_ptr</span><span class="p">;</span>
	<span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span>
		<span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_finfo</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_root</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_HAVE_DELTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_SC_HAVE_DELTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
	<span class="cm">/* skip finfo */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_end_finfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_finfo</span> <span class="o">*</span><span class="n">finfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">cno</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_blk_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_GCINODE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
		<span class="n">cno</span> <span class="o">=</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_cno</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">NILFS_ROOT_METADATA_FILE</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">))</span>
		<span class="n">cno</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">cno</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_cno</span><span class="p">;</span>

	<span class="n">finfo</span> <span class="o">=</span> <span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_finfo_ptr</span><span class="p">,</span>
						 <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">finfo</span><span class="p">));</span>
	<span class="n">finfo</span><span class="o">-&gt;</span><span class="n">fi_ino</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="n">finfo</span><span class="o">-&gt;</span><span class="n">fi_nblocks</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_blk_cnt</span><span class="p">);</span>
	<span class="n">finfo</span><span class="o">-&gt;</span><span class="n">fi_ndatablk</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_datablk_cnt</span><span class="p">);</span>
	<span class="n">finfo</span><span class="o">-&gt;</span><span class="n">fi_cno</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">cno</span><span class="p">);</span>

	<span class="n">segbuf</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">;</span>
	<span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">sumbytes</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">*</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nsumblk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_finfo_ptr</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_blk_cnt</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_datablk_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_add_file_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					<span class="kt">unsigned</span> <span class="n">binfo_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">required</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">retry:</span>
	<span class="n">segbuf</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">;</span>
	<span class="n">required</span> <span class="o">=</span> <span class="n">nilfs_segctor_segsum_block_required</span><span class="p">(</span>
		<span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span><span class="p">,</span> <span class="n">binfo_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nblocks</span> <span class="o">+</span> <span class="n">required</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_rest_blocks</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nilfs_segctor_end_finfo</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_feed_segment</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">required</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segbuf_extend_segsum</span><span class="p">(</span><span class="n">segbuf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_blk_cnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">nilfs_segctor_begin_finfo</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_binfo_ptr</span><span class="p">,</span> <span class="n">binfo_size</span><span class="p">);</span>
	<span class="cm">/* Substitution to vblocknr is delayed until update_blocknr() */</span>
	<span class="n">nilfs_segbuf_add_file_buffer</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_blk_cnt</span><span class="o">++</span><span class="p">;</span>
 <span class="nl">failed:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Callback functions that enumerate, mark, and collect dirty blocks</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_collect_file_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_bmap_propagate</span><span class="p">(</span><span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_add_file_block</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_binfo_v</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_datablk_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_collect_file_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">nilfs_bmap_propagate</span><span class="p">(</span><span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_collect_file_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">nilfs_segctor_add_file_block</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_write_file_data_binfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="o">*</span><span class="n">binfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_binfo_v</span> <span class="o">*</span><span class="n">binfo_v</span> <span class="o">=</span> <span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span>
		<span class="n">sci</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">binfo_v</span><span class="p">));</span>
	<span class="o">*</span><span class="n">binfo_v</span> <span class="o">=</span> <span class="n">binfo</span><span class="o">-&gt;</span><span class="n">bi_v</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_write_file_node_binfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span>
					<span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="o">*</span><span class="n">binfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">vblocknr</span> <span class="o">=</span> <span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span>
		<span class="n">sci</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vblocknr</span><span class="p">));</span>
	<span class="o">*</span><span class="n">vblocknr</span> <span class="o">=</span> <span class="n">binfo</span><span class="o">-&gt;</span><span class="n">bi_v</span><span class="p">.</span><span class="n">bi_vblocknr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nilfs_sc_operations</span> <span class="n">nilfs_sc_file_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">collect_data</span> <span class="o">=</span> <span class="n">nilfs_collect_file_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">collect_node</span> <span class="o">=</span> <span class="n">nilfs_collect_file_node</span><span class="p">,</span>
	<span class="p">.</span><span class="n">collect_bmap</span> <span class="o">=</span> <span class="n">nilfs_collect_file_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_data_binfo</span> <span class="o">=</span> <span class="n">nilfs_write_file_data_binfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_node_binfo</span> <span class="o">=</span> <span class="n">nilfs_write_file_node_binfo</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_collect_dat_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_bmap_propagate</span><span class="p">(</span><span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_add_file_block</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">__le64</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_datablk_cnt</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_collect_dat_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">));</span>
	<span class="k">return</span> <span class="n">nilfs_segctor_add_file_block</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_binfo_dat</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_write_dat_data_binfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span>
				       <span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="o">*</span><span class="n">binfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__le64</span> <span class="o">*</span><span class="n">blkoff</span> <span class="o">=</span> <span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span>
							  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">blkoff</span><span class="p">));</span>
	<span class="o">*</span><span class="n">blkoff</span> <span class="o">=</span> <span class="n">binfo</span><span class="o">-&gt;</span><span class="n">bi_dat</span><span class="p">.</span><span class="n">bi_blkoff</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_write_dat_node_binfo</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="o">*</span><span class="n">ssp</span><span class="p">,</span>
				       <span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="o">*</span><span class="n">binfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_binfo_dat</span> <span class="o">*</span><span class="n">binfo_dat</span> <span class="o">=</span>
		<span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">ssp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">binfo_dat</span><span class="p">));</span>
	<span class="o">*</span><span class="n">binfo_dat</span> <span class="o">=</span> <span class="n">binfo</span><span class="o">-&gt;</span><span class="n">bi_dat</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nilfs_sc_operations</span> <span class="n">nilfs_sc_dat_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">collect_data</span> <span class="o">=</span> <span class="n">nilfs_collect_dat_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">collect_node</span> <span class="o">=</span> <span class="n">nilfs_collect_file_node</span><span class="p">,</span>
	<span class="p">.</span><span class="n">collect_bmap</span> <span class="o">=</span> <span class="n">nilfs_collect_dat_bmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_data_binfo</span> <span class="o">=</span> <span class="n">nilfs_write_dat_data_binfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_node_binfo</span> <span class="o">=</span> <span class="n">nilfs_write_dat_node_binfo</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">nilfs_sc_operations</span> <span class="n">nilfs_sc_dsync_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">collect_data</span> <span class="o">=</span> <span class="n">nilfs_collect_file_data</span><span class="p">,</span>
	<span class="p">.</span><span class="n">collect_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">collect_bmap</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_data_binfo</span> <span class="o">=</span> <span class="n">nilfs_write_file_data_binfo</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_node_binfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">nilfs_lookup_dirty_data_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">listp</span><span class="p">,</span>
					      <span class="kt">size_t</span> <span class="n">nlimit</span><span class="p">,</span>
					      <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">last</span> <span class="o">=</span> <span class="n">ULONG_MAX</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ndirties</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">end</span> <span class="o">!=</span> <span class="n">LLONG_MAX</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * A valid range is given for sync-ing data pages. The</span>
<span class="cm">		 * range is rounded to per-page; extra dirty buffers</span>
<span class="cm">		 * may be included if blocksize &lt; pagesize.</span>
<span class="cm">		 */</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
 <span class="nl">repeat:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">pagevec_lookup_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">,</span>
				<span class="n">min_t</span><span class="p">(</span><span class="n">pgoff_t</span><span class="p">,</span> <span class="n">last</span> <span class="o">-</span> <span class="n">index</span><span class="p">,</span>
				      <span class="n">PAGEVEC_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ndirties</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">last</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_has_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">create_empty_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">,</span> <span class="n">listp</span><span class="p">);</span>
			<span class="n">ndirties</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ndirties</span> <span class="o">&gt;=</span> <span class="n">nlimit</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
				<span class="n">cond_resched</span><span class="p">();</span>
				<span class="k">return</span> <span class="n">ndirties</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">,</span> <span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
	<span class="n">cond_resched</span><span class="p">();</span>
	<span class="k">goto</span> <span class="n">repeat</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_lookup_dirty_node_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">listp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_btnode_cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">pagevec</span> <span class="n">pvec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">pagevec_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">pagevec_lookup_tag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">,</span>
				  <span class="n">PAGEVEC_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">pagevec_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">head</span> <span class="o">=</span> <span class="n">page_buffers</span><span class="p">(</span><span class="n">pvec</span><span class="p">.</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">do</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">get_bh</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">,</span>
						      <span class="n">listp</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_this_page</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">head</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">pagevec_release</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pvec</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_dispose_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ivec</span><span class="p">[</span><span class="n">SC_N_INODEVEC</span><span class="p">],</span> <span class="o">**</span><span class="n">pii</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">brelse</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">);</span>
					<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
				<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dirty_files</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ivec</span><span class="p">[</span><span class="n">nv</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">ii</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nv</span> <span class="o">==</span> <span class="n">SC_N_INODEVEC</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pii</span> <span class="o">=</span> <span class="n">ivec</span><span class="p">;</span> <span class="n">nv</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pii</span><span class="o">++</span><span class="p">,</span> <span class="n">nv</span><span class="o">--</span><span class="p">)</span>
			<span class="n">iput</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">pii</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_test_metadata_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_mdt_fetch_dirty</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">))</span>
		<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_mdt_fetch_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">))</span>
		<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_mdt_fetch_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">))</span>
		<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">ret</span> <span class="o">||</span> <span class="n">nilfs_doing_gc</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nilfs_mdt_fetch_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">))</span>
		<span class="n">ret</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_clean</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nfreesegs</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		<span class="p">(</span><span class="o">!</span><span class="n">nilfs_doing_gc</span><span class="p">()</span> <span class="o">||</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_gc_inodes</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_confirm</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_metadata_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_SC_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dirty_files</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nilfs_segctor_clean</span><span class="p">(</span><span class="n">sci</span><span class="p">))</span>
		<span class="n">ret</span><span class="o">++</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_clear_metadata_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>

	<span class="n">nilfs_mdt_clear_dirty</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">);</span>
	<span class="n">nilfs_mdt_clear_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">);</span>
	<span class="n">nilfs_mdt_clear_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">);</span>
	<span class="n">nilfs_mdt_clear_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_create_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_checkpoint</span> <span class="o">*</span><span class="n">raw_cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* XXX: this interface will be changed */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_cpfile_get_checkpoint</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">raw_cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh_cp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* The following code is duplicated with cpfile.  But, it is</span>
<span class="cm">		   needed to collect the checkpoint even if it was not newly</span>
<span class="cm">		   created */</span>
		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh_cp</span><span class="p">);</span>
		<span class="n">nilfs_mdt_mark_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">);</span>
		<span class="n">nilfs_cpfile_put_checkpoint</span><span class="p">(</span>
			<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="p">,</span> <span class="n">bh_cp</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_fill_in_checkpoint</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_cp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_checkpoint</span> <span class="o">*</span><span class="n">raw_cp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_cpfile_get_checkpoint</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="o">&amp;</span><span class="n">raw_cp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh_cp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EINVAL</span> <span class="o">||</span> <span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">failed_ibh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_snapshot_list</span><span class="p">.</span><span class="n">ssl_next</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_snapshot_list</span><span class="p">.</span><span class="n">ssl_prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_inodes_count</span> <span class="o">=</span>
		<span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="o">-&gt;</span><span class="n">inodes_count</span><span class="p">));</span>
	<span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_blocks_count</span> <span class="o">=</span>
		<span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="o">-&gt;</span><span class="n">blocks_count</span><span class="p">));</span>
	<span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_nblk_inc</span> <span class="o">=</span>
		<span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_inc</span> <span class="o">+</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_this_inc</span><span class="p">);</span>
	<span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_create</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seg_ctime</span><span class="p">);</span>
	<span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_cno</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_HAVE_DELTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span>
		<span class="n">nilfs_checkpoint_clear_minor</span><span class="p">(</span><span class="n">raw_cp</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">nilfs_checkpoint_set_minor</span><span class="p">(</span><span class="n">raw_cp</span><span class="p">);</span>

	<span class="n">nilfs_write_inode_common</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">raw_cp</span><span class="o">-&gt;</span><span class="n">cp_ifile_inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">nilfs_cpfile_put_checkpoint</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="p">,</span> <span class="n">bh_cp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed_ibh:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_fill_in_file_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ifile</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ibh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode</span> <span class="o">*</span><span class="n">raw_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BMAP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ibh</span> <span class="o">=</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ibh</span><span class="p">);</span>
		<span class="n">raw_inode</span> <span class="o">=</span> <span class="n">nilfs_ifile_map_inode</span><span class="p">(</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_ino</span><span class="p">,</span>
						  <span class="n">ibh</span><span class="p">);</span>
		<span class="n">nilfs_bmap_write</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="n">raw_inode</span><span class="p">);</span>
		<span class="n">nilfs_ifile_unmap_inode</span><span class="p">(</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_ino</span><span class="p">,</span> <span class="n">ibh</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_fill_in_file_bmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nilfs_fill_in_file_bmap</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span> <span class="n">ii</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_COLLECTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_fill_in_super_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_sr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_root</span> <span class="o">*</span><span class="n">raw_sr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">isz</span><span class="p">,</span> <span class="n">srsz</span><span class="p">;</span>

	<span class="n">bh_sr</span> <span class="o">=</span> <span class="n">NILFS_LAST_SEGBUF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">sb_super_root</span><span class="p">;</span>
	<span class="n">raw_sr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_super_root</span> <span class="o">*</span><span class="p">)</span><span class="n">bh_sr</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">isz</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_size</span><span class="p">;</span>
	<span class="n">srsz</span> <span class="o">=</span> <span class="n">NILFS_SR_BYTES</span><span class="p">(</span><span class="n">isz</span><span class="p">);</span>

	<span class="n">raw_sr</span><span class="o">-&gt;</span><span class="n">sr_bytes</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">srsz</span><span class="p">);</span>
	<span class="n">raw_sr</span><span class="o">-&gt;</span><span class="n">sr_nongc_ctime</span>
		<span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">nilfs_doing_gc</span><span class="p">()</span> <span class="o">?</span>
			      <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nongc_ctime</span> <span class="o">:</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seg_ctime</span><span class="p">);</span>
	<span class="n">raw_sr</span><span class="o">-&gt;</span><span class="n">sr_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nilfs_write_inode_common</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_sr</span> <span class="o">+</span>
				 <span class="n">NILFS_SR_DAT_OFFSET</span><span class="p">(</span><span class="n">isz</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">nilfs_write_inode_common</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_sr</span> <span class="o">+</span>
				 <span class="n">NILFS_SR_CPFILE_OFFSET</span><span class="p">(</span><span class="n">isz</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">nilfs_write_inode_common</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_sr</span> <span class="o">+</span>
				 <span class="n">NILFS_SR_SUFILE_OFFSET</span><span class="p">(</span><span class="n">isz</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">raw_sr</span> <span class="o">+</span> <span class="n">srsz</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocksize</span> <span class="o">-</span> <span class="n">srsz</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_redirty_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_COLLECTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_I_COLLECTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_drop_collected_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NILFS_I_COLLECTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_I_INODE_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_UPDATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_apply_buffers</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">listp</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">collect</span><span class="p">)(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span>
						      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="p">))</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">collect</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">listp</span><span class="p">,</span> <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">dispose_buffers</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

 <span class="nl">dispose_buffers:</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">listp</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="n">listp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span><span class="p">,</span>
				      <span class="n">b_assoc_buffers</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">size_t</span> <span class="nf">nilfs_segctor_buffer_rest</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Remaining number of blocks within segment buffer */</span>
	<span class="k">return</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbuf_nblocks</span> <span class="o">-</span>
		<span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_this_inc</span> <span class="o">+</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nblocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_scan_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nilfs_sc_operations</span> <span class="o">*</span><span class="n">sc_ops</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">data_buffers</span><span class="p">);</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">node_buffers</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_CF_NODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">nilfs_segctor_buffer_rest</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

		<span class="n">n</span> <span class="o">=</span> <span class="n">nilfs_lookup_dirty_data_buffers</span><span class="p">(</span>
			<span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_buffers</span><span class="p">,</span> <span class="n">rest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">LLONG_MAX</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">rest</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_apply_buffers</span><span class="p">(</span>
				<span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_buffers</span><span class="p">,</span>
				<span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">collect_data</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">);</span> <span class="cm">/* always receive -E2BIG or true error */</span>
			<span class="k">goto</span> <span class="n">break_or_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">nilfs_lookup_dirty_node_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_buffers</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_CF_NODE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_apply_buffers</span><span class="p">(</span>
			<span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_buffers</span><span class="p">,</span> <span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">collect_data</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* dispose node list */</span>
			<span class="n">nilfs_segctor_apply_buffers</span><span class="p">(</span>
				<span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_buffers</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">break_or_fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NILFS_CF_NODE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* Collect node */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_apply_buffers</span><span class="p">(</span>
		<span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_buffers</span><span class="p">,</span> <span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">collect_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">break_or_fail</span><span class="p">;</span>

	<span class="n">nilfs_bmap_lookup_dirty_buffers</span><span class="p">(</span><span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_buffers</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_apply_buffers</span><span class="p">(</span>
		<span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">node_buffers</span><span class="p">,</span> <span class="n">sc_ops</span><span class="o">-&gt;</span><span class="n">collect_bmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">break_or_fail</span><span class="p">;</span>

	<span class="n">nilfs_segctor_end_finfo</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NILFS_CF_NODE</span><span class="p">;</span>

 <span class="nl">break_or_fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_scan_file_dsync</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">data_buffers</span><span class="p">);</span>
	<span class="kt">size_t</span> <span class="n">n</span><span class="p">,</span> <span class="n">rest</span> <span class="o">=</span> <span class="n">nilfs_segctor_buffer_rest</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">nilfs_lookup_dirty_data_buffers</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_buffers</span><span class="p">,</span> <span class="n">rest</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					    <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dsync_start</span><span class="p">,</span>
					    <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dsync_end</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_apply_buffers</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">data_buffers</span><span class="p">,</span>
					  <span class="n">nilfs_collect_file_data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nilfs_segctor_end_finfo</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">rest</span><span class="p">);</span>
		<span class="cm">/* always receive -E2BIG or true error if n &gt; rest */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_collect_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">ndone</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">NILFS_ST_INIT</span>:
		<span class="cm">/* Pre-processes */</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_UNCLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_inc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">NILFS_SS_LOGBGN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_LSEG_DSYNC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">=</span> <span class="n">NILFS_ST_DSYNC</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">dsync_mode</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">dirty_file_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">gc_inode_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_FLUSH_DAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">=</span> <span class="n">NILFS_ST_DAT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">dat_stage</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">NILFS_ST_GC</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_doing_gc</span><span class="p">())</span> <span class="p">{</span>
			<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_gc_inodes</span><span class="p">;</span>
			<span class="n">ii</span> <span class="o">=</span> <span class="n">list_prepare_entry</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">gc_inode_ptr</span><span class="p">,</span>
						<span class="n">head</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">);</span>
			<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_scan_file</span><span class="p">(</span>
					<span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">nilfs_sc_file_ops</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">gc_inode_ptr</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span>
						<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">nilfs_inode_info</span><span class="p">,</span>
						<span class="n">i_dirty</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">break_or_fail</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_COLLECTED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">gc_inode_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">NILFS_ST_FILE</span>:
		<span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">;</span>
		<span class="n">ii</span> <span class="o">=</span> <span class="n">list_prepare_entry</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">dirty_file_ptr</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span>
					<span class="n">i_dirty</span><span class="p">);</span>
		<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_I_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_scan_file</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">nilfs_sc_file_ops</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">dirty_file_ptr</span> <span class="o">=</span>
					<span class="n">list_entry</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">.</span><span class="n">prev</span><span class="p">,</span>
						   <span class="k">struct</span> <span class="n">nilfs_inode_info</span><span class="p">,</span>
						   <span class="n">i_dirty</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">break_or_fail</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* sci-&gt;sc_stage.dirty_file_ptr = NILFS_I(inode); */</span>
			<span class="cm">/* XXX: required ? */</span>
		<span class="p">}</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">dirty_file_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_FLUSH_FILE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">=</span> <span class="n">NILFS_ST_DONE</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NILFS_CF_IFILE_STARTED</span><span class="p">;</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">NILFS_ST_IFILE</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_scan_file</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">nilfs_sc_file_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="o">++</span><span class="p">;</span>
		<span class="cm">/* Creating a checkpoint */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_create_checkpoint</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">NILFS_ST_CPFILE</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_scan_file</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cpfile</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">nilfs_sc_file_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">NILFS_ST_SUFILE</span>:
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_sufile_freev</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_freesegs</span><span class="p">,</span>
					 <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nfreesegs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ndone</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nilfs_sufile_cancel_freev</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span>
						  <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_freesegs</span><span class="p">,</span> <span class="n">ndone</span><span class="p">,</span>
						  <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NILFS_CF_SUFREED</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_scan_file</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">nilfs_sc_file_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">NILFS_ST_DAT</span>:
 <span class="nl">dat_stage:</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_scan_file</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">nilfs_sc_dat_ops</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_FLUSH_DAT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">=</span> <span class="n">NILFS_ST_DONE</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span><span class="o">++</span><span class="p">;</span>  <span class="cm">/* Fall through */</span>
	<span class="k">case</span> <span class="n">NILFS_ST_SR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_LSEG_SR</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Appending a super root */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_add_super_root</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* End of a logical segment */</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NILFS_SS_LOGEND</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">=</span> <span class="n">NILFS_ST_DONE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NILFS_ST_DSYNC</span>:
 <span class="nl">dsync_mode:</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NILFS_SS_SYNDT</span><span class="p">;</span>
		<span class="n">ii</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dsync_inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_scan_file_dsync</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">NILFS_SS_LOGEND</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">=</span> <span class="n">NILFS_ST_DONE</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">NILFS_ST_DONE</span>:
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

 <span class="nl">break_or_fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_begin_construction - setup segment buffer to make a new log</span>
<span class="cm"> * @sci: nilfs_sc_info</span>
<span class="cm"> * @nilfs: nilfs object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_begin_construction</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">nextnum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">segbuf</span> <span class="o">=</span> <span class="n">nilfs_segbuf_new</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">segbuf</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_segbuf_map</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segnum</span><span class="p">,</span>
				 <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_pseg_offset</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_rest_blocks</span> <span class="o">&lt;</span> <span class="n">NILFS_PSEG_MIN_BLOCKS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nilfs_shift_to_next_segment</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
			<span class="n">nilfs_segbuf_map</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_seg_seq</span><span class="p">;</span>
		<span class="n">nextnum</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nextnum</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segnum</span> <span class="o">==</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nextnum</span><span class="p">)</span>
			<span class="cm">/* Start from the head of a new full segment */</span>
			<span class="n">alloc</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* Continue logs */</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">NILFS_LAST_SEGBUF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">);</span>
		<span class="n">nilfs_segbuf_map_cont</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">prev</span><span class="p">);</span>
		<span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span><span class="p">;</span>
		<span class="n">nextnum</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_rest_blocks</span> <span class="o">&lt;</span> <span class="n">NILFS_PSEG_MIN_BLOCKS</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nilfs_segbuf_map</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
			<span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span><span class="o">++</span><span class="p">;</span>
			<span class="n">alloc</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_sufile_mark_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_sufile_alloc</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nextnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nilfs_segbuf_set_next_segnum</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">nextnum</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">));</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">);</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbuf_nblocks</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_rest_blocks</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed:</span>
	<span class="n">nilfs_segbuf_free</span><span class="p">(</span><span class="n">segbuf</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_extend_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nadd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">sufile</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">;</span>
	<span class="n">__u64</span> <span class="n">nextnextnum</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">NILFS_LAST_SEGBUF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since the segment specified with nextnum might be allocated during</span>
<span class="cm">	 * the previous construction, the buffer including its segusage may</span>
<span class="cm">	 * not be dirty.  The following call ensures that the buffer is dirty</span>
<span class="cm">	 * and will pin the buffer on memory until the sufile is written.</span>
<span class="cm">	 */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_sufile_mark_dirty</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nadd</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* extend segment info */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">segbuf</span> <span class="o">=</span> <span class="n">nilfs_segbuf_new</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">segbuf</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

		<span class="cm">/* map this buffer to region of segment on-disk */</span>
		<span class="n">nilfs_segbuf_map</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbuf_nblocks</span> <span class="o">+=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_rest_blocks</span><span class="p">;</span>

		<span class="cm">/* allocate the next next full segment */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_sufile_alloc</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nextnextnum</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed_segbuf</span><span class="p">;</span>

		<span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span> <span class="o">=</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">nilfs_segbuf_set_next_segnum</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">nextnextnum</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>

		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">segbuf</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">list_splice_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed_segbuf:</span>
	<span class="n">nilfs_segbuf_free</span><span class="p">(</span><span class="n">segbuf</span><span class="p">);</span>
 <span class="nl">failed:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_free</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* never fails */</span>
	<span class="p">}</span>
	<span class="n">nilfs_destroy_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_free_incomplete_logs</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">logs</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">sufile</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">segbuf</span> <span class="o">=</span> <span class="n">NILFS_FIRST_SEGBUF</span><span class="p">(</span><span class="n">logs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nextnum</span> <span class="o">!=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_free</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* never fails */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_err</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* Case 1: The first segment failed */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_pseg_start</span> <span class="o">!=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_fseg_start</span><span class="p">)</span>
			<span class="cm">/* Case 1a:  Partial segment appended into an existing</span>
<span class="cm">			   segment */</span>
			<span class="n">nilfs_terminate_segment</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_fseg_start</span><span class="p">,</span>
						<span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_fseg_end</span><span class="p">);</span>
		<span class="k">else</span> <span class="cm">/* Case 1b:  New full segment */</span>
			<span class="n">set_nilfs_discontinued</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">prev</span> <span class="o">=</span> <span class="n">segbuf</span><span class="p">;</span>
	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">logs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span> <span class="o">!=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_free</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* never fails */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_err</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segnum</span> <span class="o">!=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nextnum</span><span class="p">)</span>
			<span class="cm">/* Case 2: extended segment (!= next) failed */</span>
			<span class="n">nilfs_sufile_set_error</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segnum</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">segbuf</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_update_segusage</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">sufile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">live_blocks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">live_blocks</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nblocks</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_pseg_start</span> <span class="o">-</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_fseg_start</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_set_segment_usage</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segnum</span><span class="p">,</span>
						     <span class="n">live_blocks</span><span class="p">,</span>
						     <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seg_ctime</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* always succeed because the segusage is dirty */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_cancel_segusage</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">logs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">sufile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">segbuf</span> <span class="o">=</span> <span class="n">NILFS_FIRST_SEGBUF</span><span class="p">(</span><span class="n">logs</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_set_segment_usage</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segnum</span><span class="p">,</span>
					     <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_pseg_start</span> <span class="o">-</span>
					     <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_fseg_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* always succeed because the segusage is dirty */</span>

	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">logs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_set_segment_usage</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segnum</span><span class="p">,</span>
						     <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* always succeed */</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_truncate_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">last</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">sufile</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">list_for_each_entry_continue</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbuf_nblocks</span> <span class="o">-=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_rest_blocks</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_free</span><span class="p">(</span><span class="n">sufile</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nilfs_truncate_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_collect</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_cstage</span> <span class="n">prev_stage</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">,</span> <span class="n">nadd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* Collection retry loop */</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_this_inc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span> <span class="o">=</span> <span class="n">NILFS_FIRST_SEGBUF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_reset_segment_buffer</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_collect_blocks</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_this_inc</span> <span class="o">+=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nblocks</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="o">-</span><span class="n">E2BIG</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

		<span class="cm">/* The current segment is filled up */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">SC_LSEG_SR</span> <span class="o">||</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">&lt;</span> <span class="n">NILFS_ST_CPFILE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">nilfs_clear_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_extend_segments</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">,</span> <span class="n">nadd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_CF_SUFREED</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_sufile_cancel_freev</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span>
							<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_freesegs</span><span class="p">,</span>
							<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nfreesegs</span><span class="p">,</span>
							<span class="nb">NULL</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">err</span><span class="p">);</span> <span class="cm">/* do not happen */</span>
		<span class="p">}</span>
		<span class="n">nadd</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">nadd</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">SC_MAX_SEGDELTA</span><span class="p">);</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span> <span class="o">=</span> <span class="n">prev_stage</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">nilfs_segctor_truncate_segments</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_list_replace_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">old_bh</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">new_bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">));</span>

	<span class="n">list_replace_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">old_bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_bh</span><span class="o">-&gt;</span><span class="n">b_assoc_buffers</span><span class="p">);</span>
	<span class="cm">/* The caller must release old_bh */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">nilfs_segctor_update_payload_blocknr</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nfinfo</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nfinfo</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nblocks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ndatablk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_operations</span> <span class="o">*</span><span class="n">sc_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_segsum_pointer</span> <span class="n">ssp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_finfo</span> <span class="o">*</span><span class="n">finfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">union</span> <span class="n">nilfs_binfo</span> <span class="n">binfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="o">*</span><span class="n">bh_org</span><span class="p">;</span>
	<span class="n">ino_t</span> <span class="n">ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nfinfo</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">blocknr</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_pseg_start</span> <span class="o">+</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nsumblk</span><span class="p">;</span>
	<span class="n">ssp</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="n">NILFS_SEGBUF_FIRST_BH</span><span class="p">(</span><span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segsum_buffers</span><span class="p">);</span>
	<span class="n">ssp</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_segment_summary</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_payload_buffers</span><span class="p">,</span> <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_super_root</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">finfo</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">finfo</span> <span class="o">=</span>	<span class="n">nilfs_segctor_map_segsum_entry</span><span class="p">(</span>
				<span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">finfo</span><span class="p">));</span>
			<span class="n">ino</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">finfo</span><span class="o">-&gt;</span><span class="n">fi_ino</span><span class="p">);</span>
			<span class="n">nblocks</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">finfo</span><span class="o">-&gt;</span><span class="n">fi_nblocks</span><span class="p">);</span>
			<span class="n">ndatablk</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">finfo</span><span class="o">-&gt;</span><span class="n">fi_ndatablk</span><span class="p">);</span>

			<span class="n">inode</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_LSEG_DSYNC</span><span class="p">)</span>
				<span class="n">sc_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_sc_dsync_ops</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">NILFS_DAT_INO</span><span class="p">)</span>
				<span class="n">sc_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_sc_dat_ops</span><span class="p">;</span>
			<span class="k">else</span> <span class="cm">/* file blocks */</span>
				<span class="n">sc_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">nilfs_sc_file_ops</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bh_org</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">get_bh</span><span class="p">(</span><span class="n">bh_org</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_bmap_assign</span><span class="p">(</span><span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_bmap</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bh</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">binfo</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">!=</span> <span class="n">bh_org</span><span class="p">)</span>
			<span class="n">nilfs_list_replace_buffer</span><span class="p">(</span><span class="n">bh_org</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh_org</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed_bmap</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ndatablk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">sc_op</span><span class="o">-&gt;</span><span class="n">write_data_binfo</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">binfo</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">sc_op</span><span class="o">-&gt;</span><span class="n">write_node_binfo</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ssp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">binfo</span><span class="p">);</span>

		<span class="n">blocknr</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nblocks</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">finfo</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">nfinfo</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ndatablk</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ndatablk</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
 <span class="nl">out:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">failed_bmap:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_assign</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_update_payload_blocknr</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">segbuf</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">nilfs_segbuf_fill_in_segsum</span><span class="p">(</span><span class="n">segbuf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_begin_page_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">||</span> <span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="cm">/* For split b-tree node pages, this function may be called</span>
<span class="cm">		   twice.  We ignore the 2nd or later calls by this check. */</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_prepare_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">bd_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">fs_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segsum_buffers</span><span class="p">,</span>
				    <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lock_page</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">bd_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_payload_buffers</span><span class="p">,</span>
				    <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_super_root</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">lock_page</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">unlock_page</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">bd_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">fs_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nilfs_begin_page_io</span><span class="p">(</span><span class="n">fs_page</span><span class="p">);</span>
				<span class="n">fs_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
		<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
		<span class="n">set_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">nilfs_begin_page_io</span><span class="p">(</span><span class="n">fs_page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_write_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_end_page_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buffer_nilfs_node</span><span class="p">(</span><span class="n">page_buffers</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * For b-tree node pages, this function may be called twice</span>
<span class="cm">		 * or more because they might be split in a segment.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * For pages holding split b-tree node buffers, dirty</span>
<span class="cm">			 * flag on the buffers may be cleared discretely.</span>
<span class="cm">			 * In that case, the page is once redirtied for</span>
<span class="cm">			 * remaining buffers, and it must be cancelled if</span>
<span class="cm">			 * all the buffers get cleaned later.</span>
<span class="cm">			 */</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_page_buffers_clean</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
				<span class="n">__nilfs_clear_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_page_buffers_clean</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
			<span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">ClearPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">SetPageError</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_abort_logs</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">logs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">bd_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">fs_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">logs</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="n">logs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segsum_buffers</span><span class="p">,</span>
				    <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bd_page</span><span class="p">)</span>
					<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
				<span class="n">bd_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_payload_buffers</span><span class="p">,</span>
				    <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_super_root</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">bd_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">fs_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nilfs_end_page_io</span><span class="p">(</span><span class="n">fs_page</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="n">fs_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bd_page</span><span class="p">)</span>
		<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>

	<span class="n">nilfs_end_page_io</span><span class="p">(</span><span class="n">fs_page</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_abort_construction</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">logs</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">logs</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_wait_on_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logs</span><span class="p">);</span>
	<span class="n">nilfs_abort_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logs</span><span class="p">,</span> <span class="n">ret</span> <span class="o">?</span> <span class="o">:</span> <span class="n">err</span><span class="p">);</span>

	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">logs</span><span class="p">);</span>
	<span class="n">nilfs_cancel_segusage</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logs</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">);</span>
	<span class="n">nilfs_free_incomplete_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logs</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_CF_SUFREED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_sufile_cancel_freev</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">,</span>
						<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_freesegs</span><span class="p">,</span>
						<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nfreesegs</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* do not happen */</span>
	<span class="p">}</span>

	<span class="n">nilfs_destroy_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">logs</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_set_next_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segnum</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segnum</span><span class="p">;</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nextnum</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_nextnum</span><span class="p">;</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_pseg_offset</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_pseg_start</span> <span class="o">-</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_fseg_start</span>
		<span class="o">+</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">nblocks</span><span class="p">;</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_seg_seq</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span><span class="p">;</span>
	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_ctime</span> <span class="o">=</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">ctime</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_complete_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segment_buffer</span> <span class="o">*</span><span class="n">segbuf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">bd_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">fs_page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_sr</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">segbuf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">,</span> <span class="n">sb_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_segsum_buffers</span><span class="p">,</span>
				    <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bd_page</span><span class="p">)</span>
					<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
				<span class="n">bd_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * We assume that the buffers which belong to the same page</span>
<span class="cm">		 * continue over the buffer list.</span>
<span class="cm">		 * Under this assumption, the last BHs of pages is</span>
<span class="cm">		 * identifiable by the discontinuity of bh-&gt;b_page</span>
<span class="cm">		 * (page != fs_page).</span>
<span class="cm">		 *</span>
<span class="cm">		 * For B-tree node blocks, however, this assumption is not</span>
<span class="cm">		 * guaranteed.  The cleanup code of B-tree node pages needs</span>
<span class="cm">		 * special care.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_payload_buffers</span><span class="p">,</span>
				    <span class="n">b_assoc_buffers</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_delay</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_nilfs_volatile</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">clear_buffer_nilfs_redirected</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span> <span class="o">==</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_super_root</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">bd_page</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>
					<span class="n">bd_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">update_sr</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span> <span class="o">!=</span> <span class="n">fs_page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">nilfs_end_page_io</span><span class="p">(</span><span class="n">fs_page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">fs_page</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_page</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_segbuf_simplex</span><span class="p">(</span><span class="n">segbuf</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_SS_LOGBGN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_SC_UNCLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
				<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_lseg_stime</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_SS_LOGEND</span><span class="p">)</span>
				<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_SC_UNCLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Since pages may continue over multiple segment buffers,</span>
<span class="cm">	 * end of the last page must be checked outside of the loop.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bd_page</span><span class="p">)</span>
		<span class="n">end_page_writeback</span><span class="p">(</span><span class="n">bd_page</span><span class="p">);</span>

	<span class="n">nilfs_end_page_io</span><span class="p">(</span><span class="n">fs_page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">nilfs_drop_collected_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_doing_gc</span><span class="p">())</span>
		<span class="n">nilfs_drop_collected_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_gc_inodes</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_nongc_ctime</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seg_ctime</span><span class="p">;</span>

	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_inc</span> <span class="o">+=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nblk_this_inc</span><span class="p">;</span>

	<span class="n">segbuf</span> <span class="o">=</span> <span class="n">NILFS_LAST_SEGBUF</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">);</span>
	<span class="n">nilfs_set_next_segment</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">segbuf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">update_sr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nilfs_set_last_segment</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_pseg_start</span><span class="p">,</span>
				       <span class="n">segbuf</span><span class="o">-&gt;</span><span class="n">sb_sum</span><span class="p">.</span><span class="n">seg_seq</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="o">++</span><span class="p">);</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_SC_HAVE_DELTA</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_SC_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_SC_SUPER_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
		<span class="n">nilfs_segctor_clear_metadata_dirty</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_SC_SUPER_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_wait</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_wait_on_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nilfs_segctor_complete_write</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="n">nilfs_destroy_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_collect_dirty_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">ifile</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="o">-&gt;</span><span class="n">ifile</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
 <span class="nl">retry:</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dirty_files</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">ibh</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_ifile_get_inode_block</span><span class="p">(</span>
				<span class="n">ifile</span><span class="p">,</span> <span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ibh</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
					      <span class="s">&quot;failed to get inode block.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">ibh</span><span class="p">);</span>
			<span class="n">nilfs_mdt_mark_dirty</span><span class="p">(</span><span class="n">ifile</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">))</span>
				<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">=</span> <span class="n">ibh</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">ibh</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_I_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_I_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_drop_written_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">NILFS_I_UPDATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_I_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span><span class="p">);</span>
		<span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">list_move_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_garbage</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Main procedure of segment constructor</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_do_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">=</span> <span class="n">NILFS_ST_INIT</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_cno</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_cno</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_collect_dirty_files</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_metadata_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="p">))</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">NILFS_SC_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_segctor_clean</span><span class="p">(</span><span class="n">sci</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NILFS_CF_HISTORY_MASK</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_begin_construction</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* Update time stamp */</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seg_ctime</span> <span class="o">=</span> <span class="n">get_seconds</span><span class="p">();</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_collect</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

		<span class="cm">/* Avoid empty segment */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">==</span> <span class="n">NILFS_ST_DONE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nilfs_segbuf_empty</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_curseg</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">nilfs_segctor_abort_construction</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_assign</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_CF_IFILE_STARTED</span><span class="p">)</span>
			<span class="n">nilfs_segctor_fill_in_file_bmap</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_LSEG_SR</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">&gt;=</span> <span class="n">NILFS_ST_CPFILE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_fill_in_checkpoint</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">failed_to_write</span><span class="p">;</span>

			<span class="n">nilfs_segctor_fill_in_super_root</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">nilfs_segctor_update_segusage</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sufile</span><span class="p">);</span>

		<span class="cm">/* Write partial segments */</span>
		<span class="n">nilfs_segctor_prepare_write</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

		<span class="n">nilfs_add_checksums_on_logs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">,</span>
					    <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_crc_seed</span><span class="p">);</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_write</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">failed_to_write</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">==</span> <span class="n">NILFS_ST_DONE</span> <span class="o">||</span>
		    <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_blocksize_bits</span> <span class="o">!=</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * At this point, we avoid double buffering</span>
<span class="cm">			 * for blocksize &lt; pagesize because page dirty</span>
<span class="cm">			 * flag is turned off during write and dirty</span>
<span class="cm">			 * buffers are not properly collected for</span>
<span class="cm">			 * pages crossing over segments.</span>
<span class="cm">			 */</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_wait</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">failed_to_write</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">scnt</span> <span class="o">!=</span> <span class="n">NILFS_ST_DONE</span><span class="p">);</span>

 <span class="nl">out:</span>
	<span class="n">nilfs_segctor_drop_written_files</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

 <span class="nl">failed_to_write:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_stage</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">NILFS_CF_IFILE_STARTED</span><span class="p">)</span>
		<span class="n">nilfs_redirty_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">);</span>

 <span class="nl">failed:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_doing_gc</span><span class="p">())</span>
		<span class="n">nilfs_redirty_inodes</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_gc_inodes</span><span class="p">);</span>
	<span class="n">nilfs_segctor_abort_construction</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">nilfs</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_start_timer - set timer of background write</span>
<span class="cm"> * @sci: nilfs_sc_info</span>
<span class="cm"> *</span>
<span class="cm"> * If the timer has already been set, it ignores the new request.</span>
<span class="cm"> * This function MUST be called within a section locking the segment</span>
<span class="cm"> * semaphore.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_start_timer</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">&amp;</span> <span class="n">NILFS_SEGCTOR_COMMIT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">expires</span> <span class="o">=</span> <span class="n">jiffies</span> <span class="o">+</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_interval</span><span class="p">;</span>
		<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">);</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">|=</span> <span class="n">NILFS_SEGCTOR_COMMIT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_do_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bn</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bn</span><span class="p">)))</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">prev_req</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span><span class="p">;</span>

		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">bn</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_req</span><span class="p">)</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_daemon</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_flush_segment - trigger a segment construction for resource control</span>
<span class="cm"> * @sb: super block</span>
<span class="cm"> * @ino: inode number of the file to be flushed out.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nilfs_flush_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino_t</span> <span class="n">ino</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci</span> <span class="o">||</span> <span class="n">nilfs_doing_construction</span><span class="p">())</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">nilfs_segctor_do_flush</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">NILFS_MDT_INODE</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">ino</span><span class="p">)</span> <span class="o">?</span> <span class="n">ino</span> <span class="o">:</span> <span class="mi">0</span><span class="p">);</span>
					<span class="cm">/* assign bit 0 to data files */</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">nilfs_segctor_wait_request</span> <span class="p">{</span>
	<span class="n">wait_queue_t</span>	<span class="n">wq</span><span class="p">;</span>
	<span class="n">__u32</span>		<span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">err</span><span class="p">;</span>
	<span class="n">atomic_t</span>	<span class="n">done</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segctor_wait_request</span> <span class="n">wait_req</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="n">init_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_req</span><span class="p">.</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">wait_req</span><span class="p">.</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_req</span><span class="p">.</span><span class="n">done</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">wait_req</span><span class="p">.</span><span class="n">seq</span> <span class="o">=</span> <span class="o">++</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_request</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>

	<span class="n">init_waitqueue_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_req</span><span class="p">.</span><span class="n">wq</span><span class="p">,</span> <span class="n">current</span><span class="p">);</span>
	<span class="n">add_wait_queue</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait_req</span><span class="p">.</span><span class="n">wq</span><span class="p">);</span>
	<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_daemon</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wait_req</span><span class="p">.</span><span class="n">done</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">wait_req</span><span class="p">.</span><span class="n">err</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">signal_pending</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ERESTARTSYS</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_request</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait_req</span><span class="p">.</span><span class="n">wq</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_wakeup</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_segctor_wait_request</span> <span class="o">*</span><span class="n">wrq</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_request</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">wrq</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_request</span><span class="p">.</span><span class="n">task_list</span><span class="p">,</span>
				 <span class="n">wq</span><span class="p">.</span><span class="n">task_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrq</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nilfs_cnt32_ge</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_done</span><span class="p">,</span> <span class="n">wrq</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wrq</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrq</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrq</span><span class="o">-&gt;</span><span class="n">done</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wrq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">.</span><span class="n">func</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wrq</span><span class="o">-&gt;</span><span class="n">wq</span><span class="p">,</span>
				     <span class="n">TASK_UNINTERRUPTIBLE</span> <span class="o">|</span> <span class="n">TASK_INTERRUPTIBLE</span><span class="p">,</span>
				     <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_request</span><span class="p">.</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_construct_segment - construct a logical segment</span>
<span class="cm"> * @sb: super block</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value: On success, 0 is retured. On errors, one of the following</span>
<span class="cm"> * negative error code is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * %-EROFS - Read only filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * %-EIO - I/O error</span>
<span class="cm"> *</span>
<span class="cm"> * %-ENOSPC - No space left on device (only in a panic state).</span>
<span class="cm"> *</span>
<span class="cm"> * %-ERESTARTSYS - Interrupted.</span>
<span class="cm"> *</span>
<span class="cm"> * %-ENOMEM - Insufficient memory available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_construct_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="o">*</span><span class="n">ti</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="cm">/* A call inside transactions causes a deadlock. */</span>
	<span class="n">BUG_ON</span><span class="p">((</span><span class="n">ti</span> <span class="o">=</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">ti</span><span class="o">-&gt;</span><span class="n">ti_magic</span> <span class="o">==</span> <span class="n">NILFS_TI_MAGIC</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_sync</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_construct_dsync_segment - construct a data-only logical segment</span>
<span class="cm"> * @sb: super block</span>
<span class="cm"> * @inode: inode whose data blocks should be written out</span>
<span class="cm"> * @start: start byte offset</span>
<span class="cm"> * @end: end byte offset (inclusive)</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value: On success, 0 is retured. On errors, one of the following</span>
<span class="cm"> * negative error code is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * %-EROFS - Read only filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * %-EIO - I/O error</span>
<span class="cm"> *</span>
<span class="cm"> * %-ENOSPC - No space left on device (only in a panic state).</span>
<span class="cm"> *</span>
<span class="cm"> * %-ERESTARTSYS - Interrupted.</span>
<span class="cm"> *</span>
<span class="cm"> * %-ENOMEM - Insufficient memory available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_construct_dsync_segment</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				  <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">nilfs_transaction_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ii</span> <span class="o">=</span> <span class="n">NILFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_INODE_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">STRICT_ORDER</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_UNCLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">nilfs_discontinued</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_transaction_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_sync</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_QUEUED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_BUSY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
		<span class="n">nilfs_transaction_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dsync_inode</span> <span class="o">=</span> <span class="n">ii</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dsync_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dsync_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_do_construct</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">SC_LSEG_DSYNC</span><span class="p">);</span>

	<span class="n">nilfs_transaction_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define FLUSH_FILE_BIT	(0x1) </span><span class="cm">/* data file only */</span><span class="cp"></span>
<span class="cp">#define FLUSH_DAT_BIT	(1 &lt;&lt; NILFS_DAT_INO) </span><span class="cm">/* DAT only */</span><span class="cp"></span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_accept - record accepted sequence count of log-write requests</span>
<span class="cm"> * @sci: segment constructor object</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_accept</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_accepted</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_request</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_notify - notify the result of request to caller threads</span>
<span class="cm"> * @sci: segment constructor object</span>
<span class="cm"> * @mode: mode of log forming</span>
<span class="cm"> * @err: error code to be notified</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_notify</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* Clear requests (even when the construction failed) */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_LSEG_SR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">NILFS_SEGCTOR_COMMIT</span><span class="p">;</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_done</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_accepted</span><span class="p">;</span>
		<span class="n">nilfs_segctor_wakeup</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_FLUSH_FILE</span><span class="p">)</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLUSH_FILE_BIT</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_FLUSH_DAT</span><span class="p">)</span>
			<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">FLUSH_DAT_BIT</span><span class="p">;</span>

		<span class="cm">/* re-enable timer if checkpoint creation was not done */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">&amp;</span> <span class="n">NILFS_SEGCTOR_COMMIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">expires</span><span class="p">))</span>
			<span class="n">add_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_construct - form logs and write them to disk</span>
<span class="cm"> * @sci: segment constructor object</span>
<span class="cm"> * @mode: mode of log forming</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_super_block</span> <span class="o">**</span><span class="n">sbp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nilfs_segctor_accept</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_discontinued</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span>
		<span class="n">mode</span> <span class="o">=</span> <span class="n">SC_LSEG_SR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs_segctor_confirm</span><span class="p">(</span><span class="n">sci</span><span class="p">))</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_do_construct</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">!=</span> <span class="n">SC_FLUSH_DAT</span><span class="p">)</span>
			<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_ndirtyblks</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_SUPER_ROOT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">nilfs_discontinued</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="n">sbp</span> <span class="o">=</span> <span class="n">nilfs_prepare_super</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">,</span>
						  <span class="n">nilfs_sb_will_flip</span><span class="p">(</span><span class="n">nilfs</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="n">sbp</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">nilfs_set_log_cursor</span><span class="p">(</span><span class="n">sbp</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nilfs</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_commit_super</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">,</span>
							 <span class="n">NILFS_SB_COMMIT</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_sem</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">nilfs_segctor_notify</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_construction_timeout</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span><span class="p">;</span>
	<span class="n">wake_up_process</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span>
<span class="nf">nilfs_remove_written_gcinodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_inode_info</span> <span class="o">*</span><span class="n">ii</span><span class="p">,</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">i_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_I_UPDATED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_state</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_dirty</span><span class="p">);</span>
		<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">nilfs_btnode_cache_clear</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">i_btnode_cache</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ii</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">nilfs_clean_segments</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nilfs_argv</span> <span class="o">*</span><span class="n">argv</span><span class="p">,</span>
			 <span class="kt">void</span> <span class="o">**</span><span class="n">kbufs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">sci</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">nilfs_transaction_lock</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_mdt_save_to_shadow_map</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_ioctl_prepare_clean_segments</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="n">kbufs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_mdt_restore_from_shadow_map</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_freesegs</span> <span class="o">=</span> <span class="n">kbufs</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nfreesegs</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">4</span><span class="p">].</span><span class="n">v_nmembs</span><span class="p">;</span>
	<span class="n">list_splice_tail_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_gc_inodes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_gc_inodes</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_construct</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">SC_LSEG_SR</span><span class="p">);</span>
		<span class="n">nilfs_remove_written_gcinodes</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_gc_inodes</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">likely</span><span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			      <span class="s">&quot;segment construction failed. (err=%d)&quot;</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">set_current_state</span><span class="p">(</span><span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_interval</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_test_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">DISCARD</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_discard_segments</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_freesegs</span><span class="p">,</span>
						 <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nfreesegs</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span>
			       <span class="s">&quot;NILFS warning: error %d on discard request, &quot;</span>
			       <span class="s">&quot;turning discards off for the device</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">nilfs_clear_opt</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="n">DISCARD</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

 <span class="nl">out_unlock:</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_freesegs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_nfreesegs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nilfs_mdt_clear_shadow_map</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dat</span><span class="p">);</span>
	<span class="n">nilfs_transaction_unlock</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_thread_construct</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>

	<span class="n">nilfs_transaction_lock</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">nilfs_segctor_construct</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Unclosed segment should be retried.  We do this using sc_timer.</span>
<span class="cm">	 * Timeout of sc_timer will invoke complete construction which leads</span>
<span class="cm">	 * to close the current logical segment.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_UNCLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">))</span>
		<span class="n">nilfs_segctor_start_timer</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

	<span class="n">nilfs_transaction_unlock</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_do_immediate_flush</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">mode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="n">mode</span> <span class="o">=</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;</span> <span class="n">FLUSH_DAT_BIT</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">SC_FLUSH_DAT</span> <span class="o">:</span> <span class="n">SC_FLUSH_FILE</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_do_construct</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;=</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="n">SC_FLUSH_FILE</span><span class="p">)</span> <span class="o">?</span>
			<span class="o">~</span><span class="n">FLUSH_FILE_BIT</span> <span class="o">:</span> <span class="o">~</span><span class="n">FLUSH_DAT_BIT</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">NILFS_SC_PRIOR_FLUSH</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_flush_mode</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">NILFS_SC_UNCLOSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_lseg_stime</span> <span class="o">+</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_mjcp_freq</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FLUSH_FILE_BIT</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">SC_FLUSH_FILE</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FLUSH_DAT_BIT</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">SC_FLUSH_DAT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">SC_LSEG_SR</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_thread - main loop of the segment constructor thread.</span>
<span class="cm"> * @arg: pointer to a struct nilfs_sc_info.</span>
<span class="cm"> *</span>
<span class="cm"> * nilfs_segctor_thread() initializes a timer and serves as a daemon</span>
<span class="cm"> * to execute segment constructions.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_thread</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">current</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">function</span> <span class="o">=</span> <span class="n">nilfs_construction_timeout</span><span class="p">;</span>

	<span class="cm">/* start sync. */</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_task</span> <span class="o">=</span> <span class="n">current</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_task</span><span class="p">);</span> <span class="cm">/* for nilfs_segctor_start_thread() */</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;segctord starting. Construction interval = %lu seconds, &quot;</span>
	       <span class="s">&quot;CP frequency &lt; %lu seconds</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_interval</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_mjcp_freq</span> <span class="o">/</span> <span class="n">HZ</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
 <span class="nl">loop:</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">mode</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">&amp;</span> <span class="n">NILFS_SEGCTOR_QUIT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">end_thread</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">timeout</span> <span class="o">||</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_request</span> <span class="o">!=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_done</span><span class="p">)</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">SC_LSEG_SR</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">mode</span> <span class="o">=</span> <span class="n">nilfs_segctor_flush_mode</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
		<span class="n">nilfs_segctor_thread_construct</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">freezing</span><span class="p">(</span><span class="n">current</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
		<span class="n">try_to_freeze</span><span class="p">();</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">should_sleep</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_daemon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span>
				<span class="n">TASK_INTERRUPTIBLE</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_request</span> <span class="o">!=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_done</span><span class="p">)</span>
			<span class="n">should_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span><span class="p">)</span>
			<span class="n">should_sleep</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">&amp;</span> <span class="n">NILFS_SEGCTOR_COMMIT</span><span class="p">)</span>
			<span class="n">should_sleep</span> <span class="o">=</span> <span class="n">time_before</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span>
					<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">expires</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">should_sleep</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
			<span class="n">schedule</span><span class="p">();</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_daemon</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">timeout</span> <span class="o">=</span> <span class="p">((</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">&amp;</span> <span class="n">NILFS_SEGCTOR_COMMIT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
			   <span class="n">time_after_eq</span><span class="p">(</span><span class="n">jiffies</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">.</span><span class="n">expires</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">nilfs_sb_dirty</span><span class="p">(</span><span class="n">nilfs</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">nilfs_sb_need_update</span><span class="p">(</span><span class="n">nilfs</span><span class="p">))</span>
			<span class="n">set_nilfs_discontinued</span><span class="p">(</span><span class="n">nilfs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>

 <span class="nl">end_thread:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>

	<span class="cm">/* end sync. */</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_task</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_task</span><span class="p">);</span> <span class="cm">/* for nilfs_segctor_kill_thread() */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">nilfs_segctor_start_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">task_struct</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="n">t</span> <span class="o">=</span> <span class="n">kthread_run</span><span class="p">(</span><span class="n">nilfs_segctor_thread</span><span class="p">,</span> <span class="n">sci</span><span class="p">,</span> <span class="s">&quot;segctord&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;NILFS: error %d creating segctord thread</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">err</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_task</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_task</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_kill_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
	<span class="n">__acquires</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">)</span>
	<span class="n">__releases</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">|=</span> <span class="n">NILFS_SEGCTOR_QUIT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_task</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_daemon</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_task</span><span class="p">,</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_task</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Setup &amp; clean-up functions</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="nf">nilfs_segctor_new</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">;</span>

	<span class="n">sci</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sci</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sci</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span> <span class="o">=</span> <span class="n">sb</span><span class="p">;</span>

	<span class="n">nilfs_get_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_request</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_daemon</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_wait_task</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_gc_inodes</span><span class="p">);</span>
	<span class="n">init_timer</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">);</span>

	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_interval</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">NILFS_SC_DEFAULT_TIMEOUT</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_mjcp_freq</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">NILFS_SC_DEFAULT_SR_FREQ</span><span class="p">;</span>
	<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_watermark</span> <span class="o">=</span> <span class="n">NILFS_SC_DEFAULT_WATERMARK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_interval</span><span class="p">)</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_interval</span> <span class="o">=</span> <span class="n">HZ</span> <span class="o">*</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_interval</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_watermark</span><span class="p">)</span>
		<span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_watermark</span> <span class="o">=</span> <span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_watermark</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sci</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_write_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">retrycount</span> <span class="o">=</span> <span class="n">NILFS_SC_CLEANUP_RETRY</span><span class="p">;</span>

	<span class="cm">/* The segctord thread was stopped and its timer was removed.</span>
<span class="cm">	   But some tasks remain. */</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">nilfs_transaction_info</span> <span class="n">ti</span><span class="p">;</span>

		<span class="n">nilfs_transaction_lock</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ti</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nilfs_segctor_construct</span><span class="p">(</span><span class="n">sci</span><span class="p">,</span> <span class="n">SC_LSEG_SR</span><span class="p">);</span>
		<span class="n">nilfs_transaction_unlock</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">retrycount</span><span class="o">--</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_segctor_destroy - destroy the segment constructor.</span>
<span class="cm"> * @sci: nilfs_sc_info</span>
<span class="cm"> *</span>
<span class="cm"> * nilfs_segctor_destroy() kills the segctord thread and frees</span>
<span class="cm"> * the nilfs_sc_info struct.</span>
<span class="cm"> * Caller must hold the segment semaphore.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">nilfs_segctor_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">nilfs_sc_info</span> <span class="o">*</span><span class="n">sci</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flag</span><span class="p">;</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>
	<span class="n">nilfs_segctor_kill_thread</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
	<span class="n">flag</span> <span class="o">=</span> <span class="p">((</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state</span> <span class="o">&amp;</span> <span class="n">NILFS_SEGCTOR_COMMIT</span><span class="p">)</span> <span class="o">||</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_flush_request</span>
		<span class="o">||</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_request</span> <span class="o">!=</span> <span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_seq_done</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_state_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flag</span> <span class="o">||</span> <span class="o">!</span><span class="n">nilfs_segctor_confirm</span><span class="p">(</span><span class="n">sci</span><span class="p">))</span>
		<span class="n">nilfs_segctor_write_out</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_super</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			      <span class="s">&quot;dirty file(s) after the final construction</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">nilfs_dispose_list</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_dirty_files</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_segbufs</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_write_logs</span><span class="p">));</span>

	<span class="n">nilfs_put_root</span><span class="p">(</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_root</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>

	<span class="n">del_timer_sync</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sci</span><span class="o">-&gt;</span><span class="n">sc_timer</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sci</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_attach_log_writer - attach log writer</span>
<span class="cm"> * @sb: super block instance</span>
<span class="cm"> * @root: root object of the current filesystem tree</span>
<span class="cm"> *</span>
<span class="cm"> * This allocates a log writer object, initializes it, and starts the</span>
<span class="cm"> * log writer.</span>
<span class="cm"> *</span>
<span class="cm"> * Return Value: On success, 0 is returned. On error, one of the following</span>
<span class="cm"> * negative error code is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * %-ENOMEM - Insufficient memory available.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">nilfs_attach_log_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nilfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * This happens if the filesystem was remounted</span>
<span class="cm">		 * read/write after nilfs_error degenerated it into a</span>
<span class="cm">		 * read-only mount.</span>
<span class="cm">		 */</span>
		<span class="n">nilfs_detach_log_writer</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span> <span class="o">=</span> <span class="n">nilfs_segctor_new</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">nilfs_segctor_start_thread</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">);</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * nilfs_detach_log_writer - destroy log writer</span>
<span class="cm"> * @sb: super block instance</span>
<span class="cm"> *</span>
<span class="cm"> * This kills log writer daemon, frees the log writer object, and</span>
<span class="cm"> * destroys list of dirty files.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">nilfs_detach_log_writer</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">the_nilfs</span> <span class="o">*</span><span class="n">nilfs</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">garbage_list</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nilfs_segctor_destroy</span><span class="p">(</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span><span class="p">);</span>
		<span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_writer</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Force to free the list of dirty files */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dirty_files</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_dirty_files</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">garbage_list</span><span class="p">);</span>
		<span class="n">nilfs_warning</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">__func__</span><span class="p">,</span>
			      <span class="s">&quot;Hit dirty file after stopped log writer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_inode_lock</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">nilfs</span><span class="o">-&gt;</span><span class="n">ns_segctor_sem</span><span class="p">);</span>

	<span class="n">nilfs_dispose_list</span><span class="p">(</span><span class="n">nilfs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">garbage_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
