<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › extent-tree.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>extent-tree.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/sort.h&gt;</span>
<span class="cp">#include &lt;linux/rcupdate.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &quot;compat.h&quot;</span>
<span class="cp">#include &quot;hash.h&quot;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;print-tree.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;volumes.h&quot;</span>
<span class="cp">#include &quot;locking.h&quot;</span>
<span class="cp">#include &quot;free-space-cache.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * control flags for do_chunk_alloc&#39;s force field</span>
<span class="cm"> * CHUNK_ALLOC_NO_FORCE means to only allocate a chunk</span>
<span class="cm"> * if we really need one.</span>
<span class="cm"> *</span>
<span class="cm"> * CHUNK_ALLOC_LIMITED means to only try and allocate one</span>
<span class="cm"> * if we have very few chunks already allocated.  This is</span>
<span class="cm"> * used as part of the clustering code to help make sure</span>
<span class="cm"> * we have a good pool of storage to cluster in, without</span>
<span class="cm"> * filling the FS with empty chunks</span>
<span class="cm"> *</span>
<span class="cm"> * CHUNK_ALLOC_FORCE means it must try to allocate one</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">CHUNK_ALLOC_NO_FORCE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">CHUNK_ALLOC_LIMITED</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">CHUNK_ALLOC_FORCE</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Control how reservations are dealt with.</span>
<span class="cm"> *</span>
<span class="cm"> * RESERVE_FREE - freeing a reservation.</span>
<span class="cm"> * RESERVE_ALLOC - allocating space and we need to update bytes_may_use for</span>
<span class="cm"> *   ENOSPC accounting</span>
<span class="cm"> * RESERVE_ALLOC_NO_ACCOUNT - allocating space and we should not update</span>
<span class="cm"> *   bytes_may_use as the ENOSPC accounting is done elsewhere</span>
<span class="cm"> */</span>
<span class="k">enum</span> <span class="p">{</span>
	<span class="n">RESERVE_FREE</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">RESERVE_ALLOC</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">RESERVE_ALLOC_NO_ACCOUNT</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">update_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">__btrfs_free_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner_objectid</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">owner_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refs_to_drop</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extra_op</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">__run_delayed_extent_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">alloc_reserved_file_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ref_mod</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">alloc_reserved_tree_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">alloc_bytes</span><span class="p">,</span>
			  <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">find_next_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">dump_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytes</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">dump_block_groups</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfs_update_reserved_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserve</span><span class="p">);</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">block_group_cache_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">==</span> <span class="n">BTRFS_CACHE_FINISHED</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">block_group_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">bits</span><span class="p">)</span> <span class="o">==</span> <span class="n">bits</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_get_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_put_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this adds the block group to the fs_info rb tree for the block group</span>
<span class="cm"> * cache</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_add_block_group_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span><span class="p">,</span>
				 <span class="n">cache_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cache_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cache_node</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_tree</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This will return the block group at or after bytenr if contains is 0, else</span>
<span class="cm"> * it will return the block group that contains the bytenr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span>
<span class="nf">block_group_cache_tree_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">contains</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="o">*</span><span class="n">ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="n">start</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
	<span class="n">n</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span><span class="p">,</span>
				 <span class="n">cache_node</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bytenr</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">contains</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">||</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">ret</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">))</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">bytenr</span> <span class="o">&gt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">contains</span> <span class="o">&amp;&amp;</span> <span class="n">bytenr</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">btrfs_get_block_group</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_excluded_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">set_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_UPTODATE</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">set_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			<span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_UPTODATE</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_excluded_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">clear_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			  <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_UPTODATE</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">clear_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
			  <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_UPTODATE</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">exclude_super_stripes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">logical</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stripe_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">nr</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">BTRFS_SUPER_INFO_OFFSET</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stripe_len</span> <span class="o">=</span> <span class="n">BTRFS_SUPER_INFO_OFFSET</span> <span class="o">-</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">bytes_super</span> <span class="o">+=</span> <span class="n">stripe_len</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_excluded_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					  <span class="n">stripe_len</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_SUPER_MIRROR_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_sb_offset</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_rmap_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span>
				       <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
				       <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">logical</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">stripe_len</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">nr</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">bytes_super</span> <span class="o">+=</span> <span class="n">stripe_len</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_excluded_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">logical</span><span class="p">[</span><span class="n">nr</span><span class="p">],</span>
						  <span class="n">stripe_len</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">logical</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span>
<span class="nf">get_caching_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">ctl</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">!=</span> <span class="n">BTRFS_CACHE_STARTED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;re loading it the fast way, so we don&#39;t have a caching_ctl. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ctl</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ctl</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">put_caching_control</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">ctl</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">))</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ctl</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is only called by cache_block_group, since we could have freed extents</span>
<span class="cm"> * we need to check the pinned_extents for any extents that can&#39;t be used yet</span>
<span class="cm"> * since their free space will be released as soon as the transaction commits.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">add_new_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">extent_start</span><span class="p">,</span> <span class="n">extent_end</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">total_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_first_extent_bit</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pinned_extents</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">extent_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extent_end</span><span class="p">,</span>
					    <span class="n">EXTENT_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_UPTODATE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extent_start</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">extent_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extent_start</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="n">extent_start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">size</span> <span class="o">=</span> <span class="n">extent_start</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">total_added</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
						   <span class="n">size</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM or logic error */</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">extent_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">total_added</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM or logic error */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">total_added</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">caching_thread</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">caching_ctl</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_caching_control</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">block_group</span> <span class="o">=</span> <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">block_group</span><span class="p">;</span>
	<span class="n">fs_info</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="n">extent_root</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">last</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">BTRFS_SUPER_INFO_OFFSET</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t want to deadlock with somebody trying to allocate a new</span>
<span class="cm">	 * extent for the extent root while also trying to search the extent</span>
<span class="cm">	 * root to add free space.  So we skip locking and search the commit</span>
<span class="cm">	 * root, since its read-only</span>
<span class="cm">	 */</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="cm">/* need to make sure the commit_root doesn&#39;t disappear */</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_fs_closing</span><span class="p">(</span><span class="n">fs_info</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">find_next_key</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">need_resched</span><span class="p">()</span> <span class="o">||</span>
			    <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">cond_resched</span><span class="p">();</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span>
		    <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">total_found</span> <span class="o">+=</span> <span class="n">add_new_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span>
							  <span class="n">fs_info</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span>
							  <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
			<span class="n">last</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">total_found</span> <span class="o">&gt;</span> <span class="p">(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">2</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">total_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">total_found</span> <span class="o">+=</span> <span class="n">add_new_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">fs_info</span><span class="p">,</span> <span class="n">last</span><span class="p">,</span>
					  <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span>
					  <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">caching_ctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_FINISHED</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">err:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>

	<span class="n">free_excluded_extents</span><span class="p">(</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">load_cache_only</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">caching_ctl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">caching_ctl</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">caching_ctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">block_group</span> <span class="o">=</span> <span class="n">cache</span><span class="p">;</span>
	<span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">caching_thread</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * This should be a rare occasion, but this could happen I think in the</span>
<span class="cm">	 * case where one thread starts to load the space cache info, and then</span>
<span class="cm">	 * some other thread starts a transaction commit which tries to do an</span>
<span class="cm">	 * allocation while the other thread is still loading the space cache</span>
<span class="cm">	 * info.  The previous loop should have kept us from choosing this block</span>
<span class="cm">	 * group, but if we&#39;ve moved to the state where we will wait on caching</span>
<span class="cm">	 * block groups we need to first check if we&#39;re doing a fast load here,</span>
<span class="cm">	 * so we can wait for it to finish, otherwise we could end up allocating</span>
<span class="cm">	 * from a block group who&#39;s cache gets evicted for one reason or</span>
<span class="cm">	 * another.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">==</span> <span class="n">BTRFS_CACHE_FAST</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">ctl</span><span class="p">;</span>

		<span class="n">ctl</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
		<span class="n">prepare_to_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">,</span> <span class="n">TASK_UNINTERRUPTIBLE</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">schedule</span><span class="p">();</span>

		<span class="n">finish_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">put_caching_control</span><span class="p">(</span><span class="n">ctl</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">!=</span> <span class="n">BTRFS_CACHE_NO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span><span class="p">);</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span> <span class="o">=</span> <span class="n">caching_ctl</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_FAST</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * We can&#39;t do the read from on-disk cache during a commit since we need</span>
<span class="cm">	 * to have the normal tree locking.  Also if we are currently trying to</span>
<span class="cm">	 * allocate blocks for the tree root we can&#39;t do the fast caching since</span>
<span class="cm">	 * we likely hold important locks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mount_opt</span> <span class="o">&amp;</span> <span class="n">BTRFS_MOUNT_SPACE_CACHE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">load_free_space_cache</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_FINISHED</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">load_cache_only</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_NO</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_STARTED</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
			<span class="n">free_excluded_extents</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We are not going to do the fast caching, set cached to the</span>
<span class="cm">		 * appropriate value and wakeup any waiters.</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">load_cache_only</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">caching_ctl</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_NO</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_STARTED</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">load_cache_only</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">caching_block_groups</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>

	<span class="n">btrfs_get_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="n">btrfs_queue_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">caching_workers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return the block group that starts at or after bytenr</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span>
<span class="nf">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">block_group_cache_tree_search</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * return the block group that contains the given bytenr</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="nf">btrfs_lookup_block_group</span><span class="p">(</span>
						 <span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
						 <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">block_group_cache_tree_search</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="nf">__find_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
						  <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">&amp;=</span> <span class="n">BTRFS_BLOCK_GROUP_TYPE_MASK</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * after adding space to the filesystem, we need to clear the full flags</span>
<span class="cm"> * on all the space infos.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_clear_space_info_full</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span>
		<span class="n">found</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">div_factor</span><span class="p">(</span><span class="n">u64</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">factor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">factor</span> <span class="o">==</span> <span class="mi">10</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">num</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">div_factor_fine</span><span class="p">(</span><span class="n">u64</span> <span class="n">num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">factor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">factor</span> <span class="o">==</span> <span class="mi">100</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
	<span class="n">num</span> <span class="o">*=</span> <span class="n">factor</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">num</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">num</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">btrfs_find_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">search_start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">search_hint</span><span class="p">,</span> <span class="kt">int</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">search_hint</span><span class="p">,</span> <span class="n">search_start</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">group_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">full_search</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">9</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wrapped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">used</span> <span class="o">=</span> <span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">full_search</span> <span class="o">||</span> <span class="o">!</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">block_group_bits</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&lt;</span>
			    <span class="n">div_factor</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">factor</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">group_start</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">found</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wrapped</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">search_start</span><span class="p">;</span>
		<span class="n">wrapped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">full_search</span> <span class="o">&amp;&amp;</span> <span class="n">factor</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">search_start</span><span class="p">;</span>
		<span class="n">full_search</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">found:</span>
	<span class="k">return</span> <span class="n">group_start</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* simple helper to search for an existing extent at a given offset */</span>
<span class="kt">int</span> <span class="nf">btrfs_lookup_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function to lookup reference count and flags of extent.</span>
<span class="cm"> *</span>
<span class="cm"> * the head node for delayed ref is used to store the sum of all the</span>
<span class="cm"> * reference count modifications queued up in the rbtree. the head</span>
<span class="cm"> * node may also store the extent flags to set. This way you can check</span>
<span class="cm"> * to see what the reference count and extent flags would be if all of</span>
<span class="cm"> * the delayed refs are not processed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_lookup_extent_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_refs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">again:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">item_size</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
			<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
			<span class="n">extent_flags</span> <span class="o">=</span> <span class="n">btrfs_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
			<span class="k">struct</span> <span class="n">btrfs_extent_item_v0</span> <span class="o">*</span><span class="n">ei0</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei0</span><span class="p">));</span>
			<span class="n">ei0</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					     <span class="k">struct</span> <span class="n">btrfs_extent_item_v0</span><span class="p">);</span>
			<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_extent_refs_v0</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei0</span><span class="p">);</span>
			<span class="cm">/* FIXME: this isn&#39;t correct for data */</span>
			<span class="n">extent_flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">;</span>
<span class="cp">#else</span>
			<span class="n">BUG</span><span class="p">();</span>
<span class="cp">#endif</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">num_refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">extent_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">delayed_refs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">btrfs_find_delayed_ref_head</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">refs</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * Mutex was contended, block until it&#39;s released and try</span>
<span class="cm">			 * again</span>
<span class="cm">			 */</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">btrfs_put_delayed_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span> <span class="o">&amp;&amp;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_flags</span><span class="p">)</span>
			<span class="n">extent_flags</span> <span class="o">|=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">flags_to_set</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">num_refs</span> <span class="o">+=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">ref_mod</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">num_refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">refs</span><span class="p">)</span>
		<span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="n">num_refs</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span><span class="p">)</span>
		<span class="o">*</span><span class="n">flags</span> <span class="o">=</span> <span class="n">extent_flags</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Back reference rules.  Back refs have three main goals:</span>
<span class="cm"> *</span>
<span class="cm"> * 1) differentiate between all holders of references to an extent so that</span>
<span class="cm"> *    when a reference is dropped we can make sure it was a valid reference</span>
<span class="cm"> *    before freeing the extent.</span>
<span class="cm"> *</span>
<span class="cm"> * 2) Provide enough information to quickly find the holders of an extent</span>
<span class="cm"> *    if we notice a given block is corrupted or bad.</span>
<span class="cm"> *</span>
<span class="cm"> * 3) Make it easy to migrate blocks for FS shrinking or storage pool</span>
<span class="cm"> *    maintenance.  This is actually the same as #2, but with a slightly</span>
<span class="cm"> *    different use case.</span>
<span class="cm"> *</span>
<span class="cm"> * There are two kinds of back refs. The implicit back refs is optimized</span>
<span class="cm"> * for pointers in non-shared tree blocks. For a given pointer in a block,</span>
<span class="cm"> * back refs of this kind provide information about the block&#39;s owner tree</span>
<span class="cm"> * and the pointer&#39;s key. These information allow us to find the block by</span>
<span class="cm"> * b-tree searching. The full back refs is for pointers in tree blocks not</span>
<span class="cm"> * referenced by their owner trees. The location of tree block is recorded</span>
<span class="cm"> * in the back refs. Actually the full back refs is generic, and can be</span>
<span class="cm"> * used in all cases the implicit back refs is used. The major shortcoming</span>
<span class="cm"> * of the full back refs is its overhead. Every time a tree block gets</span>
<span class="cm"> * COWed, we have to update back refs entry for all pointers in it.</span>
<span class="cm"> *</span>
<span class="cm"> * For a newly allocated tree block, we use implicit back refs for</span>
<span class="cm"> * pointers in it. This means most tree related operations only involve</span>
<span class="cm"> * implicit back refs. For a tree block created in old transaction, the</span>
<span class="cm"> * only way to drop a reference to it is COW it. So we can detect the</span>
<span class="cm"> * event that tree block loses its owner tree&#39;s reference and do the</span>
<span class="cm"> * back refs conversion.</span>
<span class="cm"> *</span>
<span class="cm"> * When a tree block is COW&#39;d through a tree, there are four cases:</span>
<span class="cm"> *</span>
<span class="cm"> * The reference count of the block is one and the tree is the block&#39;s</span>
<span class="cm"> * owner tree. Nothing to do in this case.</span>
<span class="cm"> *</span>
<span class="cm"> * The reference count of the block is one and the tree is not the</span>
<span class="cm"> * block&#39;s owner tree. In this case, full back refs is used for pointers</span>
<span class="cm"> * in the block. Remove these full back refs, add implicit back refs for</span>
<span class="cm"> * every pointers in the new block.</span>
<span class="cm"> *</span>
<span class="cm"> * The reference count of the block is greater than one and the tree is</span>
<span class="cm"> * the block&#39;s owner tree. In this case, implicit back refs is used for</span>
<span class="cm"> * pointers in the block. Add full back refs for every pointers in the</span>
<span class="cm"> * block, increase lower level extents&#39; reference counts. The original</span>
<span class="cm"> * implicit back refs are entailed to the new block.</span>
<span class="cm"> *</span>
<span class="cm"> * The reference count of the block is greater than one and the tree is</span>
<span class="cm"> * not the block&#39;s owner tree. Add implicit back refs for every pointer in</span>
<span class="cm"> * the new block, increase lower level extents&#39; reference count.</span>
<span class="cm"> *</span>
<span class="cm"> * Back Reference Key composing:</span>
<span class="cm"> *</span>
<span class="cm"> * The key objectid corresponds to the first byte in the extent,</span>
<span class="cm"> * The key type is used to differentiate between types of back refs.</span>
<span class="cm"> * There are different meanings of the key offset for different types</span>
<span class="cm"> * of back refs.</span>
<span class="cm"> *</span>
<span class="cm"> * File extents can be referenced by:</span>
<span class="cm"> *</span>
<span class="cm"> * - multiple snapshots, subvolumes, or different generations in one subvol</span>
<span class="cm"> * - different files inside a single subvolume</span>
<span class="cm"> * - different offsets inside a file (bookend extents in file.c)</span>
<span class="cm"> *</span>
<span class="cm"> * The extent ref structure for the implicit back refs has fields for:</span>
<span class="cm"> *</span>
<span class="cm"> * - Objectid of the subvolume root</span>
<span class="cm"> * - objectid of the file holding the reference</span>
<span class="cm"> * - original offset in the file</span>
<span class="cm"> * - how many bookend extents</span>
<span class="cm"> *</span>
<span class="cm"> * The key offset for the implicit back refs is hash of the first</span>
<span class="cm"> * three fields.</span>
<span class="cm"> *</span>
<span class="cm"> * The extent ref structure for the full back refs has field for:</span>
<span class="cm"> *</span>
<span class="cm"> * - number of pointers in the tree leaf</span>
<span class="cm"> *</span>
<span class="cm"> * The key offset for the implicit back refs is the first byte of</span>
<span class="cm"> * the tree leaf</span>
<span class="cm"> *</span>
<span class="cm"> * When a file extent is allocated, The implicit back refs is used.</span>
<span class="cm"> * the fields are filled in:</span>
<span class="cm"> *</span>
<span class="cm"> *     (root_key.objectid, inode objectid, offset in file, 1)</span>
<span class="cm"> *</span>
<span class="cm"> * When a file extent is removed file truncation, we find the</span>
<span class="cm"> * corresponding implicit back refs and check the following fields:</span>
<span class="cm"> *</span>
<span class="cm"> *     (btrfs_header_owner(leaf), inode objectid, offset in file)</span>
<span class="cm"> *</span>
<span class="cm"> * Btree extents can be referenced by:</span>
<span class="cm"> *</span>
<span class="cm"> * - Different subvolumes</span>
<span class="cm"> *</span>
<span class="cm"> * Both the implicit back refs and the full back refs for tree blocks</span>
<span class="cm"> * only consist of key. The key offset for the implicit back refs is</span>
<span class="cm"> * objectid of block&#39;s owner tree. The key offset for the full back refs</span>
<span class="cm"> * is the first byte of parent block.</span>
<span class="cm"> *</span>
<span class="cm"> * When implicit back refs is used, information about the lowest key and</span>
<span class="cm"> * level of the tree block are required. These information are stored in</span>
<span class="cm"> * tree block info structure.</span>
<span class="cm"> */</span>

<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">convert_extent_item_v0</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u32</span> <span class="n">extra_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item_v0</span> <span class="o">*</span><span class="n">ei0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span> <span class="o">*</span><span class="n">ref0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">new_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei0</span><span class="p">));</span>

	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">ei0</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			     <span class="k">struct</span> <span class="n">btrfs_extent_item_v0</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">=</span> <span class="n">btrfs_extent_refs_v0</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* Corruption */</span>
				<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span>
					      <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_REF_V0_KEY</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ref0</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					      <span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span><span class="p">);</span>
			<span class="n">owner</span> <span class="o">=</span> <span class="n">btrfs_ref_objectid_v0</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref0</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span>
		<span class="n">new_size</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bi</span><span class="p">);</span>

	<span class="n">new_size</span> <span class="o">-=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="n">new_size</span> <span class="o">+</span> <span class="n">extra_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* Corruption */</span>

	<span class="n">btrfs_extend_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
	<span class="cm">/* FIXME: get real generation */</span>
	<span class="n">btrfs_set_extent_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_set_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
				       <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span> <span class="o">|</span>
				       <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">);</span>
		<span class="n">bi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* FIXME: get first key of the block */</span>
		<span class="n">memset_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bi</span><span class="p">));</span>
		<span class="n">btrfs_set_tree_block_level</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">owner</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_set_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cp">#endif</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">hash_extent_data_ref</span><span class="p">(</span><span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">high_crc</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">low_crc</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">__le64</span> <span class="n">lenum</span><span class="p">;</span>

	<span class="n">lenum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">root_objectid</span><span class="p">);</span>
	<span class="n">high_crc</span> <span class="o">=</span> <span class="n">crc32c</span><span class="p">(</span><span class="n">high_crc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lenum</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lenum</span><span class="p">));</span>
	<span class="n">lenum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">owner</span><span class="p">);</span>
	<span class="n">low_crc</span> <span class="o">=</span> <span class="n">crc32c</span><span class="p">(</span><span class="n">low_crc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lenum</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lenum</span><span class="p">));</span>
	<span class="n">lenum</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">low_crc</span> <span class="o">=</span> <span class="n">crc32c</span><span class="p">(</span><span class="n">low_crc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lenum</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">lenum</span><span class="p">));</span>

	<span class="k">return</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">high_crc</span> <span class="o">&lt;&lt;</span> <span class="mi">31</span><span class="p">)</span> <span class="o">^</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">low_crc</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">hash_extent_data_ref_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">hash_extent_data_ref</span><span class="p">(</span><span class="n">btrfs_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">),</span>
				    <span class="n">btrfs_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">),</span>
				    <span class="n">btrfs_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">match_extent_data_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">root_objectid</span> <span class="o">||</span>
	    <span class="n">btrfs_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">owner</span> <span class="o">||</span>
	    <span class="n">btrfs_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">lookup_extent_data_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">hash_extent_data_ref</span><span class="p">(</span><span class="n">root_objectid</span><span class="p">,</span>
						  <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">again:</span>
	<span class="n">recow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_REF_V0_KEY</span><span class="p">;</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="n">recow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">bytenr</span> <span class="o">||</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

		<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				     <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">match_extent_data_ref</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
					  <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">recow</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">insert_extent_data_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refs_to_add</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_refs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">hash_extent_data_ref</span><span class="p">(</span><span class="n">root_objectid</span><span class="p">,</span>
						  <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				     <span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_set_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">refs_to_add</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
			<span class="n">num_refs</span> <span class="o">+=</span> <span class="n">refs_to_add</span><span class="p">;</span>
			<span class="n">btrfs_set_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">num_refs</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					     <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match_extent_data_ref</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
						  <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
						      <span class="n">size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				     <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_set_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span>
						       <span class="n">root_objectid</span><span class="p">);</span>
			<span class="n">btrfs_set_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
			<span class="n">btrfs_set_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
			<span class="n">btrfs_set_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">refs_to_add</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">);</span>
			<span class="n">num_refs</span> <span class="o">+=</span> <span class="n">refs_to_add</span><span class="p">;</span>
			<span class="n">btrfs_set_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">num_refs</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">remove_extent_data_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">refs_to_drop</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref1</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">ref2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref1</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span><span class="p">);</span>
		<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref2</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span><span class="p">);</span>
		<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref2</span><span class="p">);</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_REF_V0_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span> <span class="o">*</span><span class="n">ref0</span><span class="p">;</span>
		<span class="n">ref0</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span><span class="p">);</span>
		<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_ref_count_v0</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_refs</span> <span class="o">&lt;</span> <span class="n">refs_to_drop</span><span class="p">);</span>
	<span class="n">num_refs</span> <span class="o">-=</span> <span class="n">refs_to_drop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span>
			<span class="n">btrfs_set_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref1</span><span class="p">,</span> <span class="n">num_refs</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span>
			<span class="n">btrfs_set_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref2</span><span class="p">,</span> <span class="n">num_refs</span><span class="p">);</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span> <span class="o">*</span><span class="n">ref0</span><span class="p">;</span>
			<span class="n">ref0</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span><span class="p">);</span>
			<span class="n">btrfs_set_ref_count_v0</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref0</span><span class="p">,</span> <span class="n">num_refs</span><span class="p">);</span>
		<span class="p">}</span>
<span class="cp">#endif</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="n">u32</span> <span class="nf">extent_data_ref_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">ref2</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">num_refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iref</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">)</span> <span class="o">==</span>
		    <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ref1</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">iref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ref2</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">iref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref2</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref1</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span><span class="p">);</span>
		<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref2</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span><span class="p">);</span>
		<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref2</span><span class="p">);</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_REF_V0_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span> <span class="o">*</span><span class="n">ref0</span><span class="p">;</span>
		<span class="n">ref0</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="k">struct</span> <span class="n">btrfs_extent_ref_v0</span><span class="p">);</span>
		<span class="n">num_refs</span> <span class="o">=</span> <span class="n">btrfs_ref_count_v0</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref0</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">num_refs</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">lookup_tree_block_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">root_objectid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_REF_V0_KEY</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">insert_tree_block_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">root_objectid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">extent_ref_type</span><span class="p">(</span><span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">type</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_next_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span>
		    <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span>
					      <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">btrfs_node_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">key</span><span class="p">,</span>
					      <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * look for inline back ref. if back ref is found, *ref_ret is set</span>
<span class="cm"> * to the address of inline back ref, and 0 is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * if back ref isn&#39;t found, *ref_ret is set to the address where it</span>
<span class="cm"> * should be inserted, and -ENOENT is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * if insert is true and there are too many inline back refs, the path</span>
<span class="cm"> * points to the extent item, and -EAGAIN is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: inline back refs are ordered in the same way that back ref</span>
<span class="cm"> *	 items in the tree are ordered.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline_for_stack</span>
<span class="kt">int</span> <span class="nf">lookup_inline_extent_backref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">**</span><span class="n">ref_ret</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">insert</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extra_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">want</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>

	<span class="n">want</span> <span class="o">=</span> <span class="n">extent_ref_type</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extra_size</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">want</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">extra_size</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">extra_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* Corruption */</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_extent_item_v0</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span>
					     <span class="n">extra_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">));</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ei</span> <span class="o">+</span> <span class="n">item_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">iref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&lt;</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">want</span> <span class="o">&gt;</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">dref</span><span class="p">;</span>
			<span class="n">dref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">iref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">match_extent_data_ref</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
						  <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">hash_extent_data_ref_item</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">)</span> <span class="o">&lt;</span>
			    <span class="n">hash_extent_data_ref</span><span class="p">(</span><span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">ref_offset</span><span class="p">;</span>
			<span class="n">ref_offset</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="n">ref_offset</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ref_offset</span> <span class="o">&lt;</span> <span class="n">parent</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">root_objectid</span> <span class="o">==</span> <span class="n">ref_offset</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ref_offset</span> <span class="o">&lt;</span> <span class="n">root_objectid</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">&amp;&amp;</span> <span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">item_size</span> <span class="o">+</span> <span class="n">extra_size</span> <span class="o">&gt;=</span>
		    <span class="n">BTRFS_MAX_EXTENT_ITEM_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * To add new inline back ref, we have to make sure</span>
<span class="cm">		 * there is no corresponding back ref item.</span>
<span class="cm">		 * For simplicity, we just do not add new inline back</span>
<span class="cm">		 * ref if there is any kind of item for this block</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">find_next_key</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">bytenr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">BTRFS_BLOCK_GROUP_ITEM_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">ref_ret</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to add new inline back ref</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline_for_stack</span>
<span class="kt">void</span> <span class="nf">setup_inline_extent_backref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refs_to_add</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">item_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">item_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iref</span> <span class="o">-</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ei</span><span class="p">;</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">extent_ref_type</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

	<span class="n">btrfs_extend_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">=</span> <span class="n">btrfs_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">+=</span> <span class="n">refs_to_add</span><span class="p">;</span>
	<span class="n">btrfs_set_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="p">)</span>
		<span class="n">__run_delayed_extent_op</span><span class="p">(</span><span class="n">extent_op</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ei</span> <span class="o">+</span> <span class="n">item_offset</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ei</span> <span class="o">+</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">end</span> <span class="o">-</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
				      <span class="n">end</span> <span class="o">-</span> <span class="n">size</span> <span class="o">-</span> <span class="n">ptr</span><span class="p">);</span>

	<span class="n">iref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
	<span class="n">btrfs_set_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">dref</span><span class="p">;</span>
		<span class="n">dref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">iref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">,</span> <span class="n">refs_to_add</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">sref</span><span class="p">;</span>
		<span class="n">sref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">iref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_set_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">sref</span><span class="p">,</span> <span class="n">refs_to_add</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_set_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_set_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">lookup_extent_backref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">**</span><span class="n">ref_ret</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">lookup_inline_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ref_ret</span><span class="p">,</span>
					   <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					   <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="o">*</span><span class="n">ref_ret</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">lookup_tree_block_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					    <span class="n">root_objectid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">lookup_extent_data_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					     <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to update/remove inline back ref</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline_for_stack</span>
<span class="kt">void</span> <span class="nf">update_inline_extent_backref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">refs_to_mod</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">dref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">sref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">=</span> <span class="n">btrfs_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">refs_to_mod</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">refs</span> <span class="o">+</span> <span class="n">refs_to_mod</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">+=</span> <span class="n">refs_to_mod</span><span class="p">;</span>
	<span class="n">btrfs_set_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="p">)</span>
		<span class="n">__run_delayed_extent_op</span><span class="p">(</span><span class="n">extent_op</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

	<span class="n">type</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">iref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">refs</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">iref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">refs</span> <span class="o">=</span> <span class="n">btrfs_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">sref</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">refs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">refs_to_mod</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">refs_to_mod</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">refs</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">refs_to_mod</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">+=</span> <span class="n">refs_to_mod</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span>
			<span class="n">btrfs_set_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">btrfs_set_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">sref</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">size</span> <span class="o">=</span>  <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
		<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iref</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ei</span> <span class="o">+</span> <span class="n">item_size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span> <span class="o">+</span> <span class="n">size</span><span class="p">,</span>
					      <span class="n">end</span> <span class="o">-</span> <span class="n">ptr</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">item_size</span> <span class="o">-=</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">btrfs_truncate_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span>
<span class="kt">int</span> <span class="nf">insert_inline_extent_backref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refs_to_add</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">lookup_inline_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iref</span><span class="p">,</span>
					   <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					   <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">);</span>
		<span class="n">update_inline_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span>
					     <span class="n">refs_to_add</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">setup_inline_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					    <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					    <span class="n">refs_to_add</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_extent_backref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refs_to_add</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">refs_to_add</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_tree_block_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
					    <span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_extent_data_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
					     <span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
					     <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">refs_to_add</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">remove_extent_backref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">,</span>
				 <span class="kt">int</span> <span class="n">refs_to_drop</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_data</span> <span class="o">&amp;&amp;</span> <span class="n">refs_to_drop</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">iref</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">update_inline_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span>
					     <span class="o">-</span><span class="n">refs_to_drop</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">is_data</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_extent_data_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">refs_to_drop</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_issue_discard</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">blkdev_issue_discard</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">,</span> <span class="n">len</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_discard_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">actual_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">discarded_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_bio</span> <span class="o">*</span><span class="n">bbio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>


	<span class="cm">/* Tell the block device(s) that the sectors can be discarded */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_map_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span> <span class="n">REQ_DISCARD</span><span class="p">,</span>
			      <span class="n">bytenr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_bytes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bbio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Error condition is -ENOMEM */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_bio_stripe</span> <span class="o">*</span><span class="n">stripe</span> <span class="o">=</span> <span class="n">bbio</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>


		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bbio</span><span class="o">-&gt;</span><span class="n">num_stripes</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">stripe</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">stripe</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">can_discard</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_issue_discard</span><span class="p">(</span><span class="n">stripe</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
						  <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">physical</span><span class="p">,</span>
						  <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">discarded_bytes</span> <span class="o">+=</span> <span class="n">stripe</span><span class="o">-&gt;</span><span class="n">length</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span> <span class="cm">/* Logic errors or -ENOMEM, or -EIO but I don&#39;t know how that could happen JDM */</span>

			<span class="cm">/*</span>
<span class="cm">			 * Just in case we get back EOPNOTSUPP for some reason,</span>
<span class="cm">			 * just ignore the return value so we don&#39;t screw up</span>
<span class="cm">			 * people calling discard_extent.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bbio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">actual_bytes</span><span class="p">)</span>
		<span class="o">*</span><span class="n">actual_bytes</span> <span class="o">=</span> <span class="n">discarded_bytes</span><span class="p">;</span>


	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Can return -ENOMEM */</span>
<span class="kt">int</span> <span class="nf">btrfs_inc_extent_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">for_cow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span> <span class="o">&amp;&amp;</span>
	       <span class="n">root_objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_tree_ref</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
					<span class="n">num_bytes</span><span class="p">,</span>
					<span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">owner</span><span class="p">,</span>
					<span class="n">BTRFS_ADD_DELAYED_REF</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">for_cow</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_data_ref</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
					<span class="n">num_bytes</span><span class="p">,</span>
					<span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					<span class="n">BTRFS_ADD_DELAYED_REF</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">for_cow</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_inc_extent_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refs_to_add</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* this will setup the path even if it fails to insert the back ref */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_inline_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
					   <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					   <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					   <span class="n">refs_to_add</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">=</span> <span class="n">btrfs_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">refs</span> <span class="o">+</span> <span class="n">refs_to_add</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="p">)</span>
		<span class="n">__run_delayed_extent_op</span><span class="p">(</span><span class="n">extent_op</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* now insert the actual backref */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
				    <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
				    <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">refs_to_add</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_delayed_data_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">insert_reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ref_root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ins</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">;</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_data_ref</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ref_root</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">BTRFS_ADD_DELAYED_REF</span> <span class="o">&amp;&amp;</span> <span class="n">insert_reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_key</span><span class="p">);</span>
			<span class="n">flags</span> <span class="o">|=</span> <span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">flags_to_set</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_reserved_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						 <span class="n">parent</span><span class="p">,</span> <span class="n">ref_root</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
						 <span class="n">ref</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">ins</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">BTRFS_ADD_DELAYED_REF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_inc_extent_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					     <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					     <span class="n">ref_root</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span>
					     <span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span><span class="p">,</span>
					     <span class="n">extent_op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">BTRFS_DROP_DELAYED_REF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					  <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					  <span class="n">ref_root</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span>
					  <span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span><span class="p">,</span>
					  <span class="n">extent_op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__run_delayed_extent_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">flags_to_set</span><span class="p">;</span>
		<span class="n">btrfs_set_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_key</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">));</span>
		<span class="n">bi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_set_tree_block_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_delayed_extent_op</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">aborted</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
				<span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_extent_item_v0</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
					     <span class="n">path</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">));</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">__run_delayed_extent_op</span><span class="p">(</span><span class="n">extent_op</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_delayed_tree_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">insert_reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_tree_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ref_root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ins</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">;</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_tree_ref</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">)</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ref_root</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">BTRFS_ADD_DELAYED_REF</span> <span class="o">&amp;&amp;</span> <span class="n">insert_reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">extent_op</span> <span class="o">||</span> <span class="o">!</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_flags</span> <span class="o">||</span>
		       <span class="o">!</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_key</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_reserved_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						<span class="n">parent</span><span class="p">,</span> <span class="n">ref_root</span><span class="p">,</span>
						<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">flags_to_set</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span>
						<span class="n">ref</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">BTRFS_ADD_DELAYED_REF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_inc_extent_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					     <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">ref_root</span><span class="p">,</span>
					     <span class="n">ref</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">BTRFS_DROP_DELAYED_REF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					  <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">ref_root</span><span class="p">,</span>
					  <span class="n">ref</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* helper function to actually process a single delayed ref entry */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_one_delayed_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">insert_reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">aborted</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_delayed_ref_is_head</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * we&#39;ve hit the end of the chain and we were supposed</span>
<span class="cm">		 * to insert this extent into the tree.  But, it got</span>
<span class="cm">		 * deleted before we ever needed to insert it, so all</span>
<span class="cm">		 * we have to do is clean up the accounting</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">extent_op</span><span class="p">);</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_head</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">insert_reserved</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_pin_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					 <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">is_data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_csums</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						      <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
						      <span class="n">node</span><span class="o">-&gt;</span><span class="n">num_bytes</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span> <span class="o">||</span>
	    <span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_delayed_tree_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">,</span>
					   <span class="n">insert_reserved</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span> <span class="o">||</span>
		 <span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_delayed_data_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">,</span>
					   <span class="n">insert_reserved</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span>
<span class="nf">select_delayed_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">action</span> <span class="o">=</span> <span class="n">BTRFS_ADD_DELAYED_REF</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * select delayed ref of type BTRFS_ADD_DELAYED_REF first.</span>
<span class="cm">	 * this prevents ref count from going down to zero when</span>
<span class="cm">	 * there still are pending delayed ref.</span>
<span class="cm">	 */</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span><span class="p">,</span>
				<span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">bytenr</span> <span class="o">!=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">bytenr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">action</span> <span class="o">==</span> <span class="n">action</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ref</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">action</span> <span class="o">==</span> <span class="n">BTRFS_ADD_DELAYED_REF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">action</span> <span class="o">=</span> <span class="n">BTRFS_DROP_DELAYED_REF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Returns 0 on success or if called with an already aborted transaction.</span>
<span class="cm"> * Returns -ENOMEM or -EIO on failure and will abort the transaction.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">run_clustered_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cluster</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">locked_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">must_insert_reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">delayed_refs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">locked_ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* pick a new head ref from the cluster list */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="n">cluster</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">locked_ref</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span><span class="p">,</span> <span class="n">cluster</span><span class="p">);</span>

			<span class="cm">/* grab the lock that says we are going to process</span>
<span class="cm">			 * all the refs for this head */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delayed_ref_lock</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">locked_ref</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * we may have dropped the spin lock to get the head</span>
<span class="cm">			 * mutex lock, and that might have given someone else</span>
<span class="cm">			 * time to free the head.  If that&#39;s true, it has been</span>
<span class="cm">			 * removed from our list and we can move on.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">locked_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">count</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * locked_ref is the head node, so we have to go one</span>
<span class="cm">		 * node back for any delayed ref updates</span>
<span class="cm">		 */</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">select_delayed_ref</span><span class="p">(</span><span class="n">locked_ref</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&amp;&amp;</span>
		    <span class="n">btrfs_check_delayed_seq</span><span class="p">(</span><span class="n">delayed_refs</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * there are still refs with lower seq numbers in the</span>
<span class="cm">			 * process of being added. Don&#39;t run this ref yet.</span>
<span class="cm">			 */</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">cluster</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
			<span class="n">locked_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_heads_ready</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * record the must insert reserved flag before we</span>
<span class="cm">		 * drop the spin lock.</span>
<span class="cm">		 */</span>
		<span class="n">must_insert_reserved</span> <span class="o">=</span> <span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">must_insert_reserved</span><span class="p">;</span>
		<span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">must_insert_reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">extent_op</span> <span class="o">=</span> <span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">extent_op</span><span class="p">;</span>
		<span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">extent_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* All delayed refs have been processed, Go ahead</span>
<span class="cm">			 * and send the head node to run_one_delayed_ref,</span>
<span class="cm">			 * so that any accounting fixes can happen</span>
<span class="cm">			 */</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span> <span class="o">&amp;&amp;</span> <span class="n">must_insert_reserved</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">extent_op</span><span class="p">);</span>
				<span class="n">extent_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">run_delayed_extent_op</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
							    <span class="n">ref</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">extent_op</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;btrfs: run_delayed_extent_op returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
					<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">locked_ref</span><span class="o">-&gt;</span><span class="n">cluster</span><span class="p">);</span>
			<span class="n">locked_ref</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">in_tree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * we modified num_entries, but as we&#39;re currently running</span>
<span class="cm">		 * delayed refs, skip</span>
<span class="cm">		 *     wake_up(&amp;delayed_refs-&gt;seq_wait);</span>
<span class="cm">		 * here.</span>
<span class="cm">		 */</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_one_delayed_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">,</span>
					  <span class="n">must_insert_reserved</span><span class="p">);</span>

		<span class="n">btrfs_put_delayed_ref</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">extent_op</span><span class="p">);</span>
		<span class="n">count</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;btrfs: run_one_delayed_ref returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">next:</span>
		<span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
			       <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
			       <span class="n">btrfs_get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
			       <span class="n">CHUNK_ALLOC_NO_FORCE</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">wait_for_more_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_refs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">first_seq</span> <span class="o">=</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">seq_head</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;waiting for more refs (num %ld, first %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">num_refs</span><span class="p">,</span> <span class="n">first_seq</span><span class="p">);</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">seq_wait</span><span class="p">,</span>
		   <span class="n">num_refs</span> <span class="o">!=</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">||</span>
		   <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">seq_head</span><span class="p">.</span><span class="n">next</span> <span class="o">!=</span> <span class="n">first_seq</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;done waiting for more refs (num %ld, first %p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">,</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">seq_head</span><span class="p">.</span><span class="n">next</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this starts processing the delayed reference count updates and</span>
<span class="cm"> * extent insertions we have queued up so far.  count can be</span>
<span class="cm"> * 0, which means to process everything in the tree at the start</span>
<span class="cm"> * of the run (but not newly added entries), or it can be some target</span>
<span class="cm"> * number you&#39;d like to process.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 on success or if called with an aborted transaction</span>
<span class="cm"> * Returns &lt;0 on error and aborts the transaction</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_run_delayed_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">cluster</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">delayed_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">run_all</span> <span class="o">=</span> <span class="n">count</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">run_most</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_refs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">consider_waiting</span><span class="p">;</span>

	<span class="cm">/* We&#39;ll clean this up in btrfs_cleanup_transaction */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">aborted</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">)</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">;</span>

	<span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
		       <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">btrfs_get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
		       <span class="n">CHUNK_ALLOC_NO_FORCE</span><span class="p">);</span>

	<span class="n">delayed_refs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">consider_waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">count</span> <span class="o">=</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_entries</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">run_most</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">run_all</span> <span class="o">||</span> <span class="n">run_most</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_heads_ready</span> <span class="o">&lt;</span> <span class="mi">64</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * go find something we can process in the rbtree.  We start at</span>
<span class="cm">		 * the beginning of the tree, and then build a cluster</span>
<span class="cm">		 * of refs to process starting at the first one we are able to</span>
<span class="cm">		 * lock</span>
<span class="cm">		 */</span>
		<span class="n">delayed_start</span> <span class="o">=</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">run_delayed_start</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_find_ref_cluster</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cluster</span><span class="p">,</span>
					     <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">run_delayed_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">delayed_start</span> <span class="o">&gt;=</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">run_delayed_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">consider_waiting</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * btrfs_find_ref_cluster looped. let&#39;s do one</span>
<span class="cm">				 * more cycle. if we don&#39;t run any delayed ref</span>
<span class="cm">				 * during that cycle (because we can&#39;t because</span>
<span class="cm">				 * all of them are blocked) and if the number of</span>
<span class="cm">				 * refs doesn&#39;t change, we avoid busy waiting.</span>
<span class="cm">				 */</span>
				<span class="n">consider_waiting</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">num_refs</span> <span class="o">=</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">wait_for_more_refs</span><span class="p">(</span><span class="n">delayed_refs</span><span class="p">,</span> <span class="n">num_refs</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * after waiting, things have changed. we</span>
<span class="cm">				 * dropped the lock and someone else might have</span>
<span class="cm">				 * run some refs, built new clusters and so on.</span>
<span class="cm">				 * therefore, we restart staleness detection.</span>
<span class="cm">				 */</span>
				<span class="n">consider_waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_clustered_refs</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cluster</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">count</span> <span class="o">-=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">run_delayed_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* refs were run, let&#39;s reset staleness detection */</span>
			<span class="n">consider_waiting</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">run_all</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">count</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span><span class="p">,</span>
				       <span class="n">rb_node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_delayed_ref_is_head</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>

				<span class="n">head</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_head</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>

				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="cm">/*</span>
<span class="cm">				 * Mutex was contended, block until it&#39;s</span>
<span class="cm">				 * released and try again</span>
<span class="cm">				 */</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

				<span class="n">btrfs_put_delayed_ref</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
				<span class="n">cond_resched</span><span class="p">();</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_set_disk_extent_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">is_data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">extent_op</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">extent_op</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">extent_op</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">flags_to_set</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_flags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_key</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">is_data</span> <span class="o">=</span> <span class="n">is_data</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_extent_op</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
					  <span class="n">num_bytes</span><span class="p">,</span> <span class="n">extent_op</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">extent_op</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">check_delayed_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_data_ref</span> <span class="o">*</span><span class="n">data_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">delayed_refs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">btrfs_find_delayed_ref_head</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">refs</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Mutex was contended, block until it&#39;s released and let</span>
<span class="cm">		 * caller try again</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">btrfs_put_delayed_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">bytenr</span> <span class="o">!=</span> <span class="n">bytenr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">data_ref</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_data_ref</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">bytenr</span> <span class="o">==</span> <span class="n">bytenr</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data_ref</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">||</span>
	    <span class="n">data_ref</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">objectid</span> <span class="o">||</span> <span class="n">data_ref</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">check_committed_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* Corruption */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">bytenr</span> <span class="o">||</span> <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_item_v0</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">item_size</span> <span class="o">!=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">)</span> <span class="o">+</span>
	    <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_extent_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">)</span> <span class="o">&lt;=</span>
	    <span class="n">btrfs_root_last_snapshot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">iref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">iref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">btrfs_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">||</span>
	    <span class="n">btrfs_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">objectid</span> <span class="o">||</span>
	    <span class="n">btrfs_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">offset</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_cross_ref_exist</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			  <span class="n">u64</span> <span class="n">objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret2</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">check_committed_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">objectid</span><span class="p">,</span>
					  <span class="n">offset</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">ret2</span> <span class="o">=</span> <span class="n">check_delayed_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">objectid</span><span class="p">,</span>
					 <span class="n">offset</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret2</span> <span class="o">&amp;&amp;</span> <span class="n">ret2</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ret2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span> <span class="o">||</span> <span class="n">ret2</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_DATA_RELOC_TREE_OBJECTID</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_mod_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">full_backref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">inc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">for_cow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ref_root</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">process_func</span><span class="p">)(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="p">,</span>
			    <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="n">u64</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

	<span class="n">ref_root</span> <span class="o">=</span> <span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inc</span><span class="p">)</span>
		<span class="n">process_func</span> <span class="o">=</span> <span class="n">btrfs_inc_extent_ref</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">process_func</span> <span class="o">=</span> <span class="n">btrfs_free_extent</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">full_backref</span><span class="p">)</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">==</span>
			    <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">bytenr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_num_bytes</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-=</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">process_func</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
					   <span class="n">parent</span><span class="p">,</span> <span class="n">ref_root</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					   <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">for_cow</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">process_func</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
					   <span class="n">parent</span><span class="p">,</span> <span class="n">ref_root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">for_cow</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_inc_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_backref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">for_cow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_mod_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">full_backref</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">for_cow</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_dec_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">full_backref</span><span class="p">,</span> <span class="kt">int</span> <span class="n">for_cow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_mod_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">full_backref</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">for_cow</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">write_one_cache_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* Corruption */</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">bi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">bi</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">));</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span>
<span class="nf">next_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		 <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">cache_node</span><span class="p">);</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span><span class="p">,</span>
				 <span class="n">cache_node</span><span class="p">);</span>
		<span class="n">btrfs_get_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">cache</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cache_save_setup</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dcs</span> <span class="o">=</span> <span class="n">BTRFS_DC_ERROR</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If this block group is smaller than 100 megs don&#39;t bother caching the</span>
<span class="cm">	 * block group.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">100</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">=</span> <span class="n">BTRFS_DC_WRITTEN</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">again:</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">lookup_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">retries</span><span class="p">);</span>
		<span class="n">retries</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">create_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* We&#39;ve already setup this transaction, go ahead and exit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cache_generation</span> <span class="o">==</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">&amp;&amp;</span>
	    <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">dcs</span> <span class="o">=</span> <span class="n">BTRFS_DC_SETUP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We want to set the generation to 0, that way if anything goes wrong</span>
<span class="cm">	 * from here on out we know not to trust this cache when we load up next</span>
<span class="cm">	 * time.</span>
<span class="cm">	 */</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_truncate_free_space_cache</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						      <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">!=</span> <span class="n">BTRFS_CACHE_FINISHED</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We&#39;re not cached, don&#39;t bother trying to write stuff out */</span>
		<span class="n">dcs</span> <span class="o">=</span> <span class="n">BTRFS_DC_WRITTEN</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">div64_u64</span><span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_pages</span><span class="p">)</span>
		<span class="n">num_pages</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Just to make absolutely sure we have enough space, we&#39;re going to</span>
<span class="cm">	 * preallocate 12 pages worth of space for each block group.  In</span>
<span class="cm">	 * practice we ought to use at most 8, but we need extra space so we can</span>
<span class="cm">	 * add our header and have a terminator between the extents and the</span>
<span class="cm">	 * bitmaps.</span>
<span class="cm">	 */</span>
	<span class="n">num_pages</span> <span class="o">*=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">num_pages</span> <span class="o">*=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_check_data_free_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_put</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_prealloc_file_range_trans</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">,</span>
					      <span class="n">num_pages</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">alloc_hint</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">dcs</span> <span class="o">=</span> <span class="n">BTRFS_DC_SETUP</span><span class="p">;</span>
	<span class="n">btrfs_free_reserved_data_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>

<span class="nl">out_put:</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">dcs</span> <span class="o">==</span> <span class="n">BTRFS_DC_SETUP</span><span class="p">)</span>
		<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cache_generation</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
	<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">=</span> <span class="n">dcs</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_write_dirty_block_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">==</span> <span class="n">BTRFS_DC_CLEAR</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cache</span> <span class="o">=</span> <span class="n">next_block_group</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">cache_save_setup</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_run_delayed_refs</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="cm">/* File system offline */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">==</span> <span class="n">BTRFS_DC_CLEAR</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cache</span> <span class="o">=</span> <span class="n">next_block_group</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">==</span> <span class="n">BTRFS_DC_SETUP</span><span class="p">)</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">=</span> <span class="n">BTRFS_DC_NEED_WRITE</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">write_one_cache_group</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="cm">/* File system offline */</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * I don&#39;t think this is needed since we&#39;re just marking our</span>
<span class="cm">		 * preallocated extent as written, but just in case it can&#39;t</span>
<span class="cm">		 * hurt.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_run_delayed_refs</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="cm">/* File system offline */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Really this shouldn&#39;t happen, but it could if we</span>
<span class="cm">			 * couldn&#39;t write the entire preallocated extent and</span>
<span class="cm">			 * splitting the extent resulted in a new block.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">dirty</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">==</span> <span class="n">BTRFS_DC_NEED_WRITE</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">cache</span> <span class="o">=</span> <span class="n">next_block_group</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_write_out_cache</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we didn&#39;t have an error then the cache state is still</span>
<span class="cm">		 * NEED_WRITE, so we can set it to WRITTEN.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">==</span> <span class="n">BTRFS_DC_NEED_WRITE</span><span class="p">)</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">=</span> <span class="n">BTRFS_DC_WRITTEN</span><span class="p">;</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>

	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_extent_readonly</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">readonly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">block_group</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_group</span> <span class="o">||</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span>
		<span class="n">readonly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="p">)</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">readonly</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">total_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytes_used</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">**</span><span class="n">space_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_DUP</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
		     <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">))</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">found</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">found</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">total_bytes</span><span class="p">;</span>
		<span class="n">found</span><span class="o">-&gt;</span><span class="n">disk_total</span> <span class="o">+=</span> <span class="n">total_bytes</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
		<span class="n">found</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+=</span> <span class="n">bytes_used</span><span class="p">;</span>
		<span class="n">found</span><span class="o">-&gt;</span><span class="n">disk_used</span> <span class="o">+=</span> <span class="n">bytes_used</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
		<span class="n">found</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="o">*</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">found</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_NR_RAID_TYPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_TYPE_MASK</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">disk_total</span> <span class="o">=</span> <span class="n">total_bytes</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">=</span> <span class="n">bytes_used</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">disk_used</span> <span class="o">=</span> <span class="n">bytes_used</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">force_alloc</span> <span class="o">=</span> <span class="n">CHUNK_ALLOC_NO_FORCE</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">chunk_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">found</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="o">*</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
	<span class="n">list_add_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">set_avail_alloc_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">extra_flags</span> <span class="o">=</span> <span class="n">chunk_to_extended</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">BTRFS_EXTENDED_PROFILE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">)</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_data_alloc_bits</span> <span class="o">|=</span> <span class="n">extra_flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">)</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_metadata_alloc_bits</span> <span class="o">|=</span> <span class="n">extra_flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">)</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_system_alloc_bits</span> <span class="o">|=</span> <span class="n">extra_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns target flags in extended format or 0 if restripe for this</span>
<span class="cm"> * chunk_type is not in progress</span>
<span class="cm"> *</span>
<span class="cm"> * should be called with either volume_mutex or balance_lock held</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">get_restripe_target</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_balance_control</span> <span class="o">*</span><span class="n">bctl</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">target</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span> <span class="o">&amp;&amp;</span>
	    <span class="n">bctl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BALANCE_ARGS_CONVERT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span> <span class="o">|</span> <span class="n">bctl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">.</span><span class="n">target</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span> <span class="o">&amp;&amp;</span>
		   <span class="n">bctl</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BALANCE_ARGS_CONVERT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span> <span class="o">|</span> <span class="n">bctl</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">.</span><span class="n">target</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span> <span class="o">&amp;&amp;</span>
		   <span class="n">bctl</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BALANCE_ARGS_CONVERT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">target</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span> <span class="o">|</span> <span class="n">bctl</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">.</span><span class="n">target</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">target</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * @flags: available profiles in extended format (see ctree.h)</span>
<span class="cm"> *</span>
<span class="cm"> * Returns reduced profile in chunk format.  If profile changing is in</span>
<span class="cm"> * progress (either running or paused) picks the target profile (if it&#39;s</span>
<span class="cm"> * already available), otherwise falls back to plain reducing.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">btrfs_reduce_alloc_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * we add in the count of missing devices because we want</span>
<span class="cm">	 * to make sure that any RAID levels on a degraded FS</span>
<span class="cm">	 * continue to be honored.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">num_devices</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">rw_devices</span> <span class="o">+</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">missing_devices</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">target</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * see if restripe for this chunk_type is in progress, if so</span>
<span class="cm">	 * try to reduce to the target profile</span>
<span class="cm">	 */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_lock</span><span class="p">);</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">get_restripe_target</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* pick target profile only if it&#39;s already available */</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">target</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENDED_PROFILE_MASK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_lock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">extended_to_chunk</span><span class="p">(</span><span class="n">target</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_devices</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_RAID0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_devices</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
		      <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID1</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_BLOCK_GROUP_RAID1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID1</span><span class="p">)</span> <span class="o">|</span>
	     <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">)</span> <span class="o">|</span>
	     <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_BLOCK_GROUP_RAID0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">extended_to_chunk</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">get_alloc_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_data_alloc_bits</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_system_alloc_bits</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_metadata_alloc_bits</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">btrfs_reduce_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">btrfs_get_alloc_profile</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_root</span><span class="p">)</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_set_inode_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
						       <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This will check the space that the inode allocates from to make sure we have</span>
<span class="cm"> * enough space for bytes.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_check_data_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">data_sinfo</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">committed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alloc_chunk</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* make sure bytes are sectorsize aligned */</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span> <span class="o">||</span>
	    <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_FREE_INO_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">alloc_chunk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">committed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data_sinfo</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_sinfo</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">alloc</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="cm">/* make sure we have enough space to handle the data first */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+</span> <span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">+</span>
		<span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+</span> <span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+</span>
		<span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">+</span> <span class="n">bytes</span> <span class="o">&gt;</span> <span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if we don&#39;t have enough free bytes in this space then we need</span>
<span class="cm">		 * to alloc a new chunk.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">&amp;&amp;</span> <span class="n">alloc_chunk</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">alloc_target</span><span class="p">;</span>

			<span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">force_alloc</span> <span class="o">=</span> <span class="n">CHUNK_ALLOC_FORCE</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">alloc:</span>
			<span class="n">alloc_target</span> <span class="o">=</span> <span class="n">btrfs_get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
					     <span class="n">bytes</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
					     <span class="n">alloc_target</span><span class="p">,</span>
					     <span class="n">CHUNK_ALLOC_NO_FORCE</span><span class="p">);</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
					<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">else</span>
					<span class="k">goto</span> <span class="n">commit_trans</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data_sinfo</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_set_inode_space_info</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
				<span class="n">data_sinfo</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we have less pinned bytes than we want to allocate then</span>
<span class="cm">		 * don&#39;t bother committing the transaction, it won&#39;t help us.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">)</span>
			<span class="n">committed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* commit the current transaction and try again */</span>
<span class="nl">commit_trans:</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">committed</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">open_ioctl_trans</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">committed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">+=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;space_info&quot;</span><span class="p">,</span>
				      <span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Called if we need to clear a data reservation for this inode.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_free_reserved_data_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">data_sinfo</span><span class="p">;</span>

	<span class="cm">/* make sure bytes are sectorsize aligned */</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">data_sinfo</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">-=</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;space_info&quot;</span><span class="p">,</span>
				      <span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">data_sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">force_metadata_allocation</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">found</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">found</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">)</span>
			<span class="n">found</span><span class="o">-&gt;</span><span class="n">force_alloc</span> <span class="o">=</span> <span class="n">CHUNK_ALLOC_FORCE</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">should_alloc_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">,</span> <span class="n">u64</span> <span class="n">alloc_bytes</span><span class="p">,</span>
			      <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">global_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">-</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_allocated</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">thresh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">==</span> <span class="n">CHUNK_ALLOC_FORCE</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to take into account the global rsv because for all intents</span>
<span class="cm">	 * and purposes it&#39;s used space.  Don&#39;t worry about locking the</span>
<span class="cm">	 * global_rsv, it doesn&#39;t change except when the transaction commits.</span>
<span class="cm">	 */</span>
	<span class="n">num_allocated</span> <span class="o">+=</span> <span class="n">global_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * in limited mode, we want to have some free space up to</span>
<span class="cm">	 * about 1% of the FS size.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">==</span> <span class="n">CHUNK_ALLOC_LIMITED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">thresh</span> <span class="o">=</span> <span class="n">btrfs_super_total_bytes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>
		<span class="n">thresh</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span>
			       <span class="n">div_factor_fine</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="mi">1</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">-</span> <span class="n">num_allocated</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">thresh</span> <span class="o">=</span> <span class="n">btrfs_super_total_bytes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>

	<span class="cm">/* 256MB or 2% of the FS */</span>
	<span class="n">thresh</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">div_factor_fine</span><span class="p">(</span><span class="n">thresh</span><span class="p">,</span> <span class="mi">2</span><span class="p">));</span>
	<span class="cm">/* system chunks need a much small threshold */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">)</span>
		<span class="n">thresh</span> <span class="o">=</span> <span class="mi">32</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="n">thresh</span> <span class="o">&amp;&amp;</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">&lt;</span> <span class="n">div_factor</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">get_system_chunk_thresh</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">num_dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID10</span> <span class="o">||</span>
	    <span class="n">type</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID0</span><span class="p">)</span>
		<span class="n">num_dev</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">rw_devices</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID1</span><span class="p">)</span>
		<span class="n">num_dev</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">num_dev</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>	<span class="cm">/* DUP or single */</span>

	<span class="cm">/* metadata for updaing devices and chunk tree */</span>
	<span class="k">return</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">num_dev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">check_system_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">left</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">thresh</span><span class="p">;</span>

	<span class="n">info</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">left</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">-</span>
		<span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">thresh</span> <span class="o">=</span> <span class="n">get_system_chunk_thresh</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ENOSPC_DEBUG</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;left=%llu, need=%llu, flags=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">left</span><span class="p">,</span> <span class="n">thresh</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">dump_space_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;</span> <span class="n">thresh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">btrfs_alloc_chunk</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">do_chunk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">alloc_bytes</span><span class="p">,</span>
			  <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">extent_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wait_for_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">space_info</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">extent_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">space_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_space_info</span><span class="p">(</span><span class="n">extent_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">space_info</span><span class="p">);</span> <span class="cm">/* Logic error */</span>

<span class="nl">again:</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force</span> <span class="o">&lt;</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">force_alloc</span><span class="p">)</span>
		<span class="n">force</span> <span class="o">=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">force_alloc</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">should_alloc_chunk</span><span class="p">(</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">space_info</span><span class="p">,</span> <span class="n">alloc_bytes</span><span class="p">,</span> <span class="n">force</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">chunk_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_for_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">chunk_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The chunk_mutex is held throughout the entirety of a chunk</span>
<span class="cm">	 * allocation, so once we&#39;ve acquired the chunk_mutex we know that the</span>
<span class="cm">	 * other guy is done and we need to recheck and see if we should</span>
<span class="cm">	 * allocate.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait_for_alloc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_mutex</span><span class="p">);</span>
		<span class="n">wait_for_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have mixed data/metadata chunks we want to make sure we keep</span>
<span class="cm">	 * allocating mixed chunks instead of individual chunks.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_mixed_space_info</span><span class="p">(</span><span class="n">space_info</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_DATA</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we&#39;re doing a data chunk, go ahead and make sure that</span>
<span class="cm">	 * we keep a reasonable number of metadata chunks allocated in the</span>
<span class="cm">	 * FS as well.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span> <span class="o">&amp;&amp;</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">metadata_ratio</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">data_chunk_allocations</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">data_chunk_allocations</span> <span class="o">%</span>
		      <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">metadata_ratio</span><span class="p">))</span>
			<span class="n">force_metadata_allocation</span><span class="p">(</span><span class="n">fs_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Check if we have enough space in SYSTEM chunk because we may need</span>
<span class="cm">	 * to update devices.</span>
<span class="cm">	 */</span>
	<span class="n">check_system_chunk</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_alloc_chunk</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">force_alloc</span> <span class="o">=</span> <span class="n">CHUNK_ALLOC_NO_FORCE</span><span class="p">;</span>
	<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">chunk_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * shrink metadata reservation for delalloc</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">shrink_delalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">to_reclaim</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">wait_ordered</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">reserved</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">max_reclaim</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">reclaimed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">time_left</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loops</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">progress</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>
	<span class="n">space_info</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>

	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="n">reserved</span> <span class="o">=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">;</span>
	<span class="n">progress</span> <span class="o">=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">reservation_progress</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">btrfs_wait_ordered_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">max_reclaim</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">reserved</span><span class="p">,</span> <span class="n">to_reclaim</span><span class="p">);</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
			 <span class="n">max_reclaim</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">loops</span> <span class="o">&lt;</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* have the flusher threads jump in and do some IO */</span>
		<span class="n">smp_mb</span><span class="p">();</span>
		<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
		<span class="n">writeback_inodes_sb_nr_if_idle</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
						<span class="n">WB_REASON_FS_FREE_SPACE</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span> <span class="o">&gt;</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">)</span>
			<span class="n">reclaimed</span> <span class="o">+=</span> <span class="n">reserved</span> <span class="o">-</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">;</span>
		<span class="n">reserved</span> <span class="o">=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">loops</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">reclaimed</span> <span class="o">&gt;=</span> <span class="n">max_reclaim</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wait_ordered</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_wait_ordered_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">time_left</span> <span class="o">=</span> <span class="n">schedule_timeout_interruptible</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* We were interrupted, exit */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">time_left</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we&#39;ve kicked the IO a few times, if anything has been freed,</span>
<span class="cm">		 * exit.  There is no sense in looping here for a long time</span>
<span class="cm">		 * when we really need to commit the transaction, or there are</span>
<span class="cm">		 * just too many writers without enough free space</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">loops</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">smp_mb</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">progress</span> <span class="o">!=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">reservation_progress</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="k">return</span> <span class="n">reclaimed</span> <span class="o">&gt;=</span> <span class="n">to_reclaim</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * maybe_commit_transaction - possibly commit the transaction if its ok to</span>
<span class="cm"> * @root - the root we&#39;re allocating for</span>
<span class="cm"> * @bytes - the number of bytes we want to reserve</span>
<span class="cm"> * @force - force the commit</span>
<span class="cm"> *</span>
<span class="cm"> * This will check to make sure that committing the transaction will actually</span>
<span class="cm"> * get us somewhere and then commit the transaction if it does.  Otherwise it</span>
<span class="cm"> * will return -ENOSPC.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">may_commit_transaction</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">delayed_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_block_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="p">)</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">commit</span><span class="p">;</span>

	<span class="cm">/* See if there is enough pinned space to make this reservation */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">&gt;=</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">commit</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * See if there is some space in the delayed insertion reservation for</span>
<span class="cm">	 * this reservation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space_info</span> <span class="o">!=</span> <span class="n">delayed_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+</span> <span class="n">delayed_rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

<span class="nl">commit:</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * reserve_metadata_bytes - try to reserve bytes from the block_rsv&#39;s space</span>
<span class="cm"> * @root - the root we&#39;re allocating for</span>
<span class="cm"> * @block_rsv - the block_rsv we&#39;re allocating for</span>
<span class="cm"> * @orig_bytes - the number of bytes we want</span>
<span class="cm"> * @flush - wether or not we can flush to make our reservation</span>
<span class="cm"> *</span>
<span class="cm"> * This will reserve orgi_bytes number of bytes from the space info associated</span>
<span class="cm"> * with the block_rsv.  If there is not enough space it will make an attempt to</span>
<span class="cm"> * flush out space to make room.  It will do this by flushing delalloc if</span>
<span class="cm"> * possible or committing the transaction.  If flush is 0 then no attempts to</span>
<span class="cm"> * regain reservations will be made and this will fail if there is not enough</span>
<span class="cm"> * space already.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">reserve_metadata_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">orig_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">used</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">orig_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">retries</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">committed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">flushing</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">wait_ordered</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We only want to wait if somebody other than us is flushing and we are</span>
<span class="cm">	 * actually alloed to flush.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">flush</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">flushing</span> <span class="o">&amp;&amp;</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we have a trans handle we can&#39;t wait because the flusher</span>
<span class="cm">		 * may have to commit the transaction, which would mean we would</span>
<span class="cm">		 * deadlock since we are waiting for the flusher to finish, but</span>
<span class="cm">		 * hold the current transaction open.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">journal_info</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">wait_event_killable</span><span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="o">!</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flush</span><span class="p">);</span>
		<span class="cm">/* Must have been killed, return */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINTR</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">used</span> <span class="o">=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">+</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The idea here is that we&#39;ve not already over-reserved the block group</span>
<span class="cm">	 * then we can go ahead and save our reservation first and then start</span>
<span class="cm">	 * flushing if we need to.  Otherwise if we&#39;ve already overcommitted</span>
<span class="cm">	 * lets start flushing stuff first and then come back and try to make</span>
<span class="cm">	 * our reservation.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&lt;=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">+</span> <span class="n">orig_bytes</span> <span class="o">&lt;=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">+=</span> <span class="n">orig_bytes</span><span class="p">;</span>
			<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
				<span class="s">&quot;space_info&quot;</span><span class="p">,</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">orig_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * Ok set num_bytes to orig_bytes since we aren&#39;t</span>
<span class="cm">			 * overocmmitted, this way we only try and reclaim what</span>
<span class="cm">			 * we need.</span>
<span class="cm">			 */</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">orig_bytes</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Ok we&#39;re over committed, set num_bytes to the overcommitted</span>
<span class="cm">		 * amount plus the amount of bytes that we need for this</span>
<span class="cm">		 * reservation.</span>
<span class="cm">		 */</span>
		<span class="n">wait_ordered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">used</span> <span class="o">-</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">+</span>
			<span class="p">(</span><span class="n">orig_bytes</span> <span class="o">*</span> <span class="p">(</span><span class="n">retries</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">profile</span> <span class="o">=</span> <span class="n">btrfs_get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">u64</span> <span class="n">avail</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we have a lot of space that&#39;s pinned, don&#39;t bother doing</span>
<span class="cm">		 * the overcommit dance yet and just commit the transaction.</span>
<span class="cm">		 */</span>
		<span class="n">avail</span> <span class="o">=</span> <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">-</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_used</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">avail</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">&gt;=</span> <span class="n">avail</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">committed</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">flushing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">may_commit_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">space_info</span><span class="p">,</span>
						     <span class="n">orig_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">committed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">free_chunk_lock</span><span class="p">);</span>
		<span class="n">avail</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">free_chunk_space</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we have dup, raid1 or raid10 then only half of the free</span>
<span class="cm">		 * space is actually useable.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">profile</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_DUP</span> <span class="o">|</span>
			       <span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
			       <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">))</span>
			<span class="n">avail</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we aren&#39;t flushing don&#39;t let us overcommit too much, say</span>
<span class="cm">		 * 1/8th of the space.  If we can flush, let it overcommit up to</span>
<span class="cm">		 * 1/2 of the space.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flush</span><span class="p">)</span>
			<span class="n">avail</span> <span class="o">&gt;&gt;=</span> <span class="mi">3</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">avail</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
		 <span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">free_chunk_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">+</span> <span class="n">avail</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">+=</span> <span class="n">orig_bytes</span><span class="p">;</span>
			<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
				<span class="s">&quot;space_info&quot;</span><span class="p">,</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">orig_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">wait_ordered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Couldn&#39;t make our reservation, save our place so while we&#39;re trying</span>
<span class="cm">	 * to reclaim space we can actually use it instead of somebody else</span>
<span class="cm">	 * stealing it from us.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">flush</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flushing</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">flush</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do synchronous shrinking since we don&#39;t actually unreserve</span>
<span class="cm">	 * metadata until after the IO is completed.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">shrink_delalloc</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">wait_ordered</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * So if we were overcommitted it&#39;s possible that somebody else flushed</span>
<span class="cm">	 * out enough space and we simply didn&#39;t have enough space to reclaim,</span>
<span class="cm">	 * so go back around and try again.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">retries</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_ordered</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">retries</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">committed</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">may_commit_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">space_info</span><span class="p">,</span> <span class="n">orig_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">committed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flushing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">wake_up_all</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="nf">get_block_rsv</span><span class="p">(</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">csum_root</span><span class="p">)</span>
		<span class="n">block_rsv</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_rsv</span><span class="p">)</span>
		<span class="n">block_rsv</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">block_rsv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_rsv</span><span class="p">)</span>
		<span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">empty_block_rsv</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">block_rsv</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">block_rsv_use_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">num_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&lt;</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
			<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">block_rsv_add_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">update_size</span><span class="p">)</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">block_rsv_release_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
	<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u64</span> <span class="n">bytes_to_add</span><span class="p">;</span>

				<span class="n">bytes_to_add</span> <span class="o">=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">-</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">;</span>
				<span class="n">bytes_to_add</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">bytes_to_add</span><span class="p">);</span>
				<span class="n">dest</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">+=</span> <span class="n">bytes_to_add</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">dest</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span>
					<span class="n">dest</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">bytes_to_add</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;space_info&quot;</span><span class="p">,</span>
					<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">reservation_progress</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">block_rsv_migrate_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">block_rsv_use_bytes</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">block_rsv_add_bytes</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_init_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">rsv</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">rsv</span><span class="p">));</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="nf">btrfs_alloc_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">block_rsv</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">block_rsv</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_rsv</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">btrfs_init_block_rsv</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">);</span>
	<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span>
						  <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">block_rsv</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_free_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">btrfs_block_rsv_release</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rsv</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rsv</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__block_rsv_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_metadata_bytes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">flush</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_rsv_add_bytes</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_block_rsv_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__block_rsv_add</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_block_rsv_add_noflush</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__block_rsv_add</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_block_rsv_check</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_factor</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_rsv</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">div_factor</span><span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="n">min_factor</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">num_bytes</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__btrfs_block_rsv_refill</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">min_reserved</span><span class="p">,</span> <span class="kt">int</span> <span class="n">flush</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_rsv</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">min_reserved</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">num_bytes</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_metadata_bytes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">flush</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_rsv_add_bytes</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_block_rsv_refill</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">min_reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_block_rsv_refill</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">min_reserved</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_block_rsv_refill_noflush</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">min_reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_block_rsv_refill</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">min_reserved</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_block_rsv_migrate</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">src_rsv</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">dst_rsv</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">block_rsv_migrate_bytes</span><span class="p">(</span><span class="n">src_rsv</span><span class="p">,</span> <span class="n">dst_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_block_rsv_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">global_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">global_rsv</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">||</span> <span class="n">global_rsv</span> <span class="o">==</span> <span class="n">block_rsv</span> <span class="o">||</span>
	    <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span> <span class="o">!=</span> <span class="n">global_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">)</span>
		<span class="n">global_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">block_rsv_release_bytes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">global_rsv</span><span class="p">,</span>
				<span class="n">num_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to calculate size of global block reservation.</span>
<span class="cm"> * the desired value is sum of space used by extent tree,</span>
<span class="cm"> * checksum tree and root tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">calc_global_metadata_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">meta_used</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">data_used</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csum_size</span> <span class="o">=</span> <span class="n">btrfs_super_csum_size</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>

	<span class="n">sinfo</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">data_used</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_used</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">sinfo</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">)</span>
		<span class="n">data_used</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">meta_used</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_used</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">num_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">data_used</span> <span class="o">&gt;&gt;</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span> <span class="o">*</span>
		    <span class="n">csum_size</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">num_bytes</span> <span class="o">+=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">data_used</span> <span class="o">+</span> <span class="n">meta_used</span><span class="p">,</span> <span class="mi">50</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">&gt;</span> <span class="n">meta_used</span><span class="p">)</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">div64_u64</span><span class="p">(</span><span class="n">meta_used</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="o">-&gt;</span><span class="n">leafsize</span> <span class="o">&lt;&lt;</span> <span class="mi">10</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">update_global_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">sinfo</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>

	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">calc_global_metadata_size</span><span class="p">(</span><span class="n">fs_info</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>

	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+</span>
		    <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">+</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+</span>
		    <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">&gt;</span> <span class="n">num_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">-</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;space_info&quot;</span><span class="p">,</span>
				      <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">&gt;=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;space_info&quot;</span><span class="p">,</span>
				      <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">reservation_progress</span><span class="o">++</span><span class="p">;</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">;</span>
		<span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">full</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_global_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>

	<span class="n">space_info</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">);</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_block_rsv</span><span class="p">.</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">space_info</span><span class="p">;</span>

	<span class="n">space_info</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">);</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">.</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">space_info</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">.</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">space_info</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">.</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">space_info</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">empty_block_rsv</span><span class="p">.</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">space_info</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_block_rsv</span><span class="p">.</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">space_info</span><span class="p">;</span>

	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">csum_root</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_root</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_block_rsv</span><span class="p">;</span>

	<span class="n">update_global_block_rsv</span><span class="p">(</span><span class="n">fs_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">release_global_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">block_rsv_release_bytes</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">.</span><span class="n">reserved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">.</span><span class="n">reserved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_block_rsv</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_block_rsv</span><span class="p">.</span><span class="n">reserved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_block_rsv</span><span class="p">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_block_rsv</span><span class="p">.</span><span class="n">reserved</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_trans_release_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;transaction&quot;</span><span class="p">,</span>
				      <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_block_rsv_release</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span><span class="p">);</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Can only return 0 or -ENOSPC */</span>
<span class="kt">int</span> <span class="nf">btrfs_orphan_reserve_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">src_rsv</span> <span class="o">=</span> <span class="n">get_block_rsv</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">dst_rsv</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to hold space in order to delete our orphan item once we&#39;ve</span>
<span class="cm">	 * added it, so this takes the reservation so we can release it later</span>
<span class="cm">	 * when we are truly done with the orphan item.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;orphan&quot;</span><span class="p">,</span>
				      <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">block_rsv_migrate_bytes</span><span class="p">(</span><span class="n">src_rsv</span><span class="p">,</span> <span class="n">dst_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_orphan_release_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;orphan&quot;</span><span class="p">,</span>
				      <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_block_rsv_release</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_snap_reserve_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_pending_snapshot</span> <span class="o">*</span><span class="n">pending</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">pending</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">src_rsv</span> <span class="o">=</span> <span class="n">get_block_rsv</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">dst_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pending</span><span class="o">-&gt;</span><span class="n">block_rsv</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * two for root back/forward refs, two for directory entries</span>
<span class="cm">	 * and one for root of the snapshot.</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="n">dst_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">src_rsv</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">block_rsv_migrate_bytes</span><span class="p">(</span><span class="n">src_rsv</span><span class="p">,</span> <span class="n">dst_rsv</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * drop_outstanding_extent - drop an outstanding extent</span>
<span class="cm"> * @inode: the inode we&#39;re dropping the extent for</span>
<span class="cm"> *</span>
<span class="cm"> * This is called when we are freeing up an outstanding extent, either called</span>
<span class="cm"> * after an error or after an extent is written.  This will return the number of</span>
<span class="cm"> * reserved extents that need to be freed.  This must be called with</span>
<span class="cm"> * BTRFS_I(inode)-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">drop_outstanding_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="n">drop_inode_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">dropped_extents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="p">);</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">--</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_DELALLOC_META_RESERVED</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="n">drop_inode_space</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If we have more or the same amount of outsanding extents than we have</span>
<span class="cm">	 * reserved then we need to leave the reserved extents count alone.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span> <span class="o">&gt;=</span>
	    <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_extents</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">drop_inode_space</span><span class="p">;</span>

	<span class="n">dropped_extents</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_extents</span> <span class="o">-</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="p">;</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_extents</span> <span class="o">-=</span> <span class="n">dropped_extents</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">dropped_extents</span> <span class="o">+</span> <span class="n">drop_inode_space</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * calc_csum_metadata_size - return the amount of metada space that must be</span>
<span class="cm"> *	reserved/free&#39;d for the given bytes.</span>
<span class="cm"> * @inode: the inode we&#39;re manipulating</span>
<span class="cm"> * @num_bytes: the number of bytes in question</span>
<span class="cm"> * @reserve: 1 if we are reserving space, 0 if we are freeing space</span>
<span class="cm"> *</span>
<span class="cm"> * This adjusts the number of csum_bytes in the inode and then returns the</span>
<span class="cm"> * correct amount of metadata that must either be reserved or freed.  We</span>
<span class="cm"> * calculate how many checksums we can fit into one leaf and then divide the</span>
<span class="cm"> * number of bytes that will need to be checksumed by this value to figure out</span>
<span class="cm"> * how many checksums will be required.  If we are adding bytes then the number</span>
<span class="cm"> * may go up and we will return the number of additional bytes that must be</span>
<span class="cm"> * reserved.  If it is going down we will return the number of bytes that must</span>
<span class="cm"> * be freed.</span>
<span class="cm"> *</span>
<span class="cm"> * This must be called with BTRFS_I(inode)-&gt;lock held.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">calc_csum_metadata_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">reserve</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">csum_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_csums_per_leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_csums</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_csums</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATASUM</span> <span class="o">&amp;&amp;</span>
	    <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">old_csums</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">div64_u64</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span><span class="p">)</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">csum_size</span> <span class="o">=</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">);</span>
	<span class="n">num_csums_per_leaf</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">div64_u64</span><span class="p">(</span><span class="n">csum_size</span><span class="p">,</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_csum_item</span><span class="p">)</span> <span class="o">+</span>
					    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_disk_key</span><span class="p">));</span>
	<span class="n">num_csums</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">div64_u64</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="n">num_csums</span> <span class="o">=</span> <span class="n">num_csums</span> <span class="o">+</span> <span class="n">num_csums_per_leaf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">num_csums</span> <span class="o">=</span> <span class="n">num_csums</span> <span class="o">/</span> <span class="n">num_csums_per_leaf</span><span class="p">;</span>

	<span class="n">old_csums</span> <span class="o">=</span> <span class="n">old_csums</span> <span class="o">+</span> <span class="n">num_csums_per_leaf</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">old_csums</span> <span class="o">=</span> <span class="n">old_csums</span> <span class="o">/</span> <span class="n">num_csums_per_leaf</span><span class="p">;</span>

	<span class="cm">/* No change, no need to reserve more */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_csums</span> <span class="o">==</span> <span class="n">num_csums</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span>
						      <span class="n">num_csums</span> <span class="o">-</span> <span class="n">old_csums</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">old_csums</span> <span class="o">-</span> <span class="n">num_csums</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_delalloc_reserve_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">to_reserve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">csum_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">nr_extents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extra_reserve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">flush</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/* Need to be holding the i_mutex here if we aren&#39;t free space cache */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="n">flush</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flush</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_transaction_in_commit</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">))</span>
		<span class="n">schedule_timeout</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_mutex</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span> <span class="o">&gt;</span>
	    <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_extents</span><span class="p">)</span>
		<span class="n">nr_extents</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span> <span class="o">-</span>
			<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_extents</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Add an item to reserve for updating the inode when we complete the</span>
<span class="cm">	 * delalloc io.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_DELALLOC_META_RESERVED</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">nr_extents</span><span class="o">++</span><span class="p">;</span>
		<span class="n">extra_reserve</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">to_reserve</span> <span class="o">=</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr_extents</span><span class="p">);</span>
	<span class="n">to_reserve</span> <span class="o">+=</span> <span class="n">calc_csum_metadata_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">csum_bytes</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_metadata_bytes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">to_reserve</span><span class="p">,</span> <span class="n">flush</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="n">dropped</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">dropped</span> <span class="o">=</span> <span class="n">drop_outstanding_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the inodes csum_bytes is the same as the original</span>
<span class="cm">		 * csum_bytes then we know we haven&#39;t raced with any free()ers</span>
<span class="cm">		 * so we can just reduce our inodes csum bytes and carry on.</span>
<span class="cm">		 * Otherwise we have to do the normal free thing to account for</span>
<span class="cm">		 * the case that the free side didn&#39;t free up its reserve</span>
<span class="cm">		 * because of this outstanding reservation.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span> <span class="o">==</span> <span class="n">csum_bytes</span><span class="p">)</span>
			<span class="n">calc_csum_metadata_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">to_free</span> <span class="o">=</span> <span class="n">calc_csum_metadata_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dropped</span><span class="p">)</span>
			<span class="n">to_free</span> <span class="o">+=</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">dropped</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">to_free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_block_rsv_release</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">to_free</span><span class="p">);</span>
			<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
						      <span class="s">&quot;delalloc&quot;</span><span class="p">,</span>
						      <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
						      <span class="n">to_free</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extra_reserve</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_DELALLOC_META_RESERVED</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>
		<span class="n">nr_extents</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_extents</span> <span class="o">+=</span> <span class="n">nr_extents</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">to_reserve</span><span class="p">)</span>
		<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span><span class="s">&quot;delalloc&quot;</span><span class="p">,</span>
					      <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">to_reserve</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">block_rsv_add_bytes</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">,</span> <span class="n">to_reserve</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * btrfs_delalloc_release_metadata - release a metadata reservation for an inode</span>
<span class="cm"> * @inode: the inode to release the reservation for</span>
<span class="cm"> * @num_bytes: the number of bytes we&#39;re releasing</span>
<span class="cm"> *</span>
<span class="cm"> * This will release the metadata reservation for an inode.  This can be called</span>
<span class="cm"> * once we complete IO for a given set of bytes to release their metadata</span>
<span class="cm"> * reservations.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_delalloc_release_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">to_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">dropped</span><span class="p">;</span>

	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">dropped</span> <span class="o">=</span> <span class="n">drop_outstanding_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">to_free</span> <span class="o">=</span> <span class="n">calc_csum_metadata_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dropped</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">to_free</span> <span class="o">+=</span> <span class="n">btrfs_calc_trans_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">dropped</span><span class="p">);</span>

	<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="s">&quot;delalloc&quot;</span><span class="p">,</span>
				      <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">to_free</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_block_rsv_release</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">,</span>
				<span class="n">to_free</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * btrfs_delalloc_reserve_space - reserve data and metadata space for delalloc</span>
<span class="cm"> * @inode: inode we&#39;re writing to</span>
<span class="cm"> * @num_bytes: the number of bytes we want to allocate</span>
<span class="cm"> *</span>
<span class="cm"> * This will do the following things</span>
<span class="cm"> *</span>
<span class="cm"> * o reserve space in the data space info for num_bytes</span>
<span class="cm"> * o reserve space in the metadata space info based on number of outstanding</span>
<span class="cm"> *   extents and how much csums will be needed</span>
<span class="cm"> * o add to the inodes -&gt;delalloc_bytes</span>
<span class="cm"> * o add it to the fs_info&#39;s delalloc inodes list.</span>
<span class="cm"> *</span>
<span class="cm"> * This will return 0 for success and -ENOSPC if there is no space left.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_delalloc_reserve_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_check_data_free_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delalloc_reserve_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_reserved_data_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * btrfs_delalloc_release_space - release data and metadata space for delalloc</span>
<span class="cm"> * @inode: inode we&#39;re releasing space for</span>
<span class="cm"> * @num_bytes: the number of bytes we want to free up</span>
<span class="cm"> *</span>
<span class="cm"> * This must be matched with a call to btrfs_delalloc_reserve_space.  This is</span>
<span class="cm"> * called in the case that we don&#39;t need the metadata AND data reservations</span>
<span class="cm"> * anymore.  So if there is an error or we insert an inline extent.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will release the metadata space that was not used and will</span>
<span class="cm"> * decrement -&gt;delalloc_bytes and remove it from the fs_info delalloc_inodes</span>
<span class="cm"> * list if there are no delalloc bytes left.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_delalloc_release_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">btrfs_delalloc_release_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="n">btrfs_free_reserved_data_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">update_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">alloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">old_val</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">byte_in_group</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>

	<span class="cm">/* block accounting for super block */</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
	<span class="n">old_val</span> <span class="o">=</span> <span class="n">btrfs_super_bytes_used</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span>
		<span class="n">old_val</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">old_val</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">btrfs_set_super_bytes_used</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">,</span> <span class="n">old_val</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">total</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_DUP</span> <span class="o">|</span>
				    <span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
				    <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">))</span>
			<span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * If this block group has free space cache written out, we</span>
<span class="cm">		 * need to make sure to load it if we are removing space.  This</span>
<span class="cm">		 * is because we need the unpinning stage to actually add the</span>
<span class="cm">		 * space back to the block group, otherwise we will leak space.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">alloc</span> <span class="o">&amp;&amp;</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">==</span> <span class="n">BTRFS_CACHE_NO</span><span class="p">)</span>
			<span class="n">cache_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">byte_in_group</span> <span class="o">=</span> <span class="n">bytenr</span> <span class="o">-</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">byte_in_group</span> <span class="o">&gt;</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">SPACE_CACHE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">&lt;</span> <span class="n">BTRFS_DC_CLEAR</span><span class="p">)</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">=</span> <span class="n">BTRFS_DC_CLEAR</span><span class="p">;</span>

		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">dirty</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">old_val</span> <span class="o">=</span> <span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">total</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">byte_in_group</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">alloc</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">old_val</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">btrfs_set_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">old_val</span><span class="p">);</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">disk_used</span> <span class="o">+=</span> <span class="n">num_bytes</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">old_val</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">btrfs_set_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">old_val</span><span class="p">);</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">disk_used</span> <span class="o">-=</span> <span class="n">num_bytes</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

			<span class="n">set_extent_dirty</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">pinned_extents</span><span class="p">,</span>
					 <span class="n">bytenr</span><span class="p">,</span> <span class="n">bytenr</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					 <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_NOFAIL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
		<span class="n">total</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">bytenr</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">first_logical_byte</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">search_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">search_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bytenr</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">bytenr</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">pin_down_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">set_extent_dirty</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">pinned_extents</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
			 <span class="n">bytenr</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_NOFAIL</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this function must be called within transaction</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_pin_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		     <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserved</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">);</span> <span class="cm">/* Logic error */</span>

	<span class="n">pin_down_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">reserved</span><span class="p">);</span>

	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this function must be called within transaction</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_pin_extent_for_log_replay</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				    <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">);</span> <span class="cm">/* Logic error */</span>

	<span class="cm">/*</span>
<span class="cm">	 * pull in the free space cache (if any) so that our pin</span>
<span class="cm">	 * removes the free space from the cache.  We have load_only set</span>
<span class="cm">	 * to one because the slow code to read in the free extents does check</span>
<span class="cm">	 * the pinned extents.</span>
<span class="cm">	 */</span>
	<span class="n">cache_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">pin_down_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/* remove us from the free space cache (if we&#39;re there at all) */</span>
	<span class="n">btrfs_remove_free_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * btrfs_update_reserved_bytes - update the block_group and space info counters</span>
<span class="cm"> * @cache:	The cache we are manipulating</span>
<span class="cm"> * @num_bytes:	The number of bytes in question</span>
<span class="cm"> * @reserve:	One of the reservation enums</span>
<span class="cm"> *</span>
<span class="cm"> * This is called by the allocator when it reserves space, or by somebody who is</span>
<span class="cm"> * freeing space that was never actually used on disk.  For example if you</span>
<span class="cm"> * reserve some space for a new leaf in transaction A and before transaction A</span>
<span class="cm"> * commits you free that leaf, you call this with reserve set to 0 in order to</span>
<span class="cm"> * clear the reservation.</span>
<span class="cm"> *</span>
<span class="cm"> * Metadata reservations should be called with RESERVE_ALLOC so we do the proper</span>
<span class="cm"> * ENOSPC accounting.  For data we handle the reservation through clearing the</span>
<span class="cm"> * delalloc bits in the io_tree.  We have to do this since we could end up</span>
<span class="cm"> * allocating less disk space for the amount of data we have reserved in the</span>
<span class="cm"> * case of compression.</span>
<span class="cm"> *</span>
<span class="cm"> * If this is a reservation and the block group has become read only we cannot</span>
<span class="cm"> * make the reservation and return -EAGAIN, otherwise this function always</span>
<span class="cm"> * succeeds.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_update_reserved_bytes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reserve</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span> <span class="o">!=</span> <span class="n">RESERVE_FREE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span> <span class="o">==</span> <span class="n">RESERVE_ALLOC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">trace_btrfs_space_reservation</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
						<span class="s">&quot;space_info&quot;</span><span class="p">,</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
						<span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span>
			<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">reservation_progress</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_prepare_extent_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">caching_block_groups</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">block_group</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_group_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span> <span class="o">=</span> <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">pinned_extents</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">pinned_extents</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">pinned_extents</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>

	<span class="n">update_global_block_rsv</span><span class="p">(</span><span class="n">fs_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">unpin_extent_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span> <span class="o">||</span>
		    <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span>
				<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
			<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">);</span> <span class="cm">/* Logic error */</span>
		<span class="p">}</span>

		<span class="n">len</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
			<span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">start</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_finish_extent_commit</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">unpin</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">aborted</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">pinned_extents</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
		<span class="n">unpin</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">else</span>
		<span class="n">unpin</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">freed_extents</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_first_extent_bit</span><span class="p">(</span><span class="n">unpin</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span>
					    <span class="n">EXTENT_DIRTY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">DISCARD</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_discard_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
						   <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

		<span class="n">clear_extent_dirty</span><span class="p">(</span><span class="n">unpin</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">unpin_extent_range</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_free_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner_objectid</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">owner_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">refs_to_drop</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extent_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_extent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_to_del</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">is_data</span> <span class="o">=</span> <span class="n">owner_objectid</span> <span class="o">&gt;=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">is_data</span> <span class="o">&amp;&amp;</span> <span class="n">refs_to_drop</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">lookup_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iref</span><span class="p">,</span>
				    <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
				    <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner_objectid</span><span class="p">,</span>
				    <span class="n">owner_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extent_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">extent_slot</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
					      <span class="n">extent_slot</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">bytenr</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span> <span class="o">&amp;&amp;</span>
			    <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="n">num_bytes</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">found_extent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">extent_slot</span> <span class="o">&gt;</span> <span class="mi">5</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">extent_slot</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
		<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">extent_slot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_extent</span> <span class="o">&amp;&amp;</span> <span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">))</span>
			<span class="n">found_extent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found_extent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">iref</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						    <span class="nb">NULL</span><span class="p">,</span> <span class="n">refs_to_drop</span><span class="p">,</span>
						    <span class="n">is_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

			<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;umm, got %d back from search&quot;</span>
				       <span class="s">&quot;, was looking for %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">extent_root</span><span class="p">,</span>
							 <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
			<span class="n">extent_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs unable to find ref byte nr %llu &quot;</span>
		       <span class="s">&quot;parent %llu root %llu  owner %llu offset %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">parent</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">root_objectid</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">owner_objectid</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">owner_offset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_slot</span><span class="p">);</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">found_extent</span> <span class="o">||</span> <span class="n">extent_slot</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">convert_extent_item_v0</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					     <span class="n">owner_objectid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>

		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					<span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;umm, got %d back from search&quot;</span>
			       <span class="s">&quot;, was looking for %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">);</span>
			<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="n">extent_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_slot</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">));</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_slot</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">owner_objectid</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bi</span><span class="p">));</span>
		<span class="n">bi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">owner_objectid</span> <span class="o">!=</span> <span class="n">btrfs_tree_block_level</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">bi</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">refs</span> <span class="o">=</span> <span class="n">btrfs_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">refs</span> <span class="o">&lt;</span> <span class="n">refs_to_drop</span><span class="p">);</span>
	<span class="n">refs</span> <span class="o">-=</span> <span class="n">refs_to_drop</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span><span class="p">)</span>
			<span class="n">__run_delayed_extent_op</span><span class="p">(</span><span class="n">extent_op</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * In the case of inline back ref, reference count will</span>
<span class="cm">		 * be updated by remove_extent_backref</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">iref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">found_extent</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">btrfs_set_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">refs</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_extent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">remove_extent_backref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						    <span class="n">iref</span><span class="p">,</span> <span class="n">refs_to_drop</span><span class="p">,</span>
						    <span class="n">is_data</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_extent</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">is_data</span> <span class="o">&amp;&amp;</span> <span class="n">refs_to_drop</span> <span class="o">!=</span>
			       <span class="n">extent_data_ref_count</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">iref</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iref</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">extent_slot</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">extent_slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">extent_slot</span><span class="p">;</span>
				<span class="n">num_to_del</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				      <span class="n">num_to_del</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_csums</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_block_group</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">abort</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">abort:</span>
	<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * when we free an block, it is possible (and likely) that we free the last</span>
<span class="cm"> * delayed ref for that extent as well.  This searches the delayed ref tree for</span>
<span class="cm"> * a given extent, and if there are no other delayed refs to be processed, it</span>
<span class="cm"> * removes it from the tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">check_ref_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">delayed_refs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">delayed_refs</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">head</span> <span class="o">=</span> <span class="n">btrfs_find_delayed_ref_head</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

	<span class="cm">/* there are still entries for this ref, we can&#39;t drop it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">bytenr</span> <span class="o">==</span> <span class="n">bytenr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">must_insert_reserved</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span><span class="p">);</span>
		<span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * waiting for the lock here would deadlock.  If someone else has it</span>
<span class="cm">	 * locked they are already in the process of dropping it anyway</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * at this point we have a head with no other entries.  Go</span>
<span class="cm">	 * ahead and process it.</span>
<span class="cm">	 */</span>
	<span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">in_tree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>

	<span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_entries</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">seq_wait</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">seq_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t take a ref on the node because we&#39;re removing it from the</span>
<span class="cm">	 * tree, so we just steal the ref the tree was holding.</span>
<span class="cm">	 */</span>
	<span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_heads</span><span class="o">--</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">cluster</span><span class="p">))</span>
		<span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">num_heads_ready</span><span class="o">--</span><span class="p">;</span>

	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">cluster</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">must_insert_reserved</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">btrfs_put_delayed_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_free_tree_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">last_ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_tree_ref</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
					<span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					<span class="n">parent</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">buf</span><span class="p">),</span>
					<span class="n">BTRFS_DROP_DELAYED_REF</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_ref</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">check_ref_cleanup</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_flag</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_WRITTEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">pin_down_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_BUFFER_DIRTY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bflags</span><span class="p">));</span>

		<span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">btrfs_update_reserved_bytes</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">RESERVE_FREE</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * Deleting the buffer, clear the corrupt flag since it doesn&#39;t matter</span>
<span class="cm">	 * anymore.</span>
<span class="cm">	 */</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">EXTENT_BUFFER_CORRUPT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bflags</span><span class="p">);</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Can return -ENOMEM */</span>
<span class="kt">int</span> <span class="nf">btrfs_free_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		      <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
		      <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">for_cow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * tree log blocks never actually go into the extent allocation</span>
<span class="cm">	 * tree, just update pinning info and exit early.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root_objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">owner</span> <span class="o">&gt;=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">);</span>
		<span class="cm">/* unlocks the pinned mutex */</span>
		<span class="n">btrfs_pin_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">owner</span> <span class="o">&lt;</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_tree_ref</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
					<span class="n">num_bytes</span><span class="p">,</span>
					<span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">owner</span><span class="p">,</span>
					<span class="n">BTRFS_DROP_DELAYED_REF</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">for_cow</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_data_ref</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
						<span class="n">num_bytes</span><span class="p">,</span>
						<span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span>
						<span class="n">offset</span><span class="p">,</span> <span class="n">BTRFS_DROP_DELAYED_REF</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">,</span> <span class="n">for_cow</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">stripe_align</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">val</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">stripesize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">ret</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * when we wait for progress in the block group caching, its because</span>
<span class="cm"> * our allocation attempt failed at least once.  So, we must sleep</span>
<span class="cm"> * and let some progress happen before we try again.</span>
<span class="cm"> *</span>
<span class="cm"> * This function will sleep at least once waiting for new free space to</span>
<span class="cm"> * show up, and then it will check the block group free space numbers</span>
<span class="cm"> * for our min num_bytes.  Another option is to have it go ahead</span>
<span class="cm"> * and look in the rbtree for a free extent of a given size, but this</span>
<span class="cm"> * is a good start.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">wait_block_group_cache_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">caching_ctl</span> <span class="o">=</span> <span class="n">get_caching_control</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">caching_ctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">block_group_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="o">||</span>
		   <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="o">-&gt;</span><span class="n">free_space</span> <span class="o">&gt;=</span> <span class="n">num_bytes</span><span class="p">));</span>

	<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">wait_block_group_cache_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="n">DEFINE_WAIT</span><span class="p">(</span><span class="n">wait</span><span class="p">);</span>

	<span class="n">caching_ctl</span> <span class="o">=</span> <span class="n">get_caching_control</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">caching_ctl</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">block_group_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">));</span>

	<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__get_block_group_index</span><span class="p">(</span><span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID1</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID0</span><span class="p">)</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">index</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">get_block_group_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__get_block_group_index</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">btrfs_loop_type</span> <span class="p">{</span>
	<span class="n">LOOP_CACHING_NOWAIT</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
	<span class="n">LOOP_CACHING_WAIT</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">LOOP_ALLOC_CHUNK</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
	<span class="n">LOOP_NO_EMPTY_SIZE</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * walks the btree of allocated extents and find a hole of a given size.</span>
<span class="cm"> * The key ins is changed to record the hole:</span>
<span class="cm"> * ins-&gt;objectid == block start</span>
<span class="cm"> * ins-&gt;flags = BTRFS_EXTENT_ITEM_KEY</span>
<span class="cm"> * ins-&gt;offset == number of blocks</span>
<span class="cm"> * Any available blocks before search_start are skipped.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">find_free_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">orig_root</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">empty_size</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">hint_byte</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">orig_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_free_cluster</span> <span class="o">*</span><span class="n">last_ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">used_block_group</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">search_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty_cluster</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">allowed_chunk_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done_chunk_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">loop</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">)</span> <span class="o">?</span>
		<span class="n">RESERVE_ALLOC_NO_ACCOUNT</span> <span class="o">:</span> <span class="n">RESERVE_ALLOC</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">found_uncached_bg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">failed_cluster_refill</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">failed_alloc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">use_cluster</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">have_caching_bg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="n">ins</span><span class="p">,</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">);</span>
	<span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trace_find_free_extent</span><span class="p">(</span><span class="n">orig_root</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">empty_size</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="n">space_info</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">space_info</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;No space info for %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the space info is for both data and metadata it means we have a</span>
<span class="cm">	 * small filesystem and we can&#39;t use the clustering stuff.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_mixed_space_info</span><span class="p">(</span><span class="n">space_info</span><span class="p">))</span>
		<span class="n">use_cluster</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">orig_root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">||</span> <span class="n">empty_size</span><span class="p">)</span>
		<span class="n">allowed_chunk_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span> <span class="o">&amp;&amp;</span> <span class="n">use_cluster</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">last_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">meta_alloc_cluster</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">SSD</span><span class="p">))</span>
			<span class="n">empty_cluster</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">use_cluster</span> <span class="o">&amp;&amp;</span>
	    <span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">SSD</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">last_ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">data_alloc_cluster</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">last_ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">block_group</span><span class="p">)</span>
			<span class="n">hint_byte</span> <span class="o">=</span> <span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">window_start</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">search_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">search_start</span><span class="p">,</span> <span class="n">first_logical_byte</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="n">search_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">search_start</span><span class="p">,</span> <span class="n">hint_byte</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">last_ptr</span><span class="p">)</span>
		<span class="n">empty_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">search_start</span> <span class="o">==</span> <span class="n">hint_byte</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_group</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
						       <span class="n">search_start</span><span class="p">);</span>
		<span class="n">used_block_group</span> <span class="o">=</span> <span class="n">block_group</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * we don&#39;t want to use the block group if it doesn&#39;t match our</span>
<span class="cm">		 * allocation bits, or if its not cached.</span>
<span class="cm">		 *</span>
<span class="cm">		 * However if we are re-searching with an ideal block group</span>
<span class="cm">		 * picked out then we don&#39;t care that the block group is cached.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span> <span class="o">&amp;&amp;</span> <span class="n">block_group_bits</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">!=</span> <span class="n">BTRFS_CACHE_NO</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * someone is removing this block group,</span>
<span class="cm">				 * we can&#39;t jump into the have_block_group</span>
<span class="cm">				 * target because our list pointers are not</span>
<span class="cm">				 * valid</span>
<span class="cm">				 */</span>
				<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
				<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">index</span> <span class="o">=</span> <span class="n">get_block_group_index</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">have_block_group</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">search:</span>
	<span class="n">have_caching_bg</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">index</span><span class="p">],</span>
			    <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">cached</span><span class="p">;</span>

		<span class="n">used_block_group</span> <span class="o">=</span> <span class="n">block_group</span><span class="p">;</span>
		<span class="n">btrfs_get_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
		<span class="n">search_start</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * this can happen if we end up cycling through all the</span>
<span class="cm">		 * raid types, but we want to make sure we only allocate</span>
<span class="cm">		 * for the proper type.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_group_bits</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		    <span class="n">u64</span> <span class="n">extra</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span> <span class="o">|</span>
				<span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
				<span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * if they asked for extra copies and this block group</span>
<span class="cm">			 * doesn&#39;t provide them, bail.  This does allow us to</span>
<span class="cm">			 * fill raid0 from raid1.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">data</span> <span class="o">&amp;</span> <span class="n">extra</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">extra</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">have_block_group:</span>
		<span class="n">cached</span> <span class="o">=</span> <span class="n">block_group_cache_done</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="o">!</span><span class="n">cached</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">found_uncached_bg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cache_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
						<span class="n">orig_root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Ok we want to try and use the cluster allocator, so</span>
<span class="cm">		 * lets look there</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_ptr</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * the refill lock keeps out other</span>
<span class="cm">			 * people trying to start a new cluster</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
			<span class="n">used_block_group</span> <span class="o">=</span> <span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">block_group</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">used_block_group</span> <span class="o">!=</span> <span class="n">block_group</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="o">!</span><span class="n">used_block_group</span> <span class="o">||</span>
			     <span class="n">used_block_group</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">||</span>
			     <span class="o">!</span><span class="n">block_group_bits</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">,</span> <span class="n">data</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">used_block_group</span> <span class="o">=</span> <span class="n">block_group</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">refill_cluster</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">used_block_group</span> <span class="o">!=</span> <span class="n">block_group</span><span class="p">)</span>
				<span class="n">btrfs_get_block_group</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">);</span>

			<span class="n">offset</span> <span class="o">=</span> <span class="n">btrfs_alloc_from_cluster</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">,</span>
			  <span class="n">last_ptr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">used_block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* we have a block, we&#39;re done */</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
				<span class="n">trace_btrfs_reserve_extent_cluster</span><span class="p">(</span><span class="n">root</span><span class="p">,</span>
					<span class="n">block_group</span><span class="p">,</span> <span class="n">search_start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">block_group</span> <span class="o">!=</span> <span class="n">used_block_group</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">used_block_group</span> <span class="o">!=</span> <span class="n">block_group</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">);</span>
				<span class="n">used_block_group</span> <span class="o">=</span> <span class="n">block_group</span><span class="p">;</span>
			<span class="p">}</span>
<span class="nl">refill_cluster:</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">used_block_group</span> <span class="o">!=</span> <span class="n">block_group</span><span class="p">);</span>
			<span class="cm">/* If we are on LOOP_NO_EMPTY_SIZE, we can&#39;t</span>
<span class="cm">			 * set up a new clusters, so lets just skip it</span>
<span class="cm">			 * and let the allocator find whatever block</span>
<span class="cm">			 * it can find.  If we reach this point, we</span>
<span class="cm">			 * will have tried the cluster allocator</span>
<span class="cm">			 * plenty of times and not have found</span>
<span class="cm">			 * anything, so we are likely way too</span>
<span class="cm">			 * fragmented for the clustering stuff to find</span>
<span class="cm">			 * anything.</span>
<span class="cm">			 *</span>
<span class="cm">			 * However, if the cluster is taken from the</span>
<span class="cm">			 * current block group, release the cluster</span>
<span class="cm">			 * first, so that we stand a better chance of</span>
<span class="cm">			 * succeeding in the unclustered</span>
<span class="cm">			 * allocation.  */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">&gt;=</span> <span class="n">LOOP_NO_EMPTY_SIZE</span> <span class="o">&amp;&amp;</span>
			    <span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">block_group</span> <span class="o">!=</span> <span class="n">block_group</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">unclustered_alloc</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * this cluster didn&#39;t work out, free it and</span>
<span class="cm">			 * start over</span>
<span class="cm">			 */</span>
			<span class="n">btrfs_return_cluster_to_free_space</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">last_ptr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">&gt;=</span> <span class="n">LOOP_NO_EMPTY_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">unclustered_alloc</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* allocate a cluster in this block group */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_find_space_cluster</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					       <span class="n">block_group</span><span class="p">,</span> <span class="n">last_ptr</span><span class="p">,</span>
					       <span class="n">search_start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
					       <span class="n">empty_cluster</span> <span class="o">+</span> <span class="n">empty_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * now pull our allocation out of this</span>
<span class="cm">				 * cluster</span>
<span class="cm">				 */</span>
				<span class="n">offset</span> <span class="o">=</span> <span class="n">btrfs_alloc_from_cluster</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span>
						  <span class="n">last_ptr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
						  <span class="n">search_start</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
					<span class="cm">/* we found one, proceed */</span>
					<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
					<span class="n">trace_btrfs_reserve_extent_cluster</span><span class="p">(</span><span class="n">root</span><span class="p">,</span>
						<span class="n">block_group</span><span class="p">,</span> <span class="n">search_start</span><span class="p">,</span>
						<span class="n">num_bytes</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">checks</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cached</span> <span class="o">&amp;&amp;</span> <span class="n">loop</span> <span class="o">&gt;</span> <span class="n">LOOP_CACHING_NOWAIT</span>
				   <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">failed_cluster_refill</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>

				<span class="n">failed_cluster_refill</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
				<span class="n">wait_block_group_cache_progress</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span>
				       <span class="n">num_bytes</span> <span class="o">+</span> <span class="n">empty_cluster</span> <span class="o">+</span> <span class="n">empty_size</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">have_block_group</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * at this point we either didn&#39;t find a cluster</span>
<span class="cm">			 * or we weren&#39;t able to allocate a block from our</span>
<span class="cm">			 * cluster.  Free the cluster we&#39;ve been trying</span>
<span class="cm">			 * to use, and go to the next block group</span>
<span class="cm">			 */</span>
			<span class="n">btrfs_return_cluster_to_free_space</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">last_ptr</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">last_ptr</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>

<span class="nl">unclustered_alloc:</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cached</span> <span class="o">&amp;&amp;</span>
		    <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="o">-&gt;</span><span class="n">free_space</span> <span class="o">&lt;</span>
		    <span class="n">num_bytes</span> <span class="o">+</span> <span class="n">empty_cluster</span> <span class="o">+</span> <span class="n">empty_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="o">-&gt;</span><span class="n">tree_lock</span><span class="p">);</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">btrfs_find_space_for_alloc</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">search_start</span><span class="p">,</span>
						    <span class="n">num_bytes</span><span class="p">,</span> <span class="n">empty_size</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we didn&#39;t find a chunk, and we haven&#39;t failed on this</span>
<span class="cm">		 * block group before, and this block group is in the middle of</span>
<span class="cm">		 * caching and we are ok with waiting, then go ahead and wait</span>
<span class="cm">		 * for progress to be made, and set failed_alloc to true.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If failed_alloc is true then we&#39;ve already waited on this</span>
<span class="cm">		 * block group once and should move on to the next block group.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">failed_alloc</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">cached</span> <span class="o">&amp;&amp;</span>
		    <span class="n">loop</span> <span class="o">&gt;</span> <span class="n">LOOP_CACHING_NOWAIT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_block_group_cache_progress</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span>
						<span class="n">num_bytes</span> <span class="o">+</span> <span class="n">empty_size</span><span class="p">);</span>
			<span class="n">failed_alloc</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">have_block_group</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cached</span><span class="p">)</span>
				<span class="n">have_caching_bg</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">checks:</span>
		<span class="n">search_start</span> <span class="o">=</span> <span class="n">stripe_align</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>

		<span class="cm">/* move on to the next group */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_start</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">&gt;</span>
		    <span class="n">used_block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">used_block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">search_start</span><span class="p">)</span>
			<span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					     <span class="n">search_start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">search_start</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_reserved_bytes</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
						  <span class="n">alloc_type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">loop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we are all good, lets return */</span>
		<span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">search_start</span><span class="p">;</span>
		<span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>

		<span class="n">trace_btrfs_reserve_extent</span><span class="p">(</span><span class="n">orig_root</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span>
					   <span class="n">search_start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">search_start</span><span class="p">)</span>
			<span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					     <span class="n">search_start</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">search_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used_block_group</span> <span class="o">!=</span> <span class="n">block_group</span><span class="p">)</span>
			<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">);</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
<span class="nl">loop:</span>
		<span class="n">failed_cluster_refill</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">failed_alloc</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">!=</span> <span class="n">get_block_group_index</span><span class="p">(</span><span class="n">block_group</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used_block_group</span> <span class="o">!=</span> <span class="n">block_group</span><span class="p">)</span>
			<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">used_block_group</span><span class="p">);</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&amp;&amp;</span> <span class="n">loop</span> <span class="o">&gt;=</span> <span class="n">LOOP_CACHING_WAIT</span> <span class="o">&amp;&amp;</span> <span class="n">have_caching_bg</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">search</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&amp;&amp;</span> <span class="o">++</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">BTRFS_NR_RAID_TYPES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">search</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * LOOP_CACHING_NOWAIT, search partially cached block groups, kicking</span>
<span class="cm">	 *			caching kthreads as we move along</span>
<span class="cm">	 * LOOP_CACHING_WAIT, search everything, and wait if our bg is caching</span>
<span class="cm">	 * LOOP_ALLOC_CHUNK, force a chunk allocation and try again</span>
<span class="cm">	 * LOOP_NO_EMPTY_SIZE, set empty_size and empty_cluster to 0 and try</span>
<span class="cm">	 *			again</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&amp;&amp;</span> <span class="n">loop</span> <span class="o">&lt;</span> <span class="n">LOOP_NO_EMPTY_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">loop</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">==</span> <span class="n">LOOP_ALLOC_CHUNK</span><span class="p">)</span> <span class="p">{</span>
		       <span class="k">if</span> <span class="p">(</span><span class="n">allowed_chunk_alloc</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_bytes</span> <span class="o">+</span>
						     <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
						     <span class="n">CHUNK_ALLOC_LIMITED</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
								<span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">allowed_chunk_alloc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
					<span class="n">done_chunk_alloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_chunk_alloc</span> <span class="o">&amp;&amp;</span>
				   <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">force_alloc</span> <span class="o">==</span>
				   <span class="n">CHUNK_ALLOC_NO_FORCE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">space_info</span><span class="o">-&gt;</span><span class="n">force_alloc</span> <span class="o">=</span> <span class="n">CHUNK_ALLOC_LIMITED</span><span class="p">;</span>
			<span class="p">}</span>

		       <span class="cm">/*</span>
<span class="cm">			* We didn&#39;t allocate a chunk, go ahead and drop the</span>
<span class="cm">			* empty size and loop again.</span>
<span class="cm">			*/</span>
		       <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">done_chunk_alloc</span><span class="p">)</span>
			       <span class="n">loop</span> <span class="o">=</span> <span class="n">LOOP_NO_EMPTY_SIZE</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">loop</span> <span class="o">==</span> <span class="n">LOOP_NO_EMPTY_SIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">empty_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">empty_cluster</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">goto</span> <span class="n">search</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dump_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytes</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">dump_block_groups</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;space_info %llu has %llu free, is %sfull</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">-</span>
				    <span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">-</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">-</span>
				    <span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span><span class="p">),</span>
	       <span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">)</span> <span class="o">?</span> <span class="s">&quot;&quot;</span> <span class="o">:</span> <span class="s">&quot;not &quot;</span><span class="p">);</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;space_info total=%llu, used=%llu, pinned=%llu, &quot;</span>
	       <span class="s">&quot;reserved=%llu, may_use=%llu, readonly=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_used</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dump_block_groups</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">index</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;block group %llu has %llu bytes, %llu used &quot;</span>
		       <span class="s">&quot;%llu pinned %llu reserved</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span><span class="p">);</span>
		<span class="n">btrfs_dump_free_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">bytes</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">BTRFS_NR_RAID_TYPES</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_reserve_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_alloc_size</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">empty_size</span><span class="p">,</span> <span class="n">u64</span> <span class="n">hint_byte</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">,</span> <span class="n">u64</span> <span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">bool</span> <span class="n">final_tried</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">data</span> <span class="o">=</span> <span class="n">btrfs_get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * the only place that sets empty_size is btrfs_realloc_node, which</span>
<span class="cm">	 * is not called recursively on allocations</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty_size</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
				     <span class="n">num_bytes</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span>
				     <span class="n">CHUNK_ALLOC_NO_FORCE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">empty_size</span><span class="p">,</span>
			       <span class="n">hint_byte</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">final_tried</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">num_bytes</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">num_bytes</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">num_bytes</span><span class="p">,</span> <span class="n">min_alloc_size</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
				       <span class="n">num_bytes</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">CHUNK_ALLOC_FORCE</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">==</span> <span class="n">min_alloc_size</span><span class="p">)</span>
				<span class="n">final_tried</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ENOSPC_DEBUG</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">;</span>

			<span class="n">sinfo</span> <span class="o">=</span> <span class="n">__find_space_info</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">data</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs allocation failed flags %llu, &quot;</span>
			       <span class="s">&quot;wanted %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">data</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">num_bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="p">)</span>
				<span class="n">dump_space_info</span><span class="p">(</span><span class="n">sinfo</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">trace_btrfs_reserved_extent_alloc</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_free_reserved_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Unable to find block group for %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">DISCARD</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_discard_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">pin</span><span class="p">)</span>
		<span class="n">pin_down_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_add_free_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">btrfs_update_reserved_bytes</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">RESERVE_FREE</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="n">trace_btrfs_reserved_extent_free</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_free_reserved_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_free_reserved_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_free_and_pin_reserved_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_free_reserved_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_reserved_file_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ref_mod</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">extent_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span><span class="p">;</span>

	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">extent_item</span><span class="p">)</span> <span class="o">+</span> <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				      <span class="n">ins</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">extent_item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				     <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_item</span><span class="p">,</span> <span class="n">ref_mod</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_item</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_item</span><span class="p">,</span>
			       <span class="n">flags</span> <span class="o">|</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">);</span>

	<span class="n">iref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">extent_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">iref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
		<span class="n">btrfs_set_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">ref_mod</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">iref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">owner</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">ref_mod</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_block_group</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* -ENOENT, logic error */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs update block group failed for %llu &quot;</span>
		       <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">alloc_reserved_tree_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">extent_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="n">block_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">extent_item</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">block_info</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iref</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				      <span class="n">ins</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">extent_item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				     <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_refs</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_item</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_item</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent_item</span><span class="p">,</span>
			       <span class="n">flags</span> <span class="o">|</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">);</span>
	<span class="n">block_info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">extent_item</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">btrfs_set_tree_block_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">block_info</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>
	<span class="n">btrfs_set_tree_block_level</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">block_info</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="n">iref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">block_info</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">));</span>
		<span class="n">btrfs_set_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span>
						 <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_set_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span>
						 <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span><span class="p">);</span>
		<span class="n">btrfs_set_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_block_group</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* -ENOENT, logic error */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs update block group failed for %llu &quot;</span>
		       <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_alloc_reserved_file_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root_objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_data_ref</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span>
					 <span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					 <span class="n">root_objectid</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					 <span class="n">BTRFS_ADD_DELAYED_EXTENT</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is used by the tree logging recovery code.  It records that</span>
<span class="cm"> * an extent has been allocated and makes sure to clear the free</span>
<span class="cm"> * space cache bits as well</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_alloc_logged_file_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">owner</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>

	<span class="n">block_group</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">);</span>
	<span class="n">cache_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">caching_ctl</span> <span class="o">=</span> <span class="n">get_caching_control</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">caching_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">block_group_cache_done</span><span class="p">(</span><span class="n">block_group</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_remove_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_excluded_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">&lt;=</span> <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_remove_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span>
						      <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_remove_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span>
						      <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

			<span class="n">start</span> <span class="o">=</span> <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span><span class="p">;</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">-</span>
				    <span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">progress</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_excluded_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="p">}</span>

		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
		<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_reserved_bytes</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">ins</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
					  <span class="n">RESERVE_ALLOC_NO_ACCOUNT</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* logic error */</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">alloc_reserved_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
					 <span class="mi">0</span><span class="p">,</span> <span class="n">owner</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="nf">btrfs_init_new_buffer</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					    <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">blocksize</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">btrfs_find_create_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_buffer_lockdep_class</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
	<span class="n">clear_bit</span><span class="p">(</span><span class="n">EXTENT_BUFFER_STALE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">buf</span><span class="o">-&gt;</span><span class="n">bflags</span><span class="p">);</span>

	<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">btrfs_set_buffer_uptodate</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we allow two log transactions at a time, use different</span>
<span class="cm">		 * EXENT bit to differentiate dirty pages.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">log_transid</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">set_extent_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dirty_log_pages</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					<span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">set_extent_new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dirty_log_pages</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					<span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">set_extent_dirty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">dirty_pages</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
			 <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="o">++</span><span class="p">;</span>
	<span class="cm">/* this returns a buffer locked for blocking */</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span>
<span class="nf">use_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
	      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u32</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">global_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">block_rsv</span> <span class="o">=</span> <span class="n">get_block_rsv</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_metadata_bytes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we couldn&#39;t reserve metadata bytes try and use some from</span>
<span class="cm">		 * the global reserve.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">block_rsv</span> <span class="o">!=</span> <span class="n">global_rsv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">block_rsv_use_bytes</span><span class="p">(</span><span class="n">global_rsv</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">global_rsv</span><span class="p">;</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="n">block_rsv</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">block_rsv_use_bytes</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">block_rsv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">static</span> <span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">_rs</span><span class="p">,</span>
				<span class="n">DEFAULT_RATELIMIT_INTERVAL</span><span class="p">,</span>
				<span class="cm">/*DEFAULT_RATELIMIT_BURST*/</span> <span class="mi">2</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_rs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_DEBUG</span> <span class="s">&quot;btrfs: block rsv returned %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">reserve_metadata_bytes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">block_rsv</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">block_rsv</span> <span class="o">!=</span> <span class="n">global_rsv</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">block_rsv_use_bytes</span><span class="p">(</span><span class="n">global_rsv</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">global_rsv</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">unuse_block_rsv</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">block_rsv_add_bytes</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">block_rsv_release_bytes</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * finds a free extent and does all the dirty work required for allocation</span>
<span class="cm"> * returns the key for the extent through ins, and a tree buffer for</span>
<span class="cm"> * the first block of the extent through buf.</span>
<span class="cm"> *</span>
<span class="cm"> * returns the tree buffer or NULL.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="nf">btrfs_alloc_free_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u32</span> <span class="n">blocksize</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_objectid</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">hint</span><span class="p">,</span> <span class="n">u64</span> <span class="n">empty_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>


	<span class="n">block_rsv</span> <span class="o">=</span> <span class="n">use_block_rsv</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">block_rsv</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_reserve_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span>
				   <span class="n">empty_size</span><span class="p">,</span> <span class="n">hint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unuse_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">btrfs_init_new_buffer</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				    <span class="n">blocksize</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">buf</span><span class="p">));</span> <span class="cm">/* -ENOMEM */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">parent</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_objectid</span> <span class="o">!=</span> <span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span><span class="p">;</span>
		<span class="n">extent_op</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">extent_op</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">extent_op</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="k">else</span>
			<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">));</span>
		<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">flags_to_set</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_key</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_flags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">is_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_delayed_tree_ref</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span>
					<span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
					<span class="n">level</span><span class="p">,</span> <span class="n">BTRFS_ADD_DELAYED_EXTENT</span><span class="p">,</span>
					<span class="n">extent_op</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">walk_control</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">[</span><span class="n">BTRFS_MAX_LEVEL</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">[</span><span class="n">BTRFS_MAX_LEVEL</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">update_progress</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">stage</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">shared_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">update_ref</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">keep_locks</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reada_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reada_count</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">for_reloc</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DROP_REFERENCE	1</span>
<span class="cp">#define UPDATE_BACKREF	2</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">reada_walk_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">*</span> <span class="mi">3</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span><span class="p">,</span>
					<span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">];</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">];</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">slot</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nread</span> <span class="o">&gt;=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">])</span>
			<span class="k">goto</span> <span class="n">reada</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">UPDATE_BACKREF</span> <span class="o">&amp;&amp;</span>
		    <span class="n">generation</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* We don&#39;t lock the tree block, it&#39;s OK to be racy here */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_extent_info</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">refs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="cm">/* We don&#39;t care about errors in readahead. */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">DROP_REFERENCE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">reada</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_ref</span> <span class="o">||</span>
			    <span class="n">generation</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">btrfs_node_key_to_cpu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_comp_cpu_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_progress</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">))</span>
				<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">reada:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">readahead_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span>
					   <span class="n">generation</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">nread</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hepler to process tree block while walking down the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * when wc-&gt;stage == UPDATE_BACKREF, this function updates</span>
<span class="cm"> * back refs for pointers in the block.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: return value 1 means we should stop walking down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">walk_down_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lookup_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">flag</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">UPDATE_BACKREF</span> <span class="o">&amp;&amp;</span>
	    <span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * when reference count of tree block is 1, it won&#39;t increase</span>
<span class="cm">	 * again. once full backref flag is set, we never clear it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lookup_info</span> <span class="o">&amp;&amp;</span>
	    <span class="p">((</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">DROP_REFERENCE</span> <span class="o">&amp;&amp;</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">UPDATE_BACKREF</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">))))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_extent_info</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					       <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
					       <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">DROP_REFERENCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">keep_locks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* wc-&gt;stage == UPDATE_BACKREF */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">flag</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">for_reloc</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_dec_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">for_reloc</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_disk_extent_flags</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						  <span class="n">eb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">flag</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">|=</span> <span class="n">flag</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * the block is shared by multiple trees, so it&#39;s not good to</span>
<span class="cm">	 * keep the tree lock</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">level</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hepler to process tree block pointer.</span>
<span class="cm"> *</span>
<span class="cm"> * when wc-&gt;stage == DROP_REFERENCE, this function checks</span>
<span class="cm"> * reference count of the block pointed to. if the block</span>
<span class="cm"> * is shared and we need update back refs for the subtree</span>
<span class="cm"> * rooted at the block, this function changes wc-&gt;stage to</span>
<span class="cm"> * UPDATE_BACKREF. if the block is shared and there is no</span>
<span class="cm"> * need to update back, this function drops the reference</span>
<span class="cm"> * to the block.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: return value 1 means we should stop walking down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">do_walk_down</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">lookup_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reada</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
					       <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * if the lower level block was created before the snapshot</span>
<span class="cm">	 * was created, we know there is no need to update back refs</span>
<span class="cm">	 * for the subtree</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">UPDATE_BACKREF</span> <span class="o">&amp;&amp;</span>
	    <span class="n">generation</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">lookup_info</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">btrfs_find_create_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_extent_info</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span>
				       <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="o">*</span><span class="n">lookup_info</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">DROP_REFERENCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_ref</span> <span class="o">||</span>
			    <span class="n">generation</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

			<span class="n">btrfs_node_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
					      <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_comp_cpu_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_progress</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>

			<span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">=</span> <span class="n">UPDATE_BACKREF</span><span class="p">;</span>
			<span class="n">wc</span><span class="o">-&gt;</span><span class="n">shared_level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="o">*</span><span class="n">lookup_info</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reada</span> <span class="o">&amp;&amp;</span> <span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">reada_walk_down</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">generation</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">level</span><span class="o">--</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">next</span><span class="p">));</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">skip:</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">DROP_REFERENCE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span>
			       <span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]));</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
				<span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span>
	<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="o">*</span><span class="n">lookup_info</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * hepler to process tree block while walking up the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * when wc-&gt;stage == DROP_REFERENCE, this function drops</span>
<span class="cm"> * reference count on the block.</span>
<span class="cm"> *</span>
<span class="cm"> * when wc-&gt;stage == UPDATE_BACKREF, this function changes</span>
<span class="cm"> * wc-&gt;stage back to DROP_REFERENCE if we changed wc-&gt;stage</span>
<span class="cm"> * to UPDATE_BACKREF previously while processing the block.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: return value 1 means we should stop walking up.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">walk_up_proc</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">UPDATE_BACKREF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">shared_level</span> <span class="o">&lt;</span> <span class="n">level</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">shared_level</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_next_key</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_progress</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">=</span> <span class="n">DROP_REFERENCE</span><span class="p">;</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">shared_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * check reference count again if the block isn&#39;t locked.</span>
<span class="cm">		 * we should start walking down the tree again if reference</span>
<span class="cm">		 * count is one.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
			<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_extent_info</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						       <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						       <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
						       <span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* wc-&gt;stage == DROP_REFERENCE */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_dec_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						    <span class="n">wc</span><span class="o">-&gt;</span><span class="n">for_reloc</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_dec_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						    <span class="n">wc</span><span class="o">-&gt;</span><span class="n">for_reloc</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="p">}</span>
		<span class="cm">/* make block locked assertion in clean_tree_block happy */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;&amp;</span>
		    <span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span> <span class="o">==</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
			<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">)</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span>
			       <span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">eb</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">)</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span>
			       <span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]));</span>
	<span class="p">}</span>

	<span class="n">btrfs_free_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">walk_down_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lookup_info</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_down_proc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="n">lookup_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&gt;=</span>
		    <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_walk_down</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lookup_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">walk_up_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">,</span> <span class="kt">int</span> <span class="n">max_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">max_level</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span>
		    <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]))</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_up_proc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">wc</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
						     <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">level</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * drop a subvolume tree.</span>
<span class="cm"> *</span>
<span class="cm"> * this function traverses the tree freeing any blocks that only</span>
<span class="cm"> * referenced by the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * when a shared tree block is found. this function decreases its</span>
<span class="cm"> * reference count by one. if update_ref is true, this function</span>
<span class="cm"> * also make sure backrefs for the shared block and all lower level</span>
<span class="cm"> * blocks are properly updated.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_drop_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">,</span> <span class="kt">int</span> <span class="n">update_ref</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">for_reloc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">tree_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root_item</span> <span class="o">*</span><span class="n">root_item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">wc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wc</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">tree_root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="p">)</span>
		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_disk_key_objectid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="o">-&gt;</span><span class="n">drop_progress</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">btrfs_lock_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">;</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_progress</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_progress</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_disk_key_to_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_item</span><span class="o">-&gt;</span><span class="n">drop_progress</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_progress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
		       <span class="k">sizeof</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_progress</span><span class="p">));</span>

		<span class="n">level</span> <span class="o">=</span> <span class="n">root_item</span><span class="o">-&gt;</span><span class="n">drop_level</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * unlock our path, this is safe because only this</span>
<span class="cm">		 * function is allowed to delete this snapshot</span>
<span class="cm">		 */</span>
		<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_extent_info</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
						<span class="o">&amp;</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">root_item</span><span class="o">-&gt;</span><span class="n">drop_level</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">level</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">shared_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">=</span> <span class="n">DROP_REFERENCE</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_ref</span> <span class="o">=</span> <span class="n">update_ref</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">for_reloc</span> <span class="o">=</span> <span class="n">for_reloc</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">=</span> <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_down_tree</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">wc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">walk_up_tree</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">!=</span> <span class="n">DROP_REFERENCE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">==</span> <span class="n">DROP_REFERENCE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">level</span> <span class="o">=</span> <span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>
			<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
				       <span class="o">&amp;</span><span class="n">root_item</span><span class="o">-&gt;</span><span class="n">drop_progress</span><span class="p">,</span>
				       <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
			<span class="n">root_item</span><span class="o">-&gt;</span><span class="n">drop_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_should_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">,</span>
						<span class="n">root_item</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">btrfs_end_transaction_throttle</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">);</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">tree_root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="p">)</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_find_last_root</span><span class="p">(</span><span class="n">tree_root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* if we fail to delete the orphan item this time</span>
<span class="cm">			 * around, it&#39;ll get picked up the next time.</span>
<span class="cm">			 *</span>
<span class="cm">			 * The most common failure here is just -ENOENT.</span>
<span class="cm">			 */</span>
			<span class="n">btrfs_del_orphan_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span>
					      <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">in_radix</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_fs_root</span><span class="p">(</span><span class="n">tree_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">commit_root</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_end_trans:</span>
	<span class="n">btrfs_end_transaction_throttle</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">);</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">wc</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">btrfs_std_error</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * drop subtree rooted at tree block &#39;node&#39;.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: this function will unlock and release tree block &#39;node&#39;</span>
<span class="cm"> * only used by relocation code</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_drop_subtree</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">node</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">walk_control</span> <span class="o">*</span><span class="n">wc</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">parent_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">wc</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">wc</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wc</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_assert_tree_locked</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">parent_level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">parent_level</span><span class="p">]</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">parent_level</span><span class="p">]</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="n">btrfs_assert_tree_locked</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">;</span>

	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">[</span><span class="n">parent_level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">[</span><span class="n">parent_level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">shared_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">stage</span> <span class="o">=</span> <span class="n">DROP_REFERENCE</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">update_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">for_reloc</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">wc</span><span class="o">-&gt;</span><span class="n">reada_count</span> <span class="o">=</span> <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wret</span> <span class="o">=</span> <span class="n">walk_down_tree</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">wc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">wret</span> <span class="o">=</span> <span class="n">walk_up_tree</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">wc</span><span class="p">,</span> <span class="n">parent_level</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">wc</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">update_block_group_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">num_devices</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">stripped</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if restripe for this chunk_type is on pick target profile and</span>
<span class="cm">	 * return, otherwise do the usual balance</span>
<span class="cm">	 */</span>
	<span class="n">stripped</span> <span class="o">=</span> <span class="n">get_restripe_target</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">stripped</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">extended_to_chunk</span><span class="p">(</span><span class="n">stripped</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we add in the count of missing devices because we want</span>
<span class="cm">	 * to make sure that any RAID levels on a degraded FS</span>
<span class="cm">	 * continue to be honored.</span>
<span class="cm">	 */</span>
	<span class="n">num_devices</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">rw_devices</span> <span class="o">+</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">missing_devices</span><span class="p">;</span>

	<span class="n">stripped</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_RAID0</span> <span class="o">|</span>
		<span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_devices</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">stripped</span> <span class="o">|=</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">;</span>
		<span class="n">stripped</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">stripped</span><span class="p">;</span>

		<span class="cm">/* turn raid0 into single device chunks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">stripped</span><span class="p">;</span>

		<span class="cm">/* turn mirroring into duplication */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
			     <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">stripped</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* they already had raid on here, just return */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">stripped</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>

		<span class="n">stripped</span> <span class="o">|=</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">;</span>
		<span class="n">stripped</span> <span class="o">=</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">stripped</span><span class="p">;</span>

		<span class="cm">/* switch duplicated blocks with raid1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">stripped</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_RAID1</span><span class="p">;</span>

		<span class="cm">/* this is drive concat, leave it alone */</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">set_block_group_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">sinfo</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">min_allocable_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>


	<span class="cm">/*</span>
<span class="cm">	 * We need some metadata space and system metadata space for</span>
<span class="cm">	 * allocating chunks in some corner cases until we force to set</span>
<span class="cm">	 * it to be readonly.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">force</span><span class="p">)</span>
		<span class="n">min_allocable_bytes</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">min_allocable_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">-</span>
		    <span class="n">cache</span><span class="o">-&gt;</span><span class="n">bytes_super</span> <span class="o">-</span> <span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">+</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+</span>
	    <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">+</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">+</span>
	    <span class="n">min_allocable_bytes</span> <span class="o">&lt;=</span> <span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_set_block_group_ro</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>

<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">);</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">update_block_group_flags</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_flags</span> <span class="o">!=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span>
				     <span class="n">CHUNK_ALLOC_FORCE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_block_group_ro</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span>
			     <span class="n">CHUNK_ALLOC_FORCE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">set_block_group_ro</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_force_chunk_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">alloc_flags</span> <span class="o">=</span> <span class="n">get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">do_chunk_alloc</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">alloc_flags</span><span class="p">,</span>
			      <span class="n">CHUNK_ALLOC_FORCE</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to account the unused space of all the readonly block group in the</span>
<span class="cm"> * list. takes mirrors into account.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">u64</span> <span class="nf">__btrfs_get_ro_block_group_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">groups_list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">free_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">groups_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
					  <span class="n">BTRFS_BLOCK_GROUP_RAID10</span> <span class="o">|</span>
					  <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">))</span>
			<span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">free_bytes</span> <span class="o">+=</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span>
			       <span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">))</span> <span class="o">*</span>
			       <span class="n">factor</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">free_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to account the unused space of all the readonly block group in the</span>
<span class="cm"> * space_info. takes mirrors into account.</span>
<span class="cm"> */</span>
<span class="n">u64</span> <span class="nf">btrfs_account_ro_block_groups_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">sinfo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">free_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_NR_RAID_TYPES</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">free_bytes</span> <span class="o">+=</span> <span class="n">__btrfs_get_ro_block_group_free_space</span><span class="p">(</span>
						<span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">free_bytes</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_set_block_group_rw</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">sinfo</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">reserved</span> <span class="o">-</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">pinned</span> <span class="o">-</span>
		    <span class="n">cache</span><span class="o">-&gt;</span><span class="n">bytes_super</span> <span class="o">-</span> <span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
	<span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">-=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">ro</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sinfo</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * checks to see if its even possible to relocate this block group.</span>
<span class="cm"> *</span>
<span class="cm"> * @return - -1 if it&#39;s not a good idea to relocate this block group, 0 if its</span>
<span class="cm"> * ok to go ahead and try.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_can_relocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_devices</span> <span class="o">*</span><span class="n">fs_devices</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">min_free</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dev_min</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dev_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">target</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">full</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">block_group</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>

	<span class="cm">/* odd, couldn&#39;t find the block group, leave it alone */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_group</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">min_free</span> <span class="o">=</span> <span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>

	<span class="cm">/* no bytes used, we&#39;re good */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">min_free</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">space_info</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">full</span> <span class="o">=</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">full</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if this is the last block group we have in this space, we can&#39;t</span>
<span class="cm">	 * relocate it unless we&#39;re able to allocate a new chunk below.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Otherwise, we need to make sure we have room in the space to handle</span>
<span class="cm">	 * all of the extents from this block group.  If we can, we&#39;re good</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">!=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">+</span>
	     <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">+</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+</span>
	     <span class="n">min_free</span> <span class="o">&lt;</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ok we don&#39;t have enough space, but maybe we have free space on our</span>
<span class="cm">	 * devices to allocate new chunks for relocation, so loop through our</span>
<span class="cm">	 * alloc devices and guess if we have enough space.  if this block</span>
<span class="cm">	 * group is going to be restriped, run checks against the target</span>
<span class="cm">	 * profile instead of the current one.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * index:</span>
<span class="cm">	 *      0: raid10</span>
<span class="cm">	 *      1: raid1</span>
<span class="cm">	 *      2: dup</span>
<span class="cm">	 *      3: raid0</span>
<span class="cm">	 *      4: single</span>
<span class="cm">	 */</span>
	<span class="n">target</span> <span class="o">=</span> <span class="n">get_restripe_target</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">target</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">__get_block_group_index</span><span class="p">(</span><span class="n">extended_to_chunk</span><span class="p">(</span><span class="n">target</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * this is just a balance, so if we were marked as full</span>
<span class="cm">		 * we know there is no space for a new chunk</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">full</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">index</span> <span class="o">=</span> <span class="n">get_block_group_index</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_min</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="cm">/* Divide by 2 */</span>
		<span class="n">min_free</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_min</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Multiply by 2 */</span>
		<span class="n">min_free</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">index</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_min</span> <span class="o">=</span> <span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">rw_devices</span><span class="p">;</span>
		<span class="n">do_div</span><span class="p">(</span><span class="n">min_free</span><span class="p">,</span> <span class="n">dev_min</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">alloc_list</span><span class="p">,</span> <span class="n">dev_alloc_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">dev_offset</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * check to make sure we can actually find a chunk with enough</span>
<span class="cm">		 * space to fit our block group in.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">&gt;</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">+</span> <span class="n">min_free</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">find_free_dev_extent</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">min_free</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">dev_offset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">dev_nr</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">dev_nr</span> <span class="o">&gt;=</span> <span class="n">dev_min</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_mutex</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_first_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&amp;&amp;</span>
		    <span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_BLOCK_GROUP_ITEM_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_put_block_group_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

		<span class="n">block_group</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">block_group</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">iref</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">block_group</span> <span class="o">=</span> <span class="n">next_block_group</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
						       <span class="n">block_group</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_group</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">last</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
		<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">iref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">last</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_free_block_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_caching_control</span> <span class="o">*</span><span class="n">caching_ctl</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">caching_block_groups</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">caching_ctl</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">caching_block_groups</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">btrfs_caching_control</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">caching_ctl</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">put_caching_control</span><span class="p">(</span><span class="n">caching_ctl</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">extent_commit_sem</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_last</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_tree</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_group</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span><span class="p">,</span>
				       <span class="n">cache_node</span><span class="p">);</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cache_node</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_tree</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>

		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">==</span> <span class="n">BTRFS_CACHE_STARTED</span><span class="p">)</span>
			<span class="n">wait_block_group_cache_done</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We haven&#39;t cached this block group, which means we could</span>
<span class="cm">		 * possibly have excluded extents on this block group.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">==</span> <span class="n">BTRFS_CACHE_NO</span><span class="p">)</span>
			<span class="n">free_excluded_extents</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>

		<span class="n">btrfs_remove_free_space_cache</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>

	<span class="cm">/* now that all the block groups are freed, go through and</span>
<span class="cm">	 * free all the space_info structs.  This is only called during</span>
<span class="cm">	 * the final stages of unmount, and so we know nobody is</span>
<span class="cm">	 * using them.  We call synchronize_rcu() once before we start,</span>
<span class="cm">	 * just to be on the safe side.</span>
<span class="cm">	 */</span>
	<span class="n">synchronize_rcu</span><span class="p">();</span>

	<span class="n">release_global_block_rsv</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>

	<span class="k">while</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">space_info</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfs_space_info</span><span class="p">,</span>
					<span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_pinned</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_may_use</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">dump_space_info</span><span class="p">(</span><span class="n">space_info</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">space_info</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__link_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">get_block_group_index</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_read_block_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need_clear</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cache_gen</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_BLOCK_GROUP_ITEM_KEY</span><span class="p">);</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">cache_gen</span> <span class="o">=</span> <span class="n">btrfs_super_cache_generation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">SPACE_CACHE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">)</span> <span class="o">!=</span> <span class="n">cache_gen</span><span class="p">)</span>
		<span class="n">need_clear</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">CLEAR_CACHE</span><span class="p">))</span>
		<span class="n">need_clear</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_first_block_group</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="p">),</span>
						<span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">info</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">need_clear</span><span class="p">)</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">disk_cache_state</span> <span class="o">=</span> <span class="n">BTRFS_DC_CLEAR</span><span class="p">;</span>

		<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span>
				   <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">found_key</span><span class="p">));</span>

		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_block_group_flags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>

		<span class="n">btrfs_init_free_space_ctl</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * We need to exclude the super stripes now so that the space</span>
<span class="cm">		 * info has super bytes accounted for, otherwise we&#39;ll think</span>
<span class="cm">		 * we have more space than we actually do.</span>
<span class="cm">		 */</span>
		<span class="n">exclude_super_stripes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * check for two cases, either we are full, and therefore</span>
<span class="cm">		 * don&#39;t need to bother with the caching work since we won&#39;t</span>
<span class="cm">		 * find any space, or we are empty, and we can just add all</span>
<span class="cm">		 * the space in and be done with it.  This saves us _alot_ of</span>
<span class="cm">		 * time, particularly in the full case.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_FINISHED</span><span class="p">;</span>
			<span class="n">free_excluded_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_FINISHED</span><span class="p">;</span>
			<span class="n">add_new_free_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
					   <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					   <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span>
					   <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">free_excluded_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_space_info</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
					<span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">),</span>
					<span class="o">&amp;</span><span class="n">space_info</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span> <span class="o">=</span> <span class="n">space_info</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">bytes_super</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="n">__link_block_group</span><span class="p">(</span><span class="n">space_info</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_block_group_cache</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* Logic error */</span>

		<span class="n">set_avail_alloc_bits</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_chunk_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">))</span>
			<span class="n">set_block_group_ro</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">space_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">get_alloc_profile</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">space_info</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span>
		      <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_RAID10</span> <span class="o">|</span>
		       <span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
		       <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">)))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * avoid allocating from un-mirrored block group if there are</span>
<span class="cm">		 * mirrored block groups.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">set_block_group_ro</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="mi">4</span><span class="p">],</span> <span class="n">list</span><span class="p">)</span>
			<span class="n">set_block_group_ro</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">init_global_block_rsv</span><span class="p">(</span><span class="n">info</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">error:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_make_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytes_used</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">type</span><span class="p">,</span> <span class="n">u64</span> <span class="n">chunk_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">chunk_offset</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">extent_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>

	<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">last_trans_log_full_commit</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>

	<span class="n">cache</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="p">),</span>
					<span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">free_space_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">chunk_offset</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_ITEM_KEY</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">cluster_list</span><span class="p">);</span>

	<span class="n">btrfs_init_free_space_ctl</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>

	<span class="n">btrfs_set_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">bytes_used</span><span class="p">);</span>
	<span class="n">btrfs_set_block_group_chunk_objectid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">chunk_objectid</span><span class="p">);</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">type</span><span class="p">;</span>
	<span class="n">btrfs_set_block_group_flags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">last_byte_to_unpin</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">=</span> <span class="n">BTRFS_CACHE_FINISHED</span><span class="p">;</span>
	<span class="n">exclude_super_stripes</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">add_new_free_space</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">chunk_offset</span><span class="p">,</span>
			   <span class="n">chunk_offset</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>

	<span class="n">free_excluded_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_space_info</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">bytes_used</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="n">update_global_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">+=</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">bytes_super</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">__link_block_group</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_block_group_cache</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* Logic error */</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">extent_root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">set_avail_alloc_bits</span><span class="p">(</span><span class="n">extent_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_avail_alloc_bits</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">extra_flags</span> <span class="o">=</span> <span class="n">chunk_to_extended</span><span class="p">(</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;</span>
				<span class="n">BTRFS_EXTENDED_PROFILE_MASK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">)</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_data_alloc_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">extra_flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">)</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_metadata_alloc_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">extra_flags</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">)</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">avail_system_alloc_bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">extra_flags</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_remove_block_group</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">group_start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_free_cluster</span> <span class="o">*</span><span class="n">cluster</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">tree_root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">factor</span><span class="p">;</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>

	<span class="n">block_group</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">group_start</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">block_group</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">ro</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free the reserved super bytes from this block group before</span>
<span class="cm">	 * remove it.</span>
<span class="cm">	 */</span>
	<span class="n">free_excluded_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_group</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">get_block_group_index</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFS_BLOCK_GROUP_DUP</span> <span class="o">|</span>
				  <span class="n">BTRFS_BLOCK_GROUP_RAID1</span> <span class="o">|</span>
				  <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">))</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">factor</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* make sure this block group isn&#39;t part of an allocation cluster */</span>
	<span class="n">cluster</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">data_alloc_cluster</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
	<span class="n">btrfs_return_cluster_to_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">cluster</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure this block group isn&#39;t part of a metadata</span>
<span class="cm">	 * allocation cluster</span>
<span class="cm">	 */</span>
	<span class="n">cluster</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">meta_alloc_cluster</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>
	<span class="n">btrfs_return_cluster_to_free_space</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">cluster</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">cluster</span><span class="o">-&gt;</span><span class="n">refill_lock</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">lookup_free_space_inode</span><span class="p">(</span><span class="n">tree_root</span><span class="p">,</span> <span class="n">block_group</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_add</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">clear_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="cm">/* One for the block groups ref */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">iref</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">iref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* One for our lookup ref */</span>
		<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">BTRFS_FREE_SPACE_OBJECTID</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">tree_root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cache_node</span><span class="p">,</span>
		 <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">block_group_cache_tree</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">block_group_cache_lock</span><span class="p">);</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * we must use list_del_init so people can check to see if they</span>
<span class="cm">	 * are still on the list after taking the semaphore</span>
<span class="cm">	 */</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
		<span class="n">clear_avail_alloc_bits</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">cached</span> <span class="o">==</span> <span class="n">BTRFS_CACHE_STARTED</span><span class="p">)</span>
		<span class="n">wait_block_group_cache_done</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>

	<span class="n">btrfs_remove_free_space_cache</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">-=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">bytes_readonly</span> <span class="o">-=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">disk_total</span> <span class="o">-=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

	<span class="n">btrfs_clear_space_info_full</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">);</span>

	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>
	<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">block_group</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_init_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">space_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">disk_super</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mixed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">disk_super</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_super_root</span><span class="p">(</span><span class="n">disk_super</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">features</span> <span class="o">=</span> <span class="n">btrfs_super_incompat_flags</span><span class="p">(</span><span class="n">disk_super</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">BTRFS_FEATURE_INCOMPAT_MIXED_GROUPS</span><span class="p">)</span>
		<span class="n">mixed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mixed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">update_space_info</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_info</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_error_unpin_extent_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">unpin_extent_range</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_error_discard_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">actual_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">btrfs_discard_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">actual_bytes</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_trim_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fstrim_range</span> <span class="o">*</span><span class="n">range</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">group_trimmed</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">trimmed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="n">btrfs_super_total_bytes</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * try to trim all FS space, our block group may start from non-zero.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">==</span> <span class="n">total_bytes</span><span class="p">)</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_block_group</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
				<span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">cache</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">&gt;=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_group_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">cache_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
					<span class="n">wait_block_group_cache_done</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_trim_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">group_trimmed</span><span class="p">,</span>
						     <span class="n">start</span><span class="p">,</span>
						     <span class="n">end</span><span class="p">,</span>
						     <span class="n">range</span><span class="o">-&gt;</span><span class="n">minlen</span><span class="p">);</span>

			<span class="n">trimmed</span> <span class="o">+=</span> <span class="n">group_trimmed</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">cache</span> <span class="o">=</span> <span class="n">next_block_group</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span> <span class="n">cache</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">trimmed</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
