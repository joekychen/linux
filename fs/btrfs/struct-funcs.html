<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › struct-funcs.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>struct-funcs.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/highmem.h&gt;</span>

<span class="cm">/* this is some deeply nasty code.  ctree.h has a different</span>
<span class="cm"> * definition for this BTRFS_SETGET_FUNCS macro, behind a #ifndef</span>
<span class="cm"> *</span>
<span class="cm"> * The end result is that anyone who #includes ctree.h gets a</span>
<span class="cm"> * declaration for the btrfs_set_foo functions and btrfs_foo functions</span>
<span class="cm"> *</span>
<span class="cm"> * This file declares the macros and then #includes ctree.h, which results</span>
<span class="cm"> * in cpp creating the function here based on the template below.</span>
<span class="cm"> *</span>
<span class="cm"> * These setget functions do all the extent_buffer related mapping</span>
<span class="cm"> * required to efficiently read and write specific fields in the extent</span>
<span class="cm"> * buffers.  Every pointer to metadata items in btrfs is really just</span>
<span class="cm"> * an unsigned long offset into the extent buffer which has been</span>
<span class="cm"> * cast to a specific type.  This gives us all the gcc type checking.</span>
<span class="cm"> *</span>
<span class="cm"> * The extent buffer api is used to do all the kmapping and page</span>
<span class="cm"> * spanning work required to get extent buffers in highmem and have</span>
<span class="cm"> * a metadata blocksize different from the page size.</span>
<span class="cm"> *</span>
<span class="cm"> * The macro starts with a simple function prototype declaration so that</span>
<span class="cm"> * sparse won&#39;t complain about it being static.</span>
<span class="cm"> */</span>

<span class="cp">#define BTRFS_SETGET_FUNCS(name, type, member, bits)			\</span>
<span class="cp">u##bits btrfs_##name(struct extent_buffer *eb, type *s);		\</span>
<span class="cp">void btrfs_set_##name(struct extent_buffer *eb, type *s, u##bits val);	\</span>
<span class="cp">void btrfs_set_token_##name(struct extent_buffer *eb, type *s, u##bits val, struct btrfs_map_token *token);	\</span>
<span class="cp">u##bits btrfs_token_##name(struct extent_buffer *eb,				\</span>
<span class="cp">			   type *s, struct btrfs_map_token *token)	\</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned long part_offset = (unsigned long)s;			\</span>
<span class="cp">	unsigned long offset = part_offset + offsetof(type, member);	\</span>
<span class="cp">	type *p;							\</span>
<span class="cp">	int err;						\</span>
<span class="cp">	char *kaddr;						\</span>
<span class="cp">	unsigned long map_start;				\</span>
<span class="cp">	unsigned long map_len;					\</span>
<span class="cp">	unsigned long mem_len = sizeof(((type *)0)-&gt;member);	\</span>
<span class="cp">	u##bits res;						\</span>
<span class="cp">	if (token &amp;&amp; token-&gt;kaddr &amp;&amp; token-&gt;offset &lt;= offset &amp;&amp;	\</span>
<span class="cp">	    token-&gt;eb == eb &amp;&amp;					\</span>
<span class="cp">	   (token-&gt;offset + PAGE_CACHE_SIZE &gt;= offset + mem_len)) { \</span>
<span class="cp">		kaddr = token-&gt;kaddr;				\</span>
<span class="cp">		p = (type *)(kaddr + part_offset - token-&gt;offset);  \</span>
<span class="cp">		res = le##bits##_to_cpu(p-&gt;member);		\</span>
<span class="cp">		return res;					\</span>
<span class="cp">	}							\</span>
<span class="cp">	err = map_private_extent_buffer(eb, offset,		\</span>
<span class="cp">			mem_len,				\</span>
<span class="cp">			&amp;kaddr, &amp;map_start, &amp;map_len);		\</span>
<span class="cp">	if (err) {						\</span>
<span class="cp">		__le##bits leres;				\</span>
<span class="cp">		read_eb_member(eb, s, type, member, &amp;leres);	\</span>
<span class="cp">		return le##bits##_to_cpu(leres);		\</span>
<span class="cp">	}							\</span>
<span class="cp">	p = (type *)(kaddr + part_offset - map_start);		\</span>
<span class="cp">	res = le##bits##_to_cpu(p-&gt;member);			\</span>
<span class="cp">	if (token) {						\</span>
<span class="cp">		token-&gt;kaddr = kaddr;				\</span>
<span class="cp">		token-&gt;offset = map_start;			\</span>
<span class="cp">		token-&gt;eb = eb;					\</span>
<span class="cp">	}							\</span>
<span class="cp">	return res;						\</span>
<span class="cp">}									\</span>
<span class="cp">void btrfs_set_token_##name(struct extent_buffer *eb,				\</span>
<span class="cp">			    type *s, u##bits val, struct btrfs_map_token *token)		\</span>
<span class="cp">{									\</span>
<span class="cp">	unsigned long part_offset = (unsigned long)s;			\</span>
<span class="cp">	unsigned long offset = part_offset + offsetof(type, member);	\</span>
<span class="cp">	type *p;							\</span>
<span class="cp">	int err;						\</span>
<span class="cp">	char *kaddr;						\</span>
<span class="cp">	unsigned long map_start;				\</span>
<span class="cp">	unsigned long map_len;					\</span>
<span class="cp">	unsigned long mem_len = sizeof(((type *)0)-&gt;member);	\</span>
<span class="cp">	if (token &amp;&amp; token-&gt;kaddr &amp;&amp; token-&gt;offset &lt;= offset &amp;&amp;	\</span>
<span class="cp">	    token-&gt;eb == eb &amp;&amp;					\</span>
<span class="cp">	   (token-&gt;offset + PAGE_CACHE_SIZE &gt;= offset + mem_len)) { \</span>
<span class="cp">		kaddr = token-&gt;kaddr;				\</span>
<span class="cp">		p = (type *)(kaddr + part_offset - token-&gt;offset);  \</span>
<span class="cp">		p-&gt;member = cpu_to_le##bits(val);		\</span>
<span class="cp">		return;						\</span>
<span class="cp">	}							\</span>
<span class="cp">	err = map_private_extent_buffer(eb, offset,		\</span>
<span class="cp">			mem_len,				\</span>
<span class="cp">			&amp;kaddr, &amp;map_start, &amp;map_len);		\</span>
<span class="cp">	if (err) {						\</span>
<span class="cp">		__le##bits val2;				\</span>
<span class="cp">		val2 = cpu_to_le##bits(val);			\</span>
<span class="cp">		write_eb_member(eb, s, type, member, &amp;val2);	\</span>
<span class="cp">		return;						\</span>
<span class="cp">	}							\</span>
<span class="cp">	p = (type *)(kaddr + part_offset - map_start);		\</span>
<span class="cp">	p-&gt;member = cpu_to_le##bits(val);			\</span>
<span class="cp">	if (token) {						\</span>
<span class="cp">		token-&gt;kaddr = kaddr;				\</span>
<span class="cp">		token-&gt;offset = map_start;			\</span>
<span class="cp">		token-&gt;eb = eb;					\</span>
<span class="cp">	}							\</span>
<span class="cp">}								\</span>
<span class="cp">void btrfs_set_##name(struct extent_buffer *eb,			\</span>
<span class="cp">		      type *s, u##bits val)			\</span>
<span class="cp">{								\</span>
<span class="cp">	btrfs_set_token_##name(eb, s, val, NULL);		\</span>
<span class="cp">}								\</span>
<span class="cp">u##bits btrfs_##name(struct extent_buffer *eb,			\</span>
<span class="cp">		      type *s)					\</span>
<span class="cp">{								\</span>
<span class="cp">	return btrfs_token_##name(eb, s, NULL);			\</span>
<span class="cp">}								\</span>

<span class="cp">#include &quot;ctree.h&quot;</span>

<span class="kt">void</span> <span class="nf">btrfs_node_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">disk_key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">nr</span><span class="p">);</span>
	<span class="n">read_eb_member</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">disk_key</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
