<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › scrub.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>scrub.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2011 STRATO.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;volumes.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;ordered-data.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;backref.h&quot;</span>
<span class="cp">#include &quot;extent_io.h&quot;</span>
<span class="cp">#include &quot;check-integrity.h&quot;</span>
<span class="cp">#include &quot;rcu-string.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * This is only the first step towards a full-features scrub. It reads all</span>
<span class="cm"> * extent and super block and verifies the checksums. In case a bad checksum</span>
<span class="cm"> * is found or the extent cannot be read, good data will be written back if</span>
<span class="cm"> * any can be found.</span>
<span class="cm"> *</span>
<span class="cm"> * Future enhancements:</span>
<span class="cm"> *  - In case an unrepairable extent is encountered, track which files are</span>
<span class="cm"> *    affected and report them</span>
<span class="cm"> *  - track and record media errors, throw out bad devices</span>
<span class="cm"> *  - add a mode to also read unallocated space</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">scrub_block</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">scrub_dev</span><span class="p">;</span>

<span class="cp">#define SCRUB_PAGES_PER_BIO	16	</span><span class="cm">/* 64k per bio */</span><span class="cp"></span>
<span class="cp">#define SCRUB_BIOS_PER_DEV	16	</span><span class="cm">/* 1 MB per device in flight */</span><span class="cp"></span>
<span class="cp">#define SCRUB_MAX_PAGES_PER_BLOCK	16	</span><span class="cm">/* 64k per node/leaf/sector */</span><span class="cp"></span>

<span class="k">struct</span> <span class="n">scrub_page</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_block</span>	<span class="o">*</span><span class="n">sblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span>		<span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">flags</span><span class="p">;</span>  <span class="cm">/* extent flags */</span>
	<span class="n">u64</span>			<span class="n">generation</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">logical</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">physical</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">mirror_num</span><span class="o">:</span><span class="mi">8</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">have_csum</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">io_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">};</span>
	<span class="n">u8</span>			<span class="n">csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="p">{</span>
	<span class="kt">int</span>			<span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span>	<span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span>		<span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">err</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">logical</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">physical</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_page</span>	<span class="o">*</span><span class="n">pagev</span><span class="p">[</span><span class="n">SCRUB_PAGES_PER_BIO</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">page_count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">next_free</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_work</span>	<span class="n">work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scrub_block</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_page</span>	<span class="n">pagev</span><span class="p">[</span><span class="n">SCRUB_MAX_PAGES_PER_BLOCK</span><span class="p">];</span>
	<span class="kt">int</span>			<span class="n">page_count</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">outstanding_pages</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">ref_count</span><span class="p">;</span> <span class="cm">/* free mem on transition to zero */</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span>	<span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">header_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">checksum_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">no_io_error_seen</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span>	<span class="n">generation_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span> <span class="cm">/* also sets header_error */</span>
	<span class="p">};</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_bio</span>	<span class="o">*</span><span class="n">bios</span><span class="p">[</span><span class="n">SCRUB_BIOS_PER_DEV</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">first_free</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">curr</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">in_flight</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">fixup_cnt</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">list_lock</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">list_wait</span><span class="p">;</span>
	<span class="n">u16</span>			<span class="n">csum_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">csum_list</span><span class="p">;</span>
	<span class="n">atomic_t</span>		<span class="n">cancel_req</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">readonly</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">pages_per_bio</span><span class="p">;</span> <span class="cm">/* &lt;= SCRUB_PAGES_PER_BIO */</span>
	<span class="n">u32</span>			<span class="n">sectorsize</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">nodesize</span><span class="p">;</span>
	<span class="n">u32</span>			<span class="n">leafsize</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * statistics</span>
<span class="cm">	 */</span>
	<span class="k">struct</span> <span class="n">btrfs_scrub_progress</span> <span class="n">stat</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">stat_lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scrub_fixup_nodatasum</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span>	<span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">logical</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span>	<span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_work</span>	<span class="n">work</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">mirror_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">scrub_warning</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span>	<span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">extent_item_size</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">scratch_buf</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="o">*</span><span class="n">msg_buf</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">char</span>		<span class="o">*</span><span class="n">errstr</span><span class="p">;</span>
	<span class="n">sector_t</span>		<span class="n">sector</span><span class="p">;</span>
	<span class="n">u64</span>			<span class="n">logical</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span>	<span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">msg_bufsize</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">scratch_bufsize</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_handle_errored_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_to_check</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_setup_recheck_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_mapping_tree</span> <span class="o">*</span><span class="n">map_tree</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">length</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_recheck_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">have_csum</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">generation</span><span class="p">,</span>
			       <span class="n">u16</span> <span class="n">csum_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scrub_recheck_block_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">have_csum</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">generation</span><span class="p">,</span>
					 <span class="n">u16</span> <span class="n">csum_size</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scrub_complete_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_repair_block_from_good_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_bad</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_good</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">force_write</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_repair_page_from_good_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_bad</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_good</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_write</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_checksum_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_checksum_tree_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_checksum_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scrub_block_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scrub_block_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_add_page_to_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">spage</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">scrub_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span>
		       <span class="n">u64</span> <span class="n">physical</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span>
		       <span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scrub_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scrub_bio_end_io_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">scrub_block_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">);</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_free_csums</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_ordered_sum</span> <span class="o">*</span><span class="n">sum</span><span class="p">;</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_list</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfs_ordered_sum</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">void</span> <span class="nf">scrub_free_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* this can happen when scrub is cancelled */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="o">*</span><span class="n">sbio</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">];</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
			<span class="n">scrub_block_put</span><span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">sblock</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCRUB_BIOS_PER_DEV</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="o">*</span><span class="n">sbio</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbio</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sbio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">scrub_free_csums</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span>
<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="nf">scrub_setup_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">int</span>		<span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pages_per_bio</span><span class="p">;</span>

	<span class="n">pages_per_bio</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">SCRUB_PAGES_PER_BIO</span><span class="p">,</span>
			      <span class="n">bio_get_nr_vecs</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">));</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sdev</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">pages_per_bio</span> <span class="o">=</span> <span class="n">pages_per_bio</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">SCRUB_BIOS_PER_DEV</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="o">*</span><span class="n">sbio</span><span class="p">;</span>

		<span class="n">sbio</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sbio</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbio</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nomem</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sbio</span><span class="p">;</span>

		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">scrub_bio_end_io_worker</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="n">SCRUB_BIOS_PER_DEV</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_free</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_free</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">leafsize</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">fixup_cnt</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">cancel_req</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span> <span class="o">=</span> <span class="n">btrfs_super_csum_size</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_list</span><span class="p">);</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">sdev</span><span class="p">;</span>

<span class="nl">nomem:</span>
	<span class="n">scrub_free_dev</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_print_warning_inode</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">isize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nlink</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_item</span> <span class="o">*</span><span class="n">inode_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_warning</span> <span class="o">*</span><span class="n">swarn</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">swarn</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_fs_paths</span> <span class="o">*</span><span class="n">ipath</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">local_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">root_key</span><span class="p">;</span>

	<span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">root_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">root_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">local_root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">local_root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">local_root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">inode_item_info</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">local_root</span><span class="p">,</span> <span class="n">swarn</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">swarn</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">swarn</span><span class="o">-&gt;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">inode_item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">swarn</span><span class="o">-&gt;</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="k">struct</span> <span class="n">btrfs_inode_item</span><span class="p">);</span>
	<span class="n">isize</span> <span class="o">=</span> <span class="n">btrfs_inode_size</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
	<span class="n">nlink</span> <span class="o">=</span> <span class="n">btrfs_inode_nlink</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">swarn</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ipath</span> <span class="o">=</span> <span class="n">init_ipath</span><span class="p">(</span><span class="mi">4096</span><span class="p">,</span> <span class="n">local_root</span><span class="p">,</span> <span class="n">swarn</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ipath</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ipath</span><span class="p">);</span>
		<span class="n">ipath</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">paths_from_inode</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="n">ipath</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we deliberately ignore the bit ipath might have been too small to</span>
<span class="cm">	 * hold all of the paths here</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">elem_cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
		<span class="n">printk_in_rcu</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;btrfs: %s at logical %llu on dev &quot;</span>
			<span class="s">&quot;%s, sector %llu, root %llu, inode %llu, offset %llu, &quot;</span>
			<span class="s">&quot;length %llu, links %u (path: %s)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">swarn</span><span class="o">-&gt;</span><span class="n">errstr</span><span class="p">,</span>
			<span class="n">swarn</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">,</span> <span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">swarn</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">swarn</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			<span class="n">min</span><span class="p">(</span><span class="n">isize</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_SIZE</span><span class="p">),</span> <span class="n">nlink</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">free_ipath</span><span class="p">(</span><span class="n">ipath</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">err:</span>
	<span class="n">printk_in_rcu</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;btrfs: %s at logical %llu on dev &quot;</span>
		<span class="s">&quot;%s, sector %llu, root %llu, inode %llu, offset %llu: path &quot;</span>
		<span class="s">&quot;resolving failed with ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">swarn</span><span class="o">-&gt;</span><span class="n">errstr</span><span class="p">,</span>
		<span class="n">swarn</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">,</span> <span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">swarn</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span>
		<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">swarn</span><span class="o">-&gt;</span><span class="n">sector</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inum</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>

	<span class="n">free_ipath</span><span class="p">(</span><span class="n">ipath</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_print_warning</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">errstr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">dev</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_warning</span> <span class="n">swarn</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ref_root</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">ref_level</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">bufsize</span> <span class="o">=</span> <span class="mi">4096</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_item_pos</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>

	<span class="n">swarn</span><span class="p">.</span><span class="n">scratch_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">msg_buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">bufsize</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">sector</span> <span class="o">=</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">physical</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">logical</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">logical</span><span class="p">;</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">errstr</span> <span class="o">=</span> <span class="n">errstr</span><span class="p">;</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev</span><span class="p">;</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">msg_bufsize</span> <span class="o">=</span> <span class="n">bufsize</span><span class="p">;</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">scratch_bufsize</span> <span class="o">=</span> <span class="n">bufsize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span> <span class="o">||</span> <span class="o">!</span><span class="n">swarn</span><span class="p">.</span><span class="n">scratch_buf</span> <span class="o">||</span> <span class="o">!</span><span class="n">swarn</span><span class="p">.</span><span class="n">msg_buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">extent_from_logical</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">swarn</span><span class="p">.</span><span class="n">logical</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">extent_item_pos</span> <span class="o">=</span> <span class="n">swarn</span><span class="p">.</span><span class="n">logical</span> <span class="o">-</span> <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">swarn</span><span class="p">.</span><span class="n">extent_item_size</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">do</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_backref_for_extent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ptr</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">ref_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref_level</span><span class="p">);</span>
			<span class="n">printk_in_rcu</span><span class="p">(</span><span class="n">KERN_WARNING</span>
				<span class="s">&quot;btrfs: %s at logical %llu on dev %s, &quot;</span>
				<span class="s">&quot;sector %llu: metadata %s (level %d) in tree &quot;</span>
				<span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">errstr</span><span class="p">,</span> <span class="n">swarn</span><span class="p">.</span><span class="n">logical</span><span class="p">,</span>
				<span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">swarn</span><span class="p">.</span><span class="n">sector</span><span class="p">,</span>
				<span class="n">ref_level</span> <span class="o">?</span> <span class="s">&quot;node&quot;</span> <span class="o">:</span> <span class="s">&quot;leaf&quot;</span><span class="p">,</span>
				<span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ref_level</span><span class="p">,</span>
				<span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="mi">1</span> <span class="o">:</span> <span class="n">ref_root</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">swarn</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
		<span class="n">iterate_extent_inodes</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">extent_item_pos</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					<span class="n">scrub_print_warning_inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">swarn</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">swarn</span><span class="p">.</span><span class="n">scratch_buf</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">swarn</span><span class="p">.</span><span class="n">msg_buf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_fixup_readpage</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_fixup_nodatasum</span> <span class="o">*</span><span class="n">fixup</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">corrected</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">local_root</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">local_root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">fixup</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">local_root</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">local_root</span><span class="p">);</span>

	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_iget</span><span class="p">(</span><span class="n">fixup</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">local_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="n">page</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_mapping_tree</span> <span class="o">*</span><span class="n">map_tree</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we need to write the data to the defect sector. the</span>
<span class="cm">			 * data that was in that sector is not in memory,</span>
<span class="cm">			 * because the page was modified. we must not write the</span>
<span class="cm">			 * modified page to that sector.</span>
<span class="cm">			 *</span>
<span class="cm">			 * TODO: what could be done here: wait for the delalloc</span>
<span class="cm">			 *       runner to write out that page (might involve</span>
<span class="cm">			 *       COW) and see whether the sector is still</span>
<span class="cm">			 *       referenced afterwards.</span>
<span class="cm">			 *</span>
<span class="cm">			 * For the meantime, we&#39;ll treat this error</span>
<span class="cm">			 * incorrectable, although there is a chance that a</span>
<span class="cm">			 * later scrub will find the bad sector again and that</span>
<span class="cm">			 * there&#39;s no dirty page in memory, then.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">map_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">repair_io_failure</span><span class="p">(</span><span class="n">map_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span>
					<span class="n">fixup</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
					<span class="n">fixup</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">corrected</span> <span class="o">=</span> <span class="o">!</span><span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we need to get good data first. the general readpage path</span>
<span class="cm">		 * will call repair_io_failure for us, we just have to make</span>
<span class="cm">		 * sure we read the bad mirror.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">set_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
					<span class="n">EXTENT_DAMAGED</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* set_extent_bits should give proper error */</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">extent_read_full_page</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
						<span class="n">btrfs_get_extent</span><span class="p">,</span>
						<span class="n">fixup</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="n">wait_on_page_locked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="n">corrected</span> <span class="o">=</span> <span class="o">!</span><span class="n">test_range_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_DAMAGED</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">corrected</span><span class="p">)</span>
			<span class="n">clear_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
						<span class="n">EXTENT_DAMAGED</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="p">)</span>
		<span class="n">put_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">corrected</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we only need to call readpage for one of the inodes belonging</span>
<span class="cm">		 * to this extent. so make iterate_extent_inodes stop</span>
<span class="cm">		 */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_fixup_nodatasum</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_fixup_nodatasum</span> <span class="o">*</span><span class="n">fixup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uncorrectable</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fixup</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scrub_fixup_nodatasum</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">fixup</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">fs_info</span> <span class="o">=</span> <span class="n">fixup</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="o">++</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">malloc_errors</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">uncorrectable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">fixup</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">uncorrectable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * the idea is to trigger a regular read through the standard path. we</span>
<span class="cm">	 * read a page from the (failed) logical address by specifying the</span>
<span class="cm">	 * corresponding copynum of the failed sector. thus, that readpage is</span>
<span class="cm">	 * expected to fail.</span>
<span class="cm">	 * that is the point where on-the-fly error correction will kick in</span>
<span class="cm">	 * (once it&#39;s finished) and rewrite the failed sector if a good copy</span>
<span class="cm">	 * can be found.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iterate_inodes_from_logical</span><span class="p">(</span><span class="n">fixup</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">,</span> <span class="n">fixup</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
						<span class="n">path</span><span class="p">,</span> <span class="n">scrub_fixup_readpage</span><span class="p">,</span>
						<span class="n">fixup</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uncorrectable</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="o">++</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">corrected_errors</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fixup</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">uncorrectable</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="o">++</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">uncorrectable_errors</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>

		<span class="n">printk_ratelimited_in_rcu</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;btrfs: unable to fixup (nodatasum) error at logical %llu on dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fixup</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">,</span>
			<span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fixup</span><span class="p">);</span>

	<span class="cm">/* see caller why we&#39;re pretending to be paused in the scrub counters */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">fixup_cnt</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * scrub_handle_errored_block gets called when either verification of the</span>
<span class="cm"> * pages failed or the bio failed to read, e.g. with EIO. In the latter</span>
<span class="cm"> * case, this function handles all pages in the bio, even though only one</span>
<span class="cm"> * may be bad.</span>
<span class="cm"> * The goal of this function is to repair the errored block by using the</span>
<span class="cm"> * contents of one of the mirrors.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_handle_errored_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_to_check</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">logical</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">failed_mirror_index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">have_csum</span><span class="p">;</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblocks_for_recheck</span><span class="p">;</span> <span class="cm">/* holds one for each mirror */</span>
	<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_bad</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mirror_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">page_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">success</span><span class="p">;</span>
	<span class="k">static</span> <span class="n">DEFINE_RATELIMIT_STATE</span><span class="p">(</span><span class="n">_rs</span><span class="p">,</span> <span class="n">DEFAULT_RATELIMIT_INTERVAL</span><span class="p">,</span>
				      <span class="n">DEFAULT_RATELIMIT_BURST</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">fs_info</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="n">length</span> <span class="o">=</span> <span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
	<span class="n">logical</span> <span class="o">=</span> <span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">logical</span><span class="p">;</span>
	<span class="n">generation</span> <span class="o">=</span> <span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">generation</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mirror_num</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">failed_mirror_index</span> <span class="o">=</span> <span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">mirror_num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">is_metadata</span> <span class="o">=</span> <span class="o">!</span><span class="p">(</span><span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span> <span class="o">&amp;</span>
			<span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">);</span>
	<span class="n">have_csum</span> <span class="o">=</span> <span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">have_csum</span><span class="p">;</span>
	<span class="n">csum</span> <span class="o">=</span> <span class="n">sblock_to_check</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csum</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * read all mirrors one after the other. This includes to</span>
<span class="cm">	 * re-read the extent or metadata block that failed (that was</span>
<span class="cm">	 * the cause that this fixup code is called) another time,</span>
<span class="cm">	 * page by page this time in order to know which pages</span>
<span class="cm">	 * caused I/O errors and which ones are good (for all mirrors).</span>
<span class="cm">	 * It is the goal to handle the situation when more than one</span>
<span class="cm">	 * mirror contains I/O errors, but the errors do not</span>
<span class="cm">	 * overlap, i.e. the data can be repaired by selecting the</span>
<span class="cm">	 * pages from those mirrors without I/O error on the</span>
<span class="cm">	 * particular pages. One example (with blocks &gt;= 2 * PAGE_SIZE)</span>
<span class="cm">	 * would be that mirror #1 has an I/O error on the first page,</span>
<span class="cm">	 * the second page is good, and mirror #2 has an I/O error on</span>
<span class="cm">	 * the second page, but the first page is good.</span>
<span class="cm">	 * Then the first page of the first mirror can be repaired by</span>
<span class="cm">	 * taking the first page of the second mirror, and the</span>
<span class="cm">	 * second page of the second mirror can be repaired by</span>
<span class="cm">	 * copying the contents of the 2nd page of the 1st mirror.</span>
<span class="cm">	 * One more note: if the pages of one mirror contain I/O</span>
<span class="cm">	 * errors, the checksum cannot be verified. In order to get</span>
<span class="cm">	 * the best data for repairing, the first attempt is to find</span>
<span class="cm">	 * a mirror without I/O errors and with a validated checksum.</span>
<span class="cm">	 * Only if this is not possible, the pages are picked from</span>
<span class="cm">	 * mirrors with I/O errors without considering the checksum.</span>
<span class="cm">	 * If the latter is the case, at the end, the checksum of the</span>
<span class="cm">	 * repaired area is verified in order to correctly maintain</span>
<span class="cm">	 * the statistics.</span>
<span class="cm">	 */</span>

	<span class="n">sblocks_for_recheck</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">BTRFS_MAX_MIRRORS</span> <span class="o">*</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sblocks_for_recheck</span><span class="p">),</span>
				     <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sblocks_for_recheck</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">malloc_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">read_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">uncorrectable_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">BTRFS_DEV_STAT_READ_ERRS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup the context, map the logical blocks and alloc the pages */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_setup_recheck_block</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span>
					<span class="n">logical</span><span class="p">,</span> <span class="n">sblocks_for_recheck</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">read_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">uncorrectable_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">BTRFS_DEV_STAT_READ_ERRS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">failed_mirror_index</span> <span class="o">&gt;=</span> <span class="n">BTRFS_MAX_MIRRORS</span><span class="p">);</span>
	<span class="n">sblock_bad</span> <span class="o">=</span> <span class="n">sblocks_for_recheck</span> <span class="o">+</span> <span class="n">failed_mirror_index</span><span class="p">;</span>

	<span class="cm">/* build and submit the bios for the failed mirror, check checksums */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_recheck_block</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">sblock_bad</span><span class="p">,</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="n">have_csum</span><span class="p">,</span>
				  <span class="n">csum</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">read_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">uncorrectable_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">BTRFS_DEV_STAT_READ_ERRS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">header_error</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">checksum_error</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the error disappeared after reading page by page, or</span>
<span class="cm">		 * the area was part of a huge bio and other parts of the</span>
<span class="cm">		 * bio caused I/O errors, or the block layer merged several</span>
<span class="cm">		 * read requests into one and the error is caused by a</span>
<span class="cm">		 * different bio (usually one of the two latter cases is</span>
<span class="cm">		 * the cause)</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">unverified_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>

		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">read_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_rs</span><span class="p">))</span>
			<span class="n">scrub_print_warning</span><span class="p">(</span><span class="s">&quot;i/o error&quot;</span><span class="p">,</span> <span class="n">sblock_to_check</span><span class="p">);</span>
		<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">BTRFS_DEV_STAT_READ_ERRS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">checksum_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">csum_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_rs</span><span class="p">))</span>
			<span class="n">scrub_print_warning</span><span class="p">(</span><span class="s">&quot;checksum error&quot;</span><span class="p">,</span> <span class="n">sblock_to_check</span><span class="p">);</span>
		<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
					     <span class="n">BTRFS_DEV_STAT_CORRUPTION_ERRS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">header_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">verify_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">__ratelimit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">_rs</span><span class="p">))</span>
			<span class="n">scrub_print_warning</span><span class="p">(</span><span class="s">&quot;checksum/header error&quot;</span><span class="p">,</span>
					    <span class="n">sblock_to_check</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">generation_error</span><span class="p">)</span>
			<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">BTRFS_DEV_STAT_GENERATION_ERRS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">BTRFS_DEV_STAT_CORRUPTION_ERRS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">readonly</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">did_not_correct_error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_metadata</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">have_csum</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_fixup_nodatasum</span> <span class="o">*</span><span class="n">fixup_nodatasum</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * !is_metadata and !have_csum, this means that the data</span>
<span class="cm">		 * might not be COW&#39;ed, that it might be modified</span>
<span class="cm">		 * concurrently. The general strategy to work on the</span>
<span class="cm">		 * commit root does not help in the case when COW is not</span>
<span class="cm">		 * used.</span>
<span class="cm">		 */</span>
		<span class="n">fixup_nodatasum</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fixup_nodatasum</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fixup_nodatasum</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">did_not_correct_error</span><span class="p">;</span>
		<span class="n">fixup_nodatasum</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
		<span class="n">fixup_nodatasum</span><span class="o">-&gt;</span><span class="n">logical</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
		<span class="n">fixup_nodatasum</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
		<span class="n">fixup_nodatasum</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="n">failed_mirror_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * increment scrubs_running to prevent cancel requests from</span>
<span class="cm">		 * completing as long as a fixup worker is running. we must also</span>
<span class="cm">		 * increment scrubs_paused to prevent deadlocking on pause</span>
<span class="cm">		 * requests used for transactions commits (as the worker uses a</span>
<span class="cm">		 * transaction context). it is safe to regard the fixup worker</span>
<span class="cm">		 * as paused for all matters practical. effectively, we only</span>
<span class="cm">		 * avoid cancellation requests from completing.</span>
<span class="cm">		 */</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">fixup_cnt</span><span class="p">);</span>
		<span class="n">fixup_nodatasum</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">scrub_fixup_nodatasum</span><span class="p">;</span>
		<span class="n">btrfs_queue_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">fixup_nodatasum</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * now build and submit the bios for the other mirrors, check</span>
<span class="cm">	 * checksums</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mirror_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">mirror_index</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_MIRRORS</span> <span class="o">&amp;&amp;</span>
	     <span class="n">sblocks_for_recheck</span><span class="p">[</span><span class="n">mirror_index</span><span class="p">].</span><span class="n">page_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">mirror_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mirror_index</span> <span class="o">==</span> <span class="n">failed_mirror_index</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/* build and submit the bios, check checksums */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_recheck_block</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span>
					  <span class="n">sblocks_for_recheck</span> <span class="o">+</span> <span class="n">mirror_index</span><span class="p">,</span>
					  <span class="n">is_metadata</span><span class="p">,</span> <span class="n">have_csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span>
					  <span class="n">generation</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">did_not_correct_error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * first try to pick the mirror which is completely without I/O</span>
<span class="cm">	 * errors and also does not have a checksum error.</span>
<span class="cm">	 * If one is found, and if a checksum is present, the full block</span>
<span class="cm">	 * that is known to contain an error is rewritten. Afterwards</span>
<span class="cm">	 * the block is known to be corrected.</span>
<span class="cm">	 * If a mirror is found which is completely correct, and no</span>
<span class="cm">	 * checksum is present, only those pages are rewritten that had</span>
<span class="cm">	 * an I/O error in the block to be repaired, since it cannot be</span>
<span class="cm">	 * determined, which copy of the other pages is better (and it</span>
<span class="cm">	 * could happen otherwise that a correct page would be</span>
<span class="cm">	 * overwritten by a bad one).</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">mirror_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">mirror_index</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_MIRRORS</span> <span class="o">&amp;&amp;</span>
	     <span class="n">sblocks_for_recheck</span><span class="p">[</span><span class="n">mirror_index</span><span class="p">].</span><span class="n">page_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">mirror_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_other</span> <span class="o">=</span> <span class="n">sblocks_for_recheck</span> <span class="o">+</span>
						   <span class="n">mirror_index</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sblock_other</span><span class="o">-&gt;</span><span class="n">header_error</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">sblock_other</span><span class="o">-&gt;</span><span class="n">checksum_error</span> <span class="o">&amp;&amp;</span>
		    <span class="n">sblock_other</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">force_write</span> <span class="o">=</span> <span class="n">is_metadata</span> <span class="o">||</span> <span class="n">have_csum</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_repair_block_from_good_copy</span><span class="p">(</span><span class="n">sblock_bad</span><span class="p">,</span>
								<span class="n">sblock_other</span><span class="p">,</span>
								<span class="n">force_write</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">corrected_error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * in case of I/O errors in the area that is supposed to be</span>
<span class="cm">	 * repaired, continue by picking good copies of those pages.</span>
<span class="cm">	 * Select the good pages from mirrors to rewrite bad pages from</span>
<span class="cm">	 * the area to fix. Afterwards verify the checksum of the block</span>
<span class="cm">	 * that is supposed to be repaired. This verification step is</span>
<span class="cm">	 * only done for the purpose of statistic counting and for the</span>
<span class="cm">	 * final scrub report, whether errors remain.</span>
<span class="cm">	 * A perfect algorithm could make use of the checksum and try</span>
<span class="cm">	 * all possible combinations of pages from the different mirrors</span>
<span class="cm">	 * until the checksum verification succeeds. For example, when</span>
<span class="cm">	 * the 2nd page of mirror #1 faces I/O errors, and the 2nd page</span>
<span class="cm">	 * of mirror #2 is readable but the final checksum test fails,</span>
<span class="cm">	 * then the 2nd page of mirror #3 could be tried, whether now</span>
<span class="cm">	 * the final checksum succeedes. But this would be a rare</span>
<span class="cm">	 * exception and is therefore not implemented. At least it is</span>
<span class="cm">	 * avoided that the good copy is overwritten.</span>
<span class="cm">	 * A more useful improvement would be to pick the sectors</span>
<span class="cm">	 * without I/O error based on sector sizes (512 bytes on legacy</span>
<span class="cm">	 * disks) instead of on PAGE_SIZE. Then maybe 512 byte of one</span>
<span class="cm">	 * mirror could be repaired by taking 512 byte of a different</span>
<span class="cm">	 * mirror, even if other 512 byte sectors in the same PAGE_SIZE</span>
<span class="cm">	 * area are unreadable.</span>
<span class="cm">	 */</span>

	<span class="cm">/* can only fix I/O errors from here on */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">did_not_correct_error</span><span class="p">;</span>

	<span class="n">success</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_num</span> <span class="o">&lt;</span> <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">page_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">page_bad</span> <span class="o">=</span> <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span> <span class="n">page_num</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_bad</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">mirror_index</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_MIRRORS</span> <span class="o">&amp;&amp;</span>
		     <span class="n">sblocks_for_recheck</span><span class="p">[</span><span class="n">mirror_index</span><span class="p">].</span><span class="n">page_count</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
		     <span class="n">mirror_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_other</span> <span class="o">=</span> <span class="n">sblocks_for_recheck</span> <span class="o">+</span>
							   <span class="n">mirror_index</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">page_other</span> <span class="o">=</span> <span class="n">sblock_other</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span>
							<span class="n">page_num</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_other</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_repair_page_from_good_copy</span><span class="p">(</span>
					<span class="n">sblock_bad</span><span class="p">,</span> <span class="n">sblock_other</span><span class="p">,</span> <span class="n">page_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">page_bad</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span> <span class="cm">/* succeeded for this page */</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page_bad</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* did not find a mirror to copy the page from */</span>
			<span class="n">success</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">success</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_metadata</span> <span class="o">||</span> <span class="n">have_csum</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * need to verify the checksum now that all</span>
<span class="cm">			 * sectors on disk are repaired (the write</span>
<span class="cm">			 * request for data to be repaired is on its way).</span>
<span class="cm">			 * Just be lazy and use scrub_recheck_block()</span>
<span class="cm">			 * which re-reads the data before the checksum</span>
<span class="cm">			 * is verified, but most likely the data comes out</span>
<span class="cm">			 * of the page cache.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_recheck_block</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">sblock_bad</span><span class="p">,</span>
						  <span class="n">is_metadata</span><span class="p">,</span> <span class="n">have_csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span>
						  <span class="n">generation</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">header_error</span> <span class="o">&amp;&amp;</span>
			    <span class="o">!</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">checksum_error</span> <span class="o">&amp;&amp;</span>
			    <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">corrected_error</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="k">goto</span> <span class="n">did_not_correct_error</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">corrected_error:</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">corrected_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
			<span class="n">printk_ratelimited_in_rcu</span><span class="p">(</span><span class="n">KERN_ERR</span>
				<span class="s">&quot;btrfs: fixed up error at logical %llu on dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">logical</span><span class="p">,</span>
				<span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">did_not_correct_error:</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">uncorrectable_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">printk_ratelimited_in_rcu</span><span class="p">(</span><span class="n">KERN_ERR</span>
			<span class="s">&quot;btrfs: unable to fixup (regular) error at logical %llu on dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">logical</span><span class="p">,</span>
			<span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sblocks_for_recheck</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mirror_index</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_MIRRORS</span><span class="p">;</span>
		     <span class="n">mirror_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span> <span class="o">=</span> <span class="n">sblocks_for_recheck</span> <span class="o">+</span>
						     <span class="n">mirror_index</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">page_index</span><span class="p">;</span>

			<span class="k">for</span> <span class="p">(</span><span class="n">page_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_index</span> <span class="o">&lt;</span> <span class="n">SCRUB_PAGES_PER_BIO</span><span class="p">;</span>
			     <span class="n">page_index</span><span class="o">++</span><span class="p">)</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">page_index</span><span class="p">].</span><span class="n">page</span><span class="p">)</span>
					<span class="n">__free_page</span><span class="p">(</span>
						<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">page_index</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sblocks_for_recheck</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_setup_recheck_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_mapping_tree</span> <span class="o">*</span><span class="n">map_tree</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">length</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblocks_for_recheck</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mirror_index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * note: the three members sdev, ref_count and outstanding_pages</span>
<span class="cm">	 * are not used (and not set) in the blocks that are used for</span>
<span class="cm">	 * the recheck procedure</span>
<span class="cm">	 */</span>

	<span class="n">page_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">sublen</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="n">u64</span> <span class="n">mapped_length</span> <span class="o">=</span> <span class="n">sublen</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfs_bio</span> <span class="o">*</span><span class="n">bbio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * with a length of PAGE_SIZE, each returned stripe</span>
<span class="cm">		 * represents one mirror</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_map_block</span><span class="p">(</span><span class="n">map_tree</span><span class="p">,</span> <span class="n">WRITE</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mapped_length</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">bbio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">bbio</span> <span class="o">||</span> <span class="n">mapped_length</span> <span class="o">&lt;</span> <span class="n">sublen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">bbio</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">page_index</span> <span class="o">&gt;=</span> <span class="n">SCRUB_PAGES_PER_BIO</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">mirror_index</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">bbio</span><span class="o">-&gt;</span><span class="n">num_stripes</span><span class="p">;</span>
		     <span class="n">mirror_index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mirror_index</span> <span class="o">&gt;=</span> <span class="n">BTRFS_MAX_MIRRORS</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">sblock</span> <span class="o">=</span> <span class="n">sblocks_for_recheck</span> <span class="o">+</span> <span class="n">mirror_index</span><span class="p">;</span>
			<span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span> <span class="n">page_index</span><span class="p">;</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">logical</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">=</span> <span class="n">bbio</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="n">mirror_index</span><span class="p">].</span><span class="n">physical</span><span class="p">;</span>
			<span class="cm">/* for missing devices, dev-&gt;bdev is NULL */</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">bbio</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="n">mirror_index</span><span class="p">].</span><span class="n">dev</span><span class="p">;</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="n">mirror_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
				<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">malloc_errors</span><span class="o">++</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bbio</span><span class="p">);</span>
		<span class="n">length</span> <span class="o">-=</span> <span class="n">sublen</span><span class="p">;</span>
		<span class="n">logical</span> <span class="o">+=</span> <span class="n">sublen</span><span class="p">;</span>
		<span class="n">page_index</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this function will check the on disk data for checksum errors, header</span>
<span class="cm"> * errors and read I/O errors. If any I/O errors happen, the exact pages</span>
<span class="cm"> * which are errored are marked as being bad. The goal is to enable scrub</span>
<span class="cm"> * to take those pages that are not errored from all the mirrors so that</span>
<span class="cm"> * the pages that are errored in the just handled mirror can be repaired.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_recheck_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">have_csum</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">generation</span><span class="p">,</span>
			       <span class="n">u16</span> <span class="n">csum_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_num</span><span class="p">;</span>

	<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">header_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">checksum_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_num</span> <span class="o">&lt;</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">page_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span> <span class="n">page_num</span><span class="p">;</span>
		<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">complete</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">);</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">scrub_complete_bio_end_io</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">complete</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfsic_submit_bio</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

		<span class="cm">/* this will also unplug the queue */</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">complete</span><span class="p">);</span>

		<span class="n">page</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">))</span>
			<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span><span class="p">)</span>
		<span class="n">scrub_recheck_block_checksum</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">sblock</span><span class="p">,</span> <span class="n">is_metadata</span><span class="p">,</span>
					     <span class="n">have_csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span>
					     <span class="n">csum_size</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_recheck_block_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span> <span class="kt">int</span> <span class="n">have_csum</span><span class="p">,</span>
					 <span class="k">const</span> <span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">generation</span><span class="p">,</span>
					 <span class="n">u16</span> <span class="n">csum_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_num</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">calculated_csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">crc</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mapped_buffer</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">is_metadata</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>

		<span class="n">mapped_buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
		<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span><span class="n">mapped_buffer</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">logical</span> <span class="o">!=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">memcmp</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">BTRFS_UUID_SIZE</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">memcmp</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span>
			   <span class="n">BTRFS_UUID_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">header_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">header_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">generation_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">csum</span> <span class="o">=</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">have_csum</span><span class="p">)</span>
			<span class="k">return</span><span class="p">;</span>

		<span class="n">mapped_buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;;)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">is_metadata</span><span class="p">)</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">btrfs_csum_data</span><span class="p">(</span><span class="n">root</span><span class="p">,</span>
				<span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">mapped_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">,</span>
				<span class="n">crc</span><span class="p">,</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">crc</span> <span class="o">=</span> <span class="n">btrfs_csum_data</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">mapped_buffer</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span>
					      <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">mapped_buffer</span><span class="p">);</span>
		<span class="n">page_num</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">&gt;=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">page_num</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>

		<span class="n">mapped_buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">page_num</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_csum_final</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">calculated_csum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">calculated_csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="n">csum_size</span><span class="p">))</span>
		<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">checksum_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_complete_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_repair_block_from_good_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_bad</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_good</span><span class="p">,</span>
					     <span class="kt">int</span> <span class="n">force_write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">page_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">page_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">page_num</span> <span class="o">&lt;</span> <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">page_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret_sub</span><span class="p">;</span>

		<span class="n">ret_sub</span> <span class="o">=</span> <span class="n">scrub_repair_page_from_good_copy</span><span class="p">(</span><span class="n">sblock_bad</span><span class="p">,</span>
							   <span class="n">sblock_good</span><span class="p">,</span>
							   <span class="n">page_num</span><span class="p">,</span>
							   <span class="n">force_write</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret_sub</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ret_sub</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_repair_page_from_good_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_bad</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock_good</span><span class="p">,</span>
					    <span class="kt">int</span> <span class="n">page_num</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_write</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">page_bad</span> <span class="o">=</span> <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span> <span class="n">page_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">page_good</span> <span class="o">=</span> <span class="n">sblock_good</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span> <span class="n">page_num</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">page_num</span><span class="p">].</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock_good</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">page_num</span><span class="p">].</span><span class="n">page</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">force_write</span> <span class="o">||</span> <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">header_error</span> <span class="o">||</span>
	    <span class="n">sblock_bad</span><span class="o">-&gt;</span><span class="n">checksum_error</span> <span class="o">||</span> <span class="n">page_bad</span><span class="o">-&gt;</span><span class="n">io_error</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">complete</span><span class="p">);</span>

		<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">page_bad</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">page_bad</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">scrub_complete_bio_end_io</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">complete</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">page_good</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_SIZE</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfsic_submit_bio</span><span class="p">(</span><span class="n">WRITE</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

		<span class="cm">/* this will also unplug the queue */</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">complete</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio_flagged</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">BIO_UPTODATE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">page_bad</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">BTRFS_DEV_STAT_WRITE_ERRS</span><span class="p">);</span>
			<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_checksum</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_checksum_data</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_checksum_tree_block</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_SUPER</span><span class="p">)</span>
		<span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">scrub_checksum_super</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">scrub_handle_errored_block</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_checksum_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="o">*</span><span class="n">on_disk_csum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">have_csum</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">on_disk_csum</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">csum</span><span class="p">;</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page</span><span class="p">;</span>
	<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">l</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">crc</span> <span class="o">=</span> <span class="n">btrfs_csum_data</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">buffer</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">page</span><span class="p">;</span>
		<span class="n">buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_csum_final</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="n">on_disk_csum</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">))</span>
		<span class="n">fail</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_checksum_tree_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">calculated_csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">on_disk_csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mapped_buffer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mapped_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">crc_fail</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page</span><span class="p">;</span>
	<span class="n">mapped_buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span><span class="n">mapped_buffer</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">on_disk_csum</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t use the getter functions here, as we</span>
<span class="cm">	 * a) don&#39;t have an extent buffer and</span>
<span class="cm">	 * b) the page is already kmapped</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">logical</span> <span class="o">!=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">BTRFS_UUID_SIZE</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span>
		   <span class="n">BTRFS_UUID_SIZE</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">!=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">-</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">;</span>
	<span class="n">mapped_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">mapped_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">l</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mapped_size</span><span class="p">);</span>

		<span class="n">crc</span> <span class="o">=</span> <span class="n">btrfs_csum_data</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">mapped_buffer</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">page</span><span class="p">;</span>
		<span class="n">mapped_buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">mapped_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">mapped_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_csum_final</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">calculated_csum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">calculated_csum</span><span class="p">,</span> <span class="n">on_disk_csum</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">))</span>
		<span class="o">++</span><span class="n">crc_fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">fail</span> <span class="o">||</span> <span class="n">crc_fail</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_checksum_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">calculated_csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="n">u8</span> <span class="n">on_disk_csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mapped_buffer</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mapped_size</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">crc</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">fail_cor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">page</span><span class="p">;</span>
	<span class="n">mapped_buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="p">)</span><span class="n">mapped_buffer</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">on_disk_csum</span><span class="p">,</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">logical</span> <span class="o">!=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail_cor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">generation</span> <span class="o">!=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail_gen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">BTRFS_UUID_SIZE</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail_cor</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">BTRFS_SUPER_INFO_SIZE</span> <span class="o">-</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">;</span>
	<span class="n">mapped_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span> <span class="o">-</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">;</span>
	<span class="n">p</span> <span class="o">=</span> <span class="p">((</span><span class="n">u8</span> <span class="o">*</span><span class="p">)</span><span class="n">mapped_buffer</span><span class="p">)</span> <span class="o">+</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">l</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">mapped_size</span><span class="p">);</span>

		<span class="n">crc</span> <span class="o">=</span> <span class="n">btrfs_csum_data</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">crc</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">mapped_buffer</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">index</span><span class="o">++</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">page</span><span class="p">;</span>
		<span class="n">mapped_buffer</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">mapped_size</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="n">p</span> <span class="o">=</span> <span class="n">mapped_buffer</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_csum_final</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">calculated_csum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">calculated_csum</span><span class="p">,</span> <span class="n">on_disk_csum</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">))</span>
		<span class="o">++</span><span class="n">fail_cor</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fail_cor</span> <span class="o">+</span> <span class="n">fail_gen</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if we find an error in a super block, we just report it.</span>
<span class="cm">		 * They will get written with the next transaction commit</span>
<span class="cm">		 * anyway</span>
<span class="cm">		 */</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="o">++</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">super_errors</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">fail_cor</span><span class="p">)</span>
			<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">BTRFS_DEV_STAT_CORRUPTION_ERRS</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">btrfs_dev_stat_inc_and_print</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">,</span>
				<span class="n">BTRFS_DEV_STAT_GENERATION_ERRS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">fail_cor</span> <span class="o">+</span> <span class="n">fail_gen</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_block_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_block_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page</span><span class="p">)</span>
				<span class="n">__free_page</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="o">*</span><span class="n">sbio</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">sbio</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">];</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">);</span>

	<span class="n">btrfsic_submit_bio</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_add_page_to_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">spage</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span> <span class="o">=</span> <span class="n">spage</span><span class="o">-&gt;</span><span class="n">sblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="o">*</span><span class="n">sbio</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * grab a fresh bio or wait for one to become available</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_free</span><span class="p">;</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">next_free</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">sbio</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">bios</span><span class="p">[</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">curr</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>

		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">=</span> <span class="n">spage</span><span class="o">-&gt;</span><span class="n">physical</span><span class="p">;</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">logical</span> <span class="o">=</span> <span class="n">spage</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">;</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">pages_per_bio</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">sbio</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">scrub_bio_end_io</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">spage</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">+</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span>
		   <span class="n">spage</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">||</span>
		   <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">logical</span> <span class="o">+</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">*</span> <span class="n">PAGE_SIZE</span> <span class="o">!=</span>
		   <span class="n">spage</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">scrub_submit</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">]</span> <span class="o">=</span> <span class="n">spage</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">,</span> <span class="n">spage</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bio_put</span><span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>
			<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">scrub_submit</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">scrub_block_get</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span> <span class="cm">/* one for the added page */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">outstanding_pages</span><span class="p">);</span>
	<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="o">++</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">==</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">pages_per_bio</span><span class="p">)</span>
		<span class="n">scrub_submit</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span>
		       <span class="n">u64</span> <span class="n">physical</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span>
		       <span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>

	<span class="n">sblock</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sblock</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">malloc_errors</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* one ref inside this function, plus one for each page later on */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">ref_count</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>
	<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">spage</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">l</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">PAGE_SIZE</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">SCRUB_MAX_PAGES_PER_BLOCK</span><span class="p">);</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">spage</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
			<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">malloc_errors</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">index</span><span class="o">--</span><span class="p">;</span>
				<span class="n">__free_page</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">index</span><span class="p">].</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">sblock</span> <span class="o">=</span> <span class="n">sblock</span><span class="p">;</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">gen</span><span class="p">;</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">logical</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">physical</span> <span class="o">=</span> <span class="n">physical</span><span class="p">;</span>
		<span class="n">spage</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="n">mirror_num</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">csum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spage</span><span class="o">-&gt;</span><span class="n">have_csum</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">spage</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spage</span><span class="o">-&gt;</span><span class="n">have_csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="o">++</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">logical</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">physical</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">spage</span> <span class="o">=</span> <span class="n">sblock</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">+</span> <span class="n">index</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_add_page_to_bio</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">spage</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">scrub_block_put</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">force</span><span class="p">)</span>
		<span class="n">scrub_submit</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

	<span class="cm">/* last one frees, either here or in bio completion for last page */</span>
	<span class="n">scrub_block_put</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="o">*</span><span class="n">sbio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">err</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>

	<span class="n">btrfs_queue_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_bio_end_io_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_bio</span> <span class="o">*</span><span class="n">sbio</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">scrub_bio</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">sdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span> <span class="o">&gt;</span> <span class="n">SCRUB_PAGES_PER_BIO</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">spage</span> <span class="o">=</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

			<span class="n">spage</span><span class="o">-&gt;</span><span class="n">io_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">spage</span><span class="o">-&gt;</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* now complete the scrub_block items that have all pages completed */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">scrub_page</span> <span class="o">*</span><span class="n">spage</span> <span class="o">=</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span> <span class="o">=</span> <span class="n">spage</span><span class="o">-&gt;</span><span class="n">sblock</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">outstanding_pages</span><span class="p">))</span>
			<span class="n">scrub_block_complete</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
		<span class="n">scrub_block_put</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* what is this good for??? */</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BIO_POOL_MASK</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span> <span class="o">|=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">BIO_UPTODATE</span><span class="p">;</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_phys_segments</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">page_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bi</span><span class="p">;</span>
			<span class="n">bi</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bv_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">bi</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">=</span> <span class="n">PAGE_SIZE</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">bio_put</span><span class="p">(</span><span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span><span class="p">);</span>
	<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">sbio</span><span class="o">-&gt;</span><span class="n">next_free</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">first_free</span><span class="p">;</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">first_free</span> <span class="o">=</span> <span class="n">sbio</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_lock</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">scrub_block_complete</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_block</span> <span class="o">*</span><span class="n">sblock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sblock</span><span class="o">-&gt;</span><span class="n">no_io_error_seen</span><span class="p">)</span>
		<span class="n">scrub_handle_errored_block</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">scrub_checksum</span><span class="p">(</span><span class="n">sblock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_find_csum</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span>
			   <span class="n">u8</span> <span class="o">*</span><span class="n">csum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_sum</span> <span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_sectors</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_list</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfs_ordered_sum</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">bytenr</span> <span class="o">&gt;</span> <span class="n">logical</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">bytenr</span> <span class="o">+</span> <span class="n">sum</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">logical</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="o">++</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">csum_discards</span><span class="p">;</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
		<span class="n">sum</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sum</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">num_sectors</span> <span class="o">=</span> <span class="n">sum</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">/</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_sectors</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bytenr</span> <span class="o">==</span> <span class="n">logical</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">sums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sum</span><span class="p">,</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">==</span> <span class="n">num_sectors</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* scrub extent tries to collect up to 64 kB for each bio */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">scrub_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">physical</span><span class="p">,</span> <span class="n">u64</span> <span class="n">flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">blocksize</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">blocksize</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">data_extents_scrubbed</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">data_bytes_scrubbed</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">!=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">);</span>
		<span class="n">blocksize</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">tree_extents_scrubbed</span><span class="o">++</span><span class="p">;</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">tree_bytes_scrubbed</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">blocksize</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">l</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="kt">int</span> <span class="n">have_csum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* push csums to sbio */</span>
			<span class="n">have_csum</span> <span class="o">=</span> <span class="n">scrub_find_csum</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">have_csum</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="o">++</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">no_csum</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_pages</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">physical</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span>
				  <span class="n">mirror_num</span><span class="p">,</span> <span class="n">have_csum</span> <span class="o">?</span> <span class="n">csum</span> <span class="o">:</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">logical</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
		<span class="n">physical</span> <span class="o">+=</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">int</span> <span class="nf">scrub_stripe</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
	<span class="k">struct</span> <span class="n">map_lookup</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">,</span> <span class="n">u64</span> <span class="n">base</span><span class="p">,</span> <span class="n">u64</span> <span class="n">length</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">csum_root</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">csum_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">extent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">blk_plug</span> <span class="n">plug</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nstripes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">physical</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">logical</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reada_control</span> <span class="o">*</span><span class="n">reada1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">reada_control</span> <span class="o">*</span><span class="n">reada2</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key_start</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key_end</span><span class="p">;</span>

	<span class="n">u64</span> <span class="n">increment</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">nstripes</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">do_div</span><span class="p">(</span><span class="n">nstripes</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span> <span class="o">*</span> <span class="n">num</span><span class="p">;</span>
		<span class="n">increment</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span> <span class="o">*</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">num_stripes</span><span class="p">;</span>
		<span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID10</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">num_stripes</span> <span class="o">/</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">sub_stripes</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span> <span class="o">*</span> <span class="p">(</span><span class="n">num</span> <span class="o">/</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">sub_stripes</span><span class="p">);</span>
		<span class="n">increment</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span> <span class="o">*</span> <span class="n">factor</span><span class="p">;</span>
		<span class="n">mirror_num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">sub_stripes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_RAID1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">increment</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">;</span>
		<span class="n">mirror_num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">num_stripes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_GROUP_DUP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">increment</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">;</span>
		<span class="n">mirror_num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">%</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">num_stripes</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">increment</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">;</span>
		<span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * work on commit root. The related disk blocks are static as</span>
<span class="cm">	 * long as COW is applied. This means, it is save to rewrite</span>
<span class="cm">	 * them to repair disk errors without any race conditions</span>
<span class="cm">	 */</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * trigger the readahead for extent tree csum tree and wait for</span>
<span class="cm">	 * completion. During readahead, the scrub is officially paused</span>
<span class="cm">	 * to not hold off transaction commits</span>
<span class="cm">	 */</span>
	<span class="n">logical</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">,</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">);</span>

	<span class="cm">/* FIXME it might be better to start readahead at commit root */</span>
	<span class="n">key_start</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
	<span class="n">key_start</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key_start</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">key_end</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">nstripes</span> <span class="o">*</span> <span class="n">increment</span><span class="p">;</span>
	<span class="n">key_end</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key_end</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="n">reada1</span> <span class="o">=</span> <span class="n">btrfs_reada_add</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_end</span><span class="p">);</span>

	<span class="n">key_start</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_CSUM_OBJECTID</span><span class="p">;</span>
	<span class="n">key_start</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_CSUM_KEY</span><span class="p">;</span>
	<span class="n">key_start</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
	<span class="n">key_end</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_CSUM_OBJECTID</span><span class="p">;</span>
	<span class="n">key_end</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_CSUM_KEY</span><span class="p">;</span>
	<span class="n">key_end</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">nstripes</span> <span class="o">*</span> <span class="n">increment</span><span class="p">;</span>
	<span class="n">reada2</span> <span class="o">=</span> <span class="n">btrfs_reada_add</span><span class="p">(</span><span class="n">csum_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_end</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">reada1</span><span class="p">))</span>
		<span class="n">btrfs_reada_wait</span><span class="p">(</span><span class="n">reada1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">reada2</span><span class="p">))</span>
		<span class="n">btrfs_reada_wait</span><span class="p">(</span><span class="n">reada2</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_req</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">,</span>
		   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_req</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * collect all data csums for the stripe to avoid seeking during</span>
<span class="cm">	 * the scrub. This might currently (crc32) end up to be about 1MB</span>
<span class="cm">	 */</span>
	<span class="n">blk_start_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * now find all extents for each stripe and scrub them</span>
<span class="cm">	 */</span>
	<span class="n">logical</span> <span class="o">=</span> <span class="n">base</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">physical</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="n">num</span><span class="p">].</span><span class="n">physical</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nstripes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * canceled?</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_cancel_req</span><span class="p">)</span> <span class="o">||</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">cancel_req</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ECANCELED</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * check to see if we have to pause</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_req</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* push queued extents */</span>
			<span class="n">scrub_submit</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">,</span>
				   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">);</span>
			<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_req</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
				<span class="n">wait_event</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">,</span>
				   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_req</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
			<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_csums_range</span><span class="p">(</span><span class="n">csum_root</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
					       <span class="n">logical</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">csum_list</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_previous_item</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						  <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* there&#39;s no smaller item, so stick with the</span>
<span class="cm">				 * larger one */</span>
				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
							<span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">l</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">logical</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;=</span> <span class="n">logical</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

			<span class="n">extent</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_extent_flags</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">extent</span><span class="p">);</span>
			<span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_extent_generation</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">extent</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">logical</span> <span class="o">&amp;&amp;</span>
			    <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
				       <span class="s">&quot;btrfs scrub: tree block %llu spanning &quot;</span>
				       <span class="s">&quot;stripes, ignored. logical=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">logical</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/*</span>
<span class="cm">			 * trim extent to this stripe</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">logical</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-=</span> <span class="n">logical</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
				<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span>
			    <span class="n">logical</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">logical</span> <span class="o">+</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span> <span class="o">-</span>
					     <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_extent</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
					   <span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">-</span> <span class="n">logical</span> <span class="o">+</span> <span class="n">physical</span><span class="p">,</span>
					   <span class="n">flags</span><span class="p">,</span> <span class="n">generation</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">next:</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">logical</span> <span class="o">+=</span> <span class="n">increment</span><span class="p">;</span>
		<span class="n">physical</span> <span class="o">+=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripe_len</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
		<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">.</span><span class="n">last_physical</span> <span class="o">=</span> <span class="n">physical</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/* push queued extents */</span>
	<span class="n">scrub_submit</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="n">blk_finish_plug</span><span class="p">(</span><span class="o">&amp;</span><span class="n">plug</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">int</span> <span class="nf">scrub_chunk</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span>
	<span class="n">u64</span> <span class="n">chunk_tree</span><span class="p">,</span> <span class="n">u64</span> <span class="n">chunk_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">chunk_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">length</span><span class="p">,</span>
	<span class="n">u64</span> <span class="n">dev_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_mapping_tree</span> <span class="o">*</span><span class="n">map_tree</span> <span class="o">=</span>
		<span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">map_lookup</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_tree</span><span class="o">-&gt;</span><span class="n">map_tree</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">em</span> <span class="o">=</span> <span class="n">lookup_extent_mapping</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_tree</span><span class="o">-&gt;</span><span class="n">map_tree</span><span class="p">,</span> <span class="n">chunk_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">map_tree</span><span class="o">-&gt;</span><span class="n">map_tree</span><span class="p">.</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">map_lookup</span> <span class="o">*</span><span class="p">)</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">!=</span> <span class="n">chunk_offset</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">length</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">num_stripes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">dev</span> <span class="o">==</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">&amp;&amp;</span>
		    <span class="n">map</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">physical</span> <span class="o">==</span> <span class="n">dev_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_stripe</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">chunk_offset</span><span class="p">,</span> <span class="n">length</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span>
<span class="kt">int</span> <span class="nf">scrub_enumerate_chunks</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_dev_extent</span> <span class="o">*</span><span class="n">dev_extent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">chunk_tree</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">chunk_objectid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">chunk_offset</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">cache</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devid</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0ull</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_DEV_EXTENT_KEY</span><span class="p">;</span>


	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span>
			    <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">l</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">devid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_DEV_EXTENT_KEY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">dev_extent</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_dev_extent</span><span class="p">);</span>
		<span class="n">length</span> <span class="o">=</span> <span class="n">btrfs_dev_extent_length</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">dev_extent</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">chunk_tree</span> <span class="o">=</span> <span class="n">btrfs_dev_extent_chunk_tree</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">dev_extent</span><span class="p">);</span>
		<span class="n">chunk_objectid</span> <span class="o">=</span> <span class="n">btrfs_dev_extent_chunk_objectid</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">dev_extent</span><span class="p">);</span>
		<span class="n">chunk_offset</span> <span class="o">=</span> <span class="n">btrfs_dev_extent_chunk_offset</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">dev_extent</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * get a reference on the corresponding block group to prevent</span>
<span class="cm">		 * the chunk from going away while we scrub it</span>
<span class="cm">		 */</span>
		<span class="n">cache</span> <span class="o">=</span> <span class="n">btrfs_lookup_block_group</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">chunk_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_chunk</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">chunk_tree</span><span class="p">,</span> <span class="n">chunk_objectid</span><span class="p">,</span>
				  <span class="n">chunk_offset</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">btrfs_put_block_group</span><span class="p">(</span><span class="n">cache</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">length</span><span class="p">;</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * ret can still be 1 from search_slot or next_leaf,</span>
<span class="cm">	 * that&#39;s not an error</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">ret</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">int</span> <span class="nf">scrub_supers</span><span class="p">(</span><span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span>	<span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">bytenr</span><span class="p">;</span>
	<span class="n">u64</span>	<span class="n">gen</span><span class="p">;</span>
	<span class="kt">int</span>	<span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="n">sdev</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">dev_root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_state</span> <span class="o">&amp;</span> <span class="n">BTRFS_SUPER_FLAG_ERROR</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>

	<span class="n">gen</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">last_trans_committed</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_SUPER_MIRROR_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_sb_offset</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytenr</span> <span class="o">+</span> <span class="n">BTRFS_SUPER_INFO_SIZE</span> <span class="o">&gt;</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_pages</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">BTRFS_SUPER_INFO_SIZE</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
				     <span class="n">BTRFS_EXTENT_FLAG_SUPER</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wait_event</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get a reference count on fs_info-&gt;scrub_workers. start worker if necessary</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">int</span> <span class="nf">scrub_workers_get</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers_refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_init_workers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers</span><span class="p">,</span> <span class="s">&quot;scrub&quot;</span><span class="p">,</span>
			   <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">thread_pool_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">generic_worker</span><span class="p">);</span>
		<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers</span><span class="p">.</span><span class="n">idle_thresh</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_start_workers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">++</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers_refcnt</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline_for_stack</span> <span class="kt">void</span> <span class="nf">scrub_workers_put</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">--</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers_refcnt</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">btrfs_stop_workers</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_workers_refcnt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">btrfs_scrub_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">devid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">btrfs_scrub_progress</span> <span class="o">*</span><span class="n">progress</span><span class="p">,</span> <span class="kt">int</span> <span class="n">readonly</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_fs_closing</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check some assumptions</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;btrfs_scrub: size assumption nodesize == leafsize (%d == %d) fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">&gt;</span> <span class="n">BTRFS_STRIPE_LEN</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * in this case scrub is unable to calculate the checksum</span>
<span class="cm">		 * the way scrub is implemented. Do not handle this</span>
<span class="cm">		 * situation at all because it won&#39;t ever happen.</span>
<span class="cm">		 */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;btrfs_scrub: size assumption nodesize &lt;= BTRFS_STRIPE_LEN (%d &lt;= %d) fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">,</span> <span class="n">BTRFS_STRIPE_LEN</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">!=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not supported for data w/o checksums */</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span>
		       <span class="s">&quot;btrfs_scrub: size assumption sectorsize != PAGE_SIZE (%d != %lld) fails</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_workers_get</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">btrfs_find_device</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">devid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span> <span class="o">||</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">missing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
		<span class="n">scrub_workers_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">in_fs_metadata</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
		<span class="n">scrub_workers_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scrub_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
		<span class="n">scrub_workers_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">scrub_setup_dev</span><span class="p">(</span><span class="n">dev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sdev</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
		<span class="n">scrub_workers_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">sdev</span><span class="o">-&gt;</span><span class="n">readonly</span> <span class="o">=</span> <span class="n">readonly</span><span class="p">;</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">scrub_device</span> <span class="o">=</span> <span class="n">sdev</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_super_lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_supers</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_super_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">scrub_enumerate_chunks</span><span class="p">(</span><span class="n">sdev</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">in_flight</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">);</span>

	<span class="n">wait_event</span><span class="p">(</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">list_wait</span><span class="p">,</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">fixup_cnt</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">progress</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">progress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">progress</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="n">dev</span><span class="o">-&gt;</span><span class="n">scrub_device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>

	<span class="n">scrub_free_dev</span><span class="p">(</span><span class="n">sdev</span><span class="p">);</span>
	<span class="n">scrub_workers_put</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_scrub_pause</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_req</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">)</span> <span class="o">!=</span>
	       <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">,</span>
			   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_paused</span><span class="p">)</span> <span class="o">==</span>
			   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">));</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_scrub_continue</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_req</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_scrub_pause_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_super_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_scrub_continue_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_super_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">__btrfs_scrub_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_cancel_req</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">,</span>
			   <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrubs_running</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_cancel_req</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_scrub_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_scrub_cancel</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_scrub_cancel_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="n">sdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scrub_device</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sdev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">cancel_req</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">scrub_device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_pause_wait</span><span class="p">,</span>
			   <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scrub_device</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">scrub_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_scrub_cancel_devid</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">devid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we have to hold the device_list_mutex here so the device</span>
<span class="cm">	 * does not go away in cancel_dev. FIXME: find a better solution</span>
<span class="cm">	 */</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">btrfs_find_device</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">devid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_scrub_cancel_dev</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">dev</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_scrub_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">devid</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_scrub_progress</span> <span class="o">*</span><span class="n">progress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">scrub_dev</span> <span class="o">*</span><span class="n">sdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">btrfs_find_device</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">devid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="p">)</span>
		<span class="n">sdev</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">scrub_device</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sdev</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">progress</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sdev</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">progress</span><span class="p">));</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dev</span> <span class="o">?</span> <span class="p">(</span><span class="n">sdev</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">)</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
