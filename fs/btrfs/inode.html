<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › inode.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>inode.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/statfs.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/posix_acl.h&gt;</span>
<span class="cp">#include &lt;linux/falloc.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &quot;compat.h&quot;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;btrfs_inode.h&quot;</span>
<span class="cp">#include &quot;ioctl.h&quot;</span>
<span class="cp">#include &quot;print-tree.h&quot;</span>
<span class="cp">#include &quot;ordered-data.h&quot;</span>
<span class="cp">#include &quot;xattr.h&quot;</span>
<span class="cp">#include &quot;tree-log.h&quot;</span>
<span class="cp">#include &quot;volumes.h&quot;</span>
<span class="cp">#include &quot;compression.h&quot;</span>
<span class="cp">#include &quot;locking.h&quot;</span>
<span class="cp">#include &quot;free-space-cache.h&quot;</span>
<span class="cp">#include &quot;inode-map.h&quot;</span>

<span class="k">struct</span> <span class="n">btrfs_iget_args</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_dir_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_symlink_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_dir_ro_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_special_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_file_inode_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">btrfs_aops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">btrfs_symlink_aops</span><span class="p">;</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">btrfs_dir_file_operations</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">extent_io_ops</span> <span class="n">btrfs_extent_io_ops</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">btrfs_inode_cachep</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">btrfs_trans_handle_cachep</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">btrfs_transaction_cachep</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">btrfs_path_cachep</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">btrfs_free_space_cachep</span><span class="p">;</span>

<span class="cp">#define S_SHIFT 12</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">btrfs_type_by_mode</span><span class="p">[</span><span class="n">S_IFMT</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="n">S_IFREG</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">BTRFS_FT_REG_FILE</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFDIR</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">BTRFS_FT_DIR</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFCHR</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">BTRFS_FT_CHRDEV</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFBLK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">BTRFS_FT_BLKDEV</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFIFO</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">BTRFS_FT_FIFO</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFSOCK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">BTRFS_FT_SOCK</span><span class="p">,</span>
	<span class="p">[</span><span class="n">S_IFLNK</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">]</span>	<span class="o">=</span> <span class="n">BTRFS_FT_SYMLINK</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfs_setsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfs_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfs_finish_ordered_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered_extent</span><span class="p">);</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="n">cow_file_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">page_started</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_written</span><span class="p">,</span> <span class="kt">int</span> <span class="n">unlock</span><span class="p">);</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="n">btrfs_update_inode_fallback</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">);</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_init_inode_security</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>  <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				     <span class="k">const</span> <span class="k">struct</span> <span class="n">qstr</span> <span class="o">*</span><span class="n">qstr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_init_acl</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_xattr_security_init</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">qstr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this does all the hard work for inserting an inline extent into</span>
<span class="cm"> * the btree.  The caller should have done a btrfs_drop_extents so that</span>
<span class="cm"> * no overlapping inline items exist in the btree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">insert_inline_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">compressed_size</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">compress_type</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">compressed_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">cur_size</span> <span class="o">=</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">datasize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">compressed_size</span> <span class="o">&amp;&amp;</span> <span class="n">compressed_pages</span><span class="p">)</span>
		<span class="n">cur_size</span> <span class="o">=</span> <span class="n">compressed_size</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">);</span>
	<span class="n">datasize</span> <span class="o">=</span> <span class="n">btrfs_file_extent_calc_inline_size</span><span class="p">(</span><span class="n">cur_size</span><span class="p">);</span>

	<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
				      <span class="n">datasize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_encryption</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_other_encoding</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_ram_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_inline_start</span><span class="p">(</span><span class="n">ei</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">compress_type</span> <span class="o">!=</span> <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">cpage</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">compressed_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cpage</span> <span class="o">=</span> <span class="n">compressed_pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">cur_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">compressed_size</span><span class="p">,</span>
				       <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>

			<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">cpage</span><span class="p">);</span>
			<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">kaddr</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">cur_size</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>

			<span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ptr</span> <span class="o">+=</span> <span class="n">cur_size</span><span class="p">;</span>
			<span class="n">compressed_size</span> <span class="o">-=</span> <span class="n">cur_size</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_set_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span>
						  <span class="n">compress_type</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">find_get_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
				     <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
		<span class="n">btrfs_set_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we&#39;re an inline extent, so nobody can</span>
<span class="cm">	 * extend the file past i_size without locking</span>
<span class="cm">	 * a page we already have locked.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We must do any isize and inode updates</span>
<span class="cm">	 * before we unlock the pages.  Otherwise we</span>
<span class="cm">	 * could end up racing with unlink.</span>
<span class="cm">	 */</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * conditionally insert an inline extent into the file.  This</span>
<span class="cm"> * does the checks required to make sure the data is small enough</span>
<span class="cm"> * to fit as an inline extent.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">cow_file_range_inline</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
				 <span class="kt">size_t</span> <span class="n">compressed_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">compress_type</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">compressed_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">actual_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">isize</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">inline_len</span> <span class="o">=</span> <span class="n">actual_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">aligned_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">hint_byte</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">data_len</span> <span class="o">=</span> <span class="n">inline_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">compressed_size</span><span class="p">)</span>
		<span class="n">data_len</span> <span class="o">=</span> <span class="n">compressed_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span>
	    <span class="n">actual_end</span> <span class="o">&gt;=</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">||</span>
	    <span class="n">data_len</span> <span class="o">&gt;=</span> <span class="n">BTRFS_MAX_INLINE_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="o">!</span><span class="n">compressed_size</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">actual_end</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">isize</span> <span class="o">||</span>
	    <span class="n">data_len</span> <span class="o">&gt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">max_inline</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_drop_extents</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">aligned_end</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">hint_byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isize</span> <span class="o">&gt;</span> <span class="n">actual_end</span><span class="p">)</span>
		<span class="n">inline_len</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">isize</span><span class="p">,</span> <span class="n">actual_end</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_inline_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
				   <span class="n">inline_len</span><span class="p">,</span> <span class="n">compressed_size</span><span class="p">,</span>
				   <span class="n">compress_type</span><span class="p">,</span> <span class="n">compressed_pages</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_delalloc_release_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">aligned_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">async_extent</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ram_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">compressed_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compress_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">async_cow</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">extents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_work</span> <span class="n">work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">add_async_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">async_cow</span> <span class="o">*</span><span class="n">cow</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ram_size</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">compressed_size</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
				     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">compress_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_extent</span> <span class="o">*</span><span class="n">async_extent</span><span class="p">;</span>

	<span class="n">async_extent</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">async_extent</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">async_extent</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">=</span> <span class="n">ram_size</span><span class="p">;</span>
	<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">compressed_size</span> <span class="o">=</span> <span class="n">compressed_size</span><span class="p">;</span>
	<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="n">pages</span><span class="p">;</span>
	<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">compress_type</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cow</span><span class="o">-&gt;</span><span class="n">extents</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * we create compressed extents in two phases.  The first</span>
<span class="cm"> * phase compresses a range of pages that have already been</span>
<span class="cm"> * locked (both pages and state bits are locked).</span>
<span class="cm"> *</span>
<span class="cm"> * This is done inside an ordered work queue, and the compression</span>
<span class="cm"> * is spread across many cpus.  The actual IO submission is step</span>
<span class="cm"> * two, and the ordered work queue takes care of making sure that</span>
<span class="cm"> * happens in the same order things were put onto the queue by</span>
<span class="cm"> * writepages and friends.</span>
<span class="cm"> *</span>
<span class="cm"> * If this code finds it can&#39;t get good compression, it puts an</span>
<span class="cm"> * entry onto the work queue to write the uncompressed bytes.  This</span>
<span class="cm"> * makes sure that both compressed inodes and uncompressed inodes</span>
<span class="cm"> * are written in the same order that pdflush sent them down.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">compress_file_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">async_cow</span> <span class="o">*</span><span class="n">async_cow</span><span class="p">,</span>
					<span class="kt">int</span> <span class="o">*</span><span class="n">num_added</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">actual_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_compressed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">total_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_compressed</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_uncompressed</span> <span class="o">=</span> <span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">will_compress</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compress_type</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">;</span>

	<span class="cm">/* if this is a small write inside eof, kick off a defrag */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span><span class="p">))</span>
		<span class="n">btrfs_add_inode_defrag</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">actual_end</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">isize</span><span class="p">,</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">will_compress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="p">(</span><span class="mi">128</span> <span class="o">*</span> <span class="mi">1024UL</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t want to send crud past the end of i_size through</span>
<span class="cm">	 * compression, that&#39;s just a waste of CPU time.  So, if the</span>
<span class="cm">	 * end of the file is before the start of our current</span>
<span class="cm">	 * requested range of bytes, we bail out to the uncompressed</span>
<span class="cm">	 * cleanup code that can deal with all of this.</span>
<span class="cm">	 *</span>
<span class="cm">	 * It isn&#39;t really the fastest way to fix things, but this is a</span>
<span class="cm">	 * very uncommon corner.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">actual_end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cleanup_and_bail_uncompressed</span><span class="p">;</span>

	<span class="n">total_compressed</span> <span class="o">=</span> <span class="n">actual_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>

	<span class="cm">/* we want to make sure that amount of ram required to uncompress</span>
<span class="cm">	 * an extent is reasonable, so we limit the total size in ram</span>
<span class="cm">	 * of a compressed extent to 128k.  This is a crucial number</span>
<span class="cm">	 * because it also controls how easily we can spread reads across</span>
<span class="cm">	 * cpus for decompression.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We also want to make sure the amount of IO required to do</span>
<span class="cm">	 * a random read is reasonably small, so we limit the size of</span>
<span class="cm">	 * a compressed extent to 128k.</span>
<span class="cm">	 */</span>
	<span class="n">total_compressed</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">total_compressed</span><span class="p">,</span> <span class="n">max_uncompressed</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">blocksize</span><span class="p">,</span>  <span class="n">num_bytes</span><span class="p">);</span>
	<span class="n">total_in</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we do compression for mount -o compress and when the</span>
<span class="cm">	 * inode has not been flagged as nocompress.  This flag can</span>
<span class="cm">	 * change at any time if we discover bad compression ratios.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">COMPRESS</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">force_compress</span><span class="p">)</span> <span class="o">||</span>
	     <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_pages</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* just bail out to the uncompressed code */</span>
			<span class="k">goto</span> <span class="n">cont</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">force_compress</span><span class="p">)</span>
			<span class="n">compress_type</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">force_compress</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_compress_pages</span><span class="p">(</span><span class="n">compress_type</span><span class="p">,</span>
					   <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
					   <span class="n">total_compressed</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span>
					   <span class="n">nr_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_pages_ret</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">total_in</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">total_compressed</span><span class="p">,</span>
					   <span class="n">max_compressed</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">total_compressed</span> <span class="o">&amp;</span>
				<span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">nr_pages_ret</span> <span class="o">-</span> <span class="mi">1</span><span class="p">];</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>

			<span class="cm">/* zero the tail end of the last page, we might be</span>
<span class="cm">			 * sending it down to disk</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				       <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
				<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">will_compress</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">cont:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">cleanup_and_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>

		<span class="cm">/* lets try to make an inline extent */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">total_in</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">actual_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/* we didn&#39;t compress the entire range, try</span>
<span class="cm">			 * to make an uncompressed inline extent.</span>
<span class="cm">			 */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range_inline</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* try making a compressed inline extent */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range_inline</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
						    <span class="n">total_compressed</span><span class="p">,</span>
						    <span class="n">compress_type</span><span class="p">,</span> <span class="n">pages</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * inline extent creation worked or returned error,</span>
<span class="cm">			 * we don&#39;t need to create any more async work items.</span>
<span class="cm">			 * Unlock and free up our temp pages.</span>
<span class="cm">			 */</span>
			<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
			     <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span> <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
			     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span> <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>

			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">free_pages_out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">will_compress</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we aren&#39;t doing an inline extent round the compressed size</span>
<span class="cm">		 * up to a block size boundary so the allocator does sane</span>
<span class="cm">		 * things</span>
<span class="cm">		 */</span>
		<span class="n">total_compressed</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_compressed</span> <span class="o">+</span> <span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * one last check to make sure the compression is really a</span>
<span class="cm">		 * win, compare the page count read with the blocks on disk</span>
<span class="cm">		 */</span>
		<span class="n">total_in</span> <span class="o">=</span> <span class="p">(</span><span class="n">total_in</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_compressed</span> <span class="o">&gt;=</span> <span class="n">total_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">will_compress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">total_in</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">will_compress</span> <span class="o">&amp;&amp;</span> <span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the compression code ran but failed to make things smaller,</span>
<span class="cm">		 * free any pages it allocated and our page pointer array</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages_ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
		<span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">total_compressed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">nr_pages_ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* flag the file so we don&#39;t compress in the future */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">FORCE_COMPRESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">force_compress</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">will_compress</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">num_added</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* the async work queues will take care of doing actual</span>
<span class="cm">		 * allocation on disk for these compressed pages,</span>
<span class="cm">		 * and will submit them to the elevator.</span>
<span class="cm">		 */</span>
		<span class="n">add_async_extent</span><span class="p">(</span><span class="n">async_cow</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
				 <span class="n">total_compressed</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages_ret</span><span class="p">,</span>
				 <span class="n">compress_type</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">start</span> <span class="o">+=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
<span class="nl">cleanup_and_bail_uncompressed:</span>
		<span class="cm">/*</span>
<span class="cm">		 * No compression, but we still need to write the pages in</span>
<span class="cm">		 * the file we&#39;ve been given so far.  redirty the locked</span>
<span class="cm">		 * page if it corresponds to our extent and set things up</span>
<span class="cm">		 * for the async work queue to run cow_file_range to do</span>
<span class="cm">		 * the normal delalloc dance</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page_offset</span><span class="p">(</span><span class="n">locked_page</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">&amp;&amp;</span>
		    <span class="n">page_offset</span><span class="p">(</span><span class="n">locked_page</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">locked_page</span><span class="p">);</span>
			<span class="cm">/* unlocked later on in the async handlers */</span>
		<span class="p">}</span>
		<span class="n">add_async_extent</span><span class="p">(</span><span class="n">async_cow</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">);</span>
		<span class="o">*</span><span class="n">num_added</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">free_pages_out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_pages_ret</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

<span class="nl">cleanup_and_out:</span>
	<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
				     <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
				     <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
				     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
				     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span>
				     <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span> <span class="o">||</span> <span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="n">btrfs_error</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="s">&quot;Failed to join transaction&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">free_pages_out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * phase two of compressed writeback.  This is the ordered portion</span>
<span class="cm"> * of the code, which only gets called in the order the work was</span>
<span class="cm"> * queued.  We walk all the async extents created by compress_file_range</span>
<span class="cm"> * and send them down to the disk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">submit_compressed_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">async_cow</span> <span class="o">*</span><span class="n">async_cow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_extent</span> <span class="o">*</span><span class="n">async_extent</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">extents</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>


	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">extents</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">async_extent</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">extents</span><span class="p">.</span><span class="n">next</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">async_extent</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

		<span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>

<span class="nl">retry:</span>
		<span class="cm">/* did the compression code fall back to uncompressed IO? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">page_started</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">lock_extent</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					 <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
					 <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

			<span class="cm">/* allocate blocks */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">locked_page</span><span class="p">,</span>
					     <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					     <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
					     <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">page_started</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_written</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="cm">/* JDM XXX */</span>

			<span class="cm">/*</span>
<span class="cm">			 * if page_started, cow_file_range inserted an</span>
<span class="cm">			 * inline extent and took care of all the unlocking</span>
<span class="cm">			 * and IO for us.  Otherwise, we need to submit</span>
<span class="cm">			 * all those pages down to the drive.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page_started</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">extent_write_locked_range</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span>
						  <span class="n">inode</span><span class="p">,</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						  <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
						  <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
						  <span class="n">btrfs_get_extent</span><span class="p">,</span>
						  <span class="n">WB_SYNC_ALL</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">async_extent</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">lock_extent</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
			    <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_reserve_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					   <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">compressed_size</span><span class="p">,</span>
					   <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">compressed_size</span><span class="p">,</span>
					   <span class="mi">0</span><span class="p">,</span> <span class="n">alloc_hint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">);</span>
			<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">unlock_extent</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				      <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
				      <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">retry</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span> <span class="cm">/* JDM: Requeue? */</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * here we&#39;re doing allocation and writeback of the</span>
<span class="cm">		 * compressed pages</span>
<span class="cm">		 */</span>
		<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
					<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">em</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

		<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">latest_bdev</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PINNED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_COMPRESSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
						<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_ordered_extent_compress</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						<span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
						<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span><span class="p">,</span>
						<span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
						<span class="n">BTRFS_ORDERED_COMPRESSED</span><span class="p">,</span>
						<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

		<span class="cm">/*</span>
<span class="cm">		 * clear dirty, set writeback and unlock the pages.</span>
<span class="cm">		 */</span>
		<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
				<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span>
				<span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				<span class="nb">NULL</span><span class="p">,</span> <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
				<span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span>
				<span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
				<span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_SET_WRITEBACK</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_submit_compressed_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				    <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				    <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">ram_size</span><span class="p">,</span>
				    <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				    <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">pages</span><span class="p">,</span>
				    <span class="n">async_extent</span><span class="o">-&gt;</span><span class="n">nr_pages</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">alloc_hint</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">async_extent</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">async_extent</span><span class="p">);</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">get_extent_allocation_hint</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">em</span> <span class="o">=</span> <span class="n">search_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if block start isn&#39;t an actual block number then find the</span>
<span class="cm">		 * first block in this inode and use that as a hint.  If that</span>
<span class="cm">		 * block is also bogus then just don&#39;t worry about it.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">EXTENT_MAP_LAST_BYTE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="n">em</span> <span class="o">=</span> <span class="n">search_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">em</span> <span class="o">&amp;&amp;</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">EXTENT_MAP_LAST_BYTE</span><span class="p">)</span>
				<span class="n">alloc_hint</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="p">)</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">alloc_hint</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span><span class="p">;</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">alloc_hint</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * when extent_io.c finds a delayed allocation range in the file,</span>
<span class="cm"> * the call backs end up in this code.  The basic idea is to</span>
<span class="cm"> * allocate extents on disk for the range, and create ordered data structs</span>
<span class="cm"> * in ram to track those extents.</span>
<span class="cm"> *</span>
<span class="cm"> * locked_page is the page that writepage had locked already.  We use</span>
<span class="cm"> * it to make sure we don&#39;t do extra locks or unlocks.</span>
<span class="cm"> *</span>
<span class="cm"> * *page_started is set to one if we unlock locked_page and do everything</span>
<span class="cm"> * required to start IO on it.  It may be clean and already done with</span>
<span class="cm"> * IO when we return.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">cow_file_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">page_started</span><span class="p">,</span>
				   <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_written</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">unlock</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ram_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">disk_num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_alloc_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">));</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
			     <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
			     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span>
			     <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>

	<span class="n">num_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">blocksize</span><span class="p">,</span>  <span class="n">num_bytes</span><span class="p">);</span>
	<span class="n">disk_num_bytes</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* if this is a small write inside eof, kick off defrag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span><span class="p">))</span>
		<span class="n">btrfs_add_inode_defrag</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* lets try to make an inline extent */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range_inline</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					    <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
				     <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
				     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
				     <span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span>
				     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
				     <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
				     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span>
				     <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>

			<span class="o">*</span><span class="n">nr_written</span> <span class="o">=</span> <span class="o">*</span><span class="n">nr_written</span> <span class="o">+</span>
			     <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="o">/</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
			<span class="o">*</span><span class="n">page_started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">disk_num_bytes</span> <span class="o">&gt;</span>
	       <span class="n">btrfs_super_total_bytes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">));</span>

	<span class="n">alloc_hint</span> <span class="o">=</span> <span class="n">get_extent_allocation_hint</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">disk_num_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">op</span><span class="p">;</span>

		<span class="n">cur_alloc_size</span> <span class="o">=</span> <span class="n">disk_num_bytes</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_reserve_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cur_alloc_size</span><span class="p">,</span>
					   <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">alloc_hint</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">ins</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">em</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">ram_size</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

		<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">latest_bdev</span><span class="p">;</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PINNED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
						<span class="n">start</span> <span class="o">+</span> <span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cur_alloc_size</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					       <span class="n">ram_size</span><span class="p">,</span> <span class="n">cur_alloc_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span>
		    <span class="n">BTRFS_DATA_RELOC_TREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_reloc_clone_csums</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
						      <span class="n">cur_alloc_size</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">disk_num_bytes</span> <span class="o">&lt;</span> <span class="n">cur_alloc_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* we&#39;re not doing compressed IO, don&#39;t unlock the first</span>
<span class="cm">		 * page (which the caller expects to stay locked), don&#39;t</span>
<span class="cm">		 * clear any dirty bits and don&#39;t set any writeback bits</span>
<span class="cm">		 *</span>
<span class="cm">		 * Do set the Private2 bit so we know this page was properly</span>
<span class="cm">		 * setup for writepage</span>
<span class="cm">		 */</span>
		<span class="n">op</span> <span class="o">=</span> <span class="n">unlock</span> <span class="o">?</span> <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">op</span> <span class="o">|=</span> <span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span> <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
			<span class="n">EXTENT_SET_PRIVATE2</span><span class="p">;</span>

		<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
					     <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">ram_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="n">locked_page</span><span class="p">,</span> <span class="n">op</span><span class="p">);</span>
		<span class="n">disk_num_bytes</span> <span class="o">-=</span> <span class="n">cur_alloc_size</span><span class="p">;</span>
		<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">cur_alloc_size</span><span class="p">;</span>
		<span class="n">alloc_hint</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">+=</span> <span class="n">cur_alloc_size</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
		     <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span>
		     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
		     <span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span>
		     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
		     <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
		     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span>
		     <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>

	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * work queue call back to started compression on a file and pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">async_cow_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_cow</span> <span class="o">*</span><span class="n">async_cow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_added</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">async_cow</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">async_cow</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="n">compress_file_range</span><span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">locked_page</span><span class="p">,</span>
			    <span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span> <span class="n">async_cow</span><span class="p">,</span>
			    <span class="o">&amp;</span><span class="n">num_added</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_added</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * work queue call back to submit previously compressed pages</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">async_cow_submit</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_cow</span> <span class="o">*</span><span class="n">async_cow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>

	<span class="n">async_cow</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">async_cow</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>

	<span class="n">root</span> <span class="o">=</span> <span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="n">atomic_sub</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">)</span> <span class="o">&lt;</span>
	    <span class="mi">5</span> <span class="o">*</span> <span class="mi">1042</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">&amp;&amp;</span>
	    <span class="n">waitqueue_active</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_wait</span><span class="p">))</span>
		<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_wait</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">submit_compressed_extents</span><span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">async_cow</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">async_cow_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_cow</span> <span class="o">*</span><span class="n">async_cow</span><span class="p">;</span>
	<span class="n">async_cow</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">async_cow</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
		<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">async_cow</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">cow_file_range_async</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">page_started</span><span class="p">,</span>
				<span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_written</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">async_cow</span> <span class="o">*</span><span class="n">async_cow</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_pages</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1042</span><span class="p">;</span>

	<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_LOCKED</span><span class="p">,</span>
			 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">async_cow</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">async_cow</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">async_cow</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">locked_page</span> <span class="o">=</span> <span class="n">locked_page</span><span class="p">;</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">)</span>
			<span class="n">cur_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">cur_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">512</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">=</span> <span class="n">cur_end</span><span class="p">;</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">extents</span><span class="p">);</span>

		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">async_cow_start</span><span class="p">;</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">ordered_func</span> <span class="o">=</span> <span class="n">async_cow_submit</span><span class="p">;</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">ordered_free</span> <span class="o">=</span> <span class="n">async_cow_free</span><span class="p">;</span>
		<span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">nr_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">cur_end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			<span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="n">atomic_add</span><span class="p">(</span><span class="n">nr_pages</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">);</span>

		<span class="n">btrfs_queue_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_workers</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">async_cow</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">limit</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_wait</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">)</span> <span class="o">&lt;</span>
			    <span class="n">limit</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_draining</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		      <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_wait</span><span class="p">,</span>
			  <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">)</span> <span class="o">==</span>
			   <span class="mi">0</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">nr_written</span> <span class="o">+=</span> <span class="n">nr_pages</span><span class="p">;</span>
		<span class="n">start</span> <span class="o">=</span> <span class="n">cur_end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">page_started</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">csum_exist_in_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_sum</span> <span class="o">*</span><span class="n">sums</span><span class="p">;</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_csums_range</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">csum_root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
				       <span class="n">bytenr</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">sums</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_sum</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sums</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">sums</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * when nowcow writeback call back.  This checks for snapshots or COW copies</span>
<span class="cm"> * of the extents that exist in the file, and COWs the file as required.</span>
<span class="cm"> *</span>
<span class="cm"> * If no cow copies or snapshots exist, we write directly to the existing</span>
<span class="cm"> * blocks on disk</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">run_delalloc_nocow</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">,</span>
			      <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">page_started</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_written</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cow_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">disk_bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extent_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nocow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">check_prev</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nolock</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
			     <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
			     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span>
			     <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">nolock</span> <span class="o">=</span> <span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nolock</span><span class="p">)</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction_nolock</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
			     <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
			     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span>
			     <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>

	<span class="n">cow_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span>
					       <span class="n">cur_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">check_prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span>
					      <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">ino</span> <span class="o">&amp;&amp;</span>
			    <span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">check_prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">next_slot:</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>

		<span class="n">nocow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">disk_bytenr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;</span> <span class="n">ino</span> <span class="o">||</span>
		    <span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span> <span class="o">||</span>
		    <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">cur_offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">extent_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_check</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">extent_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">||</span>
		    <span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disk_bytenr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">extent_offset</span> <span class="o">=</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span>
				<span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extent_end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next_slot</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">disk_bytenr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_check</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">btrfs_file_extent_encryption</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">||</span>
			    <span class="n">btrfs_file_extent_other_encoding</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_check</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">force</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_check</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_extent_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_check</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_cross_ref_exist</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span>
						  <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span>
						  <span class="n">extent_offset</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_check</span><span class="p">;</span>
			<span class="n">disk_bytenr</span> <span class="o">+=</span> <span class="n">extent_offset</span><span class="p">;</span>
			<span class="n">disk_bytenr</span> <span class="o">+=</span> <span class="n">cur_offset</span> <span class="o">-</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">extent_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">cur_offset</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * force cow if csum exists in the range.</span>
<span class="cm">			 * this ensure that csum for a given extent are</span>
<span class="cm">			 * either valid or do not exist.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">csum_exist_in_range</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out_check</span><span class="p">;</span>
			<span class="n">nocow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span>
				<span class="n">btrfs_file_extent_inline_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">extent_end</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">out_check:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extent_end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_slot</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nocow</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cow_start</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="n">cow_start</span> <span class="o">=</span> <span class="n">cur_offset</span><span class="p">;</span>
			<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">extent_end</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_slot</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cow_start</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span> <span class="n">cow_start</span><span class="p">,</span>
					<span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">page_started</span><span class="p">,</span>
					<span class="n">nr_written</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">cow_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span><span class="p">;</span>
			<span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
			<span class="n">em</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">cur_offset</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">disk_bytenr</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">latest_bdev</span><span class="p">;</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PINNED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
				<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ORDERED_PREALLOC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ORDERED_NOCOW</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cur_offset</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">,</span>
					       <span class="n">num_bytes</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span>
		    <span class="n">BTRFS_DATA_RELOC_TREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_reloc_clone_csums</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cur_offset</span><span class="p">,</span>
						      <span class="n">num_bytes</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
				<span class="n">cur_offset</span><span class="p">,</span> <span class="n">cur_offset</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				<span class="n">locked_page</span><span class="p">,</span> <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
				<span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span> <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
				<span class="n">EXTENT_SET_PRIVATE2</span><span class="p">);</span>
		<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">extent_end</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&lt;=</span> <span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="n">cow_start</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cow_start</span> <span class="o">=</span> <span class="n">cur_offset</span><span class="p">;</span>
		<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cow_start</span> <span class="o">!=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span> <span class="n">cow_start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
				     <span class="n">page_started</span><span class="p">,</span> <span class="n">nr_written</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">error:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nolock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_end_transaction_nolock</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">cur_offset</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
		<span class="n">extent_clear_unlock_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
			     <span class="n">cur_offset</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK_PAGE</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_UNLOCK</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DELALLOC</span> <span class="o">|</span>
			     <span class="n">EXTENT_CLEAR_DIRTY</span> <span class="o">|</span>
			     <span class="n">EXTENT_SET_WRITEBACK</span> <span class="o">|</span>
			     <span class="n">EXTENT_END_WRITEBACK</span><span class="p">);</span>

	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * extent_io.c call back to do delayed allocation processing</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">run_delalloc_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">locked_page</span><span class="p">,</span>
			      <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">page_started</span><span class="p">,</span>
			      <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">nr_written</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_delalloc_nocow</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
					 <span class="n">page_started</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nr_written</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">run_delalloc_nocow</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
					 <span class="n">page_started</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_written</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">COMPRESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">force_compress</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		   <span class="o">!</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
				      <span class="n">page_started</span><span class="p">,</span> <span class="n">nr_written</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ASYNC_EXTENT</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cow_file_range_async</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">locked_page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
					   <span class="n">page_started</span><span class="p">,</span> <span class="n">nr_written</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_split_extent_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">orig</span><span class="p">,</span> <span class="n">u64</span> <span class="n">split</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* not delalloc, ignore it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">orig</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">EXTENT_DELALLOC</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * extent_io.c merge_extent_hook, used to track merged delayed allocation</span>
<span class="cm"> * extents so we can keep track of new extents that are just merged onto old</span>
<span class="cm"> * extents, such as when we are doing sequential writes, so we can properly</span>
<span class="cm"> * account for the metadata space we&#39;ll need.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_merge_extent_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">new</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">other</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* not delalloc, ignore it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">other</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">EXTENT_DELALLOC</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">--</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * extent_io.c set_bit_hook, used to track delayed allocation</span>
<span class="cm"> * bytes in this file, and to maintain the list of inodes that</span>
<span class="cm"> * have pending delalloc work to be done.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_set_bit_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>

	<span class="cm">/*</span>
<span class="cm">	 * set_bit and clear bit hooks normally require _irqsave/restore</span>
<span class="cm">	 * but in this case, we are only testing for the DELALLOC</span>
<span class="cm">	 * bit, which is only set or cleared with irqs on</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">EXTENT_DELALLOC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">EXTENT_DELALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">do_list</span> <span class="o">=</span> <span class="o">!</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">EXTENT_FIRST_DELALLOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXTENT_FIRST_DELALLOC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">++</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">+=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">do_list</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * extent_io.c clear_bit_hook, see set_bit_hook for why</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_clear_bit_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bits</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * set_bit and clear bit hooks normally require _irqsave/restore</span>
<span class="cm">	 * but in this case, we are only testing for the DELALLOC</span>
<span class="cm">	 * bit, which is only set or cleared with irqs on</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">&amp;</span> <span class="n">EXTENT_DELALLOC</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">*</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">EXTENT_DELALLOC</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">bool</span> <span class="n">do_list</span> <span class="o">=</span> <span class="o">!</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">EXTENT_FIRST_DELALLOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">bits</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">EXTENT_FIRST_DELALLOC</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">*</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">--</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">bits</span> <span class="o">&amp;</span> <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">)</span>
			<span class="n">btrfs_delalloc_release_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_DATA_RELOC_TREE_OBJECTID</span>
		    <span class="o">&amp;&amp;</span> <span class="n">do_list</span><span class="p">)</span>
			<span class="n">btrfs_free_reserved_data_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">do_list</span> <span class="o">&amp;&amp;</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * extent_io.c merge_bio_hook, this must check the chunk tree to make sure</span>
<span class="cm"> * we don&#39;t create bios that span stripes or chunks</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_merge_bio_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bio_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_mapping_tree</span> <span class="o">*</span><span class="n">map_tree</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">logical</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">length</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">map_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bio_flags</span> <span class="o">&amp;</span> <span class="n">EXTENT_BIO_COMPRESSED</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">map_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">;</span>
	<span class="n">map_length</span> <span class="o">=</span> <span class="n">length</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_map_block</span><span class="p">(</span><span class="n">map_tree</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">map_length</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="cm">/* Will always return 0 or 1 with map_multi == NULL */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map_length</span> <span class="o">&lt;</span> <span class="n">length</span> <span class="o">+</span> <span class="n">size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * in order to insert checksums into the metadata in large chunks,</span>
<span class="cm"> * we wait until bio submission time.   All the pages in the bio are</span>
<span class="cm"> * checksummed and sums are attached onto the ordered extent record.</span>
<span class="cm"> *</span>
<span class="cm"> * At IO completion time the cums attached on the ordered extent record</span>
<span class="cm"> * are inserted into the btree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_submit_bio_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bio_flags</span><span class="p">,</span>
				    <span class="n">u64</span> <span class="n">bio_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_csum_one_bio</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * in order to insert checksums into the metadata in large chunks,</span>
<span class="cm"> * we wait until bio submission time.   All the pages in the bio are</span>
<span class="cm"> * checksummed and sums are attached onto the ordered extent record.</span>
<span class="cm"> *</span>
<span class="cm"> * At IO completion time the cums attached on the ordered extent record</span>
<span class="cm"> * are inserted into the btree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_submit_bio_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bio_flags</span><span class="p">,</span>
			  <span class="n">u64</span> <span class="n">bio_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">btrfs_map_bio</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * extent_io.c submission hook. This does the right thing for csum calculation</span>
<span class="cm"> * on write, or reading the csums from the tree before a read</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_submit_bio_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bio_flags</span><span class="p">,</span>
			  <span class="n">u64</span> <span class="n">bio_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip_sum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">metadata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skip_sum</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATASUM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="n">metadata</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_bio_wq_end_io</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">metadata</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bio_flags</span> <span class="o">&amp;</span> <span class="n">EXTENT_BIO_COMPRESSED</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="n">btrfs_submit_compressed_read</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span>
						    <span class="n">mirror_num</span><span class="p">,</span> <span class="n">bio_flags</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_sum</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_bio_sums</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">mapit</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_sum</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* csum items have already been cloned */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_DATA_RELOC_TREE_OBJECTID</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">mapit</span><span class="p">;</span>
		<span class="cm">/* we&#39;re doing a write, do the async checksumming */</span>
		<span class="k">return</span> <span class="n">btrfs_wq_submit_bio</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
				   <span class="n">inode</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">,</span>
				   <span class="n">bio_flags</span><span class="p">,</span> <span class="n">bio_offset</span><span class="p">,</span>
				   <span class="n">__btrfs_submit_bio_start</span><span class="p">,</span>
				   <span class="n">__btrfs_submit_bio_done</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">mapit:</span>
	<span class="k">return</span> <span class="n">btrfs_map_bio</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * given a list of ordered sums record them in the inode.  This happens</span>
<span class="cm"> * at IO completion time based on sums calculated at bio submission time.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">add_pending_csums</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">list</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_sum</span> <span class="o">*</span><span class="n">sum</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">sum</span><span class="p">,</span> <span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_csum_file_blocks</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
		       <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">csum_root</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_set_extent_delalloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">**</span><span class="n">cached_state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">end</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">set_extent_delalloc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
				   <span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* see btrfs_writepage_start_hook for details on why this is required */</span>
<span class="k">struct</span> <span class="n">btrfs_writepage_fixup</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_work</span> <span class="n">work</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_writepage_fixup_worker</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_writepage_fixup</span> <span class="o">*</span><span class="n">fixup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">fixup</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_writepage_fixup</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">fixup</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_page</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="n">page_start</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_end</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">lock_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>

	<span class="cm">/* already ordered? We&#39;re done */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PagePrivate2</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span>
				     <span class="n">page_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">btrfs_start_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delalloc_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mapping_set_error</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">end_extent_writepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">);</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	 <span class="p">}</span>

	<span class="n">btrfs_set_extent_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="nl">out_page:</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">fixup</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * There are a few paths in the higher layers of the kernel that directly</span>
<span class="cm"> * set the page dirty bit without asking the filesystem if it is a</span>
<span class="cm"> * good idea.  This causes problems because we want to make sure COW</span>
<span class="cm"> * properly happens and the data=ordered rules are followed.</span>
<span class="cm"> *</span>
<span class="cm"> * In our case any range that doesn&#39;t have the ORDERED bit set</span>
<span class="cm"> * hasn&#39;t been properly setup for IO.  We kick off an async process</span>
<span class="cm"> * to fix it up.  The async helper will wait for ordered extents, set</span>
<span class="cm"> * the delalloc bit and make it safe to write the page.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_writepage_start_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_writepage_fixup</span> <span class="o">*</span><span class="n">fixup</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="cm">/* this page is properly in the ordered list */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">TestClearPagePrivate2</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">fixup</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fixup</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fixup</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

	<span class="n">SetPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_get</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">fixup</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">btrfs_writepage_fixup_worker</span><span class="p">;</span>
	<span class="n">fixup</span><span class="o">-&gt;</span><span class="n">page</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
	<span class="n">btrfs_queue_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fixup_workers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fixup</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">insert_reserved_file_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_pos</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">disk_bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">disk_num_bytes</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ram_bytes</span><span class="p">,</span>
				       <span class="n">u8</span> <span class="n">compression</span><span class="p">,</span> <span class="n">u8</span> <span class="n">encryption</span><span class="p">,</span>
				       <span class="n">u16</span> <span class="n">other_encoding</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extent_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hint</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we may be replacing one extent in the tree with another.</span>
<span class="cm">	 * The new extent is pinned in the extent map, and we don&#39;t want</span>
<span class="cm">	 * to drop it from the cache until it is completely in the btree.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So, tell btrfs_drop_extents to leave this extent in the cache.</span>
<span class="cm">	 * the caller is expected to unpin it and allow it to be merged</span>
<span class="cm">	 * with the others.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_drop_extents</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">file_pos</span><span class="p">,</span> <span class="n">file_pos</span> <span class="o">+</span> <span class="n">num_bytes</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">hint</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ins</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">file_pos</span><span class="p">;</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fi</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">extent_type</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_disk_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">disk_num_bytes</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_ram_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">ram_bytes</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">compression</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_encryption</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">encryption</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_other_encoding</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">other_encoding</span><span class="p">);</span>

	<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">);</span>

	<span class="n">ins</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">disk_bytenr</span><span class="p">;</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">disk_num_bytes</span><span class="p">;</span>
	<span class="n">ins</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_alloc_reserved_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					<span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">file_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function for btrfs_finish_ordered_io, this</span>
<span class="cm"> * just reads in some of the csum leaves to prime them into ram</span>
<span class="cm"> * before we start the transaction.  It limits the amount of btree</span>
<span class="cm"> * reads required while inside the transaction.</span>
<span class="cm"> */</span>
<span class="cm">/* as ordered data IO finishes, this gets called so we can finish</span>
<span class="cm"> * an ordered extent if the range of bytes in the file it covers are</span>
<span class="cm"> * fully written.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_finish_ordered_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered_extent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compress_type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nolock</span><span class="p">;</span>

	<span class="n">nolock</span> <span class="o">=</span> <span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_IOERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_NOCOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">));</span> <span class="cm">/* Logic error */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nolock</span><span class="p">)</span>
				<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction_nolock</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
				<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
			<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode_fallback</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="cm">/* -ENOMEM or corruption */</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lock_extent_bits</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
			 <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nolock</span><span class="p">)</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction_nolock</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_COMPRESSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">compress_type</span> <span class="o">=</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">compress_type</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_mark_extent_written</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_reserved_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">disk_len</span><span class="p">,</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
						<span class="n">compress_type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">BTRFS_FILE_EXTENT_REG</span><span class="p">);</span>
		<span class="n">unpin_extent_cache</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">,</span>
				   <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
				   <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">add_pending_csums</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
			  <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">||</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode_fallback</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* -ENOMEM or corruption */</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out_unlock:</span>
	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
			     <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span>
			     <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">)</span>
		<span class="n">btrfs_delalloc_release_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nolock</span><span class="p">)</span>
			<span class="n">btrfs_end_transaction_nolock</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">clear_extent_uptodate</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
				      <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span>
				      <span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This needs to be dont to make sure anybody waiting knows we are done</span>
<span class="cm">	 * upating everything for this ordered extent.</span>
<span class="cm">	 */</span>
	<span class="n">btrfs_remove_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered_extent</span><span class="p">);</span>

	<span class="cm">/* once for us */</span>
	<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered_extent</span><span class="p">);</span>
	<span class="cm">/* once for the tree */</span>
	<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered_extent</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">finish_ordered_fn</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_work</span> <span class="o">*</span><span class="n">work</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered_extent</span><span class="p">;</span>
	<span class="n">ordered_extent</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">work</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">work</span><span class="p">);</span>
	<span class="n">btrfs_finish_ordered_io</span><span class="p">(</span><span class="n">ordered_extent</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_writepage_end_io_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered_extent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_workers</span> <span class="o">*</span><span class="n">workers</span><span class="p">;</span>

	<span class="n">trace_btrfs_writepage_end_io_hook</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">);</span>

	<span class="n">ClearPagePrivate2</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_dec_test_ordered_pending</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
					    <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">finish_ordered_fn</span><span class="p">;</span>
	<span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="n">workers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">endio_freespace_worker</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">workers</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">endio_write_workers</span><span class="p">;</span>
	<span class="n">btrfs_queue_worker</span><span class="p">(</span><span class="n">workers</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered_extent</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * when reads are done, we need to check csums to verify the data is correct</span>
<span class="cm"> * if there&#39;s a match, we allow the bio to finish.  If not, the code in</span>
<span class="cm"> * extent_io.c will try to find good copies for us.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_readpage_end_io_hook</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mirror</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">private</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">csum</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">PageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">good</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATASUM</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">good</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_DATA_RELOC_TREE_OBJECTID</span> <span class="o">&amp;&amp;</span>
	    <span class="n">test_range_bit</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_NODATASUM</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">clear_extent_bits</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">EXTENT_NODATASUM</span><span class="p">,</span>
				  <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span> <span class="o">&amp;&amp;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">private</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">get_state_private</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">private</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">zeroit</span><span class="p">;</span>

	<span class="n">csum</span> <span class="o">=</span> <span class="n">btrfs_csum_data</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span>  <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_csum_final</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csum</span> <span class="o">!=</span> <span class="n">private</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">zeroit</span><span class="p">;</span>

	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
<span class="nl">good:</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">zeroit:</span>
	<span class="n">printk_ratelimited</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs csum failed ino %llu off %llu csum %u &quot;</span>
		       <span class="s">&quot;private %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span> <span class="n">csum</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">private</span><span class="p">);</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">private</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">delayed_iput</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* JDM: If this is fs-wide, why can&#39;t we add a pointer to</span>
<span class="cm"> * btrfs_inode instead and avoid the allocation? */</span>
<span class="kt">void</span> <span class="nf">btrfs_add_delayed_iput</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_iput</span> <span class="o">*</span><span class="n">delayed</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_add_unless</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">delayed</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">delayed</span><span class="p">),</span> <span class="n">GFP_NOFS</span> <span class="o">|</span> <span class="n">__GFP_NOFAIL</span><span class="p">);</span>
	<span class="n">delayed</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iput_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iputs</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iput_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_run_delayed_iputs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">LIST_HEAD</span><span class="p">(</span><span class="n">list</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">delayed_iput</span> <span class="o">*</span><span class="n">delayed</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iput_lock</span><span class="p">);</span>
	<span class="n">empty</span> <span class="o">=</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iputs</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iput_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">cleanup_work_sem</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iput_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iputs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delayed_iput_lock</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">delayed</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">delayed_iput</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">delayed</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">delayed</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">cleanup_work_sem</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">btrfs_orphan_cleanup_state</span> <span class="p">{</span>
	<span class="n">ORPHAN_CLEANUP_STARTED</span>	<span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
	<span class="n">ORPHAN_CLEANUP_DONE</span>	<span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * This is called in transaction commit time. If there are no orphan</span>
<span class="cm"> * files in the subvolume, it removes orphan item and frees block_rsv</span>
<span class="cm"> * structure.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_orphan_commit_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_inodes</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_cleanup_state</span> <span class="o">!=</span> <span class="n">ORPHAN_CLEANUP_DONE</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_inodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_cleanup_state</span> <span class="o">!=</span> <span class="n">ORPHAN_CLEANUP_DONE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">block_rsv</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">;</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_item_inserted</span> <span class="o">&amp;&amp;</span>
	    <span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_orphan_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
					    <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_item_inserted</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">block_rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">btrfs_free_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This creates an orphan entry for the given inode in case something goes</span>
<span class="cm"> * wrong in the middle of an unlink/truncate.</span>
<span class="cm"> *</span>
<span class="cm"> * NOTE: caller of this function should reserve 5 units of metadata for</span>
<span class="cm"> *	 this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_orphan_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserve</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">insert</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_rsv</span> <span class="o">=</span> <span class="n">btrfs_alloc_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_rsv</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span> <span class="o">=</span> <span class="n">block_rsv</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block_rsv</span><span class="p">);</span>
		<span class="n">block_rsv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ORPHAN_ITEM</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">		/*</span>
<span class="c">		 * For proper ENOSPC handling, we should do orphan</span>
<span class="c">		 * cleanup when mounting. But this introduces backward</span>
<span class="c">		 * compatibility issue.</span>
<span class="c">		 */</span>
<span class="c">		if (!xchg(&amp;root-&gt;orphan_item_inserted, 1))</span>
<span class="c">			insert = 2;</span>
<span class="c">		else</span>
<span class="c">			insert = 1;</span>
<span class="cp">#endif</span>
		<span class="n">insert</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_inodes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_ORPHAN_META_RESERVED</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="n">reserve</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>

	<span class="cm">/* grab metadata reservation from transaction handle */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">reserve</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_reserve_metadata</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOSPC in reservation; Logic error? JDM */</span>
	<span class="p">}</span>

	<span class="cm">/* insert an orphan item to track this unlinked/truncated file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_orphan_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ORPHAN_ITEM</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* insert an orphan item to track subvolume contains orphan files */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">insert</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_orphan_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
					       <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * We have done the truncate/delete so we can go ahead and remove the orphan</span>
<span class="cm"> * item for this particular inode.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_orphan_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">delete_item</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">release_rsv</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ORPHAN_ITEM</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="n">delete_item</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_ORPHAN_META_RESERVED</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="n">release_rsv</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="n">delete_item</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_orphan_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM or corruption (JDM: Recheck) */</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">release_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_orphan_release_metadata</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_inodes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this cleans up any orphans that may be left on the list from the last use</span>
<span class="cm"> * of this root.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_orphan_cleanup</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">,</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_unlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nr_truncate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cmpxchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_cleanup_state</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ORPHAN_CLEANUP_STARTED</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">BTRFS_ORPHAN_OBJECTID</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_ORPHAN_ITEM_KEY</span><span class="p">);</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * if ret == 0 means we found what we were searching for, which</span>
<span class="cm">		 * is weird, but possible, so only screw with path if we didn&#39;t</span>
<span class="cm">		 * find the key and see if we have stuff that matches</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* pull out the item */</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="cm">/* make sure the item matches what we want */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_ORPHAN_OBJECTID</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_ORPHAN_ITEM_KEY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* release the path since we&#39;re done with it */</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * this is where we are basically btrfs_lookup, without the</span>
<span class="cm">		 * crossing root thing.  we store the inode number in the</span>
<span class="cm">		 * offset of the orphan item.</span>
<span class="cm">		 */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="n">last_objectid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs: Error removing orphan entry, &quot;</span>
			       <span class="s">&quot;stopping orphan cleanup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">last_objectid</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

		<span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">;</span>
		<span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_iget</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_RET</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESTALE</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">dead_root</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">is_dead_root</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * this is an orphan in the tree root. Currently these</span>
<span class="cm">			 * could come from 2 sources:</span>
<span class="cm">			 *  a) a snapshot deletion in progress</span>
<span class="cm">			 *  b) a free space cache inode</span>
<span class="cm">			 * We need to distinguish those two, as the snapshot</span>
<span class="cm">			 * orphan must not get deleted.</span>
<span class="cm">			 * find_dead_roots already ran before us, so if this</span>
<span class="cm">			 * is a snapshot deletion, we should find the root</span>
<span class="cm">			 * in the dead_roots list</span>
<span class="cm">			 */</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_lock</span><span class="p">);</span>
			<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">dead_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">dead_roots</span><span class="p">,</span>
					    <span class="n">root_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dead_root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span>
				    <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">is_dead_root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">is_dead_root</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* prevent this orphan from being found again */</span>
				<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Inode is already gone but the orphan item is still there,</span>
<span class="cm">		 * kill the orphan item.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ESTALE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;auto deleting %Lu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_orphan_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						    <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM or corruption (JDM: Recheck) */</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * add this inode to the orphan list so btrfs_orphan_del does</span>
<span class="cm">		 * the proper thing when we hit it</span>
<span class="cm">		 */</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ORPHAN_ITEM</span><span class="p">,</span>
			<span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>

		<span class="cm">/* if we have links, this was a truncate, lets do that */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
				<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">nr_truncate</span><span class="o">++</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">nr_unlink</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* this will do delete_inode and everything for us */</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* release the path since we&#39;re done with it */</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_cleanup_state</span> <span class="o">=</span> <span class="n">ORPHAN_CLEANUP_DONE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">)</span>
		<span class="n">btrfs_block_rsv_release</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span> <span class="o">||</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_item_inserted</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nr_unlink</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: unlinked %d orphans</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_unlink</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr_truncate</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: truncated %d orphans</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">nr_truncate</span><span class="p">);</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;btrfs: could not do orphan cleanup %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * very simple check to peek ahead in the leaf looking for xattrs.  If we</span>
<span class="cm"> * don&#39;t find any xattrs, we know there can&#39;t be any acls.</span>
<span class="cm"> *</span>
<span class="cm"> * slot is the slot the inode is in, objectid is the objectid of the inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">acls_after_inode_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u64</span> <span class="n">objectid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">scanned</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="cm">/* we found a different objectid, there must not be acls */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">objectid</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* we found an xattr, assume we&#39;ve got an acl */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_XATTR_ITEM_KEY</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * we found a key greater than an xattr key, there can&#39;t</span>
<span class="cm">		 * be any acls later on</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">BTRFS_XATTR_ITEM_KEY</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
		<span class="n">scanned</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * it goes inode, inode backrefs, xattrs, extents,</span>
<span class="cm">		 * so if there are a ton of hard links to an inode there can</span>
<span class="cm">		 * be a lot of backrefs.  Don&#39;t waste time searching too hard,</span>
<span class="cm">		 * this is just an optimization</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">scanned</span> <span class="o">&gt;=</span> <span class="mi">8</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* we hit the end of the leaf before we found an xattr or</span>
<span class="cm">	 * something larger than an xattr.  We have to assume the inode</span>
<span class="cm">	 * has acls</span>
<span class="cm">	 */</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read an inode from the btree into the in-memory inode</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_read_locked_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_item</span> <span class="o">*</span><span class="n">inode_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_timespec</span> <span class="o">*</span><span class="n">tspec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">location</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">maybe_acls</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">rdev</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">filled</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_fill_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">filled</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">make_bad</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">location</span><span class="p">));</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_inode</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">make_bad</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">filled</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">cache_acl</span><span class="p">;</span>

	<span class="n">inode_item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">btrfs_inode_item</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">btrfs_inode_mode</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">btrfs_inode_nlink</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">));</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">=</span> <span class="n">btrfs_inode_uid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span> <span class="o">=</span> <span class="n">btrfs_inode_gid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">btrfs_inode_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">));</span>

	<span class="n">tspec</span> <span class="o">=</span> <span class="n">btrfs_inode_atime</span><span class="p">(</span><span class="n">inode_item</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">btrfs_timespec_sec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">tspec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">btrfs_timespec_nsec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">tspec</span><span class="p">);</span>

	<span class="n">tspec</span> <span class="o">=</span> <span class="n">btrfs_inode_mtime</span><span class="p">(</span><span class="n">inode_item</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">btrfs_timespec_sec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">tspec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">btrfs_timespec_nsec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">tspec</span><span class="p">);</span>

	<span class="n">tspec</span> <span class="o">=</span> <span class="n">btrfs_inode_ctime</span><span class="p">(</span><span class="n">inode_item</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="n">btrfs_timespec_sec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">tspec</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span> <span class="o">=</span> <span class="n">btrfs_timespec_nsec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">tspec</span><span class="p">);</span>

	<span class="n">inode_set_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">btrfs_inode_nbytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">));</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_inode_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span> <span class="o">=</span> <span class="n">btrfs_inode_sequence</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">rdev</span> <span class="o">=</span> <span class="n">btrfs_inode_rdev</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>

	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_inode_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">);</span>
<span class="nl">cache_acl:</span>
	<span class="cm">/*</span>
<span class="cm">	 * try to precache a NULL acl entry for files that don&#39;t have</span>
<span class="cm">	 * any xattrs or acls</span>
<span class="cm">	 */</span>
	<span class="n">maybe_acls</span> <span class="o">=</span> <span class="n">acls_after_inode_item</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					   <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">maybe_acls</span><span class="p">)</span>
		<span class="n">cache_no_acl</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_aops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_extent_io_ops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_file_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_file_inode_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_file_operations</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">)</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_ro_inode_operations</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_inode_operations</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFLNK</span>:
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_symlink_inode_operations</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_symlink_aops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_special_inode_operations</span><span class="p">;</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_update_iflags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">make_bad:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">make_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * given a leaf and an inode, copy the inode fields into the leaf</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fill_inode_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_inode_item</span> <span class="o">*</span><span class="n">item</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">btrfs_set_inode_uid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_gid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_gid</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_mode</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_nlink</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span><span class="p">);</span>

	<span class="n">btrfs_set_timespec_sec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_inode_atime</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
			       <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">btrfs_set_timespec_nsec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_inode_atime</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

	<span class="n">btrfs_set_timespec_sec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_inode_mtime</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
			       <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">btrfs_set_timespec_nsec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_inode_mtime</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

	<span class="n">btrfs_set_timespec_sec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_inode_ctime</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
			       <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_sec</span><span class="p">);</span>
	<span class="n">btrfs_set_timespec_nsec</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_inode_ctime</span><span class="p">(</span><span class="n">item</span><span class="p">),</span>
				<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span><span class="p">.</span><span class="n">tv_nsec</span><span class="p">);</span>

	<span class="n">btrfs_set_inode_nbytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">inode_get_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
	<span class="n">btrfs_set_inode_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_sequence</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_version</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_transid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_rdev</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rdev</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_block_group</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * copy everything in the in-memory inode into the btree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_update_inode_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_item</span> <span class="o">*</span><span class="n">inode_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">,</span>
				 <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">failed</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">inode_item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">btrfs_inode_item</span><span class="p">);</span>

	<span class="n">fill_inode_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">inode_item</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_last_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">failed:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * copy everything in the in-memory inode into the btree.</span>
<span class="cm"> */</span>
<span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_update_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * If the inode is a free space inode, we can deadlock during commit</span>
<span class="cm">	 * if we put it into the delayed code.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The data relocation inode should also be directly updated</span>
<span class="cm">	 * without delay</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">)</span>
	    <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_DATA_RELOC_TREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delayed_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">btrfs_set_inode_last_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">btrfs_update_inode_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_update_inode_fallback</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">btrfs_update_inode_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * unlink helper that gets used here in inode.c and in the tree logging</span>
<span class="cm"> * recovery code.  It remove a link in a directory with a given name, and</span>
<span class="cm"> * also drops the back refs in the inode to the directory</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_unlink_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">name_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_dir_item</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">dir_ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_lookup_dir_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dir_ino</span><span class="p">,</span>
				    <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">di</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_dir_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delete_one_dir_name</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">di</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_inode_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span>
				  <span class="n">dir_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs failed to delete reference to %.*s, &quot;</span>
		       <span class="s">&quot;inode %llu parent %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ino</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dir_ino</span><span class="p">);</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delete_delayed_dir_index</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_inode_ref_in_log</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span>
					 <span class="n">inode</span><span class="p">,</span> <span class="n">dir_ino</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_dir_entries_in_log</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span>
					   <span class="n">dir</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">name_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_unlink_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">name_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_unlink_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_drop_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
		

<span class="cm">/* helper to check if there is any shared block in the path */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_path_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">refs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">level</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span> <span class="n">level</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_block_can_be_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_extent_info</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">refs</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to start transaction for unlink and rmdir.</span>
<span class="cm"> *</span>
<span class="cm"> * unlink and rmdir are special in btrfs, they do not always free space.</span>
<span class="cm"> * so in enospc case, we should make sure they will free space before</span>
<span class="cm"> * allowing them to use the global metadata reservation.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="nf">__unlink_start_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
						       <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_dir_item</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">check_link</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">dir_ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * 1 for the possible orphan item</span>
<span class="cm">	 * 1 for the dir item</span>
<span class="cm">	 * 1 for the dir index</span>
<span class="cm">	 * 1 for the inode ref</span>
<span class="cm">	 * 1 for the inode ref in the tree log</span>
<span class="cm">	 * 2 for the dir entries in the log</span>
<span class="cm">	 * 1 for the inode</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="o">||</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">trans</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">BTRFS_EMPTY_SUBVOL_DIR_OBJECTID</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>

	<span class="cm">/* check if there is someone else holds reference */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">enospc_unlink</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOSPC</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">enospc_unlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* 1 for the orphan item */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">enospc_unlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">trans</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_path_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">check_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_path_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">check_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					       <span class="n">ino</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span> <span class="cm">/* Corruption */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_path_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">check_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_lookup_dir_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dir_ino</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">di</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">check_path_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_lookup_inode_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
				<span class="n">ino</span><span class="p">,</span> <span class="n">dir_ino</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ref</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ref</span><span class="p">);</span> <span class="cm">/* Logic error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_path_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">index</span> <span class="o">=</span> <span class="n">btrfs_inode_ref_index</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ref</span><span class="p">);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a commit root search, if we can lookup inode item and other</span>
<span class="cm">	 * relative items in the commit root, it means the transaction of</span>
<span class="cm">	 * dir/file creation has been committed, and the dir index item that we</span>
<span class="cm">	 * delay to insert has also been inserted into the commit root. So</span>
<span class="cm">	 * we needn&#39;t worry about the delayed insertion of the dir index item</span>
<span class="cm">	 * here.</span>
<span class="cm">	 */</span>
	<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_lookup_dir_index_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dir_ino</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">check_path_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="cm">/* Migrate the orphan reservation over */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_block_rsv_migrate</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">,</span>
				<span class="n">trans</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">enospc_unlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">trans</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">__unlink_end_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_block_rsv_release</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span><span class="p">,</span>
					<span class="n">trans</span><span class="o">-&gt;</span><span class="n">bytes_reserved</span><span class="p">);</span>
		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">enospc_unlink</span><span class="p">);</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">enospc_unlink</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_unlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">__unlink_start_trans</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">btrfs_record_unlink_dir</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_unlink_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span>
				 <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_add</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">__unlink_end_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_unlink_subvol</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">u64</span> <span class="n">objectid</span><span class="p">,</span>
			<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">name_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_dir_item</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dir_ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_lookup_dir_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dir_ino</span><span class="p">,</span>
				   <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">di</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_dir_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span> <span class="o">||</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">objectid</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delete_one_dir_name</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">di</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_root_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
				 <span class="n">objectid</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				 <span class="n">dir_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_search_dir_index_item</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">dir_ino</span><span class="p">,</span>
						 <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">di</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">index</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delete_delayed_dir_index</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">name_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_rmdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">BTRFS_EMPTY_DIR_SIZE</span> <span class="o">||</span>
	    <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">__unlink_start_trans</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTRFS_EMPTY_SUBVOL_DIR_OBJECTID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_unlink_subvol</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span>
					  <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					  <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					  <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_orphan_add</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* now the directory is empty */</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_unlink_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span>
				 <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">__unlink_end_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this can truncate away extent items, csum items and directory items.</span>
<span class="cm"> * It starts at a high offset and removes keys until it can&#39;t find</span>
<span class="cm"> * any higher than new_size</span>
<span class="cm"> *</span>
<span class="cm"> * csum items that cross the new i_size are truncated to the new size</span>
<span class="cm"> * as well.</span>
<span class="cm"> *</span>
<span class="cm"> * min_type is the minimum key type to truncate down to.  If set to 0, this</span>
<span class="cm"> * will kill all the items on this inode, including the INODE_ITEM_KEY.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_truncate_inode_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="n">new_size</span><span class="p">,</span> <span class="n">u32</span> <span class="n">min_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">item_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">found_type</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_extent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">del_item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pending_del_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pending_del_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extent_type</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">min_type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">||</span> <span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">)</span>
		<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">new_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">),</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This function is also used to drop the items in the log tree before</span>
<span class="cm">	 * we relog the inode, so if root != BTRFS_I(inode)-&gt;root, it means</span>
<span class="cm">	 * it is used to drop the loged items. So we shouldn&#39;t kill the delayed</span>
<span class="cm">	 * items.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">min_type</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">==</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
		<span class="n">btrfs_kill_delayed_inode_items</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

<span class="nl">search_again:</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* there are no items in the tree for us to truncate, we&#39;re</span>
<span class="cm">		 * done</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">found_type</span> <span class="o">=</span> <span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">ino</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">&lt;</span> <span class="n">min_type</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">item_end</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">extent_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">!=</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">item_end</span> <span class="o">+=</span>
				    <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">item_end</span> <span class="o">+=</span> <span class="n">btrfs_file_extent_inline_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
									 <span class="n">fi</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">item_end</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">&gt;</span> <span class="n">min_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">del_item</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">item_end</span> <span class="o">&lt;</span> <span class="n">new_size</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">new_size</span><span class="p">)</span>
				<span class="n">del_item</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">del_item</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">found_extent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/* FIXME, shrink the extent if the ref count is only 1 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">delete</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">!=</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">num_dec</span><span class="p">;</span>
			<span class="n">extent_start</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del_item</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u64</span> <span class="n">orig_num_bytes</span> <span class="o">=</span>
					<span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
				<span class="n">extent_num_bytes</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">-</span>
					<span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">extent_num_bytes</span> <span class="o">=</span> <span class="n">extent_num_bytes</span> <span class="o">&amp;</span>
					<span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							 <span class="n">extent_num_bytes</span><span class="p">);</span>
				<span class="n">num_dec</span> <span class="o">=</span> <span class="p">(</span><span class="n">orig_num_bytes</span> <span class="o">-</span>
					   <span class="n">extent_num_bytes</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span> <span class="n">extent_start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
					<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_dec</span><span class="p">);</span>
				<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">extent_num_bytes</span> <span class="o">=</span>
					<span class="n">btrfs_file_extent_disk_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
									 <span class="n">fi</span><span class="p">);</span>
				<span class="n">extent_offset</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span>
					<span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>

				<span class="cm">/* FIXME blocksize != 4096 */</span>
				<span class="n">num_dec</span> <span class="o">=</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">extent_start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">found_extent</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span><span class="p">)</span>
						<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">num_dec</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we can&#39;t truncate inline items that have had</span>
<span class="cm">			 * special encodings</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">del_item</span> <span class="o">&amp;&amp;</span>
			    <span class="n">btrfs_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">btrfs_file_extent_encryption</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">btrfs_file_extent_other_encoding</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">size</span> <span class="o">=</span> <span class="n">new_size</span> <span class="o">-</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">item_end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span>
							<span class="n">new_size</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">size</span> <span class="o">=</span>
				    <span class="n">btrfs_file_extent_calc_inline_size</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
				<span class="n">btrfs_truncate_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						    <span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">item_end</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">-</span>
						<span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">delete:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">del_item</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pending_del_nr</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* no pending yet, add ourselves */</span>
				<span class="n">pending_del_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">pending_del_nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">pending_del_nr</span> <span class="o">&amp;&amp;</span>
				   <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">pending_del_slot</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* hop on the pending chunk */</span>
				<span class="n">pending_del_nr</span><span class="o">++</span><span class="p">;</span>
				<span class="n">pending_del_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">BUG</span><span class="p">();</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_extent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">||</span>
				     <span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">extent_start</span><span class="p">,</span>
						<span class="n">extent_num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">leaf</span><span class="p">),</span>
						<span class="n">ino</span><span class="p">,</span> <span class="n">extent_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">pending_del_slot</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span>
			    <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span>
						<span class="n">BTRFS_FREE_INO_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">pending_del_nr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						<span class="n">pending_del_slot</span><span class="p">,</span>
						<span class="n">pending_del_nr</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
								<span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">error</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">pending_del_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">search_again</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">pending_del_nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">pending_del_slot</span><span class="p">,</span>
				      <span class="n">pending_del_nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">error:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * taken from block_truncate_page, but does cow as it zeros out</span>
<span class="cm"> * any bytes left in the last page in the file.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_truncate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">from</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="n">pgoff_t</span> <span class="n">index</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">from</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">btrfs_alloc_write_mask</span><span class="p">(</span><span class="n">mapping</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delalloc_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">page</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">mapping</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">page_start</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_end</span> <span class="o">=</span> <span class="n">page_start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_readpage</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">lock_extent_bits</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="n">set_page_extent_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">btrfs_start_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
			  <span class="n">EXTENT_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span> <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">,</span>
			  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_extent_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span>
			     <span class="n">GFP_NOFS</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function puts in dummy file extents for the area we&#39;re creating a hole</span>
<span class="cm"> * for.  So if we are truncating this file to a larger size we need to insert</span>
<span class="cm"> * these file extents so that btrfs_get_extent will return a EXTENT_MAP_HOLE for</span>
<span class="cm"> * the range between oldsize and size</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_cont_expand</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">oldsize</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hole_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">oldsize</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_byte</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hole_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">hole_start</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
		<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">hole_start</span><span class="p">,</span>
					 <span class="n">block_end</span> <span class="o">-</span> <span class="n">hole_start</span><span class="p">);</span>
		<span class="n">lock_extent_bits</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">hole_start</span><span class="p">,</span> <span class="n">block_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">hole_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ordered</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">hole_start</span><span class="p">,</span> <span class="n">block_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">hole_start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur_offset</span><span class="p">,</span>
				<span class="n">block_end</span> <span class="o">-</span> <span class="n">cur_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_byte</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">),</span> <span class="n">block_end</span><span class="p">);</span>
		<span class="n">last_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_byte</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">hint_byte</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">hole_size</span> <span class="o">=</span> <span class="n">last_byte</span> <span class="o">-</span> <span class="n">cur_offset</span><span class="p">;</span>

			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_drop_extents</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">cur_offset</span><span class="p">,</span>
						 <span class="n">cur_offset</span> <span class="o">+</span> <span class="n">hole_size</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">hint_byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_insert_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
					<span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">cur_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">hole_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">hole_size</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
				<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">hole_start</span><span class="p">,</span>
					<span class="n">last_byte</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

			<span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">last_byte</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&gt;=</span> <span class="n">block_end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">hole_start</span><span class="p">,</span> <span class="n">block_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span>
			     <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_setsize</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">newsize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">oldsize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">==</span> <span class="n">oldsize</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">&gt;</span> <span class="n">oldsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">truncate_pagecache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">oldsize</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cont_expand</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">oldsize</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
		<span class="n">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re truncating a file that used to have good data down to</span>
<span class="cm">		 * zero. Make sure it gets into the ordered flush list so that</span>
<span class="cm">		 * any new writes get down to disk quickly.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">newsize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_ORDERED_DATA_CLOSE</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>

		<span class="cm">/* we don&#39;t support swapfiles, so vmtruncate shouldn&#39;t fail */</span>
		<span class="n">truncate_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">newsize</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_truncate</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_setattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">iattr</span> <span class="o">*</span><span class="n">attr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">inode_change_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_SIZE</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_setsize</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">setattr_copy</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">attr</span><span class="p">);</span>
		<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_dirty_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="n">attr</span><span class="o">-&gt;</span><span class="n">ia_valid</span> <span class="o">&amp;</span> <span class="n">ATTR_MODE</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_acl_chmod</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_evict_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">,</span> <span class="o">*</span><span class="n">global_rsv</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">min_size</span> <span class="o">=</span> <span class="n">btrfs_calc_trunc_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">trace_btrfs_inode_evict</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">truncate_inode_pages</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
			       <span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">)))</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* do we really want it for -&gt;i_nlink &gt; 0 and zero btrfs_root_refs? */</span>
	<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">log_root_recovering</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ORPHAN_ITEM</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rsv</span> <span class="o">=</span> <span class="n">btrfs_alloc_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">min_size</span><span class="p">;</span>
	<span class="n">global_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>

	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This is a bit simpler than btrfs_truncate since</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) We&#39;ve already reserved our space for our orphan item in the</span>
<span class="cm">	 *    unlink.</span>
<span class="cm">	 * 2) We&#39;re going to delete the inode item, so we don&#39;t need to update</span>
<span class="cm">	 *    it at all.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So we just need to reserve some slack space in case we add bytes when</span>
<span class="cm">	 * doing the truncate.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_block_rsv_refill_noflush</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rsv</span><span class="p">,</span> <span class="n">min_size</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Try and steal from the global reserve since we will</span>
<span class="cm">		 * likely not use this space anyway, we want to try as</span>
<span class="cm">		 * hard as possible to get this to work.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_block_rsv_migrate</span><span class="p">(</span><span class="n">global_rsv</span><span class="p">,</span> <span class="n">rsv</span><span class="p">,</span> <span class="n">min_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_WARNING</span> <span class="s">&quot;Could not get space for a &quot;</span>
			       <span class="s">&quot;delete, will truncate on mount %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">btrfs_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">btrfs_free_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">btrfs_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="n">btrfs_free_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">no_delete</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="n">rsv</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_truncate_inode_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_free_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_del</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span> <span class="o">||</span>
	      <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">))</span>
		<span class="n">btrfs_return_ino</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
<span class="nl">no_delete:</span>
	<span class="n">clear_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this returns the key found in the dir entry in the location pointer.</span>
<span class="cm"> * If no dir entries were found, location-&gt;objectid is 0.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_inode_by_name</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">location</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_dir_item</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_lookup_dir_item</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">name</span><span class="p">,</span>
				    <span class="n">namelen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">di</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">di</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>

	<span class="n">btrfs_dir_item_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">di</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out_err:</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * when we hit a tree root in a directory, the btrfs part of the inode</span>
<span class="cm"> * needs to be changed to reflect the root directory of the tree root.  This</span>
<span class="cm"> * is kind of like crossing a mount point.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">fixup_tree_root_location</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">**</span><span class="n">sub_root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">new_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_find_root_ref</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				  <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				  <span class="n">location</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_root_ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_ref_dirid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">btrfs_root_ref_name_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ref</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">memcmp_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
				   <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">new_root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">location</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">sub_root</span> <span class="o">=</span> <span class="n">new_root</span><span class="p">;</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_root_dirid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">);</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">;</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_tree_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode_unhashed</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">))</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ino</span> <span class="o">&gt;</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">))</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">.</span><span class="n">i_state</span> <span class="o">&amp;</span>
				  <span class="p">(</span><span class="n">I_WILL_FREE</span> <span class="o">|</span> <span class="n">I_FREEING</span><span class="p">)));</span>
			<span class="n">rb_erase</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_tree</span><span class="p">);</span>
			<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_tree</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">inode_tree_del</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">empty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">RB_EMPTY_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_tree</span><span class="p">);</span>
		<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
		<span class="n">empty</span> <span class="o">=</span> <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_tree</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Free space cache has inodes in the tree root, but the tree root has a</span>
<span class="cm">	 * root_refs of 0, so this could end up dropping the tree root as a</span>
<span class="cm">	 * snapshot, so we need the extra !root-&gt;fs_info-&gt;tree_root check to</span>
<span class="cm">	 * make sure we don&#39;t drop it.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="n">root</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">synchronize_srcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_srcu</span><span class="p">);</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
		<span class="n">empty</span> <span class="o">=</span> <span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_tree</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
			<span class="n">btrfs_add_dead_root</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_invalidate_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_tree</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">node</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">))</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">objectid</span> <span class="o">&gt;</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">))</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">objectid</span> <span class="o">&lt;=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">node</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">prev</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_count</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
				<span class="n">d_prune_aliases</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * btrfs_drop_inode will have it removed from</span>
<span class="cm">			 * the inode cache when its usage count</span>
<span class="cm">			 * hits zero.</span>
<span class="cm">			 */</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">cond_resched</span><span class="p">();</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">cond_resched_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">inode_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_init_locked_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_iget_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">;</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">btrfs_set_inode_space_info</span><span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_find_actor</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">opaque</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_iget_args</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">opaque</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">==</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">==</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">btrfs_iget_locked</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">objectid</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_iget_args</span> <span class="n">args</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">args</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">iget5_locked</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">objectid</span><span class="p">,</span> <span class="n">btrfs_find_actor</span><span class="p">,</span>
			     <span class="n">btrfs_init_locked_inode</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Get an inode object given its location and corresponding root.</span>
<span class="cm"> * Returns in *is_new if the inode was read from disk</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">btrfs_iget</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_iget_locked</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">location</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_state</span> <span class="o">&amp;</span> <span class="n">I_NEW</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">,</span> <span class="n">location</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">location</span><span class="p">));</span>
		<span class="n">btrfs_read_locked_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_bad_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">inode_tree_add</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
				<span class="o">*</span><span class="n">new</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">unlock_new_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ESTALE</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">new_simple_dir</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">s</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">key</span><span class="p">));</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_DUMMY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">BTRFS_EMPTY_SUBVOL_DIR_OBJECTID</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_ro_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">simple_dir_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">=</span> <span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">S_IRUGO</span> <span class="o">|</span> <span class="n">S_IWUSR</span> <span class="o">|</span> <span class="n">S_IXUGO</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">btrfs_lookup_dentry</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">sub_root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">location</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">BTRFS_NAME_LEN</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">d_need_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key</span><span class="p">));</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">);</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="cm">/* This thing is hashed, drop it for now */</span>
		<span class="n">d_drop</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inode_by_name</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_iget</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">);</span>

	<span class="n">index</span> <span class="o">=</span> <span class="n">srcu_read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_srcu</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">fixup_tree_root_location</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sub_root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">new_simple_dir</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="n">sub_root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_iget</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">,</span> <span class="n">sub_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">srcu_read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_srcu</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">sub_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">cleanup_work_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_cleanup</span><span class="p">(</span><span class="n">sub_root</span><span class="p">);</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">cleanup_work_sem</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">inode</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_dentry_delete</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTRFS_EMPTY_SUBVOL_DIR_OBJECTID</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_dentry_release</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_fsdata</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">btrfs_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">d_splice_alias</span><span class="p">(</span><span class="n">btrfs_lookup_dentry</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">),</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">d_need_lookup</span><span class="p">(</span><span class="n">dentry</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
		<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">DCACHE_NEED_LOOKUP</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">btrfs_filetype_table</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="n">DT_UNKNOWN</span><span class="p">,</span> <span class="n">DT_REG</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">,</span> <span class="n">DT_CHR</span><span class="p">,</span> <span class="n">DT_BLK</span><span class="p">,</span> <span class="n">DT_FIFO</span><span class="p">,</span> <span class="n">DT_SOCK</span><span class="p">,</span> <span class="n">DT_LNK</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_real_readdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">dirent</span><span class="p">,</span>
			      <span class="n">filldir_t</span> <span class="n">filldir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_dir_item</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ins_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">del_list</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">d_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">di_cur</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">di_total</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">di_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">key_type</span> <span class="o">=</span> <span class="n">BTRFS_DIR_INDEX_KEY</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">tmp_name</span><span class="p">[</span><span class="mi">32</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">name_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">is_curr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* filp-&gt;f_pos points to the current index? */</span>

	<span class="cm">/* FIXME, use a real flag for deciding about the key type */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span> <span class="o">==</span> <span class="n">root</span><span class="p">)</span>
		<span class="n">key_type</span> <span class="o">=</span> <span class="n">BTRFS_DIR_ITEM_KEY</span><span class="p">;</span>

	<span class="cm">/* special case for &quot;.&quot; */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">over</span> <span class="o">=</span> <span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;.&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			       <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">DT_DIR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">over</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* special case for .., just use the back ref */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">pino</span> <span class="o">=</span> <span class="n">parent_ino</span><span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">);</span>
		<span class="n">over</span> <span class="o">=</span> <span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
			       <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">,</span> <span class="n">pino</span><span class="p">,</span> <span class="n">DT_DIR</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">over</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span> <span class="o">==</span> <span class="n">BTRFS_DIR_INDEX_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ins_list</span><span class="p">);</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">del_list</span><span class="p">);</span>
		<span class="n">btrfs_get_delayed_items</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">del_list</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">key_type</span><span class="p">);</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">key_type</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span> <span class="o">==</span> <span class="n">BTRFS_DIR_INDEX_KEY</span> <span class="o">&amp;&amp;</span>
		    <span class="n">btrfs_should_delete_dir_index</span><span class="p">(</span><span class="o">&amp;</span><span class="n">del_list</span><span class="p">,</span>
						  <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">is_curr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_dir_item</span><span class="p">);</span>
		<span class="n">di_cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">di_total</span> <span class="o">=</span> <span class="n">btrfs_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">di_cur</span> <span class="o">&lt;</span> <span class="n">di_total</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">location</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">verify_dir_item</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">name_len</span> <span class="o">=</span> <span class="n">btrfs_dir_name_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">&lt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">tmp_name</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">name_ptr</span> <span class="o">=</span> <span class="n">tmp_name</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">name_ptr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">name_len</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">name_ptr</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">name_ptr</span><span class="p">,</span>
					   <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">di</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name_len</span><span class="p">);</span>

			<span class="n">d_type</span> <span class="o">=</span> <span class="n">btrfs_filetype_table</span><span class="p">[</span><span class="n">btrfs_dir_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">)];</span>
			<span class="n">btrfs_dir_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">);</span>


			<span class="cm">/* is this a reference to our own snapshot? If so</span>
<span class="cm">			 * skip it.</span>
<span class="cm">			 *</span>
<span class="cm">			 * In contrast to old kernels, we insert the snapshot&#39;s</span>
<span class="cm">			 * dir item and dir index after it has been created, so</span>
<span class="cm">			 * we won&#39;t find a reference to our own snapshot. We</span>
<span class="cm">			 * still keep the following code for backward</span>
<span class="cm">			 * compatibility.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">location</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span> <span class="o">&amp;&amp;</span>
			    <span class="n">location</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">over</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">skip</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">over</span> <span class="o">=</span> <span class="n">filldir</span><span class="p">(</span><span class="n">dirent</span><span class="p">,</span> <span class="n">name_ptr</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span>
				       <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">location</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				       <span class="n">d_type</span><span class="p">);</span>

<span class="nl">skip:</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">name_ptr</span> <span class="o">!=</span> <span class="n">tmp_name</span><span class="p">)</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">name_ptr</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">over</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">nopos</span><span class="p">;</span>
			<span class="n">di_len</span> <span class="o">=</span> <span class="n">btrfs_dir_name_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="o">+</span>
				 <span class="n">btrfs_dir_data_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">di</span><span class="p">)</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">di</span><span class="p">);</span>
			<span class="n">di_cur</span> <span class="o">+=</span> <span class="n">di_len</span><span class="p">;</span>
			<span class="n">di</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_dir_item</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">di</span> <span class="o">+</span> <span class="n">di_len</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">next:</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span> <span class="o">==</span> <span class="n">BTRFS_DIR_INDEX_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_curr</span><span class="p">)</span>
			<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_readdir_delayed_dir_index</span><span class="p">(</span><span class="n">filp</span><span class="p">,</span> <span class="n">dirent</span><span class="p">,</span> <span class="n">filldir</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">ins_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">nopos</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Reached end of directory/root. Bump pos past the last item. */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span> <span class="o">==</span> <span class="n">BTRFS_DIR_INDEX_KEY</span><span class="p">)</span>
		<span class="cm">/*</span>
<span class="cm">		 * 32-bit glibc will use getdents64, but then strtol -</span>
<span class="cm">		 * so the last number we can serve is this.</span>
<span class="cm">		 */</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="mh">0x7fffffff</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="o">++</span><span class="p">;</span>
<span class="nl">nopos:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key_type</span> <span class="o">==</span> <span class="n">BTRFS_DIR_INDEX_KEY</span><span class="p">)</span>
		<span class="n">btrfs_put_delayed_items</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ins_list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">del_list</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_write_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">nolock</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_DUMMY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_fs_closing</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="n">nolock</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">wbc</span><span class="o">-&gt;</span><span class="n">sync_mode</span> <span class="o">==</span> <span class="n">WB_SYNC_ALL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nolock</span><span class="p">)</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction_nolock</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nolock</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_end_transaction_nolock</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is somewhat expensive, updating the tree every time the</span>
<span class="cm"> * inode changes.  But, it is most likely to find the inode in cache.</span>
<span class="cm"> * FIXME, needs more benchmarking...there are no reasons other than performance</span>
<span class="cm"> * to keep or drop this code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_dirty_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_DUMMY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* whoops, lets try again with the full transaction */</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delayed_node</span><span class="p">)</span>
		<span class="n">btrfs_balance_delayed_items</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This is a copy of file_update_time.  We need this so we can return error on</span>
<span class="cm"> * ENOSPC for updating the inode in the case of file write and mmap writes.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_update_time</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">timespec</span> <span class="o">*</span><span class="n">now</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_VERSION</span><span class="p">)</span>
		<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_CTIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="o">*</span><span class="n">now</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_MTIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="o">*</span><span class="n">now</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">S_ATIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="o">*</span><span class="n">now</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">btrfs_dirty_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find the highest existing sequence number in a directory</span>
<span class="cm"> * and then set the in-memory index_cnt variable to reflect</span>
<span class="cm"> * free sequence numbers</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_set_inode_index_count</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">,</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_DIR_INDEX_KEY</span><span class="p">);</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/* FIXME: we should be able to handle this */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * MAGIC NUMBER EXPLANATION:</span>
<span class="cm">	 * since we search a directory based on f_pos we have to start at 2</span>
<span class="cm">	 * since &#39;.&#39; and &#39;..&#39; have f_pos of 0 and 1 respectively, so everybody</span>
<span class="cm">	 * else has to start at 2</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_DIR_INDEX_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to find a free sequence number in a given directory.  This current</span>
<span class="cm"> * code is very simple, later versions will do smarter things in the btree</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_set_inode_index</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inode_delayed_dir_index_count</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_inode_index_count</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">index</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span><span class="p">;</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">btrfs_new_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
				     <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">name_len</span><span class="p">,</span>
				     <span class="n">u64</span> <span class="n">ref_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">objectid</span><span class="p">,</span>
				     <span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_item</span> <span class="o">*</span><span class="n">inode_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">location</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">owner</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">new_inode</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * we have to initialize this early, so we can reclaim the inode</span>
<span class="cm">	 * number if we fail afterwards in this function.</span>
<span class="cm">	 */</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ino</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trace_btrfs_inode_request</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_inode_index</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * index_cnt is ignored for everything but a dir,</span>
<span class="cm">	 * btrfs_get_inode_index_count has an explanation for the magic</span>
<span class="cm">	 * number</span>
<span class="cm">	 */</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
	<span class="n">btrfs_set_inode_space_info</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="n">owner</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">owner</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">);</span>
	<span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">BTRFS_INODE_REF_KEY</span><span class="p">);</span>
	<span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ref_objectid</span><span class="p">;</span>

	<span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_inode_item</span><span class="p">);</span>
	<span class="n">sizes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">name_len</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ref</span><span class="p">);</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">sizes</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">inode_init_owner</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">mode</span><span class="p">);</span>
	<span class="n">inode_set_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_atime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">inode_item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				  <span class="k">struct</span> <span class="n">btrfs_inode_item</span><span class="p">);</span>
	<span class="n">fill_inode_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">inode_item</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_inode_ref</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_ref_name_len</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ref</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_ref_index</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ref</span><span class="p">,</span> <span class="o">*</span><span class="n">index</span><span class="p">);</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">name</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">location</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">;</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">location</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">);</span>

	<span class="n">btrfs_inherit_iflags</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">NODATASUM</span><span class="p">))</span>
			<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NODATASUM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">NODATACOW</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">))</span>
			<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">insert_inode_hash</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode_tree_add</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">trace_btrfs_inode_new</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">btrfs_set_inode_last_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="p">)</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">index_cnt</span><span class="o">--</span><span class="p">;</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="n">u8</span> <span class="nf">btrfs_inode_type</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">btrfs_type_by_mode</span><span class="p">[(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">S_SHIFT</span><span class="p">];</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * utility function to add &#39;inode&#39; into &#39;parent_inode&#39; with</span>
<span class="cm"> * a give name and a given sequence number.</span>
<span class="cm"> * if &#39;add_backref&#39; is true, also insert a backref from the</span>
<span class="cm"> * inode to the parent directory.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_add_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">parent_inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		   <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">name_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">add_backref</span><span class="p">,</span> <span class="n">u64</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">parent_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">parent_ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">parent_inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
		<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">);</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_root_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
					 <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					 <span class="n">parent_ino</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">add_backref</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_inode_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span>
					     <span class="n">parent_ino</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Nothing to clean up yet */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_dir_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span>
				    <span class="n">parent_inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
				    <span class="n">btrfs_inode_type</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail_dir_item</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">parent_inode</span><span class="p">,</span> <span class="n">parent_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span>
			   <span class="n">name_len</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">parent_inode</span><span class="p">);</span>
	<span class="n">parent_inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">parent_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">parent_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="nl">fail_dir_item:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">ino</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">local_index</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_del_root_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
				 <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				 <span class="n">parent_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>

	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">add_backref</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">local_index</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_del_inode_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">name_len</span><span class="p">,</span>
					  <span class="n">ino</span><span class="p">,</span> <span class="n">parent_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">local_index</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_add_nondir</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">backref</span><span class="p">,</span> <span class="n">u64</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_add_link</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
				 <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
				 <span class="n">backref</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_mknod</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			<span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">dev_t</span> <span class="n">rdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_valid_dev</span><span class="p">(</span><span class="n">rdev</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 2 for inode item and ref</span>
<span class="cm">	 * 2 for dir items</span>
<span class="cm">	 * 1 for xattr if selinux is on</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_find_free_ino</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_new_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">objectid</span><span class="p">,</span>
				<span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_init_inode_security</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	* If the active LSM wants to access the inode during</span>
<span class="cm">	* d_instantiate it needs these. Smack checks to see</span>
<span class="cm">	* if the filesystem supports xattrs by looking at the</span>
<span class="cm">	* ops vector.</span>
<span class="cm">	*/</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_special_inode_operations</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_add_nondir</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">init_special_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">rdev</span><span class="p">);</span>
		<span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode_dec_link_count</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			<span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">nameidata</span> <span class="o">*</span><span class="n">nd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 2 for inode item and ref</span>
<span class="cm">	 * 2 for dir items</span>
<span class="cm">	 * 1 for xattr if selinux is on</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_find_free_ino</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_new_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">objectid</span><span class="p">,</span>
				<span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_init_inode_security</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	* If the active LSM wants to access the inode during</span>
<span class="cm">	* d_instantiate it needs these. Smack checks to see</span>
<span class="cm">	* if the filesystem supports xattrs by looking at the</span>
<span class="cm">	* ops vector.</span>
<span class="cm">	*/</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_file_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_file_inode_operations</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_add_nondir</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_aops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_extent_io_ops</span><span class="p">;</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_unlock:</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode_dec_link_count</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_link</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* do not allow sys_link&#39;s with other subvols of the same device */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EMLINK</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_set_inode_index</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 2 items for inode and inode ref</span>
<span class="cm">	 * 2 items for dir items</span>
<span class="cm">	 * 1 item for parent inode</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_inc_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">ihold</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_add_nondir</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="n">btrfs_log_new_name</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode_dec_link_count</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_mkdir</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="n">umode_t</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_on_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 2 items for inode and ref</span>
<span class="cm">	 * 2 items for dir items</span>
<span class="cm">	 * 1 for xattr if selinux is on</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_find_free_ino</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_new_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">objectid</span><span class="p">,</span>
				<span class="n">S_IFDIR</span> <span class="o">|</span> <span class="n">mode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">drop_on_err</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_init_inode_security</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_file_operations</span><span class="p">;</span>

	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_add_link</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">drop_on_err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_fail:</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_on_err</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* helper for btfs_get_extent.  Given an existing extent in the tree,</span>
<span class="cm"> * and an extent that you want to insert, deal with overlap and insert</span>
<span class="cm"> * the new extent into the tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">merge_extent_mapping</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">existing</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">map_start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">map_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">start_diff</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">map_start</span> <span class="o">&lt;</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">||</span> <span class="n">map_start</span> <span class="o">&gt;=</span> <span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">));</span>
	<span class="n">start_diff</span> <span class="o">=</span> <span class="n">map_start</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">map_start</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">map_len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">EXTENT_MAP_LAST_BYTE</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_COMPRESSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">+=</span> <span class="n">start_diff</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">-=</span> <span class="n">start_diff</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">uncompress_inline</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				      <span class="kt">size_t</span> <span class="n">pg_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">extent_offset</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">max_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">inline_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compress_type</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">pg_offset</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">compress_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="n">max_size</span> <span class="o">=</span> <span class="n">btrfs_file_extent_ram_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="n">inline_size</span> <span class="o">=</span> <span class="n">btrfs_file_extent_inline_item_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
					<span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]));</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">inline_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_inline_start</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

	<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">inline_size</span><span class="p">);</span>

	<span class="n">max_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_decompress</span><span class="p">(</span><span class="n">compress_type</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
			       <span class="n">extent_offset</span><span class="p">,</span> <span class="n">inline_size</span><span class="p">,</span> <span class="n">max_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">copy_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span>
				  <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">pg_offset</span><span class="p">,</span>
				  <span class="n">max_size</span> <span class="o">-</span> <span class="n">extent_offset</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">pg_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">copy_size</span><span class="p">);</span>
		<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * a bit scary, this does extent mapping from logical file offset to the disk.</span>
<span class="cm"> * the ugly parts come from merging extents from the disk with the in-ram</span>
<span class="cm"> * representation.  This gets more complex because of the data=ordered code,</span>
<span class="cm"> * where the in-ram extents might be locked pending data=ordered completion.</span>
<span class="cm"> *</span>
<span class="cm"> * This also copies inline extents directly into the page.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="nf">btrfs_get_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
				    <span class="kt">size_t</span> <span class="n">pg_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">found_type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compress_type</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">em</span> <span class="o">=</span> <span class="n">lookup_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="p">)</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">latest_bdev</span><span class="p">;</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">||</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_INLINE</span> <span class="o">&amp;&amp;</span> <span class="n">page</span><span class="p">)</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">em</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">latest_bdev</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">EXTENT_MAP_HOLE</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">EXTENT_MAP_HOLE</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * Chances are we&#39;ll be called again, so go ahead and do</span>
<span class="cm">		 * readahead</span>
<span class="cm">		 */</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				       <span class="n">objectid</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">trans</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			      <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
	<span class="cm">/* are we inside the extent that was found? */</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">found_type</span> <span class="o">=</span> <span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">objectid</span> <span class="o">||</span>
	    <span class="n">found_type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">found_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="n">extent_start</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">compress_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">||</span>
	    <span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">extent_end</span> <span class="o">=</span> <span class="n">extent_start</span> <span class="o">+</span>
		       <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">btrfs_file_extent_inline_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="n">extent_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">extent_start</span> <span class="o">+</span> <span class="n">size</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">objectid</span> <span class="o">||</span>
		    <span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">not_found</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">not_found_em</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">||</span>
	    <span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">extent_start</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">extent_end</span> <span class="o">-</span> <span class="n">extent_start</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">extent_start</span> <span class="o">-</span>
				 <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytenr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">EXTENT_MAP_HOLE</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">insert</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">compress_type</span> <span class="o">!=</span> <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_COMPRESSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">compress_type</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
									 <span class="n">item</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">bytenr</span> <span class="o">+=</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span>
				<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">goto</span> <span class="n">insert</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">extent_offset</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">copy_size</span><span class="p">;</span>

		<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">EXTENT_MAP_INLINE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span> <span class="o">||</span> <span class="n">create</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">extent_start</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">extent_end</span> <span class="o">-</span> <span class="n">extent_start</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">size</span> <span class="o">=</span> <span class="n">btrfs_file_extent_inline_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="n">extent_offset</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">+</span> <span class="n">pg_offset</span> <span class="o">-</span> <span class="n">extent_start</span><span class="p">;</span>
		<span class="n">copy_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">pg_offset</span><span class="p">,</span>
				<span class="n">size</span> <span class="o">-</span> <span class="n">extent_offset</span><span class="p">);</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">extent_start</span> <span class="o">+</span> <span class="n">extent_offset</span><span class="p">;</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">copy_size</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span>
			<span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">EXTENT_MAP_INLINE</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">compress_type</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_COMPRESSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">compress_type</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_inline_start</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="n">extent_offset</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="o">!=</span>
			    <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">uncompress_inline</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span>
							<span class="n">pg_offset</span><span class="p">,</span>
							<span class="n">extent_offset</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">map</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">map</span> <span class="o">+</span> <span class="n">pg_offset</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
						   <span class="n">copy_size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">pg_offset</span> <span class="o">+</span> <span class="n">copy_size</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">memset</span><span class="p">(</span><span class="n">map</span> <span class="o">+</span> <span class="n">pg_offset</span> <span class="o">+</span> <span class="n">copy_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">pg_offset</span> <span class="o">-</span>
					       <span class="n">copy_size</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">&amp;&amp;</span> <span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG</span><span class="p">();</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
					<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">map</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">map</span> <span class="o">+</span> <span class="n">pg_offset</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
					    <span class="n">copy_size</span><span class="p">);</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">set_extent_uptodate</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				    <span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">insert</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs unknown found_type %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">found_type</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">not_found:</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
<span class="nl">not_found_em:</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">EXTENT_MAP_HOLE</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_VACANCY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
<span class="nl">insert:</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">||</span> <span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Btrfs: bad extent! em: [%llu %llu] passed &quot;</span>
		       <span class="s">&quot;[%llu %llu]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">len</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
	<span class="cm">/* it is possible that someone inserted the extent into the tree</span>
<span class="cm">	 * while we had the lock dropped.  It is also possible that</span>
<span class="cm">	 * an overlapping map exists in the tree</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">existing</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">existing</span> <span class="o">=</span> <span class="n">lookup_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">existing</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">existing</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">||</span>
		    <span class="n">existing</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">existing</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">existing</span><span class="p">);</span>
			<span class="n">existing</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">existing</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">existing</span> <span class="o">=</span> <span class="n">lookup_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
							 <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">existing</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">merge_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">existing</span><span class="p">,</span>
							   <span class="n">em</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
							   <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">existing</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
					<span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="n">em</span> <span class="o">=</span> <span class="n">existing</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="nl">out:</span>

	<span class="n">trace_btrfs_get_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="p">)</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">);</span> <span class="cm">/* Error is always set */</span>
	<span class="k">return</span> <span class="n">em</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="nf">btrfs_get_extent_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span>
					   <span class="kt">size_t</span> <span class="n">pg_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span>
					   <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">hole_em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">range_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">found</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">found_end</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">pg_offset</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">create</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">em</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * if our em maps to a hole, there might</span>
<span class="cm">		 * actually be delalloc bytes behind it</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">!=</span> <span class="n">EXTENT_MAP_HOLE</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">em</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">hole_em</span> <span class="o">=</span> <span class="n">em</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* check to see if we&#39;ve wrapped (len == -1 or similar) */</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span>
		<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">end</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* ok, we didn&#39;t find anything, lets look for delalloc */</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">count_range_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range_start</span><span class="p">,</span>
				 <span class="n">end</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">EXTENT_DELALLOC</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">found_end</span> <span class="o">=</span> <span class="n">range_start</span> <span class="o">+</span> <span class="n">found</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_end</span> <span class="o">&lt;</span> <span class="n">range_start</span><span class="p">)</span>
		<span class="n">found_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we didn&#39;t find anything useful, return</span>
<span class="cm">	 * the original results from get_extent()</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range_start</span> <span class="o">&gt;</span> <span class="n">end</span> <span class="o">||</span> <span class="n">found_end</span> <span class="o">&lt;=</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">hole_em</span><span class="p">;</span>
		<span class="n">hole_em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* adjust the range_start to make sure it doesn&#39;t</span>
<span class="cm">	 * go backwards from the start they passed in</span>
<span class="cm">	 */</span>
	<span class="n">range_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">start</span><span class="p">,</span><span class="n">range_start</span><span class="p">);</span>
	<span class="n">found</span> <span class="o">=</span> <span class="n">found_end</span> <span class="o">-</span> <span class="n">range_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">found</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">hole_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">hole_len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>

		<span class="n">em</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * when btrfs_get_extent can&#39;t find anything it</span>
<span class="cm">		 * returns one huge hole</span>
<span class="cm">		 *</span>
<span class="cm">		 * make sure what it found really fits our range, and</span>
<span class="cm">		 * adjust to make sure it is based on the start from</span>
<span class="cm">		 * the caller</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hole_em</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">calc_end</span> <span class="o">=</span> <span class="n">extent_map_end</span><span class="p">(</span><span class="n">hole_em</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">calc_end</span> <span class="o">&lt;=</span> <span class="n">start</span> <span class="o">||</span> <span class="p">(</span><span class="n">hole_em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">hole_em</span><span class="p">);</span>
				<span class="n">hole_em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">hole_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">hole_em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
				<span class="n">hole_len</span> <span class="o">=</span> <span class="n">calc_end</span> <span class="o">-</span> <span class="n">hole_start</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">hole_em</span> <span class="o">&amp;&amp;</span> <span class="n">range_start</span> <span class="o">&gt;</span> <span class="n">hole_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* our hole starts before our delalloc, so we</span>
<span class="cm">			 * have to return just the parts of the hole</span>
<span class="cm">			 * that go until  the delalloc starts</span>
<span class="cm">			 */</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">hole_len</span><span class="p">,</span>
				      <span class="n">range_start</span> <span class="o">-</span> <span class="n">hole_start</span><span class="p">);</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">hole_start</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">hole_start</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * don&#39;t adjust block start at all,</span>
<span class="cm">			 * it is fixed at EXTENT_MAP_HOLE</span>
<span class="cm">			 */</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">hole_em</span><span class="o">-&gt;</span><span class="n">block_start</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">hole_len</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">range_start</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">range_start</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">EXTENT_MAP_DELALLOC</span><span class="p">;</span>
			<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">found</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">hole_em</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">hole_em</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>

	<span class="n">free_extent_map</span><span class="p">(</span><span class="n">hole_em</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">err</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">em</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="nf">btrfs_new_extent_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
						  <span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">,</span>
						  <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_hint</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">insert</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok if the extent map we looked up is a hole and is for the exact</span>
<span class="cm">	 * range we want, there is no reason to allocate a new one, however if</span>
<span class="cm">	 * it is not right then we need to free this one and drop the cache for</span>
<span class="cm">	 * our range.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">!=</span> <span class="n">EXTENT_MAP_HOLE</span> <span class="o">||</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">!=</span> <span class="n">start</span> <span class="o">||</span>
	    <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">!=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">insert</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
		<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">ERR_CAST</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span> <span class="o">&amp;&amp;</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span>
		<span class="n">btrfs_add_inode_defrag</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_block_rsv</span><span class="p">;</span>

	<span class="n">alloc_hint</span> <span class="o">=</span> <span class="n">get_extent_allocation_hint</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_reserve_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">alloc_hint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">em</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

	<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">latest_bdev</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * We need to do this because if we&#39;re using the original em we searched</span>
<span class="cm">	 * for, we could have EXTENT_FLAG_VACANCY set, and we don&#39;t want that.</span>
<span class="cm">	 */</span>
	<span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PINNED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">insert</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_ordered_extent_dio</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					   <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_free_reserved_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">em</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns 1 when the nocow is safe, &lt; 1 on error, 0 if the</span>
<span class="cm"> * block must be cow&#39;d</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">can_nocow_odirect</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">disk_bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">backref_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found_type</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
				       <span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* can&#39;t find the item, must cow */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">slot</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not our file or wrong item type, must cow */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Wrong offset, must cow */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
	<span class="n">found_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_type</span> <span class="o">!=</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">&amp;&amp;</span>
	    <span class="n">found_type</span> <span class="o">!=</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* not a regular extent, must cow */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">disk_bytenr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="n">backref_offset</span> <span class="o">=</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>

	<span class="n">extent_end</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extent_end</span> <span class="o">&lt;</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* extent doesn&#39;t include our full range, must cow */</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_extent_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * look for other files referencing this extent, if we</span>
<span class="cm">	 * find any we must cow</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_cross_ref_exist</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
				  <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">backref_offset</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * adjust disk_bytenr and num_bytes to cover just the bytes</span>
<span class="cm">	 * in this extent we are about to write.  If there</span>
<span class="cm">	 * are any csums in that range we have to cow in order</span>
<span class="cm">	 * to keep the csums correct</span>
<span class="cm">	 */</span>
	<span class="n">disk_bytenr</span> <span class="o">+=</span> <span class="n">backref_offset</span><span class="p">;</span>
	<span class="n">disk_bytenr</span> <span class="o">+=</span> <span class="n">offset</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">extent_end</span><span class="p">)</span> <span class="o">-</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">csum_exist_in_range</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">disk_bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * all of the above have passed, it is safe to overwrite this extent</span>
<span class="cm">	 * without cow</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_get_blocks_direct</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">iblock</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh_result</span><span class="p">,</span> <span class="kt">int</span> <span class="n">create</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">iblock</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span> <span class="o">=</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Ok for INLINE and COMPRESSED extents we need to fallback on buffered</span>
<span class="cm">	 * io.  INLINE is special, and we could probably kludge it in here, but</span>
<span class="cm">	 * it&#39;s still buffered so for safety lets just fall back to the generic</span>
<span class="cm">	 * buffered path.</span>
<span class="cm">	 *</span>
<span class="cm">	 * For COMPRESSED we _have_ to read the entire extent in so we can</span>
<span class="cm">	 * decompress it, so there will be buffering required no matter what we</span>
<span class="cm">	 * do, so go ahead and fallback to buffered.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We return -ENOTBLK because thats what makes DIO go ahead and go back</span>
<span class="cm">	 * to buffered IO.  Don&#39;t blame me, this is the price we pay for using</span>
<span class="cm">	 * the generic code.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_COMPRESSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_INLINE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTBLK</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Just a good old fashioned hole, return */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">create</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_HOLE</span> <span class="o">||</span>
			<span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="cm">/* DIO will do one hole at a time, so just unlock a sector */</span>
		<span class="n">unlock_extent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
			      <span class="n">start</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We don&#39;t allocate a new extent in the following cases</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) The inode is marked as NODATACOW.  In this case we&#39;ll just use the</span>
<span class="cm">	 * existing extent.</span>
<span class="cm">	 * 2) The extent is marked as PREALLOC.  We&#39;re good to go here and can</span>
<span class="cm">	 * just use the extent.</span>
<span class="cm">	 *</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">create</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">map</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	     <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">!=</span> <span class="n">EXTENT_MAP_HOLE</span><span class="p">))</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">block_start</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ORDERED_PREALLOC</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ORDERED_NOCOW</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">));</span>
		<span class="n">block_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * we&#39;re not going to log anything, but we do need</span>
<span class="cm">		 * to make sure the current transaction stays open</span>
<span class="cm">		 * while we look for nocow cross refs</span>
<span class="cm">		 */</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">must_cow</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">can_nocow_odirect</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_ordered_extent_dio</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span>
					   <span class="n">block_start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">type</span><span class="p">);</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">must_cow:</span>
	<span class="cm">/*</span>
<span class="cm">	 * this will cow the extent, reset the len in case we changed</span>
<span class="cm">	 * it above</span>
<span class="cm">	 */</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">;</span>
	<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_new_extent_direct</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">em</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
	<span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">));</span>
<span class="nl">unlock:</span>
	<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="n">EXTENT_LOCKED</span> <span class="o">|</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span> <span class="n">EXTENT_DIRTY</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
			  <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="nl">map:</span>
	<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_blocknr</span> <span class="o">=</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">+</span> <span class="p">(</span><span class="n">start</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">))</span> <span class="o">&gt;&gt;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">;</span>
	<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">bh_result</span><span class="o">-&gt;</span><span class="n">b_bdev</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="n">set_buffer_mapped</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">create</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">set_buffer_new</span><span class="p">(</span><span class="n">bh_result</span><span class="p">);</span>

	<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">btrfs_dio_private</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">logical_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">disk_bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">csums</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">private</span><span class="p">;</span>

	<span class="cm">/* number of bios pending for this dio */</span>
	<span class="n">atomic_t</span> <span class="n">pending_bios</span><span class="p">;</span>

	<span class="cm">/* IO errors */</span>
	<span class="kt">int</span> <span class="n">errors</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">orig_bio</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_endio_direct_read</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_dio_private</span> <span class="o">*</span><span class="n">dip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec_end</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">+</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">private</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">csums</span><span class="p">;</span>

	<span class="n">start</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATASUM</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">;</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">csum</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>

			<span class="n">local_irq_save</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
			<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">csum</span> <span class="o">=</span> <span class="n">btrfs_csum_data</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">,</span>
					       <span class="n">csum</span><span class="p">,</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">);</span>
			<span class="n">btrfs_csum_final</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">csum</span><span class="p">);</span>
			<span class="n">kunmap_atomic</span><span class="p">(</span><span class="n">kaddr</span><span class="p">);</span>
			<span class="n">local_irq_restore</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>

			<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">csum</span> <span class="o">!=</span> <span class="o">*</span><span class="n">private</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs csum failed ino %llu off&quot;</span>
				      <span class="s">&quot; %llu csum %u private %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
				      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">start</span><span class="p">,</span>
				      <span class="n">csum</span><span class="p">,</span> <span class="o">*</span><span class="n">private</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">start</span> <span class="o">+=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
		<span class="n">private</span><span class="o">++</span><span class="p">;</span>
		<span class="n">bvec</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bvec</span> <span class="o">&lt;=</span> <span class="n">bvec_end</span><span class="p">);</span>

	<span class="n">unlock_extent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span><span class="p">,</span>
		      <span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span> <span class="o">+</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">csums</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">dip</span><span class="p">);</span>

	<span class="cm">/* If we had a csum failure make sure to clear the uptodate flag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
	<span class="n">dio_end_io</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_endio_direct_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_dio_private</span> <span class="o">*</span><span class="n">dip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ordered_offset</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ordered_bytes</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_done</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_dec_test_first_ordered_pending</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">ordered_offset</span><span class="p">,</span>
						   <span class="n">ordered_bytes</span><span class="p">,</span> <span class="o">!</span><span class="n">err</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_test</span><span class="p">;</span>

	<span class="n">ordered</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">func</span> <span class="o">=</span> <span class="n">finish_ordered_fn</span><span class="p">;</span>
	<span class="n">ordered</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_queue_worker</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">endio_write_workers</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">work</span><span class="p">);</span>
<span class="nl">out_test:</span>
	<span class="cm">/*</span>
<span class="cm">	 * our bio might span multiple ordered extents.  If we haven&#39;t</span>
<span class="cm">	 * completed the accounting for the whole dio, go back and try again</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered_offset</span> <span class="o">&lt;</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span> <span class="o">+</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ordered_bytes</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span> <span class="o">+</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">-</span>
			<span class="n">ordered_offset</span><span class="p">;</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out_done:</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">private</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dip</span><span class="p">);</span>

	<span class="cm">/* If we had an error make sure to clear the uptodate flag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
	<span class="n">dio_end_io</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_submit_bio_start_direct_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">bio_flags</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_csum_one_bio</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_end_dio_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_dio_private</span> <span class="o">*</span><span class="n">dip</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs direct IO failed ino %llu rw %lu &quot;</span>
		      <span class="s">&quot;sector %#Lx len %u err no %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">),</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_rw</span><span class="p">,</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">,</span> <span class="n">err</span><span class="p">);</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * before atomic variable goto zero, we must make sure</span>
<span class="cm">		 * dip-&gt;errors is perceived to be set.</span>
<span class="cm">		 */</span>
		<span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/* if there are more bios still pending for this dio, just exit */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">pending_bios</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">errors</span><span class="p">)</span>
		<span class="n">bio_io_error</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">orig_bio</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">);</span>
		<span class="n">bio_endio</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">orig_bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="nf">btrfs_dio_bio_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">first_sector</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nr_vecs</span> <span class="o">=</span> <span class="n">bio_get_nr_vecs</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">btrfs_bio_alloc</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">first_sector</span><span class="p">,</span> <span class="n">nr_vecs</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">__btrfs_submit_dio_bio</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
					 <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">skip_sum</span><span class="p">,</span>
					 <span class="n">u32</span> <span class="o">*</span><span class="n">csums</span><span class="p">,</span> <span class="kt">int</span> <span class="n">async_submit</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">write</span> <span class="o">=</span> <span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">bio_get</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_bio_wq_end_io</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">skip_sum</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">map</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="n">async_submit</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_wq_submit_bio</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
				   <span class="n">inode</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">file_offset</span><span class="p">,</span>
				   <span class="n">__btrfs_submit_bio_start_direct_io</span><span class="p">,</span>
				   <span class="n">__btrfs_submit_bio_done</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If we aren&#39;t doing async submit, calculate the csum of the</span>
<span class="cm">		 * bio now.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_csum_one_bio</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">skip_sum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_bio_sums_dio</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span>
					  <span class="n">file_offset</span><span class="p">,</span> <span class="n">csums</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">map:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_map_bio</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">async_submit</span><span class="p">);</span>
<span class="nl">err:</span>
	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_submit_direct_hook</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_dio_private</span> <span class="o">*</span><span class="n">dip</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">skip_sum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_mapping_tree</span> <span class="o">*</span><span class="n">map_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">orig_bio</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">orig_bio</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start_sector</span> <span class="o">=</span> <span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">file_offset</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">submit_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">map_length</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="o">*</span><span class="n">csums</span> <span class="o">=</span> <span class="n">dip</span><span class="o">-&gt;</span><span class="n">csums</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">async_submit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write</span> <span class="o">=</span> <span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">;</span>

	<span class="n">map_length</span> <span class="o">=</span> <span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_map_block</span><span class="p">(</span><span class="n">map_tree</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span> <span class="n">start_sector</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">map_length</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">orig_bio</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map_length</span> <span class="o">&gt;=</span> <span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bio</span> <span class="o">=</span> <span class="n">orig_bio</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">submit</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">async_submit</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bio</span> <span class="o">=</span> <span class="n">btrfs_dio_bio_alloc</span><span class="p">(</span><span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span> <span class="n">start_sector</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">dip</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfs_end_dio_bio</span><span class="p">;</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">pending_bios</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bvec</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">+</span> <span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">map_length</span> <span class="o">&lt;</span> <span class="n">submit_len</span> <span class="o">+</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span> <span class="o">||</span>
		    <span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_page</span><span class="p">,</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">,</span>
				 <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_offset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * inc the count before we submit the bio so</span>
<span class="cm">			 * we know the end IO handler won&#39;t happen before</span>
<span class="cm">			 * we inc the count. Otherwise, the dip might get freed</span>
<span class="cm">			 * before we&#39;re done setting it up</span>
<span class="cm">			 */</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">pending_bios</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_submit_dio_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span>
						     <span class="n">file_offset</span><span class="p">,</span> <span class="n">skip_sum</span><span class="p">,</span>
						     <span class="n">csums</span><span class="p">,</span> <span class="n">async_submit</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
				<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">pending_bios</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* Write&#39;s use the ordered csums */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_sum</span><span class="p">)</span>
				<span class="n">csums</span> <span class="o">=</span> <span class="n">csums</span> <span class="o">+</span> <span class="n">nr_pages</span><span class="p">;</span>
			<span class="n">start_sector</span> <span class="o">+=</span> <span class="n">submit_len</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
			<span class="n">file_offset</span> <span class="o">+=</span> <span class="n">submit_len</span><span class="p">;</span>

			<span class="n">submit_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">nr_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">bio</span> <span class="o">=</span> <span class="n">btrfs_dio_bio_alloc</span><span class="p">(</span><span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">,</span>
						  <span class="n">start_sector</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">dip</span><span class="p">;</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfs_end_dio_bio</span><span class="p">;</span>

			<span class="n">map_length</span> <span class="o">=</span> <span class="n">orig_bio</span><span class="o">-&gt;</span><span class="n">bi_size</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_map_block</span><span class="p">(</span><span class="n">map_tree</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span> <span class="n">start_sector</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">map_length</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out_err</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">submit_len</span> <span class="o">+=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
			<span class="n">nr_pages</span> <span class="o">++</span><span class="p">;</span>
			<span class="n">bvec</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">submit:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_submit_dio_bio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">skip_sum</span><span class="p">,</span>
				     <span class="n">csums</span><span class="p">,</span> <span class="n">async_submit</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
<span class="nl">out_err:</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * before atomic variable goto zero, we must</span>
<span class="cm">	 * make sure dip-&gt;errors is perceived to be set.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb__before_atomic_dec</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">pending_bios</span><span class="p">))</span>
		<span class="n">bio_io_error</span><span class="p">(</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">orig_bio</span><span class="p">);</span>

	<span class="cm">/* bio_end_io() will handle error, so we needn&#39;t return it */</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_submit_direct</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				<span class="n">loff_t</span> <span class="n">file_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_dio_private</span> <span class="o">*</span><span class="n">dip</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">bio_vec</span> <span class="o">*</span><span class="n">bvec</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip_sum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write</span> <span class="o">=</span> <span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_WRITE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">skip_sum</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATASUM</span><span class="p">;</span>

	<span class="n">dip</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dip</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dip</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">free_ordered</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">csums</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="cm">/* Write&#39;s use the ordered csum stuff, so we don&#39;t need dip-&gt;csums */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">write</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">skip_sum</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">csums</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span> <span class="o">*</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">csums</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">dip</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">free_ordered</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">private</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">inode</span><span class="p">;</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">logical_offset</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>

	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">do</span> <span class="p">{</span>
		<span class="n">dip</span><span class="o">-&gt;</span><span class="n">bytes</span> <span class="o">+=</span> <span class="n">bvec</span><span class="o">-&gt;</span><span class="n">bv_len</span><span class="p">;</span>
		<span class="n">bvec</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">bvec</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span> <span class="o">+</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">disk_bytenr</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">&lt;&lt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">dip</span><span class="p">;</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">errors</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dip</span><span class="o">-&gt;</span><span class="n">orig_bio</span> <span class="o">=</span> <span class="n">bio</span><span class="p">;</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dip</span><span class="o">-&gt;</span><span class="n">pending_bios</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfs_endio_direct_write</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfs_endio_direct_read</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_submit_direct_hook</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">dip</span><span class="p">,</span> <span class="n">skip_sum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
<span class="nl">free_ordered:</span>
	<span class="cm">/*</span>
<span class="cm">	 * If this is a write, we need to clean up the reserved space and kill</span>
<span class="cm">	 * the ordered extent.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">write</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_NOCOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="n">btrfs_free_reserved_extent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						   <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">disk_len</span><span class="p">);</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">bio_endio</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">check_direct_IO</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">seg</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">addr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="n">blocksize_mask</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">retval</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">end</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Check the memory alignment.  Blocks cannot straddle pages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">seg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seg</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">seg</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_base</span><span class="p">;</span>
		<span class="n">size</span> <span class="o">=</span> <span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_len</span><span class="p">;</span>
		<span class="n">end</span> <span class="o">+=</span> <span class="n">size</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">addr</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">size</span> <span class="o">&amp;</span> <span class="n">blocksize_mask</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="cm">/* If this is a write we don&#39;t need to check anymore */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Check to make sure we don&#39;t have duplicate iov_base&#39;s in this</span>
<span class="cm">		 * iovec, if so return EINVAL, otherwise we&#39;ll get csum errors</span>
<span class="cm">		 * when reading back.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">seg</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_segs</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">iov</span><span class="p">[</span><span class="n">seg</span><span class="p">].</span><span class="n">iov_base</span> <span class="o">==</span> <span class="n">iov</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">iov_base</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">retval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">retval</span><span class="p">;</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">btrfs_direct_IO</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lockstart</span><span class="p">,</span> <span class="n">lockend</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">writing</span> <span class="o">=</span> <span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">write_bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">check_direct_IO</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span>
			    <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">lockstart</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
	<span class="n">lockend</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delalloc_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lock_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">lockstart</span><span class="p">,</span> <span class="n">lockend</span><span class="p">,</span>
				 <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re concerned with the entire range that we&#39;re going to be</span>
<span class="cm">		 * doing DIO to, so we need to make sure theres no ordered</span>
<span class="cm">		 * extents in this range.</span>
<span class="cm">		 */</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">lockstart</span><span class="p">,</span>
						     <span class="n">lockend</span> <span class="o">-</span> <span class="n">lockstart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ordered</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">lockstart</span><span class="p">,</span> <span class="n">lockend</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">btrfs_start_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t use btrfs_set_extent_delalloc because we don&#39;t want</span>
<span class="cm">	 * the dirty or uptodate bits</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">writing</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">write_bits</span> <span class="o">=</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span> <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">set_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">lockstart</span><span class="p">,</span> <span class="n">lockend</span><span class="p">,</span>
				     <span class="n">EXTENT_DELALLOC</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span>
				     <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">lockstart</span><span class="p">,</span>
					 <span class="n">lockend</span><span class="p">,</span> <span class="n">EXTENT_LOCKED</span> <span class="o">|</span> <span class="n">write_bits</span><span class="p">,</span>
					 <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">free_extent_state</span><span class="p">(</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__blockdev_direct_IO</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">iocb</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
		   <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">latest_bdev</span><span class="p">,</span>
		   <span class="n">iov</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">btrfs_get_blocks_direct</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
		   <span class="n">btrfs_submit_direct</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
			      <span class="n">offset</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="n">EXTENT_LOCKED</span> <span class="o">|</span> <span class="n">write_bits</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">&lt;</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We&#39;re falling back to buffered, unlock the section we didn&#39;t</span>
<span class="cm">		 * do IO on.</span>
<span class="cm">		 */</span>
		<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">ret</span><span class="p">,</span>
			      <span class="n">offset</span> <span class="o">+</span> <span class="n">iov_length</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			      <span class="n">EXTENT_LOCKED</span> <span class="o">|</span> <span class="n">write_bits</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">free_extent_state</span><span class="p">(</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_fiemap</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">fiemap_extent_info</span> <span class="o">*</span><span class="n">fieinfo</span><span class="p">,</span>
		<span class="n">__u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">__u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">extent_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">fieinfo</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">btrfs_get_extent_fiemap</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_readpage</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">extent_read_full_page</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">btrfs_get_extent</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_writepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>


	<span class="k">if</span> <span class="p">(</span><span class="n">current</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">PF_MEMALLOC</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">redirty_page_for_writepage</span><span class="p">(</span><span class="n">wbc</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">extent_write_full_page</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">btrfs_get_extent</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_writepages</span><span class="p">(</span><span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">writeback_control</span> <span class="o">*</span><span class="n">wbc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">extent_writepages</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">btrfs_get_extent</span><span class="p">,</span> <span class="n">wbc</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span>
<span class="nf">btrfs_readpages</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pages</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">nr_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">extent_readpages</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">mapping</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">nr_pages</span><span class="p">,</span>
				<span class="n">btrfs_get_extent</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_releasepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">try_release_extent_mapping</span><span class="p">(</span><span class="n">map</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">page</span><span class="p">,</span> <span class="n">gfp_flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ClearPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_releasepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">gfp_flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PageWriteback</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">||</span> <span class="n">PageDirty</span><span class="p">(</span><span class="n">page</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__btrfs_releasepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">gfp_flags</span> <span class="o">&amp;</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_invalidatepage</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_start</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">page_end</span> <span class="o">=</span> <span class="n">page_start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * we have the page locked, so new writeback can&#39;t start,</span>
<span class="cm">	 * and the dirty bit won&#39;t be cleared while we are here.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Wait for IO on this page so that we can safely clear</span>
<span class="cm">	 * the PagePrivate2 bit and do ordered accounting</span>
<span class="cm">	 */</span>
	<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_releasepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">lock_extent_bits</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					   <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * IO on this page will never be started, so we need</span>
<span class="cm">		 * to account for any ordered extents now</span>
<span class="cm">		 */</span>
		<span class="n">clear_extent_bit</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
				 <span class="n">EXTENT_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span>
				 <span class="n">EXTENT_LOCKED</span> <span class="o">|</span> <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * whoever cleared the private bit is responsible</span>
<span class="cm">		 * for the finish_ordered_io</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">TestClearPagePrivate2</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="n">btrfs_dec_test_ordered_pending</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span>
						   <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">btrfs_finish_ordered_io</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">lock_extent_bits</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">clear_extent_bit</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
		 <span class="n">EXTENT_LOCKED</span> <span class="o">|</span> <span class="n">EXTENT_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span>
		 <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">__btrfs_releasepage</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">PagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ClearPagePrivate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">set_page_private</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * btrfs_page_mkwrite() is not allowed to change the file size as it gets</span>
<span class="cm"> * called from a page fault handler when a page is first dirtied. Hence we must</span>
<span class="cm"> * be careful to check for EOF conditions here. We set the page up correctly</span>
<span class="cm"> * for a written page which means we get ENOSPC checking when writing into</span>
<span class="cm"> * holes and correct delalloc and unwritten extent mapping on filesystems that</span>
<span class="cm"> * support these features.</span>
<span class="cm"> *</span>
<span class="cm"> * We are not allowed to take the i_mutex here so we have to play games to</span>
<span class="cm"> * protect against truncate races as the page could now be beyond EOF.  Because</span>
<span class="cm"> * vmtruncate() writes the inode size before removing pages, once we have the</span>
<span class="cm"> * page lock we can determine safely if the page is beyond EOF. If it is not</span>
<span class="cm"> * beyond EOF, then the page is guaranteed safe against truncation until we</span>
<span class="cm"> * unlock the page.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_page_mkwrite</span><span class="p">(</span><span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_fault</span> <span class="o">*</span><span class="n">vmf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">vmf</span><span class="o">-&gt;</span><span class="n">page</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">zero_start</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">reserved</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_end</span><span class="p">;</span>

	<span class="n">ret</span>  <span class="o">=</span> <span class="n">btrfs_delalloc_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">file_update_time</span><span class="p">(</span><span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_file</span><span class="p">);</span>
		<span class="n">reserved</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_OOM</span><span class="p">;</span>
		<span class="k">else</span> <span class="cm">/* -ENOSPC, -EIO, etc */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">reserved</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_noreserve</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_NOPAGE</span><span class="p">;</span> <span class="cm">/* make the VM retry the fault */</span>
<span class="nl">again:</span>
	<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">page_start</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">page_end</span> <span class="o">=</span> <span class="n">page_start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">page_start</span> <span class="o">&gt;=</span> <span class="n">size</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* page got truncated out from underneath us */</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">lock_extent_bits</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="n">set_page_extent_mapped</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we can&#39;t set the delalloc bits if there are pending ordered</span>
<span class="cm">	 * extents.  Drop our locks and wait for them to finish</span>
<span class="cm">	 */</span>
	<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">btrfs_start_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * XXX - page_mkwrite gets called every time the page is dirtied, even</span>
<span class="cm">	 * if it was already dirty, so for space accounting reasons we need to</span>
<span class="cm">	 * clear any delalloc bits for the range we are fixing to save.  There</span>
<span class="cm">	 * is probably a better way to do this, but for now keep consistent with</span>
<span class="cm">	 * prepare_pages in the normal write path.</span>
<span class="cm">	 */</span>
	<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
			  <span class="n">EXTENT_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span> <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">,</span>
			  <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_extent_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">VM_FAULT_SIGBUS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* page is wholly or partially inside EOF */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">page_start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&gt;</span> <span class="n">size</span><span class="p">)</span>
		<span class="n">zero_start</span> <span class="o">=</span> <span class="n">size</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">PAGE_CACHE_MASK</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">zero_start</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">zero_start</span> <span class="o">!=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">memset</span><span class="p">(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">zero_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">zero_start</span><span class="p">);</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">kunmap</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
	<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_trans</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_sub_trans</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">log_transid</span><span class="p">;</span>

	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">VM_FAULT_LOCKED</span><span class="p">;</span>
	<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
<span class="nl">out_noreserve:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_truncate</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_block_rsv</span> <span class="o">*</span><span class="n">rsv</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">min_size</span> <span class="o">=</span> <span class="n">btrfs_calc_trunc_metadata_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_truncate_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;</span> <span class="p">(</span><span class="o">~</span><span class="n">mask</span><span class="p">),</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Yes ladies and gentelment, this is indeed ugly.  The fact is we have</span>
<span class="cm">	 * 3 things going on here</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) We need to reserve space for our orphan item and the space to</span>
<span class="cm">	 * delete our orphan item.  Lord knows we don&#39;t want to have a dangling</span>
<span class="cm">	 * orphan item because we didn&#39;t reserve space to remove it.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 2) We need to reserve space to update our inode.</span>
<span class="cm">	 *</span>
<span class="cm">	 * 3) We need to have something to cache all the space that is going to</span>
<span class="cm">	 * be free&#39;d up by the truncate operation, but also have some slack</span>
<span class="cm">	 * space reserved in case it uses space during the truncate (thank you</span>
<span class="cm">	 * very much snapshotting).</span>
<span class="cm">	 *</span>
<span class="cm">	 * And we need these to all be seperate.  The fact is we can use alot of</span>
<span class="cm">	 * space doing the truncate, and we have no earthly idea how much space</span>
<span class="cm">	 * we will use, so we need the truncate reservation to be seperate so it</span>
<span class="cm">	 * doesn&#39;t end up using space reserved for updating the inode or</span>
<span class="cm">	 * removing the orphan item.  We also need to be able to stop the</span>
<span class="cm">	 * transaction and start a new one, which means we need to be able to</span>
<span class="cm">	 * update the inode several times, and we have no idea of knowing how</span>
<span class="cm">	 * many times that will be, so we can&#39;t just reserve 1 item for the</span>
<span class="cm">	 * entirety of the opration, so that has to be done seperately as well.</span>
<span class="cm">	 * Then there is the orphan item, which does indeed need to be held on</span>
<span class="cm">	 * to for the whole operation, and we need nobody to touch this reserved</span>
<span class="cm">	 * space except the orphan code.</span>
<span class="cm">	 *</span>
<span class="cm">	 * So that leaves us with</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) root-&gt;orphan_block_rsv - for the orphan deletion.</span>
<span class="cm">	 * 2) rsv - for the truncate reservation, which we will steal from the</span>
<span class="cm">	 * transaction reservation.</span>
<span class="cm">	 * 3) fs_info-&gt;trans_block_rsv - this will have 1 items worth left for</span>
<span class="cm">	 * updating the inode.</span>
<span class="cm">	 */</span>
	<span class="n">rsv</span> <span class="o">=</span> <span class="n">btrfs_alloc_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rsv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">rsv</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">min_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 1 for the truncate slack space</span>
<span class="cm">	 * 1 for the orphan item we&#39;re going to add</span>
<span class="cm">	 * 1 for the orphan item deletion</span>
<span class="cm">	 * 1 for updating the inode.</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Migrate the slack space for the truncate to our reserve */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_block_rsv_migrate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">,</span> <span class="n">rsv</span><span class="p">,</span>
				      <span class="n">min_size</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_add</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * setattr is responsible for setting the ordered_data_close flag,</span>
<span class="cm">	 * but that is only tested during the last file release.  That</span>
<span class="cm">	 * could happen well after the next commit, leaving a great big</span>
<span class="cm">	 * window where new writes may get lost if someone chooses to write</span>
<span class="cm">	 * to this file after truncating to zero</span>
<span class="cm">	 *</span>
<span class="cm">	 * The inode doesn&#39;t have any dirty data here, and so if we commit</span>
<span class="cm">	 * this is a noop.  If someone immediately starts writing to the inode</span>
<span class="cm">	 * it is very likely we&#39;ll catch some of their writes in this</span>
<span class="cm">	 * transaction, and the commit will find this file on the ordered</span>
<span class="cm">	 * data list with good things to send down.</span>
<span class="cm">	 *</span>
<span class="cm">	 * This is a best effort solution, there is still a window where</span>
<span class="cm">	 * using truncate to replace the contents of the file will</span>
<span class="cm">	 * end up with a zero length file after a crash.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_ORDERED_DATA_CLOSE</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="n">btrfs_add_ordered_operation</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_block_rsv_refill</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rsv</span><span class="p">,</span> <span class="n">min_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * This can only happen with the original transaction we</span>
<span class="cm">			 * started above, every other time we shouldn&#39;t have a</span>
<span class="cm">			 * transaction started yet.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">end_trans</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* Just need the 1 for updating the inode */</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="n">rsv</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_truncate_inode_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						 <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span>
						 <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">end_trans:</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_block_rsv</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_del</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Failed to do the truncate, remove us from the in memory</span>
<span class="cm">		 * orphan list.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_del</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_block_rsv</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

		<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">btrfs_free_block_rsv</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">rsv</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * create a new subvolume directory/inode (helper for the ioctl).</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_create_subvol_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">new_root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_dirid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_new_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">new_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
				<span class="n">new_dirid</span><span class="p">,</span> <span class="n">new_dirid</span><span class="p">,</span>
				<span class="n">S_IFDIR</span> <span class="o">|</span> <span class="p">(</span><span class="o">~</span><span class="n">current_umask</span><span class="p">()</span> <span class="o">&amp;</span> <span class="n">S_IRWXUGO</span><span class="p">),</span>
				<span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_dir_file_operations</span><span class="p">;</span>

	<span class="n">set_nlink</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">new_root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">btrfs_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">btrfs_inode_cachep</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">space_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">last_trans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">last_sub_trans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">logged_trans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">disk_i_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">csum_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">index_cnt</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">last_unlink_trans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">spin_lock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">reserved_extents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">runtime_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">force_compress</span> <span class="o">=</span> <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">delayed_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
	<span class="n">extent_map_tree_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">);</span>
	<span class="n">extent_io_tree_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
	<span class="n">extent_io_tree_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">io_failure_tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">);</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">.</span><span class="n">track_uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">io_failure_tree</span><span class="p">.</span><span class="n">track_uptodate</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">log_mutex</span><span class="p">);</span>
	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">delalloc_mutex</span><span class="p">);</span>
	<span class="n">btrfs_ordered_inode_tree_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">);</span>
	<span class="n">RB_CLEAR_NODE</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfs_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">btrfs_inode_cachep</span><span class="p">,</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_dentry</span><span class="p">));</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">.</span><span class="n">nrpages</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">reserved_extents</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">csum_bytes</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This can happen where we create an inode, but somebody else also</span>
<span class="cm">	 * created the same inode and we need to destroy the one we already</span>
<span class="cm">	 * created.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">free</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we&#39;re properly removed from the ordered operation</span>
<span class="cm">	 * lists.</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ORPHAN_ITEM</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;BTRFS: inode %llu still on the orphan list</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">orphan_inodes</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ordered</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;btrfs found ordered &quot;</span>
			       <span class="s">&quot;extent %llu %llu on inode cleanup</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">btrfs_remove_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">);</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">inode_tree_del</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="nl">free:</span>
	<span class="n">btrfs_remove_delayed_node</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">btrfs_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_drop_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">btrfs_is_free_space_inode</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">generic_drop_inode</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="p">)</span> <span class="n">foo</span><span class="p">;</span>

	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_destroy_cachep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_inode_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">btrfs_inode_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_trans_handle_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">btrfs_trans_handle_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_transaction_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">btrfs_transaction_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_path_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">btrfs_path_cachep</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_free_space_cachep</span><span class="p">)</span>
		<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">btrfs_free_space_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_init_cachep</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">btrfs_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;btrfs_inode_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_inode</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span> <span class="o">|</span> <span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="n">init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_inode_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">btrfs_trans_handle_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;btrfs_trans_handle_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span> <span class="o">|</span> <span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_trans_handle_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">btrfs_transaction_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;btrfs_transaction_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_transaction</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span> <span class="o">|</span> <span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_transaction_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">btrfs_path_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;btrfs_path_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span> <span class="o">|</span> <span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_path_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">btrfs_free_space_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;btrfs_free_space_cache&quot;</span><span class="p">,</span>
			<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_free_space</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span>
			<span class="n">SLAB_RECLAIM_ACCOUNT</span> <span class="o">|</span> <span class="n">SLAB_MEM_SPREAD</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_free_space_cachep</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">btrfs_destroy_cachep</span><span class="p">();</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_getattr</span><span class="p">(</span><span class="k">struct</span> <span class="n">vfsmount</span> <span class="o">*</span><span class="n">mnt</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstat</span> <span class="o">*</span><span class="n">stat</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocksize</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

	<span class="n">generic_fillattr</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">stat</span><span class="p">);</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">anon_dev</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blksize</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
	<span class="n">stat</span><span class="o">-&gt;</span><span class="n">blocks</span> <span class="o">=</span> <span class="p">(</span><span class="n">ALIGN</span><span class="p">(</span><span class="n">inode_get_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">blocksize</span><span class="p">)</span> <span class="o">+</span>
		<span class="n">ALIGN</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">delalloc_bytes</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">))</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * If a file is moved, it will inherit the cow and compression flags of the new</span>
<span class="cm"> * directory.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_inode_flags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">b_dir</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">b_inode</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b_dir</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">)</span>
		<span class="n">b_inode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">b_inode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_NODATACOW</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">b_dir</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">b_inode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">;</span>
		<span class="n">b_inode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">b_inode</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BTRFS_INODE_COMPRESS</span> <span class="o">|</span>
				    <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_rename</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">old_dentry</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">new_dentry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">old_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">new_inode</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">old_inode</span> <span class="o">=</span> <span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">timespec</span> <span class="n">ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">root_objectid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">old_ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">new_dir</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTRFS_EMPTY_SUBVOL_DIR_OBJECTID</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="cm">/* we only allow rename subvolume link between subvolumes */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_ino</span> <span class="o">!=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span> <span class="o">&amp;&amp;</span> <span class="n">root</span> <span class="o">!=</span> <span class="n">dest</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_ino</span> <span class="o">==</span> <span class="n">BTRFS_EMPTY_SUBVOL_DIR_OBJECTID</span> <span class="o">||</span>
	    <span class="p">(</span><span class="n">new_inode</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">new_inode</span> <span class="o">&amp;&amp;</span>
	    <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">BTRFS_EMPTY_DIR_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * we&#39;re using rename to replace one file with another.</span>
<span class="cm">	 * and the replacement file is large.  Start IO on it now so</span>
<span class="cm">	 * we don&#39;t add too much work to the end of the transaction</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span>
	    <span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT</span><span class="p">)</span>
		<span class="n">filemap_flush</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="cm">/* close the racy window with snapshot create/destroy ioctl */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_ino</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We want to reserve the absolute worst case amount of items.  So if</span>
<span class="cm">	 * both inodes are subvols and we need to unlink them then that would</span>
<span class="cm">	 * require 4 item modifications, but if they are both normal inodes it</span>
<span class="cm">	 * would require 5 item modifications, so we&#39;ll assume their normal</span>
<span class="cm">	 * inodes.  So 5 * 2 is 10, plus 1 for the new link, so 11 total items</span>
<span class="cm">	 * should cover the worst case number of items we&#39;ll modify.</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">20</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
                <span class="k">goto</span> <span class="n">out_notrans</span><span class="p">;</span>
        <span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dest</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span>
		<span class="n">btrfs_record_root_in_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_inode_index</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old_ino</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* force full log commit if subvolume involved. */</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">last_trans_log_full_commit</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_inode_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span>
					     <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					     <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span>
					     <span class="n">old_ino</span><span class="p">,</span>
					     <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">new_dir</span><span class="p">),</span> <span class="n">index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * this is an ugly little race, but the rename is required</span>
<span class="cm">		 * to make sure that if we crash, the inode is either at the</span>
<span class="cm">		 * old name or the new one.  pinning the log transaction lets</span>
<span class="cm">		 * us make sure we don&#39;t allow a log commit to come in after</span>
<span class="cm">		 * we unlink the name but before we add the new name back in.</span>
<span class="cm">		 */</span>
		<span class="n">btrfs_pin_log_trans</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * make sure the inode gets flushed if it is replacing</span>
<span class="cm">	 * something.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span> <span class="o">&amp;&amp;</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span> <span class="n">S_ISREG</span><span class="p">(</span><span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="n">btrfs_add_ordered_operation</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">);</span>

	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">old_dir</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">new_dir</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">old_inode</span><span class="p">);</span>
	<span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">old_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">ctime</span><span class="p">;</span>
	<span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">new_dir</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">ctime</span><span class="p">;</span>
	<span class="n">old_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">ctime</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span> <span class="o">!=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">)</span>
		<span class="n">btrfs_record_unlink_dir</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">old_ino</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">root_objectid</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">old_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_unlink_subvol</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
					<span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					<span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_unlink_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span>
					<span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span>
					<span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
					<span class="n">old_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">new_inode</span><span class="p">);</span>
		<span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">new_inode</span><span class="p">)</span> <span class="o">==</span>
			     <span class="n">BTRFS_EMPTY_SUBVOL_DIR_OBJECTID</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">root_objectid</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">new_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">location</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_unlink_subvol</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span>
						<span class="n">root_objectid</span><span class="p">,</span>
						<span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
						<span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_unlink_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dest</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span>
						 <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span>
						 <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
						 <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">new_inode</span><span class="o">-&gt;</span><span class="n">i_nlink</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_add</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">fixup_inode_flags</span><span class="p">(</span><span class="n">new_dir</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_link</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">new_dir</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">,</span>
			     <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
			     <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_ino</span> <span class="o">!=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">new_dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
		<span class="n">btrfs_log_new_name</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">old_inode</span><span class="p">,</span> <span class="n">old_dir</span><span class="p">,</span> <span class="n">parent</span><span class="p">);</span>
		<span class="n">btrfs_end_log_trans</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_fail:</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="nl">out_notrans:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_ino</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * some fairly slow code that needs optimization. This walks the list</span>
<span class="cm"> * of all the inodes with pending delalloc and forces them to disk.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_start_delalloc_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay_iput</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">binode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">binode</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode</span><span class="p">,</span>
				    <span class="n">delalloc_inodes</span><span class="p">);</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span>
			<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">binode</span><span class="o">-&gt;</span><span class="n">delalloc_inodes</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">filemap_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delay_iput</span><span class="p">)</span>
				<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">delalloc_lock</span><span class="p">);</span>

	<span class="cm">/* the filemap_flush will queue IO into the worker threads, but</span>
<span class="cm">	 * we have to make sure the IO is actually started and that</span>
<span class="cm">	 * ordered extents get created before we return</span>
<span class="cm">	 */</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_draining</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">nr_async_submits</span><span class="p">)</span> <span class="o">||</span>
	      <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_wait</span><span class="p">,</span>
		   <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">nr_async_submits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
		    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_draining</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_symlink</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			 <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">symname</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span> <span class="p">;</span>
	<span class="kt">int</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">datasize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">name_len</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">symname</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">name_len</span> <span class="o">&gt;</span> <span class="n">BTRFS_MAX_INLINE_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENAMETOOLONG</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 2 items for inode item and ref</span>
<span class="cm">	 * 2 items for dir items</span>
<span class="cm">	 * 1 item for xattr if selinux is on</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_find_free_ino</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_new_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">objectid</span><span class="p">,</span>
				<span class="n">S_IFLNK</span><span class="o">|</span><span class="n">S_IRWXUGO</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_init_inode_security</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	* If the active LSM wants to access the inode during</span>
<span class="cm">	* d_instantiate it needs these. Smack checks to see</span>
<span class="cm">	* if the filesystem supports xattrs by looking at the</span>
<span class="cm">	* ops vector.</span>
<span class="cm">	*/</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_fop</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_file_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_file_inode_operations</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_add_nondir</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_aops</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">.</span><span class="n">ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_extent_io_ops</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">);</span>
	<span class="n">datasize</span> <span class="o">=</span> <span class="n">btrfs_file_extent_calc_inline_size</span><span class="p">(</span><span class="n">name_len</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
				      <span class="n">datasize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span>
				   <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_encryption</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_other_encoding</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_file_extent_ram_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_inline_start</span><span class="p">(</span><span class="n">ei</span><span class="p">);</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">symname</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_symlink_inode_operations</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_symlink_aops</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">bdi</span><span class="p">;</span>
	<span class="n">inode_set_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">name_len</span><span class="p">);</span>
	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">name_len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="n">drop_inode</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">blocks_used</span><span class="p">;</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">drop_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inode_dec_link_count</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_prealloc_file_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_size</span><span class="p">,</span>
				       <span class="n">loff_t</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">alloc_hint</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">ins</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">own_trans</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span>
		<span class="n">own_trans</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">own_trans</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_reserve_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">min_size</span><span class="p">,</span>
					   <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">alloc_hint</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ins</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">own_trans</span><span class="p">)</span>
				<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_reserved_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
						  <span class="n">cur_offset</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
						  <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
						  <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						  <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">own_trans</span><span class="p">)</span>
				<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">cur_offset</span><span class="p">,</span>
					<span class="n">cur_offset</span> <span class="o">+</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">cur_offset</span> <span class="o">+=</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="o">*</span><span class="n">alloc_hint</span> <span class="o">=</span> <span class="n">ins</span><span class="p">.</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">ins</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

		<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_PREALLOC</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">actual_len</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&gt;</span> <span class="n">actual_len</span><span class="p">)</span>
				<span class="n">i_size</span> <span class="o">=</span> <span class="n">actual_len</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">i_size</span> <span class="o">=</span> <span class="n">cur_offset</span><span class="p">;</span>
			<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_size</span><span class="p">);</span>
			<span class="n">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">own_trans</span><span class="p">)</span>
				<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">own_trans</span><span class="p">)</span>
			<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_prealloc_file_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			      <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_size</span><span class="p">,</span>
			      <span class="n">loff_t</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">alloc_hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_prealloc_file_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
					   <span class="n">min_size</span><span class="p">,</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">alloc_hint</span><span class="p">,</span>
					   <span class="nb">NULL</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_prealloc_file_range_trans</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
				    <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_size</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">alloc_hint</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_prealloc_file_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
					   <span class="n">min_size</span><span class="p">,</span> <span class="n">actual_len</span><span class="p">,</span> <span class="n">alloc_hint</span><span class="p">,</span> <span class="n">trans</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_set_page_dirty</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__set_page_dirty_nobuffers</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_permission</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mask</span> <span class="o">&amp;</span> <span class="n">MAY_WRITE</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISLNK</span><span class="p">(</span><span class="n">mode</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_READONLY</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">generic_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_dir_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">btrfs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">btrfs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">create</span>		<span class="o">=</span> <span class="n">btrfs_create</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlink</span>		<span class="o">=</span> <span class="n">btrfs_unlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">link</span>		<span class="o">=</span> <span class="n">btrfs_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mkdir</span>		<span class="o">=</span> <span class="n">btrfs_mkdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rmdir</span>		<span class="o">=</span> <span class="n">btrfs_rmdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">rename</span>		<span class="o">=</span> <span class="n">btrfs_rename</span><span class="p">,</span>
	<span class="p">.</span><span class="n">symlink</span>	<span class="o">=</span> <span class="n">btrfs_symlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">btrfs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mknod</span>		<span class="o">=</span> <span class="n">btrfs_mknod</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">btrfs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">btrfs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">btrfs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">btrfs_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">btrfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>	<span class="o">=</span> <span class="n">btrfs_get_acl</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_dir_ro_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">lookup</span>		<span class="o">=</span> <span class="n">btrfs_lookup</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">btrfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>	<span class="o">=</span> <span class="n">btrfs_get_acl</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">btrfs_dir_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">generic_read_dir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readdir</span>	<span class="o">=</span> <span class="n">btrfs_real_readdir</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">btrfs_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">btrfs_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
	<span class="p">.</span><span class="n">release</span>        <span class="o">=</span> <span class="n">btrfs_release_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">btrfs_sync_file</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">extent_io_ops</span> <span class="n">btrfs_extent_io_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fill_delalloc</span> <span class="o">=</span> <span class="n">run_delalloc_range</span><span class="p">,</span>
	<span class="p">.</span><span class="n">submit_bio_hook</span> <span class="o">=</span> <span class="n">btrfs_submit_bio_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">merge_bio_hook</span> <span class="o">=</span> <span class="n">btrfs_merge_bio_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpage_end_io_hook</span> <span class="o">=</span> <span class="n">btrfs_readpage_end_io_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage_end_io_hook</span> <span class="o">=</span> <span class="n">btrfs_writepage_end_io_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage_start_hook</span> <span class="o">=</span> <span class="n">btrfs_writepage_start_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_bit_hook</span> <span class="o">=</span> <span class="n">btrfs_set_bit_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">clear_bit_hook</span> <span class="o">=</span> <span class="n">btrfs_clear_bit_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">merge_extent_hook</span> <span class="o">=</span> <span class="n">btrfs_merge_extent_hook</span><span class="p">,</span>
	<span class="p">.</span><span class="n">split_extent_hook</span> <span class="o">=</span> <span class="n">btrfs_split_extent_hook</span><span class="p">,</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * btrfs doesn&#39;t support the bmap operation because swapfiles</span>
<span class="cm"> * use bmap to make a mapping of extents in the file.  They assume</span>
<span class="cm"> * these extents won&#39;t change over the life of the file and they</span>
<span class="cm"> * use the bmap result to do IO directly to the drive.</span>
<span class="cm"> *</span>
<span class="cm"> * the btrfs bmap call would return logical addresses that aren&#39;t</span>
<span class="cm"> * suitable for IO and they also will change frequently as COW</span>
<span class="cm"> * operations happen.  So, swapfile + btrfs == corruption.</span>
<span class="cm"> *</span>
<span class="cm"> * For now we&#39;re avoiding this by dropping bmap.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">btrfs_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>	<span class="o">=</span> <span class="n">btrfs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>	<span class="o">=</span> <span class="n">btrfs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepages</span>	<span class="o">=</span> <span class="n">btrfs_writepages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">readpages</span>	<span class="o">=</span> <span class="n">btrfs_readpages</span><span class="p">,</span>
	<span class="p">.</span><span class="n">direct_IO</span>	<span class="o">=</span> <span class="n">btrfs_direct_IO</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">btrfs_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>	<span class="o">=</span> <span class="n">btrfs_releasepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">set_page_dirty</span>	<span class="o">=</span> <span class="n">btrfs_set_page_dirty</span><span class="p">,</span>
	<span class="p">.</span><span class="n">error_remove_page</span> <span class="o">=</span> <span class="n">generic_error_remove_page</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">address_space_operations</span> <span class="n">btrfs_symlink_aops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readpage</span>	<span class="o">=</span> <span class="n">btrfs_readpage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">writepage</span>	<span class="o">=</span> <span class="n">btrfs_writepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">invalidatepage</span> <span class="o">=</span> <span class="n">btrfs_invalidatepage</span><span class="p">,</span>
	<span class="p">.</span><span class="n">releasepage</span>	<span class="o">=</span> <span class="n">btrfs_releasepage</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_file_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">btrfs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">btrfs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">btrfs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">btrfs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>      <span class="o">=</span> <span class="n">btrfs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">btrfs_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">btrfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fiemap</span>		<span class="o">=</span> <span class="n">btrfs_fiemap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>	<span class="o">=</span> <span class="n">btrfs_get_acl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_time</span>	<span class="o">=</span> <span class="n">btrfs_update_time</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_special_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">btrfs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">btrfs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">btrfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">btrfs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">btrfs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">btrfs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">btrfs_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>	<span class="o">=</span> <span class="n">btrfs_get_acl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_time</span>	<span class="o">=</span> <span class="n">btrfs_update_time</span><span class="p">,</span>
<span class="p">};</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">inode_operations</span> <span class="n">btrfs_symlink_inode_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">readlink</span>	<span class="o">=</span> <span class="n">generic_readlink</span><span class="p">,</span>
	<span class="p">.</span><span class="n">follow_link</span>	<span class="o">=</span> <span class="n">page_follow_link_light</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_link</span>	<span class="o">=</span> <span class="n">page_put_link</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getattr</span>	<span class="o">=</span> <span class="n">btrfs_getattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setattr</span>	<span class="o">=</span> <span class="n">btrfs_setattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">permission</span>	<span class="o">=</span> <span class="n">btrfs_permission</span><span class="p">,</span>
	<span class="p">.</span><span class="n">setxattr</span>	<span class="o">=</span> <span class="n">btrfs_setxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">getxattr</span>	<span class="o">=</span> <span class="n">btrfs_getxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">listxattr</span>	<span class="o">=</span> <span class="n">btrfs_listxattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">removexattr</span>	<span class="o">=</span> <span class="n">btrfs_removexattr</span><span class="p">,</span>
	<span class="p">.</span><span class="n">get_acl</span>	<span class="o">=</span> <span class="n">btrfs_get_acl</span><span class="p">,</span>
	<span class="p">.</span><span class="n">update_time</span>	<span class="o">=</span> <span class="n">btrfs_update_time</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">dentry_operations</span> <span class="n">btrfs_dentry_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">d_delete</span>	<span class="o">=</span> <span class="n">btrfs_dentry_delete</span><span class="p">,</span>
	<span class="p">.</span><span class="n">d_release</span>	<span class="o">=</span> <span class="n">btrfs_dentry_release</span><span class="p">,</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
