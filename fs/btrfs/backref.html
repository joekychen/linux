<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › backref.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>backref.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2011 STRATO.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;backref.h&quot;</span>
<span class="cp">#include &quot;ulist.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;delayed-ref.h&quot;</span>
<span class="cp">#include &quot;locking.h&quot;</span>

<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_extent_in_eb</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">extent_item_pos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">**</span><span class="n">eie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">data_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">e</span><span class="p">;</span>

	<span class="n">data_offset</span> <span class="o">=</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="n">data_len</span> <span class="o">=</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extent_item_pos</span> <span class="o">&lt;</span> <span class="n">data_offset</span> <span class="o">||</span>
	    <span class="n">extent_item_pos</span> <span class="o">&gt;=</span> <span class="n">data_offset</span> <span class="o">+</span> <span class="n">data_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">e</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">e</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">e</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">e</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="o">*</span><span class="n">eie</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">inum</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">e</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">+</span> <span class="p">(</span><span class="n">extent_item_pos</span> <span class="o">-</span> <span class="n">data_offset</span><span class="p">);</span>
	<span class="o">*</span><span class="n">eie</span> <span class="o">=</span> <span class="n">e</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_extent_in_eb</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">wanted_disk_byte</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">extent_item_pos</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">**</span><span class="n">eie</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">disk_byte</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extent_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * from the shared data ref, we only have the leaf but we need</span>
<span class="cm">	 * the key. thus, we must look into all items and see that we</span>
<span class="cm">	 * find one (some) with a reference to our extent item.</span>
<span class="cm">	 */</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">slot</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="o">++</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">extent_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="cm">/* don&#39;t skip BTRFS_FILE_EXTENT_PREALLOC, we can handle that */</span>
		<span class="n">disk_byte</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disk_byte</span> <span class="o">!=</span> <span class="n">wanted_disk_byte</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">check_extent_in_eb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">extent_item_pos</span><span class="p">,</span> <span class="n">eie</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this structure records all encountered refs on the way up to the root</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">list</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">root_id</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key_for_search</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">inode_list</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">wanted_disk_byte</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * the rules for all callers of this function are:</span>
<span class="cm"> * - obtaining the parent is the goal</span>
<span class="cm"> * - if you add a key, you must know that it is a correct key</span>
<span class="cm"> * - if you cannot add the parent or a correct key, then we will look into the</span>
<span class="cm"> *   block later to set a correct key</span>
<span class="cm"> *</span>
<span class="cm"> * delayed refs</span>
<span class="cm"> * ============</span>
<span class="cm"> *        backref type | shared | indirect | shared | indirect</span>
<span class="cm"> * information         |   tree |     tree |   data |     data</span>
<span class="cm"> * --------------------+--------+----------+--------+----------</span>
<span class="cm"> *      parent logical |    y   |     -    |    -   |     -</span>
<span class="cm"> *      key to resolve |    -   |     y    |    y   |     y</span>
<span class="cm"> *  tree block logical |    -   |     -    |    -   |     -</span>
<span class="cm"> *  root for resolving |    y   |     y    |    y   |     y</span>
<span class="cm"> *</span>
<span class="cm"> * - column 1:       we&#39;ve the parent -&gt; done</span>
<span class="cm"> * - column 2, 3, 4: we use the key to find the parent</span>
<span class="cm"> *</span>
<span class="cm"> * on disk refs (inline or keyed)</span>
<span class="cm"> * ==============================</span>
<span class="cm"> *        backref type | shared | indirect | shared | indirect</span>
<span class="cm"> * information         |   tree |     tree |   data |     data</span>
<span class="cm"> * --------------------+--------+----------+--------+----------</span>
<span class="cm"> *      parent logical |    y   |     -    |    y   |     -</span>
<span class="cm"> *      key to resolve |    -   |     -    |    -   |     y</span>
<span class="cm"> *  tree block logical |    y   |     y    |    y   |     y</span>
<span class="cm"> *  root for resolving |    -   |     y    |    y   |     y</span>
<span class="cm"> *</span>
<span class="cm"> * - column 1, 3: we&#39;ve the parent -&gt; done</span>
<span class="cm"> * - column 2:    we take the first key from the block to find the parent</span>
<span class="cm"> *                (see __add_missing_keys)</span>
<span class="cm"> * - column 4:    we use the key to find the parent</span>
<span class="cm"> *</span>
<span class="cm"> * additional information that&#39;s available but not required to find the parent</span>
<span class="cm"> * block might help in merging entries to gain some speed.</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__add_prelim_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root_id</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span> <span class="n">u64</span> <span class="n">wanted_disk_byte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>

	<span class="cm">/* in case we&#39;re adding delayed refs, we&#39;re holding the refs spinlock */</span>
	<span class="n">ref</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ref</span><span class="p">),</span> <span class="n">GFP_ATOMIC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">root_id</span> <span class="o">=</span> <span class="n">root_id</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">)</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span> <span class="o">=</span> <span class="o">*</span><span class="n">key</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">));</span>

	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">inode_list</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="n">ref</span><span class="o">-&gt;</span><span class="n">wanted_disk_byte</span> <span class="o">=</span> <span class="n">wanted_disk_byte</span><span class="p">;</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">add_all_parents</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">parents</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key_for_search</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">wanted_disk_byte</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">extent_item_pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">eie</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">disk_byte</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">ulist_add</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We normally enter this function with the path already pointing to</span>
<span class="cm">	 * the first item to check. But sometimes, we may enter it with</span>
<span class="cm">	 * slot==nritems. In that case, go to the next leaf before we continue.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_old_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">key_for_search</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">||</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">disk_byte</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">disk_byte</span> <span class="o">==</span> <span class="n">wanted_disk_byte</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eie</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extent_item_pos</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">check_extent_in_eb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
						<span class="o">*</span><span class="n">extent_item_pos</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">eie</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">ulist_add</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">eie</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">extent_item_pos</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_old_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
							<span class="n">time_seq</span><span class="p">);</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_old_item</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * resolve an indirect backref in the form (root_id, key, level)</span>
<span class="cm"> * to a logical address</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__resolve_indirect_ref</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">search_commit_root</span><span class="p">,</span>
					<span class="n">u64</span> <span class="n">time_seq</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">parents</span><span class="p">,</span>
					<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">extent_item_pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">root_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">root_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span> <span class="o">=</span> <span class="o">!!</span><span class="n">search_commit_root</span><span class="p">;</span>

	<span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root_id</span><span class="p">;</span>
	<span class="n">root_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">root_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">root_level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root_level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">level</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_old_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;search slot in root %llu (level %d, ref count %d) returned &quot;</span>
		 <span class="s">&quot;%d for key (%llu %u %llu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">root_id</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">,</span> <span class="n">ret</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
		 <span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">add_all_parents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">,</span>
				<span class="n">time_seq</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">wanted_disk_byte</span><span class="p">,</span>
				<span class="n">extent_item_pos</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * resolve all indirect backrefs from the list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__resolve_indirect_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
				   <span class="kt">int</span> <span class="n">search_commit_root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span>
				   <span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">extent_item_pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref_safe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">new_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">parents</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_iterator</span> <span class="n">uiter</span><span class="p">;</span>

	<span class="n">parents</span> <span class="o">=</span> <span class="n">ulist_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parents</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * _safe allows us to insert directly after the current item without</span>
<span class="cm">	 * iterating over the newly inserted items.</span>
<span class="cm">	 * we&#39;re also allowed to re-assign ref during iteration.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">ref_safe</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>	<span class="cm">/* already direct */</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__resolve_indirect_ref</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">search_commit_root</span><span class="p">,</span>
					     <span class="n">time_seq</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="n">parents</span><span class="p">,</span>
					     <span class="n">extent_item_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* we put the first parent into the ref at hand */</span>
		<span class="n">ULIST_ITER_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uiter</span><span class="p">);</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">ulist_next</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiter</span><span class="p">);</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span> <span class="o">?</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ref</span><span class="o">-&gt;</span><span class="n">inode_list</span> <span class="o">=</span>
			<span class="n">node</span> <span class="o">?</span> <span class="p">(</span><span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">aux</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* additional parents require new refs being added here */</span>
		<span class="k">while</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">ulist_next</span><span class="p">(</span><span class="n">parents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiter</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">new_ref</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">new_ref</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">new_ref</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">memcpy</span><span class="p">(</span><span class="n">new_ref</span><span class="p">,</span> <span class="n">ref</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ref</span><span class="p">));</span>
			<span class="n">new_ref</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
			<span class="n">new_ref</span><span class="o">-&gt;</span><span class="n">inode_list</span> <span class="o">=</span>
					<span class="p">(</span><span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">aux</span><span class="p">;</span>
			<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_ref</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ulist_reinit</span><span class="p">(</span><span class="n">parents</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ulist_free</span><span class="p">(</span><span class="n">parents</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">ref_for_same_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref1</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">!=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">root_id</span> <span class="o">!=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">root_id</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * read tree blocks and add keys where required.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__add_missing_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__prelim_ref</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">.</span><span class="n">type</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">wanted_disk_byte</span><span class="p">);</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">wanted_disk_byte</span><span class="p">,</span>
				     <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">eb</span><span class="p">);</span>
		<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">btrfs_node_key_to_cpu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">key_for_search</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">btrfs_tree_read_unlock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * merge two lists of backrefs and adjust counts accordingly</span>
<span class="cm"> *</span>
<span class="cm"> * mode = 1: merge identical keys, if key is set</span>
<span class="cm"> *    FIXME: if we add more keys in __add_prelim_ref, we can merge more here.</span>
<span class="cm"> *           additionally, we could even add a key range for the blocks we</span>
<span class="cm"> *           looked into to merge even more (-&gt; replace unresolved refs by those</span>
<span class="cm"> *           having a parent).</span>
<span class="cm"> * mode = 2: merge identical parents</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__merge_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos1</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">n2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">pos2</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref1</span><span class="p">;</span>

		<span class="n">ref1</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__prelim_ref</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">pos2</span> <span class="o">=</span> <span class="n">pos1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">pos2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span> <span class="n">pos2</span> <span class="o">!=</span> <span class="n">head</span><span class="p">;</span>
		     <span class="n">pos2</span> <span class="o">=</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="n">pos2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref2</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">xchg</span><span class="p">;</span>

			<span class="n">ref2</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">pos2</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__prelim_ref</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref_for_same_block</span><span class="p">(</span><span class="n">ref1</span><span class="p">,</span> <span class="n">ref2</span><span class="p">))</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">xchg</span> <span class="o">=</span> <span class="n">ref1</span><span class="p">;</span>
					<span class="n">ref1</span> <span class="o">=</span> <span class="n">ref2</span><span class="p">;</span>
					<span class="n">ref2</span> <span class="o">=</span> <span class="n">xchg</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">ref1</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ref1</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">!=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="n">ref1</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">+=</span> <span class="n">ref2</span><span class="o">-&gt;</span><span class="n">count</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref2</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">ref2</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add all currently queued delayed refs from this head whose seq nr is</span>
<span class="cm"> * smaller or equal that seq to the list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__add_delayed_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="n">u64</span> <span class="n">seq</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prefs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_extent_op</span> <span class="o">*</span><span class="n">extent_op</span> <span class="o">=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">extent_op</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">op_key</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">sgn</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extent_op</span> <span class="o">&amp;&amp;</span> <span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">update_key</span><span class="p">)</span>
		<span class="n">btrfs_disk_key_to_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">op_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">extent_op</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">n</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="n">n</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_delayed_ref_node</span><span class="p">,</span>
				<span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span> <span class="o">!=</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">bytenr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">is_head</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">seq</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">action</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BTRFS_ADD_DELAYED_EXTENT</span>:
		<span class="k">case</span> <span class="n">BTRFS_UPDATE_DELAYED_HEAD</span>:
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BTRFS_ADD_DELAYED_REF</span>:
			<span class="n">sgn</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BTRFS_DROP_DELAYED_REF</span>:
			<span class="n">sgn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_delayed_tree_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>

			<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_tree_ref</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">op_key</span><span class="p">,</span>
					       <span class="n">ref</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					       <span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span> <span class="o">*</span> <span class="n">sgn</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_delayed_tree_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>

			<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_tree_ref</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					       <span class="n">ref</span><span class="o">-&gt;</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
					       <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					       <span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span> <span class="o">*</span> <span class="n">sgn</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_delayed_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>
			<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_data_ref</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

			<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					       <span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span> <span class="o">*</span> <span class="n">sgn</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_delayed_data_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>

			<span class="n">ref</span> <span class="o">=</span> <span class="n">btrfs_delayed_node_to_data_ref</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

			<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">,</span>
					       <span class="n">node</span><span class="o">-&gt;</span><span class="n">ref_mod</span> <span class="o">*</span> <span class="n">sgn</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add all inline backrefs for bytenr to the list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__add_inline_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="o">*</span><span class="n">info_level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prefs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">item_size</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * enumerate all inline refs</span>
<span class="cm">	 */</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">));</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_extent_flags</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ei</span> <span class="o">+</span> <span class="n">item_size</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

		<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="o">*</span><span class="n">info_level</span> <span class="o">=</span> <span class="n">btrfs_tree_block_level</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ptr</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>

		<span class="n">iref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)</span><span class="n">ptr</span><span class="p">;</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="o">*</span><span class="n">info_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						<span class="n">bytenr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">sdref</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

			<span class="n">sdref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">iref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">btrfs_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">sdref</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
					       <span class="n">bytenr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					       <span class="o">*</span><span class="n">info_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">bytenr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">dref</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">root</span><span class="p">;</span>

			<span class="n">dref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="n">iref</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">);</span>
			<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
								      <span class="n">dref</span><span class="p">);</span>
			<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">);</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">bytenr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">+=</span> <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="n">type</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * add all non-inline backrefs for bytenr to the list</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__add_keyed_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">info_level</span><span class="p">,</span> <span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">prefs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">extent_root</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_item</span><span class="p">(</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">bytenr</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
						<span class="n">info_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
						<span class="n">bytenr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BTRFS_SHARED_DATA_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span> <span class="o">*</span><span class="n">sdref</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>

			<span class="n">sdref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">btrfs_shared_data_ref</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">btrfs_shared_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">sdref</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
						<span class="n">bytenr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">case</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span>:
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					       <span class="n">info_level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">bytenr</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">BTRFS_EXTENT_DATA_REF_KEY</span>: <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span> <span class="o">*</span><span class="n">dref</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">count</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">root</span><span class="p">;</span>

			<span class="n">dref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
					      <span class="k">struct</span> <span class="n">btrfs_extent_data_ref</span><span class="p">);</span>
			<span class="n">count</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_count</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">);</span>
			<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_objectid</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
								      <span class="n">dref</span><span class="p">);</span>
			<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">);</span>
			<span class="n">root</span> <span class="o">=</span> <span class="n">btrfs_extent_data_ref_root</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">dref</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_prelim_ref</span><span class="p">(</span><span class="n">prefs</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					       <span class="n">bytenr</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="nl">default:</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this adds all existing backrefs (inline backrefs, backrefs and delayed</span>
<span class="cm"> * refs) for the given bytenr to the refs list, merges duplicates and resolves</span>
<span class="cm"> * indirect refs to their parent bytenr.</span>
<span class="cm"> * When roots are found, they&#39;re added to the roots list</span>
<span class="cm"> *</span>
<span class="cm"> * FIXME some caching might speed things up</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_parent_nodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">delayed_ref_seq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">refs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">roots</span><span class="p">,</span>
			     <span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">extent_item_pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_head</span> <span class="o">*</span><span class="n">head</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">info_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">search_commit_root</span> <span class="o">=</span> <span class="p">(</span><span class="n">trans</span> <span class="o">==</span> <span class="n">BTRFS_BACKREF_SEARCH_COMMIT_ROOT</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">prefs_delayed</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">prefs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">__prelim_ref</span> <span class="o">*</span><span class="n">ref</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs_delayed</span><span class="p">);</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span> <span class="o">=</span> <span class="o">!!</span><span class="n">search_commit_root</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * grab both a lock on the path and a lock on the delayed ref head.</span>
<span class="cm">	 * We need both to get a consistent picture of how the refs look</span>
<span class="cm">	 * at a specified point in time</span>
<span class="cm">	 */</span>
<span class="nl">again:</span>
	<span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span> <span class="o">!=</span> <span class="n">BTRFS_BACKREF_SEARCH_COMMIT_ROOT</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * look if there are updates for this ref queued and lock the</span>
<span class="cm">		 * head</span>
<span class="cm">		 */</span>
		<span class="n">delayed_refs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">delayed_refs</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">head</span> <span class="o">=</span> <span class="n">btrfs_find_delayed_ref_head</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mutex_trylock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">.</span><span class="n">refs</span><span class="p">);</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

				<span class="cm">/*</span>
<span class="cm">				 * Mutex was contended, block until it&#39;s</span>
<span class="cm">				 * released and try again</span>
<span class="cm">				 */</span>
				<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
				<span class="n">btrfs_put_delayed_ref</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_delayed_refs</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="n">delayed_ref_seq</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">prefs_delayed</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">bytenr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_inline_refs</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">info_level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prefs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_keyed_refs</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
					       <span class="n">info_level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prefs</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs_delayed</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prefs</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__add_missing_keys</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prefs</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__merge_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__resolve_indirect_refs</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">search_commit_root</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">,</span>
				      <span class="o">&amp;</span><span class="n">prefs</span><span class="p">,</span> <span class="n">extent_item_pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__merge_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__prelim_ref</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root_id</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* no parent == root of tree */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ulist_add</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">root_id</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">count</span> <span class="o">&amp;&amp;</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">eie</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">extent_item_pos</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">inode_list</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u32</span> <span class="n">bsz</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
				<span class="n">bsz</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
							<span class="n">info_level</span><span class="p">);</span>
				<span class="n">eb</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span>
							   <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span> <span class="n">bsz</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">eb</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">find_extent_in_eb</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
							<span class="o">*</span><span class="n">extent_item_pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eie</span><span class="p">);</span>
				<span class="n">ref</span><span class="o">-&gt;</span><span class="n">inode_list</span> <span class="o">=</span> <span class="n">eie</span><span class="p">;</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">ulist_add_merge</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">parent</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">inode_list</span><span class="p">,</span>
					      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">eie</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">extent_item_pos</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * we&#39;ve recorded that parent, so we must extend</span>
<span class="cm">				 * its inode list here</span>
<span class="cm">				 */</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">eie</span><span class="p">);</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">eie</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span>
					<span class="n">eie</span> <span class="o">=</span> <span class="n">eie</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
				<span class="n">eie</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">ref</span><span class="o">-&gt;</span><span class="n">inode_list</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">head</span><span class="p">)</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">mutex</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__prelim_ref</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs_delayed</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ref</span> <span class="o">=</span> <span class="n">list_first_entry</span><span class="p">(</span><span class="o">&amp;</span><span class="n">prefs_delayed</span><span class="p">,</span> <span class="k">struct</span> <span class="n">__prelim_ref</span><span class="p">,</span>
				       <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ref</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">free_leaf_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">blocks</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ulist_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">eie</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">eie_next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_iterator</span> <span class="n">uiter</span><span class="p">;</span>

	<span class="n">ULIST_ITER_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uiter</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">((</span><span class="n">node</span> <span class="o">=</span> <span class="n">ulist_next</span><span class="p">(</span><span class="n">blocks</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">aux</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">eie</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="p">)</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">aux</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(;</span> <span class="n">eie</span><span class="p">;</span> <span class="n">eie</span> <span class="o">=</span> <span class="n">eie_next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eie_next</span> <span class="o">=</span> <span class="n">eie</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">eie</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">node</span><span class="o">-&gt;</span><span class="n">aux</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ulist_free</span><span class="p">(</span><span class="n">blocks</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Finds all leafs with a reference to the specified combination of bytenr and</span>
<span class="cm"> * offset. key_list_head will point to a list of corresponding keys (caller must</span>
<span class="cm"> * free each list element). The leafs will be stored in the leafs ulist, which</span>
<span class="cm"> * must be freed with ulist_free.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt;0 on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_find_all_leafs</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">delayed_ref_seq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ulist</span> <span class="o">**</span><span class="n">leafs</span><span class="p">,</span>
				<span class="k">const</span> <span class="n">u64</span> <span class="o">*</span><span class="n">extent_item_pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ulist_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">leafs</span> <span class="o">=</span> <span class="n">ulist_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">leafs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ulist_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">find_parent_nodes</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">delayed_ref_seq</span><span class="p">,</span>
				<span class="n">time_seq</span><span class="p">,</span> <span class="o">*</span><span class="n">leafs</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">extent_item_pos</span><span class="p">);</span>
	<span class="n">ulist_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_leaf_list</span><span class="p">(</span><span class="o">*</span><span class="n">leafs</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * walk all backrefs for a given extent to find all roots that reference this</span>
<span class="cm"> * extent. Walking a backref means finding all extents that reference this</span>
<span class="cm"> * extent and in turn walk the backrefs of those, too. Naturally this is a</span>
<span class="cm"> * recursive process, but here it is implemented in an iterative fashion: We</span>
<span class="cm"> * find all referencing extents for the extent in question and put them on a</span>
<span class="cm"> * list. In turn, we find all referencing extents for those, further appending</span>
<span class="cm"> * to the list. The way we iterate the list allows adding more elements after</span>
<span class="cm"> * the current while iterating. The process stops when we reach the end of the</span>
<span class="cm"> * list. Found roots are added to the roots list.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success, &lt; 0 on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_find_all_roots</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">delayed_ref_seq</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">ulist</span> <span class="o">**</span><span class="n">roots</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_iterator</span> <span class="n">uiter</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">ulist_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tmp</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="o">*</span><span class="n">roots</span> <span class="o">=</span> <span class="n">ulist_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">roots</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ulist_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ULIST_ITER_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">uiter</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_parent_nodes</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">delayed_ref_seq</span><span class="p">,</span>
					<span class="n">time_seq</span><span class="p">,</span> <span class="n">tmp</span><span class="p">,</span> <span class="o">*</span><span class="n">roots</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ulist_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">ulist_free</span><span class="p">(</span><span class="o">*</span><span class="n">roots</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">ulist_next</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uiter</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">bytenr</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ulist_free</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">static</span> <span class="kt">int</span> <span class="nf">__inode_info</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ioff</span><span class="p">,</span> <span class="n">u8</span> <span class="n">key_type</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">fs_root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">found_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">key_type</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">ioff</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">fs_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">fs_root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">||</span> <span class="n">found_key</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this makes the path point to (inum INODE_ITEM ioff)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">inode_item_info</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ioff</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">fs_root</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">__inode_info</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="n">ioff</span><span class="p">,</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">,</span> <span class="n">fs_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">inode_ref_info</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ioff</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">fs_root</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">found_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__inode_info</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="n">ioff</span><span class="p">,</span> <span class="n">BTRFS_INODE_REF_KEY</span><span class="p">,</span> <span class="n">fs_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				<span class="n">found_key</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this iterates to turn a btrfs_inode_ref into a full filesystem path. elements</span>
<span class="cm"> * of the path are separated by &#39;/&#39; and the path is guaranteed to be</span>
<span class="cm"> * 0-terminated. the path is only given within the current file system.</span>
<span class="cm"> * Therefore, it never starts with a &#39;/&#39;. the caller is responsible to provide</span>
<span class="cm"> * &quot;size&quot; bytes in &quot;dest&quot;. the dest buffer will be filled backwards. finally,</span>
<span class="cm"> * the start point of the resulting string is returned. this pointer is within</span>
<span class="cm"> * dest, normally.</span>
<span class="cm"> * in case the path buffer would overflow, the pointer is decremented further</span>
<span class="cm"> * as if output was written to the buffer, though no more output is actually</span>
<span class="cm"> * generated. that way, the caller can determine how much space would be</span>
<span class="cm"> * required for the path to fit into the buffer. in that case, the returned</span>
<span class="cm"> * value will be smaller than dest. callers must check this!</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">iref_to_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">fs_root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_inode_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb_in</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent</span><span class="p">,</span>
				<span class="kt">char</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">next_inum</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">s64</span> <span class="n">bytes_left</span> <span class="o">=</span> <span class="n">size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span> <span class="o">=</span> <span class="n">eb_in</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">leave_spinning</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">dest</span><span class="p">[</span><span class="n">bytes_left</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">btrfs_inode_ref_name_len</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>
		<span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">dest</span> <span class="o">+</span> <span class="n">bytes_left</span><span class="p">,</span>
						<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">iref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">!=</span> <span class="n">eb_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_tree_read_unlock_blocking</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">inode_ref_info</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fs_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">next_inum</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

		<span class="cm">/* regular exit ahead */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span> <span class="o">==</span> <span class="n">next_inum</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="cm">/* make sure we can use eb after releasing the path */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">!=</span> <span class="n">eb_in</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
			<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
			<span class="n">btrfs_set_lock_blocking_rw</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="n">iref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode_ref</span><span class="p">);</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">next_inum</span><span class="p">;</span>
		<span class="o">--</span><span class="n">bytes_left</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes_left</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">dest</span><span class="p">[</span><span class="n">bytes_left</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="n">leave_spinning</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">dest</span> <span class="o">+</span> <span class="n">bytes_left</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this makes the path point to (logical EXTENT_ITEM *)</span>
<span class="cm"> * returns BTRFS_EXTENT_FLAG_DATA for data, BTRFS_EXTENT_FLAG_TREE_BLOCK for</span>
<span class="cm"> * tree blocks and &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">extent_from_logical</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">logical</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">found_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">logical</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_previous_item</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_ITEM_KEY</span> <span class="o">||</span>
	    <span class="n">found_key</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&gt;</span> <span class="n">logical</span> <span class="o">||</span>
	    <span class="n">found_key</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">+</span> <span class="n">found_key</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">logical</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;logical %llu is not within any extent</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">logical</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">item_size</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ei</span><span class="p">));</span>

	<span class="n">ei</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="k">struct</span> <span class="n">btrfs_extent_item</span><span class="p">);</span>
	<span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_extent_flags</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;logical %llu is at position %llu within the extent (%llu &quot;</span>
		 <span class="s">&quot;EXTENT_ITEM %llu) flags %#llx size %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">logical</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)(</span><span class="n">logical</span> <span class="o">-</span> <span class="n">found_key</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">),</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">found_key</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">found_key</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span>
		 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">flags</span><span class="p">,</span> <span class="n">item_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BTRFS_EXTENT_FLAG_DATA</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function to iterate extent inline refs. ptr must point to a 0 value</span>
<span class="cm"> * for the first call and may be modified. it is used to track state.</span>
<span class="cm"> * if more refs exist, 0 is returned and the next call to</span>
<span class="cm"> * __get_extent_inline_ref must pass the modified ptr parameter to get the</span>
<span class="cm"> * next ref. after the last ref was processed, 1 is returned.</span>
<span class="cm"> * returns &lt;0 on error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__get_extent_inline_ref</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">,</span> <span class="n">u32</span> <span class="n">item_size</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">**</span><span class="n">out_eiref</span><span class="p">,</span>
				<span class="kt">int</span> <span class="o">*</span><span class="n">out_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">ptr</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first call */</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_extent_flags</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">ei</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="o">*</span><span class="n">out_eiref</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">info</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">out_eiref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">*</span><span class="n">out_eiref</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">ei</span> <span class="o">+</span> <span class="n">item_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ei</span> <span class="o">+</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="o">*</span><span class="n">out_eiref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="p">)</span><span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="o">*</span><span class="n">out_type</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_type</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">*</span><span class="n">out_eiref</span><span class="p">);</span>

	<span class="o">*</span><span class="n">ptr</span> <span class="o">+=</span> <span class="n">btrfs_extent_inline_ref_size</span><span class="p">(</span><span class="o">*</span><span class="n">out_type</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">&gt;</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="n">end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* last */</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * reads the tree block backref for an extent. tree level and root are returned</span>
<span class="cm"> * through out_level and out_root. ptr must point to a 0 value for the first</span>
<span class="cm"> * call and may be modified (see __get_extent_inline_ref comment).</span>
<span class="cm"> * returns 0 if data was provided, 1 if there was no more data to provide or</span>
<span class="cm"> * &lt;0 on error.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">tree_backref_for_extent</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">ptr</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_extent_item</span> <span class="o">*</span><span class="n">ei</span><span class="p">,</span> <span class="n">u32</span> <span class="n">item_size</span><span class="p">,</span>
				<span class="n">u64</span> <span class="o">*</span><span class="n">out_root</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">out_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_extent_inline_ref</span> <span class="o">*</span><span class="n">eiref</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">ptr</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">__get_extent_inline_ref</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">ei</span><span class="p">,</span> <span class="n">item_size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">eiref</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">type</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_TREE_BLOCK_REF_KEY</span> <span class="o">||</span>
		    <span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_SHARED_BLOCK_REF_KEY</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we can treat both ref types equally here */</span>
	<span class="n">info</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_tree_block_info</span> <span class="o">*</span><span class="p">)(</span><span class="n">ei</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="o">*</span><span class="n">out_root</span> <span class="o">=</span> <span class="n">btrfs_extent_inline_ref_offset</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">eiref</span><span class="p">);</span>
	<span class="o">*</span><span class="n">out_level</span> <span class="o">=</span> <span class="n">btrfs_tree_block_level</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">info</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iterate_leaf_refs</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">inode_list</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">extent_item_objectid</span><span class="p">,</span>
				<span class="n">iterate_extent_inodes_t</span> <span class="o">*</span><span class="n">iterate</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="n">eie</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">eie</span> <span class="o">=</span> <span class="n">inode_list</span><span class="p">;</span> <span class="n">eie</span><span class="p">;</span> <span class="n">eie</span> <span class="o">=</span> <span class="n">eie</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;ref for %llu resolved, key (%llu EXTEND_DATA %llu), &quot;</span>
			 <span class="s">&quot;root %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">extent_item_objectid</span><span class="p">,</span>
			 <span class="n">eie</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">eie</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">iterate</span><span class="p">(</span><span class="n">eie</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">eie</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;stopping iteration for %llu due to ret=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				 <span class="n">extent_item_objectid</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * calls iterate() for every inode that references the extent identified by</span>
<span class="cm"> * the given parameters.</span>
<span class="cm"> * when the iterator function returns a non-zero value, iteration stops.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">iterate_extent_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">extent_item_objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">extent_item_pos</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">search_commit_root</span><span class="p">,</span>
				<span class="n">iterate_extent_inodes_t</span> <span class="o">*</span><span class="n">iterate</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">data_refs</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">data_refs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">shared_refs</span> <span class="o">=</span> <span class="n">LIST_HEAD_INIT</span><span class="p">(</span><span class="n">shared_refs</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">refs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist</span> <span class="o">*</span><span class="n">roots</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_node</span> <span class="o">*</span><span class="n">ref_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_node</span> <span class="o">*</span><span class="n">root_node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_list</span> <span class="n">seq_elem</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="k">struct</span> <span class="n">seq_list</span> <span class="n">tree_mod_seq_elem</span> <span class="o">=</span> <span class="p">{};</span>
	<span class="k">struct</span> <span class="n">ulist_iterator</span> <span class="n">ref_uiter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ulist_iterator</span> <span class="n">root_uiter</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_delayed_ref_root</span> <span class="o">*</span><span class="n">delayed_refs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;resolving all inodes for extent %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">extent_item_objectid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">search_commit_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">BTRFS_BACKREF_SEARCH_COMMIT_ROOT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_join_transaction</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

		<span class="n">delayed_refs</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">delayed_refs</span><span class="p">;</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">btrfs_get_delayed_seq</span><span class="p">(</span><span class="n">delayed_refs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq_elem</span><span class="p">);</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">delayed_refs</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">btrfs_get_tree_mod_seq</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree_mod_seq_elem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_find_all_leafs</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="p">,</span> <span class="n">extent_item_objectid</span><span class="p">,</span>
				   <span class="n">seq_elem</span><span class="p">.</span><span class="n">seq</span><span class="p">,</span> <span class="n">tree_mod_seq_elem</span><span class="p">.</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">refs</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">extent_item_pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ULIST_ITER_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref_uiter</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">ref_node</span> <span class="o">=</span> <span class="n">ulist_next</span><span class="p">(</span><span class="n">refs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ref_uiter</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_find_all_roots</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="p">,</span> <span class="n">ref_node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span>
						<span class="n">seq_elem</span><span class="p">.</span><span class="n">seq</span><span class="p">,</span>
						<span class="n">tree_mod_seq_elem</span><span class="p">.</span><span class="n">seq</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">roots</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">ULIST_ITER_INIT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_uiter</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">root_node</span> <span class="o">=</span> <span class="n">ulist_next</span><span class="p">(</span><span class="n">roots</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_uiter</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;root %llu references leaf %llu, data list &quot;</span>
				 <span class="s">&quot;%#lx</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">root_node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">ref_node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span>
				 <span class="n">ref_node</span><span class="o">-&gt;</span><span class="n">aux</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iterate_leaf_refs</span><span class="p">(</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">extent_inode_elem</span> <span class="o">*</span><span class="p">)</span><span class="n">ref_node</span><span class="o">-&gt;</span><span class="n">aux</span><span class="p">,</span>
				<span class="n">root_node</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">,</span> <span class="n">extent_item_objectid</span><span class="p">,</span>
				<span class="n">iterate</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ulist_free</span><span class="p">(</span><span class="n">roots</span><span class="p">);</span>
		<span class="n">roots</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_leaf_list</span><span class="p">(</span><span class="n">refs</span><span class="p">);</span>
	<span class="n">ulist_free</span><span class="p">(</span><span class="n">roots</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">search_commit_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_put_tree_mod_seq</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree_mod_seq_elem</span><span class="p">);</span>
		<span class="n">btrfs_put_delayed_seq</span><span class="p">(</span><span class="n">delayed_refs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq_elem</span><span class="p">);</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">iterate_inodes_from_logical</span><span class="p">(</span><span class="n">u64</span> <span class="n">logical</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="n">iterate_extent_inodes_t</span> <span class="o">*</span><span class="n">iterate</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_item_pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">search_commit_root</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">search_commit_root</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">extent_from_logical</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">found_key</span><span class="p">);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">extent_item_pos</span> <span class="o">=</span> <span class="n">logical</span> <span class="o">-</span> <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iterate_extent_inodes</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">extent_item_pos</span><span class="p">,</span> <span class="n">search_commit_root</span><span class="p">,</span>
					<span class="n">iterate</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">iterate_irefs</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">fs_root</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				<span class="n">iterate_irefs_t</span> <span class="o">*</span><span class="n">iterate</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">cur</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">name_len</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">inode_ref_info</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="n">parent</span> <span class="o">?</span> <span class="n">parent</span><span class="o">+</span><span class="mi">1</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">fs_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">found_key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">found</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="o">++</span><span class="n">found</span><span class="p">;</span>

		<span class="n">parent</span> <span class="o">=</span> <span class="n">found_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="cm">/* make sure we can use eb after releasing the path */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
		<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking_rw</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">);</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">iref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode_ref</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">cur</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cur</span> <span class="o">&lt;</span> <span class="n">btrfs_item_size</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span> <span class="n">cur</span> <span class="o">+=</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">name_len</span> <span class="o">=</span> <span class="n">btrfs_inode_ref_name_len</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>
			<span class="cm">/* path must be released before calling iterate()! */</span>
			<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;following ref at offset %u for inode %llu in &quot;</span>
				 <span class="s">&quot;tree %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">fs_root</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">iterate</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">len</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">iref</span><span class="p">)</span> <span class="o">+</span> <span class="n">name_len</span><span class="p">;</span>
			<span class="n">iref</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_inode_ref</span> <span class="o">*</span><span class="p">)((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">iref</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">btrfs_tree_read_unlock_blocking</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns 0 if the path could be dumped (probably truncated)</span>
<span class="cm"> * returns &lt;0 in case of an error</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">inode_to_path</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_fs_paths</span> <span class="o">*</span><span class="n">ipath</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fspath</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">fspath_min</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">elem_cnt</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">int</span> <span class="n">s_ptr</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
	<span class="n">u32</span> <span class="n">bytes_left</span><span class="p">;</span>

	<span class="n">bytes_left</span> <span class="o">=</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">&gt;</span> <span class="n">s_ptr</span> <span class="o">?</span>
					<span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">-</span> <span class="n">s_ptr</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fspath_min</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">+</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">s_ptr</span><span class="p">;</span>
	<span class="n">fspath</span> <span class="o">=</span> <span class="n">iref_to_path</span><span class="p">(</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fs_root</span><span class="p">,</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">btrfs_path</span><span class="p">,</span> <span class="n">iref</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span>
				<span class="n">inum</span><span class="p">,</span> <span class="n">fspath_min</span><span class="p">,</span> <span class="n">bytes_left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fspath</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">fspath</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fspath</span> <span class="o">&gt;</span> <span class="n">fspath_min</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;path resolved: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">fspath</span><span class="p">);</span>
		<span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fspath</span><span class="p">;</span>
		<span class="o">++</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">elem_cnt</span><span class="p">;</span>
		<span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="n">fspath</span> <span class="o">-</span> <span class="n">fspath_min</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">pr_debug</span><span class="p">(</span><span class="s">&quot;missed path, not enough space. missing bytes: %lu, &quot;</span>
			 <span class="s">&quot;constructed so far: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">fspath_min</span> <span class="o">-</span> <span class="n">fspath</span><span class="p">),</span> <span class="n">fspath_min</span><span class="p">);</span>
		<span class="o">++</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">elem_missed</span><span class="p">;</span>
		<span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">bytes_missing</span> <span class="o">+=</span> <span class="n">fspath_min</span> <span class="o">-</span> <span class="n">fspath</span><span class="p">;</span>
		<span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this dumps all file system paths to the inode into the ipath struct, provided</span>
<span class="cm"> * is has been created large enough. each path is zero-terminated and accessed</span>
<span class="cm"> * from ipath-&gt;fspath-&gt;val[i].</span>
<span class="cm"> * when it returns, there are ipath-&gt;fspath-&gt;elem_cnt number of paths available</span>
<span class="cm"> * in ipath-&gt;fspath-&gt;val[]. when the allocated space wasn&#39;t sufficient, the</span>
<span class="cm"> * number of missed paths in recored in ipath-&gt;fspath-&gt;elem_missed, otherwise,</span>
<span class="cm"> * it&#39;s zero. ipath-&gt;fspath-&gt;bytes_missing holds the number of bytes that would</span>
<span class="cm"> * have been needed to return all paths.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">paths_from_inode</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode_fs_paths</span> <span class="o">*</span><span class="n">ipath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">iterate_irefs</span><span class="p">(</span><span class="n">inum</span><span class="p">,</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fs_root</span><span class="p">,</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">btrfs_path</span><span class="p">,</span>
				<span class="n">inode_to_path</span><span class="p">,</span> <span class="n">ipath</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">btrfs_data_container</span> <span class="o">*</span><span class="nf">init_data_container</span><span class="p">(</span><span class="n">u32</span> <span class="n">total_bytes</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_data_container</span> <span class="o">*</span><span class="n">data</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">alloc_bytes</span><span class="p">;</span>

	<span class="n">alloc_bytes</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span> <span class="n">total_bytes</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">));</span>
	<span class="n">data</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">alloc_bytes</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">data</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">total_bytes</span> <span class="o">&gt;=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="n">total_bytes</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">);</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">bytes_missing</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">bytes_missing</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">total_bytes</span><span class="p">;</span>
		<span class="n">data</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">data</span><span class="o">-&gt;</span><span class="n">elem_cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data</span><span class="o">-&gt;</span><span class="n">elem_missed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * allocates space to return multiple file system paths for an inode.</span>
<span class="cm"> * total_bytes to allocate are passed, note that space usable for actual path</span>
<span class="cm"> * information will be total_bytes - sizeof(struct inode_fs_paths).</span>
<span class="cm"> * the returned pointer must be freed with free_ipath() in the end.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode_fs_paths</span> <span class="o">*</span><span class="nf">init_ipath</span><span class="p">(</span><span class="n">s32</span> <span class="n">total_bytes</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">fs_root</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_fs_paths</span> <span class="o">*</span><span class="n">ifp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_data_container</span> <span class="o">*</span><span class="n">fspath</span><span class="p">;</span>

	<span class="n">fspath</span> <span class="o">=</span> <span class="n">init_data_container</span><span class="p">(</span><span class="n">total_bytes</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">fspath</span><span class="p">))</span>
		<span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="n">fspath</span><span class="p">;</span>

	<span class="n">ifp</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ifp</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ifp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">fspath</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ERR_PTR</span><span class="p">(</span><span class="o">-</span><span class="n">ENOMEM</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">btrfs_path</span> <span class="o">=</span> <span class="n">path</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">fspath</span> <span class="o">=</span> <span class="n">fspath</span><span class="p">;</span>
	<span class="n">ifp</span><span class="o">-&gt;</span><span class="n">fs_root</span> <span class="o">=</span> <span class="n">fs_root</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ifp</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">free_ipath</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode_fs_paths</span> <span class="o">*</span><span class="n">ipath</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ipath</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ipath</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
