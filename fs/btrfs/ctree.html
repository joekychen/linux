<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › ctree.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ctree.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007,2008 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/rbtree.h&gt;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;print-tree.h&quot;</span>
<span class="cp">#include &quot;locking.h&quot;</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">split_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span>
		      <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">split_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span>
		      <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins_key</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">extend</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">push_node_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">empty</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">balance_node_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">dst_buf</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">src_buf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">del_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">tree_mod_log</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">tree_mod_log_free_eb</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">read_old_tree_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
					  <span class="n">u32</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">u64</span> <span class="n">parent_transid</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">time_seq</span><span class="p">);</span>
<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">btrfs_find_old_tree_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
						<span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">blocksize</span><span class="p">,</span>
						<span class="n">u64</span> <span class="n">time_seq</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="nf">btrfs_alloc_path</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="n">path</span> <span class="o">=</span> <span class="n">kmem_cache_zalloc</span><span class="p">(</span><span class="n">btrfs_path_cachep</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">path</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * set all locked nodes in the path to blocking locks.  This should</span>
<span class="cm"> * be done before scheduling</span>
<span class="cm"> */</span>
<span class="n">noinline</span> <span class="kt">void</span> <span class="nf">btrfs_set_path_blocking</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">||</span> <span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">btrfs_set_lock_blocking_rw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK_BLOCKING</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">BTRFS_WRITE_LOCK</span><span class="p">)</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * reset all the locked nodes in the patch to spinning locks.</span>
<span class="cm"> *</span>
<span class="cm"> * held is used to keep lockdep happy, when lockdep is enabled</span>
<span class="cm"> * we set held to a blocking lock before we go around and</span>
<span class="cm"> * retake all the spinlocks in the path.  You can safely use NULL</span>
<span class="cm"> * for held</span>
<span class="cm"> */</span>
<span class="n">noinline</span> <span class="kt">void</span> <span class="nf">btrfs_clear_path_blocking</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">held</span><span class="p">,</span> <span class="kt">int</span> <span class="n">held_rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
	<span class="cm">/* lockdep really cares that we take all of these spinlocks</span>
<span class="cm">	 * in the right order.  If any of the locks in the path are not</span>
<span class="cm">	 * currently blocking, it is going to complain.  So, make really</span>
<span class="cm">	 * really sure by forcing the path to blocking before we clear</span>
<span class="cm">	 * the path blocking.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">held</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_set_lock_blocking_rw</span><span class="p">(</span><span class="n">held</span><span class="p">,</span> <span class="n">held_rw</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">held_rw</span> <span class="o">==</span> <span class="n">BTRFS_WRITE_LOCK</span><span class="p">)</span>
			<span class="n">held_rw</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">held_rw</span> <span class="o">==</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">)</span>
			<span class="n">held_rw</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK_BLOCKING</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="cp">#endif</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">BTRFS_MAX_LEVEL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&amp;&amp;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">btrfs_clear_lock_blocking_rw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">)</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK</span><span class="p">;</span>
			<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">BTRFS_READ_LOCK_BLOCKING</span><span class="p">)</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="cp">#ifdef CONFIG_DEBUG_LOCK_ALLOC</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">held</span><span class="p">)</span>
		<span class="n">btrfs_clear_lock_blocking_rw</span><span class="p">(</span><span class="n">held</span><span class="p">,</span> <span class="n">held_rw</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="p">}</span>

<span class="cm">/* this also releases the path */</span>
<span class="kt">void</span> <span class="nf">btrfs_free_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">btrfs_path_cachep</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * path release drops references on the extent buffers in the path</span>
<span class="cm"> * and it drops any locks held by this path</span>
<span class="cm"> *</span>
<span class="cm"> * It is safe to call this on paths that no locks or extent buffers held.</span>
<span class="cm"> */</span>
<span class="n">noinline</span> <span class="kt">void</span> <span class="nf">btrfs_release_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * safely gets a reference on the root node of a tree.  A lock</span>
<span class="cm"> * is not taken, so a concurrent writer may put a different node</span>
<span class="cm"> * at the root of the tree.  See btrfs_lock_root_node for the</span>
<span class="cm"> * looping required.</span>
<span class="cm"> *</span>
<span class="cm"> * The extent buffer returned by this has a reference taken, so</span>
<span class="cm"> * it won&#39;t disappear.  It may stop being the root of the tree</span>
<span class="cm"> * at any time because there are no locks held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="nf">btrfs_root_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * RCU really hurts here, we could free up the root node because</span>
<span class="cm">		 * it was cow&#39;ed but we may not get the new root node yet so do</span>
<span class="cm">		 * the inc_not_zero dance and if it doesn&#39;t work then</span>
<span class="cm">		 * synchronize_rcu and try again.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">atomic_inc_not_zero</span><span class="p">(</span><span class="o">&amp;</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">rcu_read_unlock</span><span class="p">();</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">synchronize_rcu</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* loop around taking references on and locking the root node of the</span>
<span class="cm"> * tree until you end up with a lock on the root.  A locked buffer</span>
<span class="cm"> * is returned, with a reference held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="nf">btrfs_lock_root_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">btrfs_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* loop around taking references on and locking the root node of the</span>
<span class="cm"> * tree until you end up with a lock on the root.  A locked buffer</span>
<span class="cm"> * is returned, with a reference held.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="nf">btrfs_read_lock_root_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">btrfs_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">btrfs_tree_read_unlock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* cowonly root (everything not a reference counted cow subvolume), just get</span>
<span class="cm"> * put onto a simple dirty list.  transaction.c walks this to make sure they</span>
<span class="cm"> * get properly updated on disk.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_root_to_dirty_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">track_dirty</span> <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dirty_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">dirty_list</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">dirty_cowonly_roots</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * used by snapshot creation to make a copy of a root for a tree with</span>
<span class="cm"> * a given objectid.  The buffer with the new root node is returned in</span>
<span class="cm"> * cow_ret, and this func returns zero on success or a negative error code.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_copy_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">**</span><span class="n">cow_ret</span><span class="p">,</span> <span class="n">u64</span> <span class="n">new_root_objectid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">cow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">!=</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">running_transaction</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">last_trans</span><span class="p">);</span>

	<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">cow</span> <span class="o">=</span> <span class="n">btrfs_alloc_free_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				     <span class="n">new_root_objectid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
				     <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cow</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cow</span><span class="p">);</span>

	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cow</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">cow</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">);</span>
	<span class="n">btrfs_clear_header_flag</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_WRITTEN</span> <span class="o">|</span>
				     <span class="n">BTRFS_HEADER_FLAG_RELOC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_root_objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span>
		<span class="n">btrfs_set_header_flag</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_RELOC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">new_root_objectid</span><span class="p">);</span>

	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_fsid</span><span class="p">(</span><span class="n">cow</span><span class="p">),</span>
			    <span class="n">BTRFS_FSID_SIZE</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_root_objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">cow</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cow_ret</span> <span class="o">=</span> <span class="n">cow</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">enum</span> <span class="n">mod_log_op</span> <span class="p">{</span>
	<span class="n">MOD_LOG_KEY_REPLACE</span><span class="p">,</span>
	<span class="n">MOD_LOG_KEY_ADD</span><span class="p">,</span>
	<span class="n">MOD_LOG_KEY_REMOVE</span><span class="p">,</span>
	<span class="n">MOD_LOG_KEY_REMOVE_WHILE_FREEING</span><span class="p">,</span>
	<span class="n">MOD_LOG_KEY_REMOVE_WHILE_MOVING</span><span class="p">,</span>
	<span class="n">MOD_LOG_MOVE_KEYS</span><span class="p">,</span>
	<span class="n">MOD_LOG_ROOT_REPLACE</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tree_mod_move</span> <span class="p">{</span>
	<span class="kt">int</span> <span class="n">dst_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_items</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tree_mod_root</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">logical</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">level</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">node</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span><span class="p">;</span>		<span class="cm">/* shifted logical */</span>
	<span class="k">struct</span> <span class="n">seq_list</span> <span class="n">elem</span><span class="p">;</span>
	<span class="k">enum</span> <span class="n">mod_log_op</span> <span class="n">op</span><span class="p">;</span>

	<span class="cm">/* this is used for MOD_LOG_KEY_* and MOD_LOG_MOVE_KEYS operations */</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="cm">/* this is used for MOD_LOG_KEY* and MOD_LOG_ROOT_REPLACE */</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>

	<span class="cm">/* those are used for op == MOD_LOG_KEY_{REPLACE,REMOVE} */</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">blockptr</span><span class="p">;</span>

	<span class="cm">/* this is used for op == MOD_LOG_MOVE_KEYS */</span>
	<span class="k">struct</span> <span class="n">tree_mod_move</span> <span class="n">move</span><span class="p">;</span>

	<span class="cm">/* this is used for op == MOD_LOG_ROOT_REPLACE */</span>
	<span class="k">struct</span> <span class="n">tree_mod_root</span> <span class="n">old_root</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">__get_tree_mod_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">seq_list</span> <span class="o">*</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elem</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="n">atomic_inc_return</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_list</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_get_tree_mod_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">seq_list</span> <span class="o">*</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">elem</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
	<span class="n">__get_tree_mod_seq</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">elem</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfs_put_tree_mod_seq</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">seq_list</span> <span class="o">*</span><span class="n">elem</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">tm_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">seq_list</span> <span class="o">*</span><span class="n">cur_elem</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">min_seq</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">seq_putting</span> <span class="o">=</span> <span class="n">elem</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">seq_putting</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">));</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">elem</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">cur_elem</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">cur_elem</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cur_elem</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">min_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">seq_putting</span> <span class="o">&gt;</span> <span class="n">cur_elem</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * blocker with lower sequence number exists, we</span>
<span class="cm">				 * cannot remove anything from the log</span>
<span class="cm">				 */</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">min_seq</span> <span class="o">=</span> <span class="n">cur_elem</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * anything that&#39;s lower than the lowest existing (read: blocked)</span>
<span class="cm">	 * sequence number can be removed from the tree.</span>
<span class="cm">	 */</span>
	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log_lock</span><span class="p">);</span>
	<span class="n">tm_root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">node</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="n">tm_root</span><span class="p">);</span> <span class="n">node</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="n">tm</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">min_seq</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">tm_root</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tm</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log_lock</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * key order of the log:</span>
<span class="cm"> *       index -&gt; sequence</span>
<span class="cm"> *</span>
<span class="cm"> * the index is the shifted logical of the *new* root node for root replace</span>
<span class="cm"> * operations, or the shifted logical of the affected block for all other</span>
<span class="cm"> * operations.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">__tree_mod_log_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">tm_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">new</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tm</span> <span class="o">||</span> <span class="o">!</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log_lock</span><span class="p">);</span>
	<span class="n">tm_root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log</span><span class="p">;</span>
	<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tm_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="o">*</span><span class="n">new</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">new</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span><span class="p">)</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">);</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span><span class="p">)</span>
			<span class="n">new</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">((</span><span class="o">*</span><span class="n">new</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">tm</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">new</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">tm_root</span><span class="p">);</span>
<span class="nl">unlock:</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tree_mod_dont_log</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">fs_info</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_list</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eb</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This allocates memory and gets a tree modification sequence number when</span>
<span class="cm"> * needed.</span>
<span class="cm"> *</span>
<span class="cm"> * Returns 0 when no sequence number is needed, &lt; 0 on error.</span>
<span class="cm"> * Returns 1 when a sequence number was added. In this case,</span>
<span class="cm"> * fs_info-&gt;tree_mod_seq_lock was acquired and must be released by the caller</span>
<span class="cm"> * after inserting into the rb tree.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">tree_mod_alloc</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">**</span><span class="n">tm_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">seq</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_dont_log</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">tm</span> <span class="o">=</span> <span class="o">*</span><span class="n">tm_ret</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">tm</span><span class="p">),</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tm</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * someone emptied the list while we were waiting for the lock.</span>
<span class="cm">		 * we must not add to the list, because no blocker exists. items</span>
<span class="cm">		 * are removed from the list only when the existing blocker is</span>
<span class="cm">		 * removed from the list.</span>
<span class="cm">		 */</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">tm</span><span class="p">);</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">__get_tree_mod_seq</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">);</span>
		<span class="n">seq</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">seq</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">tree_mod_log_insert_key_mask</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span>
			     <span class="k">enum</span> <span class="n">mod_log_op</span> <span class="n">op</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_alloc</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">op</span> <span class="o">!=</span> <span class="n">MOD_LOG_KEY_ADD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">tm</span><span class="o">-&gt;</span><span class="n">blockptr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__tree_mod_log_insert</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">tm</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">tree_mod_log_insert_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="k">enum</span> <span class="n">mod_log_op</span> <span class="n">op</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">tree_mod_log_insert_key_mask</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">tree_mod_log_insert_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dst_slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src_slot</span><span class="p">,</span>
			 <span class="kt">int</span> <span class="n">nr_items</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_dont_log</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">eb</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dst_slot</span> <span class="o">&lt;</span> <span class="n">src_slot</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_key</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dst_slot</span><span class="p">,</span>
					      <span class="n">MOD_LOG_KEY_REMOVE_WHILE_MOVING</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_alloc</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">src_slot</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">.</span><span class="n">dst_slot</span> <span class="o">=</span> <span class="n">dst_slot</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">.</span><span class="n">nr_items</span> <span class="o">=</span> <span class="n">nr_items</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">MOD_LOG_MOVE_KEYS</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__tree_mod_log_insert</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">tm</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span>
<span class="nf">tree_mod_log_insert_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">old_root</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">new_root</span><span class="p">,</span> <span class="n">gfp_t</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_alloc</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">=</span> <span class="n">new_root</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">old_root</span><span class="p">.</span><span class="n">logical</span> <span class="o">=</span> <span class="n">old_root</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">old_root</span><span class="p">.</span><span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">old_root</span><span class="p">);</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">old_root</span><span class="p">);</span>
	<span class="n">tm</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">=</span> <span class="n">MOD_LOG_ROOT_REPLACE</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__tree_mod_log_insert</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">tm</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_seq_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span>
<span class="nf">__tree_mod_log_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_seq</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">smallest</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">tm_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">cur</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log_lock</span><span class="p">);</span>
	<span class="n">tm_root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log</span><span class="p">;</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">tm_root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&gt;</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">min_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">smallest</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we want the node with the highest seq */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&gt;</span> <span class="n">min_seq</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* we want the node with the smallest seq */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">found</span><span class="p">)</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">found</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&lt;</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span><span class="p">);</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">found</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_mod_log_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this returns the element from the log with the smallest time sequence</span>
<span class="cm"> * value that&#39;s in the log (the oldest log item). any element with a time</span>
<span class="cm"> * sequence lower than min_seq will be ignored.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span>
<span class="nf">tree_mod_log_search_oldest</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span>
			   <span class="n">u64</span> <span class="n">min_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__tree_mod_log_search</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">min_seq</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this returns the element from the log with the largest time sequence</span>
<span class="cm"> * value that&#39;s in the log (the most recent log item). any element with</span>
<span class="cm"> * a time sequence lower than min_seq will be ignored.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span>
<span class="nf">tree_mod_log_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__tree_mod_log_search</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">min_seq</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">tree_mod_log_eb_copy</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">dst_offset</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">src_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_items</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_dont_log</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* speed this up by single seq for all operations? */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_key</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">src_offset</span><span class="p">,</span>
					      <span class="n">MOD_LOG_KEY_REMOVE</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_key</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="n">dst_offset</span><span class="p">,</span>
					      <span class="n">MOD_LOG_KEY_ADD</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">tree_mod_log_eb_move</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">dst_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">src_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr_items</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_move</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">dst_offset</span><span class="p">,</span> <span class="n">src_offset</span><span class="p">,</span>
				       <span class="n">nr_items</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">tree_mod_log_set_node_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">disk_key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">atomic</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_key_mask</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
					   <span class="n">MOD_LOG_KEY_REPLACE</span><span class="p">,</span>
					   <span class="n">atomic</span> <span class="o">?</span> <span class="n">GFP_ATOMIC</span> <span class="o">:</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">tree_mod_log_free_eb</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_dont_log</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">eb</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_key</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">eb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					      <span class="n">MOD_LOG_KEY_REMOVE_WHILE_FREEING</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span>
<span class="nf">tree_mod_log_set_root_pointer</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">new_root_node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">tree_mod_log_free_eb</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_root</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span>
				       <span class="n">new_root_node</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * check if the tree block can be shared by multiple trees</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_block_can_be_shared</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * Tree blocks not in refernece counted trees and tree roots</span>
<span class="cm">	 * are never shared. If a block was allocated after the last</span>
<span class="cm">	 * snapshot and the block was not allocated by tree relocation,</span>
<span class="cm">	 * we know the block is not shared.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span>
	    <span class="n">buf</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">buf</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">commit_root</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&lt;=</span>
	     <span class="n">btrfs_root_last_snapshot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">||</span>
	     <span class="n">btrfs_header_flag</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_RELOC</span><span class="p">)))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#ifdef BTRFS_COMPAT_EXTENT_TREE_V0</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span>
	    <span class="n">btrfs_header_backref_rev</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="cp">#endif</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">update_ref_for_cow</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">cow</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="o">*</span><span class="n">last_ref</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">refs</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">owner</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Backrefs update rules:</span>
<span class="cm">	 *</span>
<span class="cm">	 * Always use full backrefs for extent pointers in tree block</span>
<span class="cm">	 * allocated by tree relocation.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If a shared tree block is no longer referenced by its owner</span>
<span class="cm">	 * tree (btrfs_header_owner(buf) == root-&gt;root_key.objectid),</span>
<span class="cm">	 * use full backrefs for extent pointers in tree block.</span>
<span class="cm">	 *</span>
<span class="cm">	 * If a tree block is been relocating</span>
<span class="cm">	 * (root-&gt;root_key.objectid == BTRFS_TREE_RELOC_OBJECTID),</span>
<span class="cm">	 * use full backrefs for extent pointers in tree block.</span>
<span class="cm">	 * The reason for this is some operations (such as drop tree)</span>
<span class="cm">	 * are only allowed for blocks use full backrefs.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_block_can_be_shared</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_extent_info</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					       <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">refs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
			<span class="n">btrfs_std_error</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">refs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span> <span class="o">||</span>
		    <span class="n">btrfs_header_backref_rev</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">)</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">owner</span> <span class="o">=</span> <span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">owner</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span> <span class="o">&amp;&amp;</span>
	       <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">refs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">owner</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">||</span>
		     <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span>
			    <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_dec_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
			<span class="p">}</span>
			<span class="n">new_flags</span> <span class="o">|=</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span>
			    <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_flags</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_disk_extent_flags</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
							  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
							  <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span>
							  <span class="n">new_flags</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BLOCK_FLAG_FULL_BACKREF</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span>
			    <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_dec_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * don&#39;t log freeing in case we&#39;re freeing the root node, this</span>
<span class="cm">		 * is done by tree_mod_log_set_root_pointer later</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">tree_mod_log_free_eb</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
		<span class="o">*</span><span class="n">last_ref</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * does the dirty work in cow of a single block.  The parent block (if</span>
<span class="cm"> * supplied) is updated to point to the new cow copy.  The new buffer is marked</span>
<span class="cm"> * dirty and returned locked.  If you modify the block it needs to be marked</span>
<span class="cm"> * dirty again.</span>
<span class="cm"> *</span>
<span class="cm"> * search_start -- an allocation hint for the new block</span>
<span class="cm"> *</span>
<span class="cm"> * empty_size -- a hint that you plan on doing more cow.  This is the size in</span>
<span class="cm"> * bytes the allocator should try to find free next to the block it returns.</span>
<span class="cm"> * This is just a hint and may be ignored by the allocator.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">__btrfs_cow_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent_slot</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">**</span><span class="n">cow_ret</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">search_start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">empty_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">cow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_ref</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">unlock_orig</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent_start</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">cow_ret</span> <span class="o">==</span> <span class="n">buf</span><span class="p">)</span>
		<span class="n">unlock_orig</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">btrfs_assert_tree_locked</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">!=</span>
		<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">running_transaction</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span> <span class="o">&amp;&amp;</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">last_trans</span><span class="p">);</span>

	<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
			<span class="n">parent_start</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">parent_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">parent_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">cow</span> <span class="o">=</span> <span class="n">btrfs_alloc_free_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">,</span> <span class="n">parent_start</span><span class="p">,</span>
				     <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span>
				     <span class="n">level</span><span class="p">,</span> <span class="n">search_start</span><span class="p">,</span> <span class="n">empty_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">cow</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">cow</span><span class="p">);</span>

	<span class="cm">/* cow is set to blocking by btrfs_init_new_buffer */</span>

	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cow</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">cow</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">);</span>
	<span class="n">btrfs_clear_header_flag</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_WRITTEN</span> <span class="o">|</span>
				     <span class="n">BTRFS_HEADER_FLAG_RELOC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span>
		<span class="n">btrfs_set_header_flag</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_RELOC</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>

	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">cow</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_fsid</span><span class="p">(</span><span class="n">cow</span><span class="p">),</span>
			    <span class="n">BTRFS_FSID_SIZE</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">update_ref_for_cow</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cow</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_ref</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span><span class="p">)</span>
		<span class="n">btrfs_reloc_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">cow</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">buf</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span> <span class="o">!=</span> <span class="n">buf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span> <span class="o">||</span>
		    <span class="n">btrfs_header_backref_rev</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">)</span>
			<span class="n">parent_start</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">parent_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">cow</span><span class="p">);</span>
		<span class="n">tree_mod_log_set_root_pointer</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cow</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">cow</span><span class="p">);</span>

		<span class="n">btrfs_free_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">parent_start</span><span class="p">,</span>
				      <span class="n">last_ref</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="n">add_root_to_dirty_list</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span><span class="p">)</span>
			<span class="n">parent_start</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">parent_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">!=</span> <span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">parent</span><span class="p">));</span>
		<span class="n">tree_mod_log_insert_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">parent_slot</span><span class="p">,</span>
					<span class="n">MOD_LOG_KEY_REPLACE</span><span class="p">);</span>
		<span class="n">btrfs_set_node_blockptr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent_slot</span><span class="p">,</span>
					<span class="n">cow</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">btrfs_set_node_ptr_generation</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">parent_slot</span><span class="p">,</span>
					      <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="n">btrfs_free_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">parent_start</span><span class="p">,</span>
				      <span class="n">last_ref</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">unlock_orig</span><span class="p">)</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">free_extent_buffer_stale</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">cow</span><span class="p">);</span>
	<span class="o">*</span><span class="n">cow_ret</span> <span class="o">=</span> <span class="n">cow</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns the logical address of the oldest predecessor of the given root.</span>
<span class="cm"> * entries older than time_seq are ignored.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span>
<span class="nf">__tree_mod_log_oldest_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">found</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">root_logical</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">looped</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_seq</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the very last operation that&#39;s logged for a root is the replacement</span>
<span class="cm">	 * operation (if it is replaced at all). this has the index of the *new*</span>
<span class="cm">	 * root, making it the very first operation that&#39;s logged for this root.</span>
<span class="cm">	 */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tm</span> <span class="o">=</span> <span class="n">tree_mod_log_search_oldest</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">root_logical</span><span class="p">,</span>
						<span class="n">time_seq</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">looped</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tm</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * we must have key remove operations in the log before the</span>
<span class="cm">		 * replace operation.</span>
<span class="cm">		 */</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tm</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">!=</span> <span class="n">MOD_LOG_ROOT_REPLACE</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">found</span> <span class="o">=</span> <span class="n">tm</span><span class="p">;</span>
		<span class="n">root_logical</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">old_root</span><span class="p">.</span><span class="n">logical</span><span class="p">;</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">root_logical</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">looped</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* if there&#39;s no old root to return, return what we found instead */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">found</span><span class="p">)</span>
		<span class="n">found</span> <span class="o">=</span> <span class="n">tm</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">found</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * tm is a pointer to the first operation to rewind within eb. then, all</span>
<span class="cm"> * previous operations will be rewinded (until we reach something older than</span>
<span class="cm"> * time_seq).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">__tree_mod_log_rewind</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">first_tm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span> <span class="o">=</span> <span class="n">first_tm</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">o_dst</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">o_src</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">);</span>

	<span class="n">n</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">tm</span> <span class="o">&amp;&amp;</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">elem</span><span class="p">.</span><span class="n">seq</span> <span class="o">&gt;=</span> <span class="n">time_seq</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * all the operations are recorded with the operator used for</span>
<span class="cm">		 * the modification. as we&#39;re going backwards, we do the</span>
<span class="cm">		 * opposite of each operation here.</span>
<span class="cm">		 */</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">op</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">MOD_LOG_KEY_REMOVE_WHILE_FREEING</span>:
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">);</span>
		<span class="k">case</span> <span class="n">MOD_LOG_KEY_REMOVE_WHILE_MOVING</span>:
		<span class="k">case</span> <span class="n">MOD_LOG_KEY_REMOVE</span>:
			<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
			<span class="n">btrfs_set_node_blockptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">blockptr</span><span class="p">);</span>
			<span class="n">btrfs_set_node_ptr_generation</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span>
						      <span class="n">tm</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">);</span>
			<span class="n">n</span><span class="o">++</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MOD_LOG_KEY_REPLACE</span>:
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">n</span><span class="p">);</span>
			<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
			<span class="n">btrfs_set_node_blockptr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">blockptr</span><span class="p">);</span>
			<span class="n">btrfs_set_node_ptr_generation</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">,</span>
						      <span class="n">tm</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MOD_LOG_KEY_ADD</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">o_dst</span> <span class="o">=</span> <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
				<span class="n">o_src</span> <span class="o">=</span> <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
				<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">o_dst</span><span class="p">,</span> <span class="n">o_src</span><span class="p">,</span> <span class="n">p_size</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">n</span><span class="o">--</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MOD_LOG_MOVE_KEYS</span>:
			<span class="n">o_dst</span> <span class="o">=</span> <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
			<span class="n">o_src</span> <span class="o">=</span> <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">.</span><span class="n">dst_slot</span><span class="p">);</span>
			<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">o_dst</span><span class="p">,</span> <span class="n">o_src</span><span class="p">,</span>
					      <span class="n">tm</span><span class="o">-&gt;</span><span class="n">move</span><span class="p">.</span><span class="n">nr_items</span> <span class="o">*</span> <span class="n">p_size</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">MOD_LOG_ROOT_REPLACE</span>:
			<span class="cm">/*</span>
<span class="cm">			 * this operation is special. for roots, this must be</span>
<span class="cm">			 * handled explicitly before rewinding.</span>
<span class="cm">			 * for non-roots, this operation may exist if the node</span>
<span class="cm">			 * was a root: root A -&gt; child B; then A gets empty and</span>
<span class="cm">			 * B is promoted to the new root. in the mod log, we&#39;ll</span>
<span class="cm">			 * have a root-replace operation for B, a tree block</span>
<span class="cm">			 * that is no root. we simply ignore that operation.</span>
<span class="cm">			 */</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">next</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">tm</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">tree_mod_elem</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">!=</span> <span class="n">first_tm</span><span class="o">-&gt;</span><span class="n">index</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">n</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span>
<span class="nf">tree_mod_log_rewind</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
		    <span class="n">u64</span> <span class="n">time_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb_rewin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">time_seq</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>

	<span class="n">tm</span> <span class="o">=</span> <span class="n">tree_mod_log_search</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">MOD_LOG_KEY_REMOVE_WHILE_FREEING</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">eb_rewin</span> <span class="o">=</span> <span class="n">alloc_dummy_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
						<span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">eb_rewin</span><span class="p">);</span>
		<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">eb_rewin</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">eb_rewin</span><span class="p">,</span>
					     <span class="n">btrfs_header_backref_rev</span><span class="p">(</span><span class="n">eb</span><span class="p">));</span>
		<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">eb_rewin</span><span class="p">,</span> <span class="n">btrfs_header_owner</span><span class="p">(</span><span class="n">eb</span><span class="p">));</span>
		<span class="n">btrfs_set_header_level</span><span class="p">(</span><span class="n">eb_rewin</span><span class="p">,</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">eb</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">eb_rewin</span> <span class="o">=</span> <span class="n">btrfs_clone_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">eb_rewin</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">eb_rewin</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>

	<span class="n">__tree_mod_log_rewind</span><span class="p">(</span><span class="n">eb_rewin</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">,</span> <span class="n">tm</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">eb_rewin</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * get_old_root() rewinds the state of @root&#39;s root node to the given @time_seq</span>
<span class="cm"> * value. If there are no changes, the current root-&gt;root_node is returned. If</span>
<span class="cm"> * anything changed in between, there&#39;s a fresh buffer allocated on which the</span>
<span class="cm"> * rewind operations are done. In any case, the returned buffer is read locked.</span>
<span class="cm"> * Returns NULL on error (with no locks held).</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span>
<span class="nf">get_old_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">tree_mod_elem</span> <span class="o">*</span><span class="n">tm</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">tree_mod_root</span> <span class="o">*</span><span class="n">old_root</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">old_generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">logical</span><span class="p">;</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">btrfs_read_lock_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">tm</span> <span class="o">=</span> <span class="n">__tree_mod_log_oldest_root</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tm</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">op</span> <span class="o">==</span> <span class="n">MOD_LOG_ROOT_REPLACE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">old_root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">old_root</span><span class="p">;</span>
		<span class="n">old_generation</span> <span class="o">=</span> <span class="n">tm</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>
		<span class="n">logical</span> <span class="o">=</span> <span class="n">old_root</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">logical</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">tm</span> <span class="o">=</span> <span class="n">tree_mod_log_search</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">logical</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * there was an item in the log when __tree_mod_log_oldest_root</span>
<span class="cm">	 * returned. this one must not go away, because the time_seq passed to</span>
<span class="cm">	 * us must be blocking its removal.</span>
<span class="cm">	 */</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">tm</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">old_root</span><span class="p">)</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">alloc_dummy_extent_buffer</span><span class="p">(</span><span class="n">tm</span><span class="o">-&gt;</span><span class="n">index</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
					       <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">btrfs_clone_extent_buffer</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">btrfs_tree_read_unlock</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">eb</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">eb</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
		<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">);</span>
		<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
		<span class="n">btrfs_set_header_level</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">old_root</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">);</span>
		<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">old_generation</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">__tree_mod_log_rewind</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">,</span> <span class="n">tm</span><span class="p">);</span>
	<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">eb</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">should_cow_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/* ensure we can see the force_cow */</span>
	<span class="n">smp_rmb</span><span class="p">();</span>

	<span class="cm">/*</span>
<span class="cm">	 * We do not need to cow a block if</span>
<span class="cm">	 * 1) this block is not created or changed in this transaction;</span>
<span class="cm">	 * 2) this block does not belong to TREE_RELOC tree;</span>
<span class="cm">	 * 3) the root is not forced COW.</span>
<span class="cm">	 *</span>
<span class="cm">	 * What is forced COW:</span>
<span class="cm">	 *    when we create snapshot during commiting the transaction,</span>
<span class="cm">	 *    after we&#39;ve finished coping src root, we must COW the shared</span>
<span class="cm">	 *    block to ensure the metadata consistency.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">==</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">btrfs_header_flag</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_WRITTEN</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">BTRFS_TREE_RELOC_OBJECTID</span> <span class="o">&amp;&amp;</span>
	      <span class="n">btrfs_header_flag</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">BTRFS_HEADER_FLAG_RELOC</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">force_cow</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * cows a single block, see __btrfs_cow_block for the real work.</span>
<span class="cm"> * This version of it has extra checks so that a block isn&#39;t cow&#39;d more than</span>
<span class="cm"> * once per transaction, as long as it hasn&#39;t been written yet</span>
<span class="cm"> */</span>
<span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_cow_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">parent_slot</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">**</span><span class="n">cow_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">search_start</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">running_transaction</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;trans %llu running %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">running_transaction</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;trans %llu running %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">should_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cow_ret</span> <span class="o">=</span> <span class="n">buf</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">search_start</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)(</span><span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">)</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">__btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
				 <span class="n">parent_slot</span><span class="p">,</span> <span class="n">cow_ret</span><span class="p">,</span> <span class="n">search_start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">trace_btrfs_cow_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="o">*</span><span class="n">cow_ret</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function for defrag to decide if two blocks pointed to by a</span>
<span class="cm"> * node are actually close by</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">close_blocks</span><span class="p">(</span><span class="n">u64</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">other</span><span class="p">,</span> <span class="n">u32</span> <span class="n">blocksize</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocknr</span> <span class="o">&lt;</span> <span class="n">other</span> <span class="o">&amp;&amp;</span> <span class="n">other</span> <span class="o">-</span> <span class="p">(</span><span class="n">blocknr</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">blocknr</span> <span class="o">&gt;</span> <span class="n">other</span> <span class="o">&amp;&amp;</span> <span class="n">blocknr</span> <span class="o">-</span> <span class="p">(</span><span class="n">other</span> <span class="o">+</span> <span class="n">blocksize</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">32768</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * compare two keys in a memcmp fashion</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">comp_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">disk</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">k2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">k1</span><span class="p">;</span>

	<span class="n">btrfs_disk_key_to_cpu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k1</span><span class="p">,</span> <span class="n">disk</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">btrfs_comp_cpu_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">k1</span><span class="p">,</span> <span class="n">k2</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * same as comp_keys only with two btrfs_key&#39;s</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_comp_cpu_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">k1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">k2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k1</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&gt;</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k1</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k1</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k1</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k1</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">k1</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">k2</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is used by the defrag code to go through all the</span>
<span class="cm"> * leaves pointed to by a node and reallocate them so that</span>
<span class="cm"> * disk order is close to key order</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_realloc_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">start_slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cache_only</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">last_ret</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">progress</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">gen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">search_start</span> <span class="o">=</span> <span class="o">*</span><span class="n">last_ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">other</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">parent_nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">end_slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">parent_level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">uptodate</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">progress_passed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>

	<span class="n">parent_level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cache_only</span> <span class="o">&amp;&amp;</span> <span class="n">parent_level</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">running_transaction</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="n">parent_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">parent_level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">end_slot</span> <span class="o">=</span> <span class="n">parent_nritems</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">parent_nritems</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">start_slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_slot</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">close</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">progress_passed</span> <span class="o">&amp;&amp;</span> <span class="n">comp_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">progress</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">progress_passed</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">blocknr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last_block</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">last_block</span> <span class="o">=</span> <span class="n">blocknr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">other</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">close</span> <span class="o">=</span> <span class="n">close_blocks</span><span class="p">(</span><span class="n">blocknr</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">close</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end_slot</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">other</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">close</span> <span class="o">=</span> <span class="n">close_blocks</span><span class="p">(</span><span class="n">blocknr</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">close</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">last_block</span> <span class="o">=</span> <span class="n">blocknr</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">cur</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span>
			<span class="n">uptodate</span> <span class="o">=</span> <span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">uptodate</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span> <span class="o">||</span> <span class="o">!</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">cache_only</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span>
							 <span class="n">blocksize</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">)</span>
					<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uptodate</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_read_buffer</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
					<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">search_start</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">search_start</span> <span class="o">=</span> <span class="n">last_block</span><span class="p">;</span>

		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">__btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">cur</span><span class="p">,</span> <span class="n">search_start</span><span class="p">,</span>
					<span class="n">min</span><span class="p">(</span><span class="mi">16</span> <span class="o">*</span> <span class="n">blocksize</span><span class="p">,</span>
					    <span class="p">(</span><span class="n">end_slot</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">blocksize</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">search_start</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">last_block</span> <span class="o">=</span> <span class="n">cur</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="o">*</span><span class="n">last_ret</span> <span class="o">=</span> <span class="n">search_start</span><span class="p">;</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The leaf data grows from end-to-front in the node.</span>
<span class="cm"> * this returns the address of the start of the last item,</span>
<span class="cm"> * which is the stop of the leaf data stack</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">leaf_data_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u32</span> <span class="n">nr</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * search for key in the extent_buffer.  The items start at offset p,</span>
<span class="cm"> * and they are item_size apart.  There are &#39;max&#39; items in p.</span>
<span class="cm"> *</span>
<span class="cm"> * the slot in the array is returned via slot, and it points to</span>
<span class="cm"> * the place where you would insert key if it is not found in</span>
<span class="cm"> * the array.</span>
<span class="cm"> *</span>
<span class="cm"> * slot may point to max if the key is bigger than all of the keys</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">generic_bin_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span>
				       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">p</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">item_size</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">max</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">high</span> <span class="o">=</span> <span class="n">max</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">tmp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">unaligned</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">map_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">low</span> <span class="o">+</span> <span class="n">high</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">p</span> <span class="o">+</span> <span class="n">mid</span> <span class="o">*</span> <span class="n">item_size</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">kaddr</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">map_start</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_disk_key</span><span class="p">))</span> <span class="o">&gt;</span>
		    <span class="n">map_start</span> <span class="o">+</span> <span class="n">map_len</span><span class="p">)</span> <span class="p">{</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">map_private_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span>
						<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_disk_key</span><span class="p">),</span>
						<span class="o">&amp;</span><span class="n">kaddr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">map_len</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="p">)(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span>
							<span class="n">map_start</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">unaligned</span><span class="p">,</span>
						   <span class="n">offset</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">unaligned</span><span class="p">));</span>
				<span class="n">tmp</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">unaligned</span><span class="p">;</span>
			<span class="p">}</span>

		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="p">)(</span><span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">-</span>
							<span class="n">map_start</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">comp_keys</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">key</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">high</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">mid</span><span class="p">;</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">slot</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * simple bin_search frontend that does the right thing for</span>
<span class="cm"> * leaves vs nodes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">bin_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">generic_bin_search</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span>
					  <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_leaf</span><span class="p">,</span> <span class="n">items</span><span class="p">),</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">),</span>
					  <span class="n">key</span><span class="p">,</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">),</span>
					  <span class="n">slot</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">generic_bin_search</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span>
					  <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_node</span><span class="p">,</span> <span class="n">ptrs</span><span class="p">),</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">),</span>
					  <span class="n">key</span><span class="p">,</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">),</span>
					  <span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_bin_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
		     <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">bin_search</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">root_add_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">accounting_lock</span><span class="p">);</span>
	<span class="n">btrfs_set_root_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">,</span>
			    <span class="n">btrfs_root_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">+</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">accounting_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">root_sub_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u32</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">accounting_lock</span><span class="p">);</span>
	<span class="n">btrfs_set_root_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">,</span>
			    <span class="n">btrfs_root_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">-</span> <span class="n">size</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">accounting_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* given a node and slot number, this reads the blocks it points to.  The</span>
<span class="cm"> * extent buffer is returned with a reference taken (but unlocked).</span>
<span class="cm"> * NULL is returned on error.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="nf">read_node_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">parent</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">slot</span><span class="p">),</span>
		       <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		       <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">slot</span><span class="p">));</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * node level balancing, used to make sure nodes are in proper order for</span>
<span class="cm"> * item deletion.  We balance from the top down, so we have to make sure</span>
<span class="cm"> * that a deletion won&#39;t leave an node completely empty later on.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">balance_level</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">mid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pslot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="n">u64</span> <span class="n">orig_ptr</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">mid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BTRFS_WRITE_LOCK</span> <span class="o">&amp;&amp;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">!=</span> <span class="n">BTRFS_WRITE_LOCK_BLOCKING</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>

	<span class="n">orig_ptr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="n">orig_slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">pslot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * deal with the case where there is only one pointer in the root</span>
<span class="cm">	 * by promoting the node below to a root</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">child</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

		<span class="cm">/* promote the child to a root */</span>
		<span class="n">child</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">child</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
			<span class="n">btrfs_std_error</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">enospc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">child</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">child</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">enospc</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">tree_mod_log_set_root_pointer</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>
		<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

		<span class="n">add_root_to_dirty_list</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>

		<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
		<span class="cm">/* once for the path */</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>

		<span class="n">root_sub_used</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">btrfs_free_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* once for the root ptr */</span>
		<span class="n">free_extent_buffer_stale</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">wret</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span>
				       <span class="n">parent</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">enospc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">right</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="n">wret</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span>
				       <span class="n">parent</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">enospc</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/* first, try to make some room in the middle buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">orig_slot</span> <span class="o">+=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">wret</span> <span class="o">=</span> <span class="n">push_node_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * then try to empty the right most buffer into the middle</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wret</span> <span class="o">=</span> <span class="n">push_node_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
			<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
			<span class="n">del_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">root_sub_used</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">btrfs_free_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">free_extent_buffer_stale</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
			<span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">right_key</span><span class="p">;</span>
			<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">tree_mod_log_set_node_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">right_key</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right_key</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * we&#39;re not allowed to leave a node with one item in the</span>
<span class="cm">		 * tree during a delete.  A deletion from lower in the tree</span>
<span class="cm">		 * could try to delete the only pointer in this node.</span>
<span class="cm">		 * So, pull some keys from the left.</span>
<span class="cm">		 * There has to be a left pointer at this point because</span>
<span class="cm">		 * otherwise we would have pulled some pointers from the</span>
<span class="cm">		 * right</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
			<span class="n">btrfs_std_error</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">enospc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wret</span> <span class="o">=</span> <span class="n">balance_node_right</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">enospc</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wret</span> <span class="o">=</span> <span class="n">push_node_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">wret</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
		<span class="n">del_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pslot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">root_sub_used</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
		<span class="n">btrfs_free_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">free_extent_buffer_stale</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
		<span class="n">mid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* update the parent key to reflect our changes */</span>
		<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">mid_key</span><span class="p">;</span>
		<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mid_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">tree_mod_log_set_node_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mid_key</span><span class="p">,</span>
					  <span class="n">pslot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mid_key</span><span class="p">,</span> <span class="n">pslot</span><span class="p">);</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* update the path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">orig_slot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
			<span class="cm">/* left was locked after cow */</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_slot</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">orig_slot</span> <span class="o">-=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_slot</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="cm">/* double check we haven&#39;t messed things up */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">orig_ptr</span> <span class="o">!=</span>
	    <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]))</span>
		<span class="n">BUG</span><span class="p">();</span>
<span class="nl">enospc:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">!=</span> <span class="n">left</span><span class="p">)</span>
			<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Node balancing for insertion.  Here we only split or push nodes around</span>
<span class="cm"> * when they are completely full.  This is also done top down, so we</span>
<span class="cm"> * have to be pessimistic.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">push_nodes_for_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">mid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pslot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">orig_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">mid</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
		<span class="n">pslot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* first, try to make some room in the middle buffer */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">left_nr</span><span class="p">;</span>

		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

		<span class="n">left_nr</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">left_nr</span> <span class="o">&gt;=</span> <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
					      <span class="n">pslot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">left</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">wret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">wret</span> <span class="o">=</span> <span class="n">push_node_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						      <span class="n">left</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
			<span class="n">orig_slot</span> <span class="o">+=</span> <span class="n">left_nr</span><span class="p">;</span>
			<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">mid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">tree_mod_log_set_node_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">pslot</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">pslot</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">orig_slot</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_slot</span><span class="p">;</span>
				<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">orig_slot</span> <span class="o">-=</span>
					<span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_slot</span><span class="p">;</span>
				<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">right</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * then try to empty the right most buffer into the middle</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">right_nr</span><span class="p">;</span>

		<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

		<span class="n">right_nr</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">right_nr</span> <span class="o">&gt;=</span> <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span>
					      <span class="n">parent</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">right</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">wret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">wret</span> <span class="o">=</span> <span class="n">balance_node_right</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
							  <span class="n">right</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>

			<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">tree_mod_log_set_node_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span>
						  <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">pslot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">mid</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">orig_slot</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">orig_slot</span> <span class="o">-</span>
					<span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
				<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">mid</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * readahead one full node of leaves, finding things that are close</span>
<span class="cm"> * to the block in &#39;slot&#39;, and triggering ra on them.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">reada_for_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="n">u64</span> <span class="n">objectid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">search</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">target</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">nread</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">gen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nscan</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>

	<span class="n">search</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">eb</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">eb</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">target</span> <span class="o">=</span> <span class="n">search</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
	<span class="n">nr</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">nr</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">direction</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">nr</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nr</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">objectid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_disk_key_objectid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">)</span> <span class="o">!=</span> <span class="n">objectid</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">search</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">search</span> <span class="o">&lt;=</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">target</span> <span class="o">-</span> <span class="n">search</span> <span class="o">&lt;=</span> <span class="mi">65536</span><span class="p">)</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">search</span> <span class="o">&gt;</span> <span class="n">target</span> <span class="o">&amp;&amp;</span> <span class="n">search</span> <span class="o">-</span> <span class="n">target</span> <span class="o">&lt;=</span> <span class="mi">65536</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">gen</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
			<span class="n">readahead_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">search</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
			<span class="n">nread</span> <span class="o">+=</span> <span class="n">blocksize</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nscan</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">nread</span> <span class="o">&gt;</span> <span class="mi">65536</span> <span class="o">||</span> <span class="n">nscan</span> <span class="o">&gt;</span> <span class="mi">32</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * returns -EAGAIN if it had to drop the path, or zero if everything was in</span>
<span class="cm"> * cache</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">reada_for_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">gen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">block2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">blocksize</span><span class="p">;</span>

	<span class="n">parent</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">parent</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block1</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * if we get -eagain from btrfs_buffer_uptodate, we</span>
<span class="cm">		 * don&#39;t want to return eagain here.  That will loop</span>
<span class="cm">		 * forever</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">block1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block2</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">gen</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">eb</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block2</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">eb</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">block2</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block1</span> <span class="o">||</span> <span class="n">block2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>

		<span class="cm">/* release the whole path */</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

		<span class="cm">/* read the blocks */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block1</span><span class="p">)</span>
			<span class="n">readahead_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block2</span><span class="p">)</span>
			<span class="n">readahead_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block2</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eb</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block1</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block2</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">eb</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">block2</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * when we walk down the tree, it is usually safe to unlock the higher layers</span>
<span class="cm"> * in the tree.  The exceptions are when our path goes through slot 0, because</span>
<span class="cm"> * operations on the tree might require changing key pointers higher up in the</span>
<span class="cm"> * tree.</span>
<span class="cm"> *</span>
<span class="cm"> * callers might also have set path-&gt;keep_locks, which tells this code to keep</span>
<span class="cm"> * the lock if the path points to the last slot in the block.  This is part of</span>
<span class="cm"> * walking through the tree, and selecting the next slot in the higher block.</span>
<span class="cm"> *</span>
<span class="cm"> * lowest_unlock sets the lowest level in the tree we&#39;re allowed to unlock.  so</span>
<span class="cm"> * if lowest_unlock is 1, level 0 won&#39;t be unlocked</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">unlock_up</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">lowest_unlock</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_write_lock_level</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="o">*</span><span class="n">write_lock_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">skip_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">no_skips</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_skips</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">skip_level</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">no_skips</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
			<span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">skip_level</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skip_level</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">lowest_unlock</span><span class="p">)</span>
			<span class="n">no_skips</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">lowest_unlock</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">skip_level</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">write_lock_level</span> <span class="o">&amp;&amp;</span>
			    <span class="n">i</span> <span class="o">&gt;</span> <span class="n">min_write_lock_level</span> <span class="o">&amp;&amp;</span>
			    <span class="n">i</span> <span class="o">&lt;=</span> <span class="o">*</span><span class="n">write_lock_level</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">write_lock_level</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This releases any locks held in the path starting at level and</span>
<span class="cm"> * going all the way up to the root.</span>
<span class="cm"> *</span>
<span class="cm"> * btrfs_search_slot will keep the lock held on higher nodes in a few</span>
<span class="cm"> * corner cases, such as COW of the block at slot zero in the node.  This</span>
<span class="cm"> * ignores those rules, and it should only be called when there are no</span>
<span class="cm"> * more updates to be done higher up in the tree.</span>
<span class="cm"> */</span>
<span class="n">noinline</span> <span class="kt">void</span> <span class="nf">btrfs_unlock_up_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function for btrfs_search_slot.  The goal is to find a block</span>
<span class="cm"> * in cache without setting the path to blocking.  If we find the block</span>
<span class="cm"> * we return zero and the path is unchanged.</span>
<span class="cm"> *</span>
<span class="cm"> * If we can&#39;t find the block, we set the path blocking and do some</span>
<span class="cm"> * reada.  -EAGAIN is returned and the search must be repeated.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">read_block_for_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">**</span><span class="n">eb_ret</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">blocknr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">gen</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="o">*</span><span class="n">eb_ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">blocknr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">gen</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">blocksize</span> <span class="o">=</span> <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">tmp</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* first we do an atomic uptodate check */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * we found an up to date block without</span>
<span class="cm">				 * sleeping, return</span>
<span class="cm">				 * right away</span>
<span class="cm">				 */</span>
				<span class="o">*</span><span class="n">eb_ret</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* the pages were up to date, but we failed</span>
<span class="cm">			 * the generation number check.  Do a full</span>
<span class="cm">			 * read for the generation number that is correct.</span>
<span class="cm">			 * We must do this without dropping locks so</span>
<span class="cm">			 * we can trust our generation number</span>
<span class="cm">			 */</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

			<span class="cm">/* now we&#39;re allowed to do a blocking uptodate check */</span>
			<span class="n">tmp</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="n">gen</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">eb_ret</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * reduce lock contention at high levels</span>
<span class="cm">	 * of the btree by dropping locks before</span>
<span class="cm">	 * we read.  Don&#39;t release the lock on the current</span>
<span class="cm">	 * level because we need to walk this node to figure</span>
<span class="cm">	 * out which blocks to read.</span>
<span class="cm">	 */</span>
	<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">reada</span><span class="p">)</span>
		<span class="n">reada_for_search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">);</span>

	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">tmp</span> <span class="o">=</span> <span class="n">read_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">blocknr</span><span class="p">,</span> <span class="n">blocksize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * If the read above didn&#39;t mark this buffer up to date,</span>
<span class="cm">		 * it will never end up being up to date.  Set ret to EIO now</span>
<span class="cm">		 * and give up so that our caller doesn&#39;t loop forever</span>
<span class="cm">		 * on our EAGAINs.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function for btrfs_search_slot.  This does all of the checks</span>
<span class="cm"> * for node-level blocks and does any balancing required based on</span>
<span class="cm"> * the ins_len.</span>
<span class="cm"> *</span>
<span class="cm"> * If no extra work was required, zero is returned.  If we had to</span>
<span class="cm"> * drop the path, -EAGAIN is returned and btrfs_search_slot must</span>
<span class="cm"> * start over</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span>
<span class="nf">setup_nodes_for_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ins_len</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="o">*</span><span class="n">write_lock_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">search_for_split</span> <span class="o">||</span> <span class="n">ins_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&gt;=</span>
	    <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">write_lock_level</span> <span class="o">&lt;</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">write_lock_level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sret</span> <span class="o">=</span> <span class="n">reada_for_balance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

		<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">sret</span> <span class="o">=</span> <span class="n">split_node</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">sret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">sret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ins_len</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span>
		   <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">sret</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">write_lock_level</span> <span class="o">&lt;</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">write_lock_level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sret</span> <span class="o">=</span> <span class="n">reada_for_balance</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

		<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">sret</span> <span class="o">=</span> <span class="n">balance_level</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">sret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * look for key in the tree.  path is filled in with nodes along the way</span>
<span class="cm"> * if key is found, we return zero and you can find the item in the leaf</span>
<span class="cm"> * level of the path (level 0)</span>
<span class="cm"> *</span>
<span class="cm"> * If the key isn&#39;t found, the path points to the slot where it should</span>
<span class="cm"> * be inserted, and 1 is returned.  If there are other errors during the</span>
<span class="cm"> * search a negative error number is returned.</span>
<span class="cm"> *</span>
<span class="cm"> * if ins_len &gt; 0, nodes and leaves will be split as we walk down the</span>
<span class="cm"> * tree.  if ins_len &lt; 0, nodes will be merged as we walk down the tree (if</span>
<span class="cm"> * possible)</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_search_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span>
		      <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span>
		      <span class="n">ins_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cow</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lowest_unlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">root_lock</span><span class="p">;</span>
	<span class="cm">/* everything at write_lock_level or lower must be write locked */</span>
	<span class="kt">int</span> <span class="n">write_lock_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lowest_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">min_write_lock_level</span><span class="p">;</span>

	<span class="n">lowest_level</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lowest_level</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">lowest_level</span> <span class="o">&amp;&amp;</span> <span class="n">ins_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ins_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">lowest_unlock</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

		<span class="cm">/* when we are removing items, we might have to go up to level</span>
<span class="cm">		 * two as we update tree pointers  Make sure we keep write</span>
<span class="cm">		 * for those levels as well</span>
<span class="cm">		 */</span>
		<span class="n">write_lock_level</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ins_len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * for inserting items, make sure we have a write lock on</span>
<span class="cm">		 * level 1 so we can update keys</span>
<span class="cm">		 */</span>
		<span class="n">write_lock_level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cow</span><span class="p">)</span>
		<span class="n">write_lock_level</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">cow</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">||</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lowest_level</span><span class="p">))</span>
		<span class="n">write_lock_level</span> <span class="o">=</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span>

	<span class="n">min_write_lock_level</span> <span class="o">=</span> <span class="n">write_lock_level</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="cm">/*</span>
<span class="cm">	 * we try very hard to do read locks on the root</span>
<span class="cm">	 */</span>
	<span class="n">root_lock</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>
	<span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">search_commit_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * the commit roots are read only</span>
<span class="cm">		 * so we always do read locks</span>
<span class="cm">		 */</span>
		<span class="n">b</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">commit_root</span><span class="p">;</span>
		<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">skip_locking</span><span class="p">)</span>
			<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">skip_locking</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">btrfs_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* we don&#39;t know the level of the root node</span>
<span class="cm">			 * until we actually have it read locked</span>
<span class="cm">			 */</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">btrfs_read_lock_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
			<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">write_lock_level</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* whoops, must trade for write lock */</span>
				<span class="n">btrfs_tree_read_unlock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
				<span class="n">b</span> <span class="o">=</span> <span class="n">btrfs_lock_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
				<span class="n">root_lock</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK</span><span class="p">;</span>

				<span class="cm">/* the level might have changed, check again */</span>
				<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">skip_locking</span><span class="p">)</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">root_lock</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * setup the path here so we can release it under lock</span>
<span class="cm">		 * contention with the cow code</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cow</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * if we don&#39;t really need to cow this block</span>
<span class="cm">			 * then we don&#39;t want to set the path blocking,</span>
<span class="cm">			 * so we test it here</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">should_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">b</span><span class="p">))</span>
				<span class="k">goto</span> <span class="n">cow_done</span><span class="p">;</span>

			<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

			<span class="cm">/*</span>
<span class="cm">			 * must have write locks on this node and the</span>
<span class="cm">			 * parent</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;</span> <span class="n">write_lock_level</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">write_lock_level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
					      <span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
					      <span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
<span class="nl">cow_done:</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cow</span> <span class="o">&amp;&amp;</span> <span class="n">ins_len</span><span class="p">);</span>

		<span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * we have a lock on b and as long as we aren&#39;t changing</span>
<span class="cm">		 * the tree, there is no way to for the items in b to change.</span>
<span class="cm">		 * It is safe to drop the lock on our parent before we</span>
<span class="cm">		 * go through the expensive btree search on b.</span>
<span class="cm">		 *</span>
<span class="cm">		 * If cow is true, then we might be changing slot zero,</span>
<span class="cm">		 * which may require changing the parent.  So, we can&#39;t</span>
<span class="cm">		 * drop the lock until after we know which slot we&#39;re</span>
<span class="cm">		 * operating on.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cow</span><span class="p">)</span>
			<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">bin_search</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">dec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">slot</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">setup_nodes_for_search</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
					     <span class="n">ins_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_lock_level</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>

			<span class="cm">/*</span>
<span class="cm">			 * slot 0 is special, if we change the key</span>
<span class="cm">			 * we have to update the parent pointer</span>
<span class="cm">			 * which means we must have a write lock</span>
<span class="cm">			 * on the parent</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">cow</span> <span class="o">&amp;&amp;</span>
			    <span class="n">write_lock_level</span> <span class="o">&lt;</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">write_lock_level</span> <span class="o">=</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">unlock_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lowest_unlock</span><span class="p">,</span>
				  <span class="n">min_write_lock_level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_lock_level</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">lowest_level</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dec</span><span class="p">)</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">read_block_for_search</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
						    <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">skip_locking</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;=</span> <span class="n">write_lock_level</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_try_tree_write_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
						<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
						<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
								  <span class="n">BTRFS_WRITE_LOCK</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_try_tree_read_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
						<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
						<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
								  <span class="n">BTRFS_READ_LOCK</span><span class="p">);</span>
					<span class="p">}</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ins_len</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">ins_len</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">write_lock_level</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">write_lock_level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
				<span class="n">err</span> <span class="o">=</span> <span class="n">split_leaf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span>
						 <span class="n">p</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">err</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">search_for_split</span><span class="p">)</span>
				<span class="n">unlock_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lowest_unlock</span><span class="p">,</span>
					  <span class="n">min_write_lock_level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">write_lock_level</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="cm">/*</span>
<span class="cm">	 * we don&#39;t really know what they plan on doing with the path</span>
<span class="cm">	 * from here on, so for now just mark it as blocking</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">leave_spinning</span><span class="p">)</span>
		<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Like btrfs_search_slot, this looks for a key in the given tree. It uses the</span>
<span class="cm"> * current state of the tree together with the operations recorded in the tree</span>
<span class="cm"> * modification log to search for the key in a previous version of this tree, as</span>
<span class="cm"> * denoted by the time_seq parameter.</span>
<span class="cm"> *</span>
<span class="cm"> * Naturally, there is no support for insert, delete or cow operations.</span>
<span class="cm"> *</span>
<span class="cm"> * The resulting path and return value will be set up as if we called</span>
<span class="cm"> * btrfs_search_slot at that point in time with ins_len and cow both set to 0.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_search_old_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="n">u64</span> <span class="n">time_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">lowest_unlock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">lowest_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lowest_level</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">lowest_level</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">search_commit_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">time_seq</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">again:</span>
	<span class="n">b</span> <span class="o">=</span> <span class="n">get_old_root</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
	<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
		<span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
		<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * we have a lock on b and as long as we aren&#39;t changing</span>
<span class="cm">		 * the tree, there is no way to for the items in b to change.</span>
<span class="cm">		 * It is safe to drop the lock on our parent before we</span>
<span class="cm">		 * go through the expensive btree search on b.</span>
<span class="cm">		 */</span>
		<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">bin_search</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">dec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">dec</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">slot</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
			<span class="n">unlock_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lowest_unlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">lowest_level</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">dec</span><span class="p">)</span>
					<span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">err</span> <span class="o">=</span> <span class="n">read_block_for_search</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
						    <span class="n">slot</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_try_tree_read_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
				<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
				<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span>
							  <span class="n">BTRFS_READ_LOCK</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
			<span class="n">b</span> <span class="o">=</span> <span class="n">tree_mod_log_rewind</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">!=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">],</span>
						     <span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">p</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">p</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
			<span class="n">unlock_up</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">lowest_unlock</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">leave_spinning</span><span class="p">)</span>
		<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * adjust the pointers going up the tree, starting at level</span>
<span class="cm"> * making sure the right key of each node is points to &#39;key&#39;.</span>
<span class="cm"> * This is used after shifting pointers to the left, so it stops</span>
<span class="cm"> * fixing up pointers when a given leaf/node is not in slot 0 of the</span>
<span class="cm"> * higher levels</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">fixup_low_keys</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">tslot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">t</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">tree_mod_log_set_node_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">tslot</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">tslot</span><span class="p">);</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tslot</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * update item key.</span>
<span class="cm"> *</span>
<span class="cm"> * This function isn&#39;t completely safe. It&#39;s the caller&#39;s responsibility</span>
<span class="cm"> * that the new key won&#39;t break the order</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_set_item_key_safe</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">new_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">eb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>

	<span class="n">eb</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">comp_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">new_key</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">eb</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">comp_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">new_key</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">new_key</span><span class="p">);</span>
	<span class="n">btrfs_set_item_key</span><span class="p">(</span><span class="n">eb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">eb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * try to push data from one node into the next node left in the</span>
<span class="cm"> * tree.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if some ptrs were pushed left, &lt; 0 if there was some horrible</span>
<span class="cm"> * error, and &gt; 0 if there was no room in the left hand block.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">push_node_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
			  <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="kt">int</span> <span class="n">empty</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">push_items</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">src_nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dst_nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">src_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">dst_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">push_items</span> <span class="o">=</span> <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="n">dst_nritems</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="n">src_nritems</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">push_items</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">src_nritems</span><span class="p">,</span> <span class="n">push_items</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">&lt;</span> <span class="n">src_nritems</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* leave at least 8 pointers in the node if</span>
<span class="cm">			 * we aren&#39;t going to empty it</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">src_nritems</span> <span class="o">-</span> <span class="n">push_items</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">&lt;=</span> <span class="mi">8</span><span class="p">)</span>
					<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">push_items</span> <span class="o">-=</span> <span class="mi">8</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">push_items</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">src_nritems</span> <span class="o">-</span> <span class="mi">8</span><span class="p">,</span> <span class="n">push_items</span><span class="p">);</span>

	<span class="n">tree_mod_log_eb_copy</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="n">dst_nritems</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">push_items</span><span class="p">);</span>
	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span>
			   <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">dst_nritems</span><span class="p">),</span>
			   <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			   <span class="n">push_items</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">&lt;</span> <span class="n">src_nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">tree_mod_log_eb_move</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">push_items</span><span class="p">,</span>
				     <span class="n">src_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">);</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
				      <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">push_items</span><span class="p">),</span>
				      <span class="p">(</span><span class="n">src_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">)</span> <span class="o">*</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">);</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_nritems</span> <span class="o">+</span> <span class="n">push_items</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * try to push data from one node into the next node right in the</span>
<span class="cm"> * tree.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if some ptrs were pushed, &lt; 0 if there was some horrible</span>
<span class="cm"> * error, and &gt; 0 if there was no room in the right hand block.</span>
<span class="cm"> *</span>
<span class="cm"> * this will  only push up to 1/2 the contents of the left node over</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">balance_node_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">src</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">push_items</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_push</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">src_nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dst_nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">src</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">dst</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>

	<span class="n">src_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">dst_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>
	<span class="n">push_items</span> <span class="o">=</span> <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="n">dst_nritems</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">src_nritems</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">max_push</span> <span class="o">=</span> <span class="n">src_nritems</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="cm">/* don&#39;t try to empty the node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">max_push</span> <span class="o">&gt;=</span> <span class="n">src_nritems</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">max_push</span> <span class="o">&lt;</span> <span class="n">push_items</span><span class="p">)</span>
		<span class="n">push_items</span> <span class="o">=</span> <span class="n">max_push</span><span class="p">;</span>

	<span class="n">tree_mod_log_eb_move</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">push_items</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">dst_nritems</span><span class="p">);</span>
	<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">push_items</span><span class="p">),</span>
				      <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
				      <span class="p">(</span><span class="n">dst_nritems</span><span class="p">)</span> <span class="o">*</span>
				      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">));</span>

	<span class="n">tree_mod_log_eb_copy</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			     <span class="n">src_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">,</span> <span class="n">push_items</span><span class="p">);</span>
	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">src</span><span class="p">,</span>
			   <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			   <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">src_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">),</span>
			   <span class="n">push_items</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">));</span>

	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">src_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">);</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">dst_nritems</span> <span class="o">+</span> <span class="n">push_items</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">dst</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function to insert a new root level in the tree.</span>
<span class="cm"> * A new node is allocated, and a single item is inserted to</span>
<span class="cm"> * point to the existing root</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero on success or &lt; 0 on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">insert_new_root</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">lower_gen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">lower</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">lower_key</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">);</span>

	<span class="n">lower</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lower_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lower_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">btrfs_alloc_free_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
				   <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lower_key</span><span class="p">,</span>
				   <span class="n">level</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">root_add_used</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">);</span>

	<span class="n">memset_extent_buffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span><span class="p">));</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_set_header_level</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
	<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">);</span>
	<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>

	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_fsid</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
			    <span class="n">BTRFS_FSID_SIZE</span><span class="p">);</span>

	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_chunk_tree_uuid</span><span class="p">(</span><span class="n">c</span><span class="p">),</span>
			    <span class="n">BTRFS_UUID_SIZE</span><span class="p">);</span>

	<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lower_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_node_blockptr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lower</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">lower_gen</span> <span class="o">=</span> <span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">lower</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">lower_gen</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>

	<span class="n">btrfs_set_node_ptr_generation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">lower_gen</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>

	<span class="n">old</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">;</span>
	<span class="n">tree_mod_log_set_root_pointer</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
	<span class="n">rcu_assign_pointer</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>

	<span class="cm">/* the super has an extra ref to root-&gt;node */</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">old</span><span class="p">);</span>

	<span class="n">add_root_to_dirty_list</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_WRITE_LOCK</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * worker function to insert a single pointer in a node.</span>
<span class="cm"> * the node should have enough room for the pointer already</span>
<span class="cm"> *</span>
<span class="cm"> * slot and level indicate where you want the key to go, and</span>
<span class="cm"> * blocknr is the block the key points to.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">insert_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
		       <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">tree_mod_log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">lower</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
	<span class="n">btrfs_assert_tree_locked</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
	<span class="n">lower</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">lower</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="n">nritems</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nritems</span> <span class="o">==</span> <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_log</span> <span class="o">&amp;&amp;</span> <span class="n">level</span><span class="p">)</span>
			<span class="n">tree_mod_log_eb_move</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="n">slot</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span>
			      <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
			      <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			      <span class="p">(</span><span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_log</span> <span class="o">&amp;&amp;</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">lower</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
					      <span class="n">MOD_LOG_KEY_ADD</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">btrfs_set_node_blockptr</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_node_ptr_generation</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">lower</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">lower</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * split the node at the specified level in path in two.</span>
<span class="cm"> * The path is corrected to point to the appropriate node after the split</span>
<span class="cm"> *</span>
<span class="cm"> * Before splitting this tries to make some room in the node by pushing</span>
<span class="cm"> * left and right, if either one works, it returns right away.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 on success and &lt; 0 on failure</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">split_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">split</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">c_nritems</span><span class="p">;</span>

	<span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* trying to split the root, lets make a new one */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_new_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">push_nodes_for_insert</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">level</span><span class="p">);</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">&lt;</span>
		    <span class="n">BTRFS_NODEPTRS_PER_BLOCK</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="mi">3</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">c_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">c_nritems</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>

	<span class="n">split</span> <span class="o">=</span> <span class="n">btrfs_alloc_free_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="n">c</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">split</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>

	<span class="n">root_add_used</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">);</span>

	<span class="n">memset_extent_buffer</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span><span class="p">));</span>
	<span class="n">btrfs_set_header_level</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">c</span><span class="p">));</span>
	<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">);</span>
	<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_fsid</span><span class="p">(</span><span class="n">split</span><span class="p">),</span>
			    <span class="n">BTRFS_FSID_SIZE</span><span class="p">);</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_chunk_tree_uuid</span><span class="p">(</span><span class="n">split</span><span class="p">),</span>
			    <span class="n">BTRFS_UUID_SIZE</span><span class="p">);</span>

	<span class="n">tree_mod_log_eb_copy</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">c_nritems</span> <span class="o">-</span> <span class="n">mid</span><span class="p">);</span>
	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span>
			   <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			   <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">mid</span><span class="p">),</span>
			   <span class="p">(</span><span class="n">c_nritems</span> <span class="o">-</span> <span class="n">mid</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">));</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">split</span><span class="p">,</span> <span class="n">c_nritems</span> <span class="o">-</span> <span class="n">mid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>

	<span class="n">insert_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
		   <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">mid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mid</span><span class="p">;</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">split</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * how many bytes are required to store the items in a leaf.  start</span>
<span class="cm"> * and nr indicate which items in the leaf to check.  This totals up the</span>
<span class="cm"> * space used both by the item structs and the item data</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">leaf_space_used</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span> <span class="kt">int</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nritems</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">nr</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">data_len</span> <span class="o">=</span> <span class="n">btrfs_item_end_nr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="n">data_len</span> <span class="o">=</span> <span class="n">data_len</span> <span class="o">-</span> <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">data_len</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">data_len</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">data_len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * The space between the end of the leaf items and</span>
<span class="cm"> * the start of the leaf data.  IOW, how much room</span>
<span class="cm"> * the leaf has left for both items and data</span>
<span class="cm"> */</span>
<span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_leaf_free_space</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="n">leaf_space_used</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nritems</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;leaf free space ret %d, leaf data size %lu, &quot;</span>
		       <span class="s">&quot;used %d nritems %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">ret</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">),</span>
		       <span class="n">leaf_space_used</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nritems</span><span class="p">),</span> <span class="n">nritems</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * min slot controls the lowest index we&#39;re willing to push to the</span>
<span class="cm"> * right.  We&#39;ll push up to and including min_slot, but no lower</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">__push_leaf_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">empty</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">free_space</span><span class="p">,</span> <span class="n">u32</span> <span class="n">left_nritems</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">min_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">upper</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">push_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">push_items</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nr</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">right_nritems</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">data_end</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">this_item_size</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">min_slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">left_nritems</span><span class="p">)</span>
		<span class="n">push_space</span> <span class="o">+=</span> <span class="n">data_size</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">i</span> <span class="o">=</span> <span class="n">left_nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="n">push_items</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">space</span> <span class="o">=</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">+</span> <span class="n">push_space</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">free_space</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">push_space</span> <span class="o">+=</span> <span class="n">data_size</span><span class="p">;</span>

		<span class="n">this_item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_item_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="n">push_space</span> <span class="o">&gt;</span> <span class="n">free_space</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">push_items</span><span class="o">++</span><span class="p">;</span>
		<span class="n">push_space</span> <span class="o">+=</span> <span class="n">this_item_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">i</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="n">push_items</span> <span class="o">==</span> <span class="n">left_nritems</span><span class="p">)</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* push left to right */</span>
	<span class="n">right_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

	<span class="n">push_space</span> <span class="o">=</span> <span class="n">btrfs_item_end_nr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">);</span>
	<span class="n">push_space</span> <span class="o">-=</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>

	<span class="cm">/* make room in the right data area */</span>
	<span class="n">data_end</span> <span class="o">=</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
	<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span>
			      <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_end</span> <span class="o">-</span> <span class="n">push_space</span><span class="p">,</span>
			      <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_end</span><span class="p">,</span>
			      <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="n">data_end</span><span class="p">);</span>

	<span class="cm">/* copy from the left data area */</span>
	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="n">push_space</span><span class="p">,</span>
		     <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">),</span>
		     <span class="n">push_space</span><span class="p">);</span>

	<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">push_items</span><span class="p">),</span>
			      <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			      <span class="n">right_nritems</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>

	<span class="cm">/* copy the items from left to right */</span>
	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
		   <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">left_nritems</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">),</span>
		   <span class="n">push_items</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>

	<span class="cm">/* update the item pointers */</span>
	<span class="n">right_nritems</span> <span class="o">+=</span> <span class="n">push_items</span><span class="p">;</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">right_nritems</span><span class="p">);</span>
	<span class="n">push_space</span> <span class="o">=</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right_nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">push_space</span> <span class="o">-=</span> <span class="n">btrfs_token_item_size</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">push_space</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">left_nritems</span> <span class="o">-=</span> <span class="n">push_items</span><span class="p">;</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">left_nritems</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">left_nritems</span><span class="p">)</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

	<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_node_key</span><span class="p">(</span><span class="n">upper</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">upper</span><span class="p">);</span>

	<span class="cm">/* then fixup the leaf pointer in the path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">left_nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">left_nritems</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_unlock:</span>
	<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * push some data in the path leaf to the right, trying to free up at</span>
<span class="cm"> * least data_size bytes.  returns zero if the push worked, nonzero otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * returns 1 if the push failed because the other node didn&#39;t have enough</span>
<span class="cm"> * room, 0 if everything worked out and &lt; 0 if there were major errors.</span>
<span class="cm"> *</span>
<span class="cm"> * this will push starting from min_slot to the end of the leaf.  It won&#39;t</span>
<span class="cm"> * push any slot lower than min_slot</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">push_leaf_right</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span>
			   <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">min_data_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span>
			   <span class="kt">int</span> <span class="n">empty</span><span class="p">,</span> <span class="n">u32</span> <span class="n">min_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">left</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">upper</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_space</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">left_nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="n">upper</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">upper</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">btrfs_assert_tree_locked</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">right</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

	<span class="n">free_space</span> <span class="o">=</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="cm">/* cow and double check */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">upper</span><span class="p">,</span>
			      <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">right</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">free_space</span> <span class="o">=</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">left_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left_nritems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">__push_leaf_right</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">min_data_size</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span>
				<span class="n">right</span><span class="p">,</span> <span class="n">free_space</span><span class="p">,</span> <span class="n">left_nritems</span><span class="p">,</span> <span class="n">min_slot</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * push some data in the path leaf to the left, trying to free up at</span>
<span class="cm"> * least data_size bytes.  returns zero if the push worked, nonzero otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * max_slot can put a limit on how far into the leaf we&#39;ll push items.  The</span>
<span class="cm"> * item at &#39;max_slot&#39; won&#39;t be touched.  Use (u32)-1 to make us do all the</span>
<span class="cm"> * items</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">__push_leaf_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">empty</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">left</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">free_space</span><span class="p">,</span> <span class="n">u32</span> <span class="n">right_nritems</span><span class="p">,</span>
				     <span class="n">u32</span> <span class="n">max_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">push_space</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">push_items</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">old_left_nritems</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">this_item_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">old_left_item_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">empty</span><span class="p">)</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">right_nritems</span><span class="p">,</span> <span class="n">max_slot</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">right_nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">max_slot</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="n">push_items</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="kt">int</span> <span class="n">space</span> <span class="o">=</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">space</span> <span class="o">+</span> <span class="n">push_space</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">&gt;</span> <span class="n">free_space</span><span class="p">)</span>
					<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span>
			<span class="n">push_space</span> <span class="o">+=</span> <span class="n">data_size</span><span class="p">;</span>

		<span class="n">this_item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">this_item_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">)</span> <span class="o">+</span> <span class="n">push_space</span> <span class="o">&gt;</span> <span class="n">free_space</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">push_items</span><span class="o">++</span><span class="p">;</span>
		<span class="n">push_space</span> <span class="o">+=</span> <span class="n">this_item_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">empty</span> <span class="o">&amp;&amp;</span> <span class="n">push_items</span> <span class="o">==</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* push data from right to left */</span>
	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span>
			   <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">)),</span>
			   <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			   <span class="n">push_items</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>

	<span class="n">push_space</span> <span class="o">=</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span>
		     <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">push_items</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">left</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">)</span> <span class="o">-</span> <span class="n">push_space</span><span class="p">,</span>
		     <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">push_items</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
		     <span class="n">push_space</span><span class="p">);</span>
	<span class="n">old_left_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">old_left_nritems</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">old_left_item_size</span> <span class="o">=</span> <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">old_left_nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">old_left_nritems</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">old_left_nritems</span> <span class="o">+</span> <span class="n">push_items</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ioff</span><span class="p">;</span>

		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">ioff</span> <span class="o">=</span> <span class="n">btrfs_token_item_offset</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
		      <span class="n">ioff</span> <span class="o">-</span> <span class="p">(</span><span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="n">old_left_item_size</span><span class="p">),</span>
		      <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">left</span><span class="p">,</span> <span class="n">old_left_nritems</span> <span class="o">+</span> <span class="n">push_items</span><span class="p">);</span>

	<span class="cm">/* fixup right node */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">&gt;</span> <span class="n">right_nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;push items %d nr %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">push_items</span><span class="p">,</span>
		       <span class="n">right_nritems</span><span class="p">);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">push_items</span> <span class="o">&lt;</span> <span class="n">right_nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">push_space</span> <span class="o">=</span> <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">push_items</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">-</span>
						  <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span>
				      <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span> <span class="n">push_space</span><span class="p">,</span>
				      <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span>
				      <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">),</span> <span class="n">push_space</span><span class="p">);</span>

		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			      <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">push_items</span><span class="p">),</span>
			     <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">-</span> <span class="n">push_items</span><span class="p">)</span> <span class="o">*</span>
			     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">right_nritems</span> <span class="o">-=</span> <span class="n">push_items</span><span class="p">;</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">right_nritems</span><span class="p">);</span>
	<span class="n">push_space</span> <span class="o">=</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">right_nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">push_space</span> <span class="o">=</span> <span class="n">push_space</span> <span class="o">-</span> <span class="n">btrfs_token_item_size</span><span class="p">(</span><span class="n">right</span><span class="p">,</span>
								<span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">push_space</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right_nritems</span><span class="p">)</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>

	<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* then fixup the leaf pointer in the path */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">push_items</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="n">old_left_nritems</span><span class="p">;</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">left</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">push_items</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * push some data in the path leaf to the left, trying to free up at</span>
<span class="cm"> * least data_size bytes.  returns zero if the push worked, nonzero otherwise</span>
<span class="cm"> *</span>
<span class="cm"> * max_slot can put a limit on how far into the leaf we&#39;ll push items.  The</span>
<span class="cm"> * item at &#39;max_slot&#39; won&#39;t be touched.  Use (u32)-1 to make us push all the</span>
<span class="cm"> * items</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">push_leaf_left</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span>
			  <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_data_size</span><span class="p">,</span>
			  <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">empty</span><span class="p">,</span> <span class="n">u32</span> <span class="n">max_slot</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">left</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">free_space</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">right_nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">right_nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">right_nritems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">btrfs_assert_tree_locked</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

	<span class="n">left</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">left</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">btrfs_tree_lock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="n">btrfs_set_lock_blocking</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>

	<span class="n">free_space</span> <span class="o">=</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* cow and double check */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cow_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span>
			      <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* we hit -ENOSPC, but it isn&#39;t fatal here */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_space</span> <span class="o">=</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">left</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">free_space</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">__push_leaf_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">min_data_size</span><span class="p">,</span>
			       <span class="n">empty</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">free_space</span><span class="p">,</span> <span class="n">right_nritems</span><span class="p">,</span>
			       <span class="n">max_slot</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">left</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * split the path&#39;s leaf in two, making sure there is at least data_size</span>
<span class="cm"> * available for the resulting leaf level of the path.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">copy_for_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mid</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nritems</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">data_copy_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">rt_data_off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">nritems</span> <span class="o">-</span> <span class="n">mid</span><span class="p">;</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">nritems</span><span class="p">);</span>
	<span class="n">data_copy_size</span> <span class="o">=</span> <span class="n">btrfs_item_end_nr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">-</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
			   <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">mid</span><span class="p">),</span>
			   <span class="n">nritems</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>

	<span class="n">copy_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span>
		     <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">right</span><span class="p">)</span> <span class="o">+</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span>
		     <span class="n">data_copy_size</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="o">+</span>
		     <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">),</span> <span class="n">data_copy_size</span><span class="p">);</span>

	<span class="n">rt_data_off</span> <span class="o">=</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">-</span>
		      <span class="n">btrfs_item_end_nr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">u32</span> <span class="n">ioff</span><span class="p">;</span>

		<span class="n">ioff</span> <span class="o">=</span> <span class="n">btrfs_token_item_offset</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
					    <span class="n">ioff</span> <span class="o">+</span> <span class="n">rt_data_off</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>
	<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">insert_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
		   <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-=</span> <span class="n">mid</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * double splits happen when we need to insert a big item in the middle</span>
<span class="cm"> * of a leaf.  A double split can leave us with 3 mostly empty leaves:</span>
<span class="cm"> * leaf: [ slots 0 - N] [ our target ] [ N + 1 - total in leaf ]</span>
<span class="cm"> *          A                 B                 C</span>
<span class="cm"> *</span>
<span class="cm"> * We avoid this by trying to push the items on either side of our target</span>
<span class="cm"> * into the adjacent leaves.  If all goes well we can avoid the double split</span>
<span class="cm"> * completely.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">push_for_double_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">progress</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="cm">/*</span>
<span class="cm">	 * try to push all the items after our slot into the</span>
<span class="cm">	 * right leaf</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">push_leaf_right</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">progress</span><span class="o">++</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * our goal is to get our slot at the start or end of a leaf.  If</span>
<span class="cm">	 * we&#39;ve done so we&#39;re done</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nritems</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">data_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* try to push all the items before our slot into the next leaf */</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">push_leaf_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">progress</span><span class="o">++</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">progress</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * split the path&#39;s leaf in two, making sure there is at least data_size</span>
<span class="cm"> * available for the resulting leaf level of the path.</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if all went well and &lt; 0 on failure.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">split_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">ins_key</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">data_size</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">extend</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">right</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">split</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_doubles</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">tried_avoid_double</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extend</span> <span class="o">&amp;&amp;</span> <span class="n">data_size</span> <span class="o">+</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">slot</span><span class="p">)</span> <span class="o">+</span>
	    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOVERFLOW</span><span class="p">;</span>

	<span class="cm">/* first try to make some room by pushing left and right */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wret</span> <span class="o">=</span> <span class="n">push_leaf_right</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span>
				       <span class="n">data_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">wret</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">wret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">wret</span> <span class="o">=</span> <span class="n">push_leaf_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span>
					      <span class="n">data_size</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">wret</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="cm">/* did the pushes work? */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">data_size</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">insert_new_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">again:</span>
	<span class="n">split</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">l</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
	<span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span>
		    <span class="n">leaf_space_used</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">-</span> <span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_size</span> <span class="o">&gt;</span>
			<span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">split</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">mid</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">!=</span> <span class="n">nritems</span> <span class="o">&amp;&amp;</span>
				    <span class="n">leaf_space_used</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">-</span> <span class="n">mid</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">data_size</span> <span class="o">&gt;</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tried_avoid_double</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">push_for_double</span><span class="p">;</span>
					<span class="n">split</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leaf_space_used</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mid</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_size</span> <span class="o">&gt;</span>
			<span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">extend</span> <span class="o">&amp;&amp;</span> <span class="n">data_size</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">split</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">((</span><span class="n">extend</span> <span class="o">||</span> <span class="o">!</span><span class="n">data_size</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">mid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">mid</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">!=</span> <span class="n">nritems</span> <span class="o">&amp;&amp;</span>
				    <span class="n">leaf_space_used</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">-</span> <span class="n">mid</span><span class="p">)</span> <span class="o">+</span>
				    <span class="n">data_size</span> <span class="o">&gt;</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">data_size</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">tried_avoid_double</span><span class="p">)</span>
						<span class="k">goto</span> <span class="n">push_for_double</span><span class="p">;</span>
					<span class="n">split</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">split</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">ins_key</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">mid</span><span class="p">);</span>

	<span class="n">right</span> <span class="o">=</span> <span class="n">btrfs_alloc_free_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">right</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>

	<span class="n">root_add_used</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">);</span>

	<span class="n">memset_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span><span class="p">));</span>
	<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">);</span>
	<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_level</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_fsid</span><span class="p">(</span><span class="n">right</span><span class="p">),</span>
			    <span class="n">BTRFS_FSID_SIZE</span><span class="p">);</span>

	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_chunk_tree_uuid</span><span class="p">(</span><span class="n">right</span><span class="p">),</span>
			    <span class="n">BTRFS_UUID_SIZE</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">split</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">mid</span> <span class="o">&lt;=</span> <span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">insert_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				   <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">insert_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">right</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
					  <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">right</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">right</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">copy_for_split</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="n">mid</span><span class="p">,</span> <span class="n">nritems</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">split</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">num_doubles</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">num_doubles</span><span class="o">++</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">push_for_double:</span>
	<span class="n">push_for_double_split</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="n">tried_avoid_double</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">data_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">setup_leaf_for_split</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ins_len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span> <span class="o">&amp;&amp;</span>
	       <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_CSUM_KEY</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">ins_len</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">extent_len</span> <span class="o">=</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_for_split</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">search_for_split</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">;</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="cm">/* if our item isn&#39;t there or got smaller, return now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">item_size</span> <span class="o">!=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="cm">/* the leaf has  changed, it now has room.  return now */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;=</span> <span class="n">ins_len</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extent_len</span> <span class="o">!=</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">split_leaf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ins_len</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">split_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">new_key</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">split_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">new_item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">orig_offset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>

	<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">orig_offset</span> <span class="o">=</span> <span class="n">btrfs_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">);</span>

	<span class="n">buf</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">item_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
			    <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">item_size</span><span class="p">);</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* shift the items */</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
				<span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
				<span class="p">(</span><span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>
	<span class="p">}</span>

	<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">new_key</span><span class="p">);</span>
	<span class="n">btrfs_set_item_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="n">new_item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="n">btrfs_set_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">new_item</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">);</span>
	<span class="n">btrfs_set_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">new_item</span><span class="p">,</span> <span class="n">item_size</span> <span class="o">-</span> <span class="n">split_offset</span><span class="p">);</span>

	<span class="n">btrfs_set_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
			      <span class="n">orig_offset</span> <span class="o">+</span> <span class="n">item_size</span> <span class="o">-</span> <span class="n">split_offset</span><span class="p">);</span>
	<span class="n">btrfs_set_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">split_offset</span><span class="p">);</span>

	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* write the data for the start of the original item */</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
			    <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			    <span class="n">split_offset</span><span class="p">);</span>

	<span class="cm">/* write the data for the new item */</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">split_offset</span><span class="p">,</span>
			    <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">),</span>
			    <span class="n">item_size</span> <span class="o">-</span> <span class="n">split_offset</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function splits a single item into two items,</span>
<span class="cm"> * giving &#39;new_key&#39; to the new item and splitting the</span>
<span class="cm"> * old one at split_offset (from the start of the item).</span>
<span class="cm"> *</span>
<span class="cm"> * The path may be released by this operation.  After</span>
<span class="cm"> * the split, the path is pointing to the old item.  The</span>
<span class="cm"> * new item is going to be in the same node as the old one.</span>
<span class="cm"> *</span>
<span class="cm"> * Note, the item being split must be smaller enough to live alone on</span>
<span class="cm"> * a tree block with room for one extra struct btrfs_item</span>
<span class="cm"> *</span>
<span class="cm"> * This allows us to split the item in place, keeping a lock on the</span>
<span class="cm"> * leaf the entire time.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_split_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">new_key</span><span class="p">,</span>
		     <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">split_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">setup_leaf_for_split</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				   <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">split_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">new_key</span><span class="p">,</span> <span class="n">split_offset</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * This function duplicate a item, giving &#39;new_key&#39; to the new item.</span>
<span class="cm"> * It guarantees both items live in the same tree leaf and the new item</span>
<span class="cm"> * is contiguous with the original item.</span>
<span class="cm"> *</span>
<span class="cm"> * This allows us to split file extent in place, keeping a lock on the</span>
<span class="cm"> * leaf the entire time.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_duplicate_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">new_key</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">item_size</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">item_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">setup_leaf_for_split</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				   <span class="n">item_size</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
	<span class="n">setup_items_for_insert</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">new_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">item_size</span><span class="p">,</span>
			       <span class="n">item_size</span><span class="p">,</span> <span class="n">item_size</span> <span class="o">+</span>
			       <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">),</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">memcpy_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
			     <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>
			     <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span>
			     <span class="n">item_size</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * make the item pointed to by the path smaller.  new_size indicates</span>
<span class="cm"> * how small to make it, and from_end tells us if we just chop bytes</span>
<span class="cm"> * off the end of the item or if we shift the item to chop bytes off</span>
<span class="cm"> * the front.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_truncate_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			 <span class="n">u32</span> <span class="n">new_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">from_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_data_start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_size</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">size_diff</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">old_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">old_size</span> <span class="o">==</span> <span class="n">new_size</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">data_end</span> <span class="o">=</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>

	<span class="n">old_data_start</span> <span class="o">=</span> <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="n">size_diff</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">-</span> <span class="n">new_size</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * item0..itemN ... dataN.offset..dataN.size .. data0.size</span>
<span class="cm">	 */</span>
	<span class="cm">/* first correct the data pointers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ioff</span><span class="p">;</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">ioff</span> <span class="o">=</span> <span class="n">btrfs_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
					    <span class="n">ioff</span> <span class="o">+</span> <span class="n">size_diff</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* shift the data */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">from_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span> <span class="o">+</span> <span class="n">size_diff</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span><span class="p">,</span> <span class="n">old_data_start</span> <span class="o">+</span> <span class="n">new_size</span> <span class="o">-</span> <span class="n">data_end</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">offset</span><span class="p">;</span>

		<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_disk_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>

			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="p">)(</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fi</span> <span class="o">-</span> <span class="n">size_diff</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">==</span>
			    <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ptr</span> <span class="o">=</span> <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
				<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span>
				      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">fi</span><span class="p">,</span>
				      <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">,</span>
						 <span class="n">disk_bytenr</span><span class="p">));</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span> <span class="o">+</span> <span class="n">size_diff</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span><span class="p">,</span> <span class="n">old_data_start</span> <span class="o">-</span> <span class="n">data_end</span><span class="p">);</span>

		<span class="n">offset</span> <span class="o">=</span> <span class="n">btrfs_disk_key_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">);</span>
		<span class="n">btrfs_set_disk_key_offset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">size_diff</span><span class="p">);</span>
		<span class="n">btrfs_set_item_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">btrfs_set_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * make the item pointed to by the path bigger, data_size is the new size.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_extend_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
		       <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
		       <span class="n">u32</span> <span class="n">data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_end</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_data</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">data_end</span> <span class="o">=</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">data_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">old_data</span> <span class="o">=</span> <span class="n">btrfs_item_end_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;slot %d too large, nritems %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">slot</span><span class="p">,</span> <span class="n">nritems</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * item0..itemN ... dataN.offset..dataN.size .. data0.size</span>
<span class="cm">	 */</span>
	<span class="cm">/* first correct the data pointers */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">ioff</span><span class="p">;</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="n">ioff</span> <span class="o">=</span> <span class="n">btrfs_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
					    <span class="n">ioff</span> <span class="o">-</span> <span class="n">data_size</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* shift the data */</span>
	<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
		      <span class="n">data_end</span> <span class="o">-</span> <span class="n">data_size</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
		      <span class="n">data_end</span><span class="p">,</span> <span class="n">old_data</span> <span class="o">-</span> <span class="n">data_end</span><span class="p">);</span>

	<span class="n">data_end</span> <span class="o">=</span> <span class="n">old_data</span><span class="p">;</span>
	<span class="n">old_size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="n">btrfs_set_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">old_size</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a key and some data, insert items into the tree.</span>
<span class="cm"> * This does all the path init required, making room in the tree if needed.</span>
<span class="cm"> * Returns the number of keys that were inserted.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_insert_some_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data_size</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">+</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">)</span> <span class="o">&gt;</span>
		    <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">break</span><span class="p">;</span>
			<span class="n">nr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">total_data</span> <span class="o">+=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">total_size</span> <span class="o">+=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cpu_key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">data_end</span> <span class="o">=</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">total_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">total_data</span> <span class="o">-=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
			<span class="n">total_size</span> <span class="o">-=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">total_size</span> <span class="o">&lt;</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">))</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_data</span> <span class="o">=</span> <span class="n">btrfs_item_end_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="cm">/* figure out how many keys we can insert in here */</span>
		<span class="n">total_data</span> <span class="o">=</span> <span class="n">data_size</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_comp_cpu_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">cpu_key</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">total_data</span> <span class="o">+=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="p">}</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">old_data</span> <span class="o">&lt;</span> <span class="n">data_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;slot %d old_data %d data_end %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">slot</span><span class="p">,</span> <span class="n">old_data</span><span class="p">,</span> <span class="n">data_end</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * item0..itemN ... dataN.offset..dataN.size .. data0.size</span>
<span class="cm">		 */</span>
		<span class="cm">/* first correct the data pointers */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">ioff</span><span class="p">;</span>

			<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ioff</span> <span class="o">=</span> <span class="n">btrfs_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
			<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
						    <span class="n">ioff</span> <span class="o">-</span> <span class="n">total_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* shift the items */</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="n">nr</span><span class="p">),</span>
			      <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			      <span class="p">(</span><span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>

		<span class="cm">/* shift the data */</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span> <span class="o">-</span> <span class="n">total_data</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span><span class="p">,</span> <span class="n">old_data</span> <span class="o">-</span> <span class="n">data_end</span><span class="p">);</span>
		<span class="n">data_end</span> <span class="o">=</span> <span class="n">old_data</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * this sucks but it has to be done, if we are inserting at</span>
<span class="cm">		 * the end of the leaf only insert 1 of the items, since we</span>
<span class="cm">		 * have no way of knowing whats on the next leaf and we&#39;d have</span>
<span class="cm">		 * to drop our current locks to figure it out</span>
<span class="cm">		 */</span>
		<span class="n">nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup the item for the new data */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">cpu_key</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">btrfs_set_item_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
					    <span class="n">data_end</span> <span class="o">-</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">data_end</span> <span class="o">-=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">btrfs_set_token_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">+</span> <span class="n">nr</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">cpu_key</span><span class="p">);</span>
		<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">nr</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is a helper for btrfs_insert_empty_items, the main goal here is</span>
<span class="cm"> * to save stack depth by doing the bulk of the work in a function</span>
<span class="cm"> * that doesn&#39;t call btrfs_search_slot</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">setup_items_for_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data_size</span><span class="p">,</span>
			    <span class="n">u32</span> <span class="n">total_data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">total_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">data_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">data_end</span> <span class="o">=</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">total_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;not enough freespace need %u have %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">total_size</span><span class="p">,</span> <span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">));</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">old_data</span> <span class="o">=</span> <span class="n">btrfs_item_end_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">old_data</span> <span class="o">&lt;</span> <span class="n">data_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;slot %d old_data %d data_end %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">slot</span><span class="p">,</span> <span class="n">old_data</span><span class="p">,</span> <span class="n">data_end</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 * item0..itemN ... dataN.offset..dataN.size .. data0.size</span>
<span class="cm">		 */</span>
		<span class="cm">/* first correct the data pointers */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">ioff</span><span class="p">;</span>

			<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ioff</span> <span class="o">=</span> <span class="n">btrfs_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
			<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
						    <span class="n">ioff</span> <span class="o">-</span> <span class="n">total_data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="cm">/* shift the items */</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="n">nr</span><span class="p">),</span>
			      <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			      <span class="p">(</span><span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span><span class="p">)</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>

		<span class="cm">/* shift the data */</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span> <span class="o">-</span> <span class="n">total_data</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span><span class="p">,</span> <span class="n">old_data</span> <span class="o">-</span> <span class="n">data_end</span><span class="p">);</span>
		<span class="n">data_end</span> <span class="o">=</span> <span class="n">old_data</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* setup the item for the new data */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">cpu_key</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">btrfs_set_item_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
					    <span class="n">data_end</span> <span class="o">-</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="n">data_end</span> <span class="o">-=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">btrfs_set_token_item_size</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">+</span> <span class="n">nr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">cpu_key</span><span class="p">);</span>
		<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_leaf_free_space</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_print_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="n">BUG</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a key and some data, insert items into the tree.</span>
<span class="cm"> * This does all the path init required, making room in the tree if needed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_insert_empty_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">,</span> <span class="n">u32</span> <span class="o">*</span><span class="n">data_size</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">total_data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">total_data</span> <span class="o">+=</span> <span class="n">data_size</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

	<span class="n">total_size</span> <span class="o">=</span> <span class="n">total_data</span> <span class="o">+</span> <span class="p">(</span><span class="n">nr</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">cpu_key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">setup_items_for_insert</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">cpu_key</span><span class="p">,</span> <span class="n">data_size</span><span class="p">,</span>
			       <span class="n">total_data</span><span class="p">,</span> <span class="n">total_size</span><span class="p">,</span> <span class="n">nr</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Given a key and some data, insert an item into the tree.</span>
<span class="cm"> * This does all the path init required, making room in the tree if needed.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_insert_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span>
		      <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">cpu_key</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">u32</span>
		      <span class="n">data_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ptr</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">cpu_key</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">data_size</span><span class="p">);</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * delete the pointer from a given node.</span>
<span class="cm"> *</span>
<span class="cm"> * the tree should have been previously balanced so the deletion does not</span>
<span class="cm"> * empty a node.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">del_ptr</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span>
		    <span class="kt">int</span> <span class="n">tree_mod_log</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="n">nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_log</span> <span class="o">&amp;&amp;</span> <span class="n">level</span><span class="p">)</span>
			<span class="n">tree_mod_log_eb_move</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
					     <span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span>
			      <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			      <span class="n">btrfs_node_key_ptr_offset</span><span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">)</span> <span class="o">*</span>
			      <span class="p">(</span><span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">tree_mod_log</span> <span class="o">&amp;&amp;</span> <span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">tree_mod_log_insert_key</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
					      <span class="n">MOD_LOG_KEY_REMOVE</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">nritems</span><span class="o">--</span><span class="p">;</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">nritems</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">parent</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">);</span>
		<span class="cm">/* just turn the root into a leaf and break */</span>
		<span class="n">btrfs_set_header_level</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>

		<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * a helper function to delete the leaf pointed to by path-&gt;slots[1] and</span>
<span class="cm"> * path-&gt;nodes[1].</span>
<span class="cm"> *</span>
<span class="cm"> * This deletes the pointer in path-&gt;nodes[1] and frees the leaf</span>
<span class="cm"> * block extent.  zero is returned if it all worked out, &lt; 0 otherwise.</span>
<span class="cm"> *</span>
<span class="cm"> * The path must have already been setup for deleting the leaf, including</span>
<span class="cm"> * all the proper balancing.  path-&gt;nodes[1] must be locked.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">void</span> <span class="nf">btrfs_del_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">!=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">del_ptr</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * btrfs_free_extent is expensive, we want to make sure we</span>
<span class="cm">	 * aren&#39;t holding any locks when we call it</span>
<span class="cm">	 */</span>
	<span class="n">btrfs_unlock_up_safe</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">root_sub_used</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>

	<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">btrfs_free_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">free_extent_buffer_stale</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*</span>
<span class="cm"> * delete the item at the leaf level in path.  If that empties</span>
<span class="cm"> * the leaf, remove it from the tree</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_del_items</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		    <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="o">*</span><span class="n">item</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">last_off</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">dsize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">wret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_map_token</span> <span class="n">token</span><span class="p">;</span>

	<span class="n">btrfs_init_map_token</span><span class="p">(</span><span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">last_off</span> <span class="o">=</span> <span class="n">btrfs_item_offset_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">nr</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">dsize</span> <span class="o">+=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="n">nr</span> <span class="o">!=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">data_end</span> <span class="o">=</span> <span class="n">leaf_data_end</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>

		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span>
			      <span class="n">data_end</span> <span class="o">+</span> <span class="n">dsize</span><span class="p">,</span>
			      <span class="n">btrfs_leaf_data</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">+</span> <span class="n">data_end</span><span class="p">,</span>
			      <span class="n">last_off</span> <span class="o">-</span> <span class="n">data_end</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slot</span> <span class="o">+</span> <span class="n">nr</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u32</span> <span class="n">ioff</span><span class="p">;</span>

			<span class="n">item</span> <span class="o">=</span> <span class="n">btrfs_item_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
			<span class="n">ioff</span> <span class="o">=</span> <span class="n">btrfs_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
			<span class="n">btrfs_set_token_item_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">item</span><span class="p">,</span>
						    <span class="n">ioff</span> <span class="o">+</span> <span class="n">dsize</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">token</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">memmove_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span><span class="p">),</span>
			      <span class="n">btrfs_item_nr_offset</span><span class="p">(</span><span class="n">slot</span> <span class="o">+</span> <span class="n">nr</span><span class="p">),</span>
			      <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">)</span> <span class="o">*</span>
			      <span class="p">(</span><span class="n">nritems</span> <span class="o">-</span> <span class="n">slot</span> <span class="o">-</span> <span class="n">nr</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="n">btrfs_set_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">-</span> <span class="n">nr</span><span class="p">);</span>
	<span class="n">nritems</span> <span class="o">-=</span> <span class="n">nr</span><span class="p">;</span>

	<span class="cm">/* delete the leaf if we&#39;ve emptied it */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">leaf</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_set_header_level</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">clean_tree_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
			<span class="n">btrfs_del_leaf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">used</span> <span class="o">=</span> <span class="n">leaf_space_used</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">nritems</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>

			<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">fixup_low_keys</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="cm">/* delete the leaf if it is mostly empty */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">used</span> <span class="o">&lt;</span> <span class="n">BTRFS_LEAF_DATA_SIZE</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="o">/</span> <span class="mi">3</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/* push_leaf_left fixes the path.</span>
<span class="cm">			 * make sure the path still points to our leaf</span>
<span class="cm">			 * for possible call to del_ptr below</span>
<span class="cm">			 */</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
			<span class="n">extent_buffer_get</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

			<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">wret</span> <span class="o">=</span> <span class="n">push_leaf_left</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					      <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">leaf</span> <span class="o">&amp;&amp;</span>
			    <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">wret</span> <span class="o">=</span> <span class="n">push_leaf_right</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
						       <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">wret</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">wret</span> <span class="o">!=</span> <span class="o">-</span><span class="n">ENOSPC</span><span class="p">)</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">wret</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
				<span class="n">btrfs_del_leaf</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">leaf</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="cm">/* if we&#39;re still in the path, make sure</span>
<span class="cm">				 * we&#39;re dirty.  Otherwise, one of the</span>
<span class="cm">				 * push_leaf functions must have already</span>
<span class="cm">				 * dirtied this buffer</span>
<span class="cm">				 */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">leaf</span><span class="p">)</span>
					<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search the tree again to find a leaf with lesser keys</span>
<span class="cm"> * returns 0 if it found something or 1 if there are no lesser leaves.</span>
<span class="cm"> * returns &lt; 0 on io errors.</span>
<span class="cm"> *</span>
<span class="cm"> * This may release the path, and so you may lose any locks held at the</span>
<span class="cm"> * time you call it.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_prev_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="o">--</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span><span class="o">--</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="o">--</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">btrfs_item_key</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">comp_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * A helper function to walk down the tree starting at min_key, and looking</span>
<span class="cm"> * for nodes or leaves that are either in cache or have a minimum</span>
<span class="cm"> * transaction id.  This is used by the btree defrag code, and tree logging</span>
<span class="cm"> *</span>
<span class="cm"> * This does not cow, but it does stuff the starting key it finds back</span>
<span class="cm"> * into min_key, so you can call btrfs_search_slot with cow=1 on the</span>
<span class="cm"> * key and get a writable path.</span>
<span class="cm"> *</span>
<span class="cm"> * This does lock as it descends, and path-&gt;keep_locks should be set</span>
<span class="cm"> * to 1 by the caller.</span>
<span class="cm"> *</span>
<span class="cm"> * This honors path-&gt;lowest_level to prevent descent past a given level</span>
<span class="cm"> * of the tree.</span>
<span class="cm"> *</span>
<span class="cm"> * min_trans indicates the oldest transaction that you are interested</span>
<span class="cm"> * in walking through.  Any nodes or leaves older than min_trans are</span>
<span class="cm"> * skipped over (without reading them).</span>
<span class="cm"> *</span>
<span class="cm"> * returns zero if something useful was found, &lt; 0 on error and 1 if there</span>
<span class="cm"> * was nothing in the tree that matched the search criteria.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_search_forward</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">min_key</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">max_key</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cache_only</span><span class="p">,</span>
			 <span class="n">u64</span> <span class="n">min_trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sret</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">cur</span> <span class="o">=</span> <span class="n">btrfs_read_lock_root_node</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">cur</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">min_trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
		<span class="n">level</span> <span class="o">=</span> <span class="n">btrfs_header_level</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
		<span class="n">sret</span> <span class="o">=</span> <span class="n">bin_search</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">min_key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="p">);</span>

		<span class="cm">/* at the lowest level, we&#39;re done, setup the path and exit */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">find_next_key</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sret</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">slot</span><span class="o">--</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * check this node pointer against the cache_only and</span>
<span class="cm">		 * min_trans parameters.  If it isn&#39;t in cache or is too</span>
<span class="cm">		 * old, skip to the next one.</span>
<span class="cm">		 */</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">blockptr</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">gen</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>

			<span class="n">blockptr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="n">gen</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gen</span> <span class="o">&lt;</span> <span class="n">min_trans</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cache_only</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">max_key</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_node_key</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">comp_keys</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="n">max_key</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="n">tmp</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">blockptr</span><span class="p">,</span>
					    <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span> <span class="o">&amp;&amp;</span> <span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="p">)</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
			<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
<span class="nl">find_next_key:</span>
		<span class="cm">/*</span>
<span class="cm">		 * we didn&#39;t find a candidate key in this node, walk forward</span>
<span class="cm">		 * and find another one</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
			<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">sret</span> <span class="o">=</span> <span class="n">btrfs_find_next_key</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">min_key</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
						  <span class="n">cache_only</span><span class="p">,</span> <span class="n">min_trans</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="cm">/* save our key for returning back */</span>
		<span class="n">btrfs_node_key_to_cpu</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">unlock_up</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">read_node_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">cur</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">cur</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

		<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>

		<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="n">unlock_up</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">min_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">found_key</span><span class="p">));</span>
	<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is similar to btrfs_next_leaf, but does not try to preserve</span>
<span class="cm"> * and fixup the path.  It looks for and returns the next key in the</span>
<span class="cm"> * tree based on the current path and the cache_only and min_trans</span>
<span class="cm"> * parameters.</span>
<span class="cm"> *</span>
<span class="cm"> * 0 is returned if another key is found, &lt; 0 if there are any errors</span>
<span class="cm"> * and 1 is returned if there are no higher keys in the tree</span>
<span class="cm"> *</span>
<span class="cm"> * path-&gt;keep_locks should be set to 1 on the search made before</span>
<span class="cm"> * calling this function.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_find_next_key</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">cache_only</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_trans</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
<span class="nl">next:</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">orig_lowest</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">cur_key</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&gt;=</span> <span class="n">BTRFS_MAX_LEVEL</span> <span class="o">||</span>
			    <span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">level</span><span class="o">++</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">slot</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">btrfs_node_key_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

			<span class="n">orig_lowest</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span><span class="p">;</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span> <span class="o">=</span> <span class="n">level</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cur_key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">lowest_level</span> <span class="o">=</span> <span class="n">orig_lowest</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
			<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">blockptr</span> <span class="o">=</span> <span class="n">btrfs_node_blockptr</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="n">u64</span> <span class="n">gen</span> <span class="o">=</span> <span class="n">btrfs_node_ptr_generation</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">cache_only</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
				<span class="n">cur</span> <span class="o">=</span> <span class="n">btrfs_find_tree_block</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">blockptr</span><span class="p">,</span>
					    <span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">level</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">cur</span> <span class="o">||</span>
				    <span class="n">btrfs_buffer_uptodate</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">cur</span><span class="p">)</span>
						<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">gen</span> <span class="o">&lt;</span> <span class="n">min_trans</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">slot</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">btrfs_node_key_to_cpu</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search the tree again to find a leaf with greater keys</span>
<span class="cm"> * returns 0 if it found something or 1 if there are no greater leaves.</span>
<span class="cm"> * returns &lt; 0 on io errors.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_next_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">btrfs_next_old_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_next_old_leaf</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			<span class="n">u64</span> <span class="n">time_seq</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">level</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">c</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">old_spinning</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">next_rw_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">level</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">next_rw_lock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">time_seq</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_old_slot</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">time_seq</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="cm">/*</span>
<span class="cm">	 * by releasing the path above we dropped all our locks.  A balance</span>
<span class="cm">	 * could have added more items next to the key that used to be</span>
<span class="cm">	 * at the very end of the block.  So, check again here and</span>
<span class="cm">	 * advance the path if there are now more items available.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">nritems</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">c</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">level</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">level</span> <span class="o">==</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">next</span><span class="p">,</span> <span class="n">next_rw_lock</span><span class="p">);</span>
			<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">next</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">next_rw_lock</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">read_block_for_search</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
					    <span class="n">slot</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_try_tree_read_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
				<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
							  <span class="n">BTRFS_READ_LOCK</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">next_rw_lock</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">level</span><span class="o">--</span><span class="p">;</span>
		<span class="n">c</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">])</span>
			<span class="n">btrfs_tree_unlock_rw</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]);</span>

		<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span><span class="p">)</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">locks</span><span class="p">[</span><span class="n">level</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_rw_lock</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">level</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">read_block_for_search</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next</span><span class="p">,</span> <span class="n">level</span><span class="p">,</span>
					    <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">done</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">skip_locking</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_try_tree_read_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="n">btrfs_tree_read_lock</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
				<span class="n">btrfs_clear_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
							  <span class="n">BTRFS_READ_LOCK</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">next_rw_lock</span> <span class="o">=</span> <span class="n">BTRFS_READ_LOCK</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">done:</span>
	<span class="n">unlock_up</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="n">old_spinning</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">old_spinning</span><span class="p">)</span>
		<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this uses btrfs_prev_leaf to walk backwards in the tree, and keeps</span>
<span class="cm"> * searching until it gets past min_objectid or finds an item of &#39;type&#39;</span>
<span class="cm"> *</span>
<span class="cm"> * returns 0 if something is found, 1 if nothing was found and &lt; 0 on error</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_previous_item</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">u64</span> <span class="n">min_objectid</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">found_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_set_path_blocking</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_prev_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nritems</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">nritems</span><span class="p">)</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>

		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">found_key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">min_objectid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">found_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">min_objectid</span> <span class="o">&amp;&amp;</span>
		    <span class="n">found_key</span><span class="p">.</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">type</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
