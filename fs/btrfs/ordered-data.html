<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › ordered-data.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ordered-data.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/pagevec.h&gt;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;btrfs_inode.h&quot;</span>
<span class="cp">#include &quot;extent_io.h&quot;</span>

<span class="k">static</span> <span class="n">u64</span> <span class="nf">entry_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* returns NULL if the insertion worked, or it returns the node it did find</span>
<span class="cm"> * in the tree</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="nf">tree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">file_offset</span> <span class="o">&gt;=</span> <span class="n">entry_end</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rb_link_node</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">ordered_data_tree_panic</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="kt">int</span> <span class="n">errno</span><span class="p">,</span>
					       <span class="n">u64</span> <span class="n">offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">btrfs_sb</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">);</span>
	<span class="n">btrfs_panic</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">errno</span><span class="p">,</span> <span class="s">&quot;Inconsistency in ordered tree at offset &quot;</span>
		    <span class="s">&quot;%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * look for a given offset in the tree, and if it can&#39;t be found return the</span>
<span class="cm"> * first lesser offset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="nf">__tree_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">prev_ret</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">test</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">prev_entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
		<span class="n">prev_entry</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">)</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">file_offset</span> <span class="o">&gt;=</span> <span class="n">entry_end</span><span class="p">(</span><span class="n">entry</span><span class="p">))</span>
			<span class="n">n</span> <span class="o">=</span> <span class="n">n</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">n</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">prev_ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">file_offset</span> <span class="o">&gt;=</span> <span class="n">entry_end</span><span class="p">(</span><span class="n">prev_entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">test</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prev_entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span>
				      <span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">entry_end</span><span class="p">(</span><span class="n">prev_entry</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">prev</span> <span class="o">=</span> <span class="n">test</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
		<span class="n">prev_entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span>
				      <span class="n">rb_node</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">prev</span> <span class="o">&amp;&amp;</span> <span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">entry_end</span><span class="p">(</span><span class="n">prev_entry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">test</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">prev_entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span>
				      <span class="n">rb_node</span><span class="p">);</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">test</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="o">*</span><span class="n">prev_ret</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to check if a given offset is inside a given entry</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">offset_in_entry</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">||</span>
	    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">file_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">range_overlaps</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
			  <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">||</span>
	    <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">file_offset</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * look find the first ordered struct that has this offset, otherwise</span>
<span class="cm"> * the first one less than this offset</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="nf">tree_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">file_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span>
				 <span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">offset_in_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">tree</span><span class="o">-&gt;</span><span class="n">last</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">__tree_search</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">prev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">tree</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* allocate and add a new ordered_extent into the per-inode tree.</span>
<span class="cm"> * file_offset is the logical offset in the file</span>
<span class="cm"> *</span>
<span class="cm"> * start is the disk block number of an extent already reserved in the</span>
<span class="cm"> * extent allocation tree</span>
<span class="cm"> *</span>
<span class="cm"> * len is the length of the extent</span>
<span class="cm"> *</span>
<span class="cm"> * The tree is given a single reference on the ordered extent that was</span>
<span class="cm"> * inserted.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">__btrfs_add_ordered_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">disk_len</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">compress_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">entry</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">entry</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">=</span> <span class="n">file_offset</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">disk_len</span> <span class="o">=</span> <span class="n">disk_len</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">compress_type</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_ORDERED_IO_DONE</span> <span class="o">&amp;&amp;</span> <span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_ORDERED_COMPLETE</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">type</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dio</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_DIRECT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="cm">/* one ref for the tree */</span>
	<span class="n">atomic_set</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">init_waitqueue_head</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">root_extent_list</span><span class="p">);</span>

	<span class="n">trace_btrfs_ordered_extent_add</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">tree_insert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span>
			   <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span>
		<span class="n">ordered_data_tree_panic</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">root_extent_list</span><span class="p">,</span>
		      <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extents</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_add_ordered_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
			     <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">disk_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_add_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					  <span class="n">disk_len</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_add_ordered_extent_dio</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
				 <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">disk_len</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_add_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					  <span class="n">disk_len</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					  <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_add_ordered_extent_compress</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
				      <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">,</span> <span class="n">u64</span> <span class="n">disk_len</span><span class="p">,</span>
				      <span class="kt">int</span> <span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="n">compress_type</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__btrfs_add_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span>
					  <span class="n">disk_len</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					  <span class="n">compress_type</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Add a struct btrfs_ordered_sum into the list of checksums to be inserted</span>
<span class="cm"> * when an ordered extent is finished.  If the list covers more than one</span>
<span class="cm"> * ordered extent, it is split across multiples.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_add_ordered_sum</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_ordered_sum</span> <span class="o">*</span><span class="n">sum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is used to account for finished IO across a given range</span>
<span class="cm"> * of the file.  The IO may span ordered extents.  If</span>
<span class="cm"> * a given ordered_extent is completely done, 1 is returned, otherwise</span>
<span class="cm"> * 0.</span>
<span class="cm"> *</span>
<span class="cm"> * test_and_set_bit on a flag in the struct btrfs_ordered_extent is used</span>
<span class="cm"> * to make sure this function only returns 1 once for a given ordered extent.</span>
<span class="cm"> *</span>
<span class="cm"> * file_offset is updated to one byte past the range that is recorded as</span>
<span class="cm"> * complete.  This allows you to walk forward in the file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_dec_test_first_ordered_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">**</span><span class="n">cached</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="o">*</span><span class="n">file_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">io_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dec_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dec_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">to_dec</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="o">*</span><span class="n">file_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset_in_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="o">*</span><span class="n">file_offset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dec_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="o">*</span><span class="n">file_offset</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">);</span>
	<span class="n">dec_end</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">io_size</span><span class="p">,</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span>
		      <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="o">*</span><span class="n">file_offset</span> <span class="o">=</span> <span class="n">dec_end</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dec_start</span> <span class="o">&gt;</span> <span class="n">dec_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;bad ordering dec_start %llu end %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dec_start</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dec_end</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">to_dec</span> <span class="o">=</span> <span class="n">dec_end</span> <span class="o">-</span> <span class="n">dec_start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">to_dec</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;bad ordered accounting left %llu size %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">to_dec</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">to_dec</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uptodate</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_IOERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_IO_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">cached</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cached</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is used to account for finished IO across a given range</span>
<span class="cm"> * of the file.  The IO should not span ordered extents.  If</span>
<span class="cm"> * a given ordered_extent is completely done, 1 is returned, otherwise</span>
<span class="cm"> * 0.</span>
<span class="cm"> *</span>
<span class="cm"> * test_and_set_bit on a flag in the struct btrfs_ordered_extent is used</span>
<span class="cm"> * to make sure this function only returns 1 once for a given ordered extent.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_dec_test_ordered_pending</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">**</span><span class="n">cached</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">io_size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">spin_lock_irqsave</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">cached</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cached</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="o">*</span><span class="n">cached</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">have_entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">node</span> <span class="o">=</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
<span class="nl">have_entry:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset_in_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">io_size</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_CRIT</span> <span class="s">&quot;bad ordered accounting left %llu size %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">io_size</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">io_size</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uptodate</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_IOERR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">test_and_set_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_IO_DONE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">cached</span> <span class="o">&amp;&amp;</span> <span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">cached</span> <span class="o">=</span> <span class="n">entry</span><span class="p">;</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock_irqrestore</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * used to drop a reference on an ordered extent.  This will free</span>
<span class="cm"> * the extent if the last reference is dropped</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_put_ordered_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_sum</span> <span class="o">*</span><span class="n">sum</span><span class="p">;</span>

	<span class="n">trace_btrfs_ordered_extent_put</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_dec_and_test</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">)</span>
			<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">cur</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
			<span class="n">sum</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_sum</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
			<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sum</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">sum</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">entry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * remove an ordered extent from the tree.  No references are dropped</span>
<span class="cm"> * and waiters are woken up.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_remove_ordered_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="n">rb_erase</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">);</span>
	<span class="n">tree</span><span class="o">-&gt;</span><span class="n">last</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_COMPLETE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">root_extent_list</span><span class="p">);</span>

	<span class="n">trace_btrfs_ordered_extent_remove</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we have no more ordered extents for this inode and</span>
<span class="cm">	 * no dirty pages.  We can safely remove it from the</span>
<span class="cm">	 * list of ordered extents</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">RB_EMPTY_ROOT</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">mapping_tagged</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">PAGECACHE_TAG_DIRTY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * wait for all the ordered extents in a root.  This is done when balancing</span>
<span class="cm"> * space between drives.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_wait_ordered_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				<span class="kt">int</span> <span class="n">nocow_only</span><span class="p">,</span> <span class="kt">int</span> <span class="n">delay_iput</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">splice</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splice</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extents</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">splice</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splice</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">splice</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">cur</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span>
				     <span class="n">root_extent_list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nocow_only</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_NOCOW</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">root_extent_list</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extents</span><span class="p">);</span>
			<span class="n">cond_resched_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">root_extent_list</span><span class="p">);</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * the inode may be getting freed (in sys_unlink path).</span>
<span class="cm">		 */</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">inode</span><span class="p">);</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_start_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">delay_iput</span><span class="p">)</span>
				<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is used during transaction commit to write all the inodes</span>
<span class="cm"> * added to the ordered operation list.  These files must be fully on</span>
<span class="cm"> * disk before the transaction commits.</span>
<span class="cm"> *</span>
<span class="cm"> * we have two modes here, one is to just start the IO via filemap_flush</span>
<span class="cm"> * and the other is to wait for all the io.  When we wait, we have an</span>
<span class="cm"> * extra check to make sure the ordered operation list really is empty</span>
<span class="cm"> * before we return</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_run_ordered_operations</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">btrfs_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">splice</span><span class="p">;</span>

	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splice</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_operations_mutex</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
<span class="nl">again:</span>
	<span class="n">list_splice_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">splice</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">splice</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_inode</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">splice</span><span class="p">.</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode</span><span class="p">,</span>
				   <span class="n">ordered_operations</span><span class="p">);</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_inode</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>

		<span class="n">list_del_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfs_inode</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * the inode may be getting freed (in sys_unlink path).</span>
<span class="cm">		 */</span>
		<span class="n">inode</span> <span class="o">=</span> <span class="n">igrab</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span>
				<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">filemap_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
			<span class="n">btrfs_add_delayed_iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">cond_resched</span><span class="p">();</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>

	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_operations_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used to start IO or wait for a given ordered extent to finish.</span>
<span class="cm"> *</span>
<span class="cm"> * If wait is one, this effectively waits on page writeback for all the pages</span>
<span class="cm"> * in the extent, and it waits on the io completion code to insert</span>
<span class="cm"> * metadata into the btree corresponding to the extent</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_start_ordered_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span><span class="p">,</span>
				       <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">trace_btrfs_ordered_extent_start</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * pages in the range can be dirty, clean or writeback.  We</span>
<span class="cm">	 * start IO on any dirty ones so the wait doesn&#39;t stall waiting</span>
<span class="cm">	 * for pdflush to find them</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_DIRECT</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
		<span class="n">filemap_fdatawrite_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">wait</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">wait_event</span><span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">wait</span><span class="p">,</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_COMPLETE</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Used to wait on ordered extents across a large range of bytes.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_wait_ordered_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">orig_end</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">found</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">orig_end</span> <span class="o">=</span> <span class="n">INT_LIMIT</span><span class="p">(</span><span class="n">loff_t</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">orig_end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">orig_end</span> <span class="o">&gt;</span> <span class="n">INT_LIMIT</span><span class="p">(</span><span class="n">loff_t</span><span class="p">))</span>
			<span class="n">orig_end</span> <span class="o">=</span> <span class="n">INT_LIMIT</span><span class="p">(</span><span class="n">loff_t</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* start IO across the range first to instantiate any delalloc</span>
<span class="cm">	 * extents</span>
<span class="cm">	 */</span>
	<span class="n">filemap_fdatawrite_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">orig_end</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * So with compression we will find and lock a dirty page and clear the</span>
<span class="cm">	 * first one as dirty, setup an async extent, and immediately return</span>
<span class="cm">	 * with the entire range locked but with nobody actually marked with</span>
<span class="cm">	 * writeback.  So we can&#39;t just filemap_write_and_wait_range() and</span>
<span class="cm">	 * expect it to work since it will just kick off a thread to do the</span>
<span class="cm">	 * actual work.  So we need to call filemap_fdatawrite_range _again_</span>
<span class="cm">	 * since it will wait on the page lock, which won&#39;t be unlocked until</span>
<span class="cm">	 * after the pages have been marked as writeback and so we&#39;re good to go</span>
<span class="cm">	 * from there.  We have to do this otherwise we&#39;ll miss the ordered</span>
<span class="cm">	 * extents and that results in badness.  Please Josef, do not think you</span>
<span class="cm">	 * know better and pull this out at some point in the future, it is</span>
<span class="cm">	 * right and you are wrong.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_HAS_ASYNC_EXTENT</span><span class="p">,</span>
		     <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="n">filemap_fdatawrite_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">orig_end</span><span class="p">);</span>

	<span class="n">filemap_fdatawait_range</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">orig_end</span><span class="p">);</span>

	<span class="n">end</span> <span class="o">=</span> <span class="n">orig_end</span><span class="p">;</span>
	<span class="n">found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ordered</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">&gt;</span> <span class="n">orig_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">found</span><span class="o">++</span><span class="p">;</span>
		<span class="n">btrfs_start_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">;</span>
		<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">end</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">end</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * find an ordered extent corresponding to file_offset.  return NULL if</span>
<span class="cm"> * nothing is found, otherwise take a reference on the extent and return it</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="nf">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
							 <span class="n">u64</span> <span class="n">file_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">offset_in_entry</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">))</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Since the DIO code tries to lock a wide area we need to look for any ordered</span>
<span class="cm"> * extents that exist in the range, rather than just the start of the range.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="nf">btrfs_lookup_ordered_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
							<span class="n">u64</span> <span class="n">file_offset</span><span class="p">,</span>
							<span class="n">u64</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">file_offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range_overlaps</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">,</span> <span class="n">len</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">&gt;=</span> <span class="n">file_offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">)</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * lookup and return any extent before &#39;file_offset&#39;.  NULL is returned</span>
<span class="cm"> * if none is found</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span>
<span class="nf">btrfs_lookup_first_ordered_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">file_offset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">node</span> <span class="o">=</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">file_offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">refs</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * After an extent is done, call this to conditionally update the on disk</span>
<span class="cm"> * i_size.  i_size is updated to cover any fully written part of the file.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span>
				<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">disk_i_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_i_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i_size_test</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">i_size</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">test</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">entry_end</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">disk_i_size</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span><span class="p">;</span>

	<span class="cm">/* truncate file */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk_i_size</span> <span class="o">&gt;</span> <span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the disk i_size is already at the inode-&gt;i_size, or</span>
<span class="cm">	 * this ordered extent is inside the disk i_size, we&#39;re done</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">disk_i_size</span> <span class="o">==</span> <span class="n">i_size</span> <span class="o">||</span> <span class="n">offset</span> <span class="o">&lt;=</span> <span class="n">disk_i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * walk backward from this ordered extent to disk_i_size.</span>
<span class="cm">	 * if we find an ordered extent then we can&#39;t update disk i_size</span>
<span class="cm">	 * yet</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">prev</span> <span class="o">=</span> <span class="n">tree_search</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * we insert file extents without involving ordered struct,</span>
<span class="cm">		 * so there should be no ordered struct cover this offset</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">test</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span>
					<span class="n">rb_node</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">offset_in_entry</span><span class="p">(</span><span class="n">test</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">node</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">rb_prev</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">test</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="cm">/* We treat this entry as if it doesnt exist */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_UPDATED_ISIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">test</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&lt;=</span> <span class="n">disk_i_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">&gt;=</span> <span class="n">i_size</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">&gt;=</span> <span class="n">disk_i_size</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">new_i_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">i_size</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * at this point, we know we can safely update i_size to at least</span>
<span class="cm">	 * the offset from this ordered extent.  But, we need to</span>
<span class="cm">	 * walk forward and see if ios from higher up in the file have</span>
<span class="cm">	 * finished.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">prev</span><span class="p">)</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">prev</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">node</span> <span class="o">=</span> <span class="n">rb_first</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">tree</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * We are looking for an area between our current extent and the next</span>
<span class="cm">	 * ordered extent to update the i_size to.  There are 3 cases here</span>
<span class="cm">	 *</span>
<span class="cm">	 * 1) We don&#39;t actually have anything and we can update to i_size.</span>
<span class="cm">	 * 2) We have stuff but they already did their i_size update so again we</span>
<span class="cm">	 * can just update to i_size.</span>
<span class="cm">	 * 3) We have an outstanding ordered extent so the most we can update</span>
<span class="cm">	 * our disk_i_size to is the start of the next offset.</span>
<span class="cm">	 */</span>
	<span class="n">i_size_test</span> <span class="o">=</span> <span class="n">i_size</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="n">node</span><span class="p">;</span> <span class="n">node</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">node</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">test</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_ordered_extent</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_UPDATED_ISIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">test</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i_size_test</span> <span class="o">=</span> <span class="n">test</span><span class="o">-&gt;</span><span class="n">file_offset</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * i_size_test is the end of a region after this ordered</span>
<span class="cm">	 * extent where there are no ordered extents, we can safely set</span>
<span class="cm">	 * disk_i_size to this.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i_size_test</span> <span class="o">&gt;</span> <span class="n">offset</span><span class="p">)</span>
		<span class="n">new_i_size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">i_size_test</span><span class="p">,</span> <span class="n">i_size</span><span class="p">);</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span> <span class="o">=</span> <span class="n">new_i_size</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * We need to do this because we can&#39;t remove ordered extents until</span>
<span class="cm">	 * after the i_disk_size has been updated and then the inode has been</span>
<span class="cm">	 * updated to reflect the change, so we need to tell anybody who finds</span>
<span class="cm">	 * this ordered extent that we&#39;ve already done all the real work, we</span>
<span class="cm">	 * just haven&#39;t completed all the other work.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span>
		<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_ORDERED_UPDATED_ISIZE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * search the ordered extents for one corresponding to &#39;offset&#39; and</span>
<span class="cm"> * try to find a checksum.  This is used because we allow pages to</span>
<span class="cm"> * be reclaimed before their checksum is actually put into the btree</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_find_ordered_sum</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">disk_bytenr</span><span class="p">,</span>
			   <span class="n">u32</span> <span class="o">*</span><span class="n">sum</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_sum</span> <span class="o">*</span><span class="n">ordered_sum</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_sector_sum</span> <span class="o">*</span><span class="n">sector_sums</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_inode_tree</span> <span class="o">*</span><span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_tree</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">num_sectors</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">sectorsize</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ordered</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">spin_lock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">list_for_each_entry_reverse</span><span class="p">(</span><span class="n">ordered_sum</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ordered</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">disk_bytenr</span> <span class="o">&gt;=</span> <span class="n">ordered_sum</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_sectors</span> <span class="o">=</span> <span class="n">ordered_sum</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">/</span> <span class="n">sectorsize</span><span class="p">;</span>
			<span class="n">sector_sums</span> <span class="o">=</span> <span class="n">ordered_sum</span><span class="o">-&gt;</span><span class="n">sums</span><span class="p">;</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_sectors</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sector_sums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bytenr</span> <span class="o">==</span> <span class="n">disk_bytenr</span><span class="p">)</span> <span class="p">{</span>
					<span class="o">*</span><span class="n">sum</span> <span class="o">=</span> <span class="n">sector_sums</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">sum</span><span class="p">;</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">spin_unlock_irq</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>


<span class="cm">/*</span>
<span class="cm"> * add a given inode to the list of inodes that must be fully on</span>
<span class="cm"> * disk before a transaction commit finishes.</span>
<span class="cm"> *</span>
<span class="cm"> * This basically gives us the ext3 style data=ordered mode, and it is mostly</span>
<span class="cm"> * used to make sure renamed files are fully on disk.</span>
<span class="cm"> *</span>
<span class="cm"> * It is a noop if the inode is already fully on disk.</span>
<span class="cm"> *</span>
<span class="cm"> * If trans is not null, we&#39;ll do a friendly check for a transaction that</span>
<span class="cm"> * is already flushing things and force the IO down ourselves.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_add_ordered_operation</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">last_mod</span><span class="p">;</span>

	<span class="n">last_mod</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">,</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_trans</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * if this file hasn&#39;t been changed since the last transaction</span>
<span class="cm">	 * commit, we can safely return without doing anything</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">last_mod</span> <span class="o">&lt;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">last_trans_committed</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * the transaction is already committing.  Just start the IO and</span>
<span class="cm">	 * don&#39;t bother with all of this list nonsense</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span> <span class="o">&amp;&amp;</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">running_transaction</span><span class="o">-&gt;</span><span class="n">blocked</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_operations</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">ordered_extent_lock</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
