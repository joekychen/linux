<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › ioctl.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>ioctl.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/bio.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/file.h&gt;</span>
<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/fsnotify.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/namei.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/statfs.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/bit_spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/security.h&gt;</span>
<span class="cp">#include &lt;linux/xattr.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &quot;compat.h&quot;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;btrfs_inode.h&quot;</span>
<span class="cp">#include &quot;ioctl.h&quot;</span>
<span class="cp">#include &quot;print-tree.h&quot;</span>
<span class="cp">#include &quot;volumes.h&quot;</span>
<span class="cp">#include &quot;locking.h&quot;</span>
<span class="cp">#include &quot;inode-map.h&quot;</span>
<span class="cp">#include &quot;backref.h&quot;</span>
<span class="cp">#include &quot;rcu-string.h&quot;</span>

<span class="cm">/* Mask out flags that are inappropriate for the given type of inode. */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="n">__u32</span> <span class="nf">btrfs_mask_flags</span><span class="p">(</span><span class="n">umode_t</span> <span class="n">mode</span><span class="p">,</span> <span class="n">__u32</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISREG</span><span class="p">(</span><span class="n">mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FS_DIRSYNC_FL</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FS_NODUMP_FL</span> <span class="o">|</span> <span class="n">FS_NOATIME_FL</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Export inode flags to the format expected by the FS_IOC_GETFLAGS ioctl.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">btrfs_flags_to_ioctl</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iflags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_SYNC</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_SYNC_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_IMMUTABLE</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_IMMUTABLE_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_APPEND</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_APPEND_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODUMP</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_NODUMP_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NOATIME</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_NOATIME_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_DIRSYNC</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_DIRSYNC_FL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_NOCOW_FL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">))</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_COMPR_FL</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">)</span>
		<span class="n">iflags</span> <span class="o">|=</span> <span class="n">FS_NOCOMP_FL</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">iflags</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Update inode-&gt;i_flags based on the btrfs internal flags.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_update_iflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">S_SYNC</span><span class="o">|</span><span class="n">S_APPEND</span><span class="o">|</span><span class="n">S_IMMUTABLE</span><span class="o">|</span><span class="n">S_NOATIME</span><span class="o">|</span><span class="n">S_DIRSYNC</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_SYNC</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_IMMUTABLE</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_IMMUTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_APPEND</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_APPEND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NOATIME</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_NOATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_DIRSYNC</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DIRSYNC</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Inherit flags from the parent inode.</span>
<span class="cm"> *</span>
<span class="cm"> * Currently only the compression flags and the cow flags are inherited.</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_inherit_iflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dir</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_COMPRESS</span><span class="p">;</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">;</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">)</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">;</span>

	<span class="n">btrfs_update_iflags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_getflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_flags_to_ioctl</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_flags</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">(</span><span class="n">FS_IMMUTABLE_FL</span> <span class="o">|</span> <span class="n">FS_APPEND_FL</span> <span class="o">|</span> \
		      <span class="n">FS_NOATIME_FL</span> <span class="o">|</span> <span class="n">FS_NODUMP_FL</span> <span class="o">|</span> \
		      <span class="n">FS_SYNC_FL</span> <span class="o">|</span> <span class="n">FS_DIRSYNC_FL</span> <span class="o">|</span> \
		      <span class="n">FS_NOCOMP_FL</span> <span class="o">|</span> <span class="n">FS_COMPR_FL</span> <span class="o">|</span>
		      <span class="n">FS_NOCOW_FL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_NOCOMP_FL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_COMPR_FL</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_setflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="n">oldflags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ip_oldflags</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i_oldflags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">check_flags</span><span class="p">(</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode_owner_or_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">ip_oldflags</span> <span class="o">=</span> <span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">i_oldflags</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span><span class="p">;</span>

	<span class="n">flags</span> <span class="o">=</span> <span class="n">btrfs_mask_flags</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">,</span> <span class="n">flags</span><span class="p">);</span>
	<span class="n">oldflags</span> <span class="o">=</span> <span class="n">btrfs_flags_to_ioctl</span><span class="p">(</span><span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">flags</span> <span class="o">^</span> <span class="n">oldflags</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">FS_APPEND_FL</span> <span class="o">|</span> <span class="n">FS_IMMUTABLE_FL</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_LINUX_IMMUTABLE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mnt_want_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_SYNC_FL</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_SYNC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_SYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_IMMUTABLE_FL</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_IMMUTABLE</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_IMMUTABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_APPEND_FL</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_APPEND</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_APPEND</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_NODUMP_FL</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NODUMP</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_NODUMP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_NOATIME_FL</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NOATIME</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_NOATIME</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_DIRSYNC_FL</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_DIRSYNC</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_DIRSYNC</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_NOCOW_FL</span><span class="p">)</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NODATACOW</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_NODATACOW</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * The COMPRESS flag can only be changed by users, while the NOCOMPRESS</span>
<span class="cm">	 * flag may be changed automatically if compression code won&#39;t make</span>
<span class="cm">	 * things smaller.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_NOCOMP_FL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_COMPRESS</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">FS_COMPR_FL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_INODE_COMPRESS</span><span class="p">;</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="n">BTRFS_INODE_COMPRESS</span> <span class="o">|</span> <span class="n">BTRFS_INODE_NOCOMPRESS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_drop</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_update_iflags</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>

	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
 <span class="nl">out_drop:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ip</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">ip_oldflags</span><span class="p">;</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">=</span> <span class="n">i_oldflags</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mnt_drop_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
 <span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_getversion</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">put_user</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_generation</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_fitrim</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">btrfs_sb</span><span class="p">(</span><span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">request_queue</span> <span class="o">*</span><span class="n">q</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">fstrim_range</span> <span class="n">range</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">minlen</span> <span class="o">=</span> <span class="n">ULLONG_MAX</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_devices</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">total_bytes</span> <span class="o">=</span> <span class="n">btrfs_super_total_bytes</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">rcu_read_lock</span><span class="p">();</span>
	<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span>
				<span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">q</span> <span class="o">=</span> <span class="n">bdev_get_queue</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">blk_queue_discard</span><span class="p">(</span><span class="n">q</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">num_devices</span><span class="o">++</span><span class="p">;</span>
			<span class="n">minlen</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">q</span><span class="o">-&gt;</span><span class="n">limits</span><span class="p">.</span><span class="n">discard_granularity</span><span class="p">,</span>
				     <span class="n">minlen</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">rcu_read_unlock</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_devices</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">range</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">total_bytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">range</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">total_bytes</span> <span class="o">-</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
	<span class="n">range</span><span class="p">.</span><span class="n">minlen</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">range</span><span class="p">.</span><span class="n">minlen</span><span class="p">,</span> <span class="n">minlen</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_trim_fs</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">range</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">create_subvol</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
				  <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
				  <span class="n">u64</span> <span class="o">*</span><span class="n">async_transid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root_item</span> <span class="n">root_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_item</span> <span class="o">*</span><span class="n">inode_item</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">new_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_dirid</span> <span class="o">=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_find_free_objectid</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">objectid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">dir</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * 1 - inode item</span>
<span class="cm">	 * 2 - refs</span>
<span class="cm">	 * 1 - root item</span>
<span class="cm">	 * 2 - dir items</span>
<span class="cm">	 */</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">btrfs_alloc_free_block</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">,</span>
				      <span class="mi">0</span><span class="p">,</span> <span class="n">objectid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memset_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span><span class="p">));</span>
	<span class="n">btrfs_set_header_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_set_header_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_header_backref_rev</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">BTRFS_MIXED_BACKREF_REV</span><span class="p">);</span>
	<span class="n">btrfs_set_header_owner</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">objectid</span><span class="p">);</span>

	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_fsid</span><span class="p">(</span><span class="n">leaf</span><span class="p">),</span>
			    <span class="n">BTRFS_FSID_SIZE</span><span class="p">);</span>
	<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">chunk_tree_uuid</span><span class="p">,</span>
			    <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">btrfs_header_chunk_tree_uuid</span><span class="p">(</span><span class="n">leaf</span><span class="p">),</span>
			    <span class="n">BTRFS_UUID_SIZE</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="n">inode_item</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root_item</span><span class="p">.</span><span class="n">inode</span><span class="p">;</span>
	<span class="n">memset</span><span class="p">(</span><span class="n">inode_item</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">inode_item</span><span class="p">));</span>
	<span class="n">inode_item</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">inode_item</span><span class="o">-&gt;</span><span class="n">size</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
	<span class="n">inode_item</span><span class="o">-&gt;</span><span class="n">nlink</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="n">inode_item</span><span class="o">-&gt;</span><span class="n">nbytes</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">);</span>
	<span class="n">inode_item</span><span class="o">-&gt;</span><span class="n">mode</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">S_IFDIR</span> <span class="o">|</span> <span class="mo">0755</span><span class="p">);</span>

	<span class="n">root_item</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">root_item</span><span class="p">.</span><span class="n">byte_limit</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">inode_item</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">BTRFS_INODE_ROOT_ITEM_INIT</span><span class="p">);</span>

	<span class="n">btrfs_set_root_bytenr</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">);</span>
	<span class="n">btrfs_set_root_generation</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">);</span>
	<span class="n">btrfs_set_root_level</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="n">btrfs_set_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">btrfs_set_root_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span> <span class="n">leaf</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">btrfs_set_root_last_snapshot</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">.</span><span class="n">drop_progress</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">root_item</span><span class="p">.</span><span class="n">drop_progress</span><span class="p">));</span>
	<span class="n">root_item</span><span class="p">.</span><span class="n">drop_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">btrfs_tree_unlock</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">free_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="n">leaf</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">btrfs_set_root_dirid</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span> <span class="n">new_dirid</span><span class="p">);</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">root_item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">new_root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">));</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_record_root_in_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">new_root</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_create_subvol_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">new_root</span><span class="p">,</span> <span class="n">new_dirid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* We potentially lose an unused inode item here */</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * insert the directory item</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_set_inode_index</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_dir_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
				    <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span>
				    <span class="n">BTRFS_FT_DIR</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">+</span> <span class="n">namelen</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_add_root_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
				 <span class="n">objectid</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				 <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">dir</span><span class="p">),</span> <span class="n">index</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">btrfs_lookup_dentry</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">));</span>
<span class="nl">fail:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">async_transid</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">async_transid</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction_async</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">create_snapshot</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span>
			   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">async_transid</span><span class="p">,</span>
			   <span class="n">bool</span> <span class="n">readonly</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_pending_snapshot</span> <span class="o">*</span><span class="n">pending_snapshot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">ref_cows</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">pending_snapshot</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">pending_snapshot</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pending_snapshot</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">btrfs_init_block_rsv</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending_snapshot</span><span class="o">-&gt;</span><span class="n">block_rsv</span><span class="p">);</span>
	<span class="n">pending_snapshot</span><span class="o">-&gt;</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">dentry</span><span class="p">;</span>
	<span class="n">pending_snapshot</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">pending_snapshot</span><span class="o">-&gt;</span><span class="n">readonly</span> <span class="o">=</span> <span class="n">readonly</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_snap_reserve_metadata</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">pending_snapshot</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_lock</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">pending_snapshot</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span>
		 <span class="o">&amp;</span><span class="n">trans</span><span class="o">-&gt;</span><span class="n">transaction</span><span class="o">-&gt;</span><span class="n">pending_snapshots</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">trans_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">async_transid</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">async_transid</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction_async</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
				     <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
					       <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">pending_snapshot</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_orphan_cleanup</span><span class="p">(</span><span class="n">pending_snapshot</span><span class="o">-&gt;</span><span class="n">snap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_lookup_dentry</span><span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">d_instantiate</span><span class="p">(</span><span class="n">dentry</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pending_snapshot</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*  copy of check_sticky in fs/namei.c()</span>
<span class="cm">* It&#39;s inline, so penalty for filesystems that don&#39;t use sticky bit is</span>
<span class="cm">* minimal.</span>
<span class="cm">*/</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">btrfs_check_sticky</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">uid_t</span> <span class="n">fsuid</span> <span class="o">=</span> <span class="n">current_fsuid</span><span class="p">();</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_ISVTX</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">==</span> <span class="n">fsuid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_uid</span> <span class="o">==</span> <span class="n">fsuid</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_FOWNER</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*  copy of may_delete in fs/namei.c()</span>
<span class="cm"> *	Check whether we can remove a link victim from directory dir, check</span>
<span class="cm"> *  whether the type of victim is right.</span>
<span class="cm"> *  1. We can&#39;t do it if dir is read-only (done in permission())</span>
<span class="cm"> *  2. We should have write and exec permissions on dir</span>
<span class="cm"> *  3. We can&#39;t remove anything from append-only dir</span>
<span class="cm"> *  4. We can&#39;t do anything with immutable dir (done in permission())</span>
<span class="cm"> *  5. If the sticky bit on dir is set we should either</span>
<span class="cm"> *	a. be owner of dir, or</span>
<span class="cm"> *	b. be owner of victim, or</span>
<span class="cm"> *	c. have CAP_FOWNER capability</span>
<span class="cm"> *  6. If the victim is append-only or immutable we can&#39;t do antyhing with</span>
<span class="cm"> *     links pointing to it.</span>
<span class="cm"> *  7. If we were asked to remove a directory and victim isn&#39;t one - ENOTDIR.</span>
<span class="cm"> *  8. If we were asked to remove a non-directory and victim isn&#39;t one - EISDIR.</span>
<span class="cm"> *  9. We can&#39;t remove a root or mountpoint.</span>
<span class="cm"> * 10. We don&#39;t allow removal of NFS sillyrenamed files; it&#39;s handled by</span>
<span class="cm"> *     nfs_async_unlink().</span>
<span class="cm"> */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_may_delete</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">victim</span><span class="p">,</span><span class="kt">int</span> <span class="n">isdir</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_parent</span><span class="o">-&gt;</span><span class="n">d_inode</span> <span class="o">!=</span> <span class="n">dir</span><span class="p">);</span>
	<span class="n">audit_inode_child</span><span class="p">(</span><span class="n">victim</span><span class="p">,</span> <span class="n">dir</span><span class="p">);</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_APPEND</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_check_sticky</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">||</span>
		<span class="n">IS_APPEND</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">||</span>
	    <span class="n">IS_IMMUTABLE</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="o">||</span> <span class="n">IS_SWAPFILE</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">isdir</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOTDIR</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ROOT</span><span class="p">(</span><span class="n">victim</span><span class="p">))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DEADDIR</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">victim</span><span class="o">-&gt;</span><span class="n">d_flags</span> <span class="o">&amp;</span> <span class="n">DCACHE_NFSFS_RENAMED</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EBUSY</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* copy of may_create in fs/namei.c() */</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">btrfs_may_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">child</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">child</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_DEADDIR</span><span class="p">(</span><span class="n">dir</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Create a new subvolume below @parent.  This is largely modeled after</span>
<span class="cm"> * sys_mkdirat and vfs_mkdir, but we only do a single component lookup</span>
<span class="cm"> * inside this filesystem so it&#39;s quite a bit simpler.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_mksubvol</span><span class="p">(</span><span class="k">struct</span> <span class="n">path</span> <span class="o">*</span><span class="n">parent</span><span class="p">,</span>
				   <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span> <span class="kt">int</span> <span class="n">namelen</span><span class="p">,</span>
				   <span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">snap_src</span><span class="p">,</span>
				   <span class="n">u64</span> <span class="o">*</span><span class="n">async_transid</span><span class="p">,</span> <span class="n">bool</span> <span class="n">readonly</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span>  <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>

	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">dentry</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="n">error</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">btrfs_may_create</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up_read</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">snap_src</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">create_snapshot</span><span class="p">(</span><span class="n">snap_src</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span>
					<span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">async_transid</span><span class="p">,</span> <span class="n">readonly</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">create_subvol</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span>
				      <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span> <span class="n">async_transid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span>
		<span class="n">fsnotify_mkdir</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
<span class="nl">out_up_read:</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>
<span class="nl">out_drop_write:</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">mnt</span><span class="p">);</span>
<span class="nl">out_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * When we&#39;re defragging a range, we don&#39;t want to kick it off again</span>
<span class="cm"> * if it is really just waiting for delalloc to send it down.</span>
<span class="cm"> * If we find a nice big extent or delalloc range for the bytes in the</span>
<span class="cm"> * file you want to defrag, we return 0 to let you know to skip this</span>
<span class="cm"> * part of the file</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">check_defrag_in_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end</span><span class="p">;</span>

	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">em</span> <span class="o">=</span> <span class="n">lookup_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">end</span> <span class="o">=</span> <span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">offset</span> <span class="o">&gt;</span> <span class="n">thresh</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/* if we already have a nice delalloc here, just stop */</span>
	<span class="n">thresh</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">end</span> <span class="o">=</span> <span class="n">count_range_bits</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">thresh</span><span class="p">,</span>
			       <span class="n">thresh</span><span class="p">,</span> <span class="n">EXTENT_DELALLOC</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper function to walk through a file and find extents</span>
<span class="cm"> * newer than a specific transid, and smaller than thresh.</span>
<span class="cm"> *</span>
<span class="cm"> * This is used by the defragging code to find new and small</span>
<span class="cm"> * extents</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_new_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">newer_than</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="o">*</span><span class="n">off</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thresh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">min_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">max_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">extent</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">min_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">min_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
	<span class="n">min_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="o">*</span><span class="n">off</span><span class="p">;</span>

	<span class="n">max_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">max_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">max_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_forward</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">min_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_key</span><span class="p">,</span>
					   <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">newer_than</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">none</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">min_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">ino</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">none</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">min_key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">none</span><span class="p">;</span>

		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">extent</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>

		<span class="n">type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">&amp;&amp;</span>
		    <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">thresh</span> <span class="o">&amp;&amp;</span>
		    <span class="n">check_defrag_in_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">min_key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">thresh</span><span class="p">))</span> <span class="p">{</span>
			<span class="o">*</span><span class="n">off</span> <span class="o">=</span> <span class="n">min_key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">min_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">none</span><span class="p">;</span>

		<span class="n">min_key</span><span class="p">.</span><span class="n">offset</span><span class="o">++</span><span class="p">;</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">none:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="nf">defrag_lookup_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">io_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span> <span class="o">=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * hopefully we have this extent in the tree already, try without</span>
<span class="cm">	 * the full extent lock</span>
<span class="cm">	 */</span>
	<span class="n">read_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
	<span class="n">em</span> <span class="o">=</span> <span class="n">lookup_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="n">read_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* get the big lock and read metadata off disk */</span>
		<span class="n">lock_extent</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">unlock_extent</span><span class="p">(</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">))</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">em</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">bool</span> <span class="nf">defrag_check_next_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">ret</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/* this is the last extent */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">next</span> <span class="o">=</span> <span class="n">defrag_lookup_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">next</span> <span class="o">||</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">EXTENT_MAP_LAST_BYTE</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">free_extent_map</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">should_defrag_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="kt">int</span> <span class="n">thresh</span><span class="p">,</span>
			       <span class="n">u64</span> <span class="o">*</span><span class="n">last_len</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">skip</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">defrag_end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">next_mergeable</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * make sure that once we start defragging an extent, we keep on</span>
<span class="cm">	 * defragging it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;</span> <span class="o">*</span><span class="n">defrag_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="o">*</span><span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">em</span> <span class="o">=</span> <span class="n">defrag_lookup_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* this will cover holes, and inline extents */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&gt;=</span> <span class="n">EXTENT_MAP_LAST_BYTE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">next_mergeable</span> <span class="o">=</span> <span class="n">defrag_check_next_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we hit a real extent, if it is big or the next extent is not a</span>
<span class="cm">	 * real extent, don&#39;t bother defragging it</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">last_len</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">||</span> <span class="o">*</span><span class="n">last_len</span> <span class="o">&gt;=</span> <span class="n">thresh</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">thresh</span> <span class="o">||</span> <span class="o">!</span><span class="n">next_mergeable</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="cm">/*</span>
<span class="cm">	 * last_len ends up being a counter of how many bytes we&#39;ve defragged.</span>
<span class="cm">	 * every time we choose not to defrag an extent, we reset *last_len</span>
<span class="cm">	 * so that the next tiny extent will force a defrag.</span>
<span class="cm">	 *</span>
<span class="cm">	 * The end result of this is that tiny extents before a single big</span>
<span class="cm">	 * extent will force at least part of that big extent to be defragged.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">defrag_end</span> <span class="o">=</span> <span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">last_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="o">*</span><span class="n">skip</span> <span class="o">=</span> <span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="o">*</span><span class="n">defrag_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * it doesn&#39;t do much good to defrag one or two pages</span>
<span class="cm"> * at a time.  This pulls in a nice chunk of pages</span>
<span class="cm"> * to COW and defrag.</span>
<span class="cm"> *</span>
<span class="cm"> * It also makes sure the delalloc code has enough</span>
<span class="cm"> * dirty data to avoid making new small extents as part</span>
<span class="cm"> * of the defrag</span>
<span class="cm"> *</span>
<span class="cm"> * It&#39;s a good idea to start RA on this range</span>
<span class="cm"> * before calling this.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">cluster_pages_for_defrag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">start_index</span><span class="p">,</span>
				    <span class="kt">int</span> <span class="n">num_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">file_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">page_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">page_cnt</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i_done</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_io_tree</span> <span class="o">*</span><span class="n">tree</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">btrfs_alloc_write_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="n">file_end</span> <span class="o">=</span> <span class="p">(</span><span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isize</span> <span class="o">||</span> <span class="n">start_index</span> <span class="o">&gt;</span> <span class="n">file_end</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">page_cnt</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">num_pages</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">file_end</span> <span class="o">-</span> <span class="n">start_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delalloc_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					   <span class="n">page_cnt</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">i_done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">;</span>

	<span class="cm">/* step one, lock all the pages */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">page_cnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">;</span>
<span class="nl">again:</span>
		<span class="n">page</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
					   <span class="n">start_index</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">mask</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">page</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">page_start</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="n">page_end</span> <span class="o">=</span> <span class="n">page_start</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lock_extent</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">);</span>
			<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
							      <span class="n">page_start</span><span class="p">);</span>
			<span class="n">unlock_extent</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ordered</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">btrfs_start_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">ordered</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * we unlocked the page above, so we need check if</span>
<span class="cm">			 * it was released or not.</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">btrfs_readpage</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
			<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">page</span><span class="o">-&gt;</span><span class="n">mapping</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">page</span><span class="p">;</span>
		<span class="n">i_done</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">i_done</span> <span class="o">||</span> <span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_ACTIVE</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * so now we have a nice long stream of locked</span>
<span class="cm">	 * and up to date pages, lets wait on them</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_done</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="n">page_start</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">page_end</span> <span class="o">=</span> <span class="n">page_offset</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i_done</span> <span class="o">-</span> <span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>

	<span class="n">lock_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
			 <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
	<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span>
			  <span class="n">page_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">EXTENT_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span>
			  <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span>
			  <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i_done</span> <span class="o">!=</span> <span class="n">page_cnt</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">++</span><span class="p">;</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
				     <span class="p">(</span><span class="n">page_cnt</span> <span class="o">-</span> <span class="n">i_done</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="p">}</span>


	<span class="n">btrfs_set_extent_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				  <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>

	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
			     <span class="n">page_start</span><span class="p">,</span> <span class="n">page_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span>
			     <span class="n">GFP_NOFS</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_done</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">set_page_extent_mapped</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">i_done</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">i_done</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">page_cnt</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_defrag_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">btrfs_ioctl_defrag_range_args</span> <span class="o">*</span><span class="n">range</span><span class="p">,</span>
		      <span class="n">u64</span> <span class="n">newer_than</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">max_to_defrag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">disk_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file_ra_state</span> <span class="o">*</span><span class="n">ra</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">last_index</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">defrag_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">newer_off</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ra_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">defrag_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compress_type</span> <span class="o">=</span> <span class="n">BTRFS_COMPRESS_ZLIB</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extent_thresh</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">extent_thresh</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max_cluster</span> <span class="o">=</span> <span class="p">(</span><span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">cluster</span> <span class="o">=</span> <span class="n">max_cluster</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">new_align</span> <span class="o">=</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="mi">128</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">extent_thresh</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">extent_thresh</span> <span class="o">=</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_DEFRAG_RANGE_COMPRESS</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">&gt;</span> <span class="n">BTRFS_COMPRESS_TYPES</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">)</span>
			<span class="n">compress_type</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">isize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * if we were not given a file, allocate a readahead</span>
<span class="cm">	 * context</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ra</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ra</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ra</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="n">file_ra_state_init</span><span class="p">(</span><span class="n">ra</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ra</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_ra</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">pages</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">max_cluster</span><span class="p">,</span>
			<span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_ra</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* find the last page to defrag */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">last_index</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			 <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">last_index</span> <span class="o">=</span> <span class="p">(</span><span class="n">isize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">newer_than</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_new_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">newer_than</span><span class="p">,</span>
				       <span class="o">&amp;</span><span class="n">newer_off</span><span class="p">,</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">newer_off</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * we always align our defrag to help keep</span>
<span class="cm">			 * the extents in the file evenly spaced</span>
<span class="cm">			 */</span>
			<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">newer_off</span> <span class="o">&amp;</span> <span class="n">new_align</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span>
			<span class="k">goto</span> <span class="n">out_ra</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max_to_defrag</span><span class="p">)</span>
		<span class="n">max_to_defrag</span> <span class="o">=</span> <span class="n">last_index</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * make writeback starts from i, so the defrag range can be</span>
<span class="cm">	 * written sequentially.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span><span class="p">)</span>
		<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">writeback_index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;=</span> <span class="n">last_index</span> <span class="o">&amp;&amp;</span> <span class="n">defrag_count</span> <span class="o">&lt;</span> <span class="n">max_to_defrag</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		<span class="n">PAGE_CACHE_SHIFT</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * make sure we stop running if someone unmounts</span>
<span class="cm">		 * the FS</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_ACTIVE</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">should_defrag_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
					 <span class="n">extent_thresh</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">last_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">skip</span><span class="p">,</span>
					 <span class="o">&amp;</span><span class="n">defrag_end</span><span class="p">))</span> <span class="p">{</span>
			<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">next</span><span class="p">;</span>
			<span class="cm">/*</span>
<span class="cm">			 * the should_defrag function tells us how much to skip</span>
<span class="cm">			 * bump our counter by the suggested amount</span>
<span class="cm">			 */</span>
			<span class="n">next</span> <span class="o">=</span> <span class="p">(</span><span class="n">skip</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
			<span class="n">i</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">newer_than</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">cluster</span> <span class="o">=</span> <span class="p">(</span><span class="n">PAGE_CACHE_ALIGN</span><span class="p">(</span><span class="n">defrag_end</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				   <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">-</span> <span class="n">i</span><span class="p">;</span>
			<span class="n">cluster</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">cluster</span><span class="p">,</span> <span class="n">max_cluster</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">cluster</span> <span class="o">=</span> <span class="n">max_cluster</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_DEFRAG_RANGE_COMPRESS</span><span class="p">)</span>
			<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">force_compress</span> <span class="o">=</span> <span class="n">compress_type</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="n">cluster</span> <span class="o">&gt;</span> <span class="n">ra_index</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ra_index</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">ra_index</span><span class="p">);</span>
			<span class="n">btrfs_force_ra</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">ra_index</span><span class="p">,</span>
				       <span class="n">cluster</span><span class="p">);</span>
			<span class="n">ra_index</span> <span class="o">+=</span> <span class="n">max_cluster</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">cluster_pages_for_defrag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">cluster</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_ra</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">defrag_count</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">balance_dirty_pages_ratelimited_nr</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">newer_than</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">newer_off</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">i</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>

			<span class="n">newer_off</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">newer_off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
					<span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">find_new_extents</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
					       <span class="n">newer_than</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newer_off</span><span class="p">,</span>
					       <span class="mi">64</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">range</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">newer_off</span><span class="p">;</span>
				<span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">newer_off</span> <span class="o">&amp;</span> <span class="n">new_align</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">i</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
				<span class="n">last_len</span> <span class="o">+=</span> <span class="n">ret</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">i</span><span class="o">++</span><span class="p">;</span>
				<span class="n">last_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_DEFRAG_RANGE_START_IO</span><span class="p">))</span>
		<span class="n">filemap_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_DEFRAG_RANGE_COMPRESS</span><span class="p">))</span> <span class="p">{</span>
		<span class="cm">/* the filemap_flush will queue IO into the worker threads, but</span>
<span class="cm">		 * we have to make sure the IO is actually started and that</span>
<span class="cm">		 * ordered extents get created before we return</span>
<span class="cm">		 */</span>
		<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_draining</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">nr_async_submits</span><span class="p">)</span> <span class="o">||</span>
		      <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">wait_event</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_wait</span><span class="p">,</span>
			   <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">nr_async_submits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
			    <span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_delalloc_pages</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">));</span>
		<span class="p">}</span>
		<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">async_submit_draining</span><span class="p">);</span>

		<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">force_compress</span> <span class="o">=</span> <span class="n">BTRFS_COMPRESS_NONE</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">disk_super</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">;</span>
	<span class="n">features</span> <span class="o">=</span> <span class="n">btrfs_super_incompat_flags</span><span class="p">(</span><span class="n">disk_super</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">==</span> <span class="n">BTRFS_COMPRESS_LZO</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">features</span> <span class="o">|=</span> <span class="n">BTRFS_FEATURE_INCOMPAT_COMPRESS_LZO</span><span class="p">;</span>
		<span class="n">btrfs_set_super_incompat_flags</span><span class="p">(</span><span class="n">disk_super</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">defrag_count</span><span class="p">;</span>

<span class="nl">out_ra:</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">ra</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_resize</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">old_size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">devid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_vol_args</span> <span class="o">*</span><span class="n">vol_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">sizestr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">devstr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mod</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: balance in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol_args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vol_args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">BTRFS_PATH_NAME_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">sizestr</span> <span class="o">=</span> <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
	<span class="n">devstr</span> <span class="o">=</span> <span class="n">strchr</span><span class="p">(</span><span class="n">sizestr</span><span class="p">,</span> <span class="sc">&#39;:&#39;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">devstr</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
		<span class="n">sizestr</span> <span class="o">=</span> <span class="n">devstr</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="o">*</span><span class="n">devstr</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="n">devstr</span> <span class="o">=</span> <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span>
		<span class="n">devid</span> <span class="o">=</span> <span class="n">simple_strtoull</span><span class="p">(</span><span class="n">devstr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">end</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: resizing devid %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">devid</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">device</span> <span class="o">=</span> <span class="n">btrfs_find_device</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">devid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: resizer unable to find device %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">devid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">fs_devices</span> <span class="o">&amp;&amp;</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">seeding</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: resizer unable to apply on &quot;</span>
		       <span class="s">&quot;seeding device %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">devid</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strcmp</span><span class="p">(</span><span class="n">sizestr</span><span class="p">,</span> <span class="s">&quot;max&quot;</span><span class="p">))</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">;</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">sizestr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mod</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">sizestr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sizestr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;+&#39;</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mod</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">sizestr</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="n">memparse</span><span class="p">(</span><span class="n">sizestr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">old_size</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">old_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">-</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">mod</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">new_size</span> <span class="o">=</span> <span class="n">old_size</span> <span class="o">+</span> <span class="n">new_size</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;</span> <span class="mi">256</span> <span class="o">*</span> <span class="mi">1024</span> <span class="o">*</span> <span class="mi">1024</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFBIG</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">do_div</span><span class="p">(</span><span class="n">new_size</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="n">new_size</span> <span class="o">*=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>

	<span class="n">printk_in_rcu</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: new size for %s is %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		      <span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span>
		      <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">new_size</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&gt;</span> <span class="n">old_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_free</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_grow_device</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
		<span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">new_size</span> <span class="o">&lt;</span> <span class="n">old_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_shrink_device</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">new_size</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out_free:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_snap_create_transid</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
						    <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">,</span>
						    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">fd</span><span class="p">,</span>
						    <span class="kt">int</span> <span class="n">subvol</span><span class="p">,</span>
						    <span class="n">u64</span> <span class="o">*</span><span class="n">transid</span><span class="p">,</span>
						    <span class="n">bool</span> <span class="n">readonly</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">src_file</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">namelen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">&amp;&amp;</span>
	   <span class="p">(</span><span class="n">namelen</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">||</span> <span class="p">(</span><span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;.&#39;</span> <span class="o">&amp;&amp;</span> <span class="n">namelen</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">subvol</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_mksubvol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
				     <span class="nb">NULL</span><span class="p">,</span> <span class="n">transid</span><span class="p">,</span> <span class="n">readonly</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">src_inode</span><span class="p">;</span>
		<span class="n">src_file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_file</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">src_inode</span> <span class="o">=</span> <span class="n">src_file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">src_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: Snapshot src from &quot;</span>
			       <span class="s">&quot;another FS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="n">fput</span><span class="p">(</span><span class="n">src_file</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_mksubvol</span><span class="p">(</span><span class="o">&amp;</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">namelen</span><span class="p">,</span>
				     <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">src_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span>
				     <span class="n">transid</span><span class="p">,</span> <span class="n">readonly</span><span class="p">);</span>
		<span class="n">fput</span><span class="p">(</span><span class="n">src_file</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_snap_create</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					    <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subvol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_vol_args</span> <span class="o">*</span><span class="n">vol_args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">vol_args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vol_args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
	<span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">BTRFS_PATH_NAME_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_ioctl_snap_create_transid</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					      <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">subvol</span><span class="p">,</span>
					      <span class="nb">NULL</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_snap_create_v2</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					       <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">subvol</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_vol_args_v2</span> <span class="o">*</span><span class="n">vol_args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">readonly</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">vol_args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vol_args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
	<span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">BTRFS_SUBVOL_NAME_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span>
	    <span class="o">~</span><span class="p">(</span><span class="n">BTRFS_SUBVOL_CREATE_ASYNC</span> <span class="o">|</span> <span class="n">BTRFS_SUBVOL_RDONLY</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_SUBVOL_CREATE_ASYNC</span><span class="p">)</span>
		<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">transid</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_SUBVOL_RDONLY</span><span class="p">)</span>
		<span class="n">readonly</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_ioctl_snap_create_transid</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					      <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">fd</span><span class="p">,</span> <span class="n">subvol</span><span class="p">,</span>
					      <span class="n">ptr</span><span class="p">,</span> <span class="n">readonly</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ptr</span> <span class="o">&amp;&amp;</span>
	    <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span> <span class="o">+</span>
			 <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ioctl_vol_args_v2</span><span class="p">,</span>
				  <span class="n">transid</span><span class="p">),</span> <span class="n">ptr</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_subvol_getflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
						<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_SUBVOL_RDONLY</span><span class="p">;</span>
	<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flags</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_subvol_setflags</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					      <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">root_flags</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">flags</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">flags</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_SUBVOL_CREATE_ASYNC</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BTRFS_SUBVOL_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode_owner_or_capable</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EACCES</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>

	<span class="cm">/* nothing to do */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!!</span><span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_SUBVOL_RDONLY</span><span class="p">)</span> <span class="o">==</span> <span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">root_flags</span> <span class="o">=</span> <span class="n">btrfs_root_flags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_SUBVOL_RDONLY</span><span class="p">)</span>
		<span class="n">btrfs_set_root_flags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">,</span>
				     <span class="n">root_flags</span> <span class="o">|</span> <span class="n">BTRFS_ROOT_SUBVOL_RDONLY</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">btrfs_set_root_flags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">,</span>
				     <span class="n">root_flags</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">BTRFS_ROOT_SUBVOL_RDONLY</span><span class="p">);</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_reset</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_root</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">);</span>

	<span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
<span class="nl">out_reset:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">btrfs_set_root_flags</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">,</span> <span class="n">root_flags</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * helper to check if the subvolume references other subvolumes</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">may_destroy_subvol</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_REF_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&amp;&amp;</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_ROOT_REF_KEY</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTEMPTY</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">key_in_sk</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfs_ioctl_search_key</span> <span class="o">*</span><span class="n">sk</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">test</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">test</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">min_objectid</span><span class="p">;</span>
	<span class="n">test</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">min_type</span><span class="p">;</span>
	<span class="n">test</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">min_offset</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_comp_cpu_keys</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">test</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_objectid</span><span class="p">;</span>
	<span class="n">test</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_type</span><span class="p">;</span>
	<span class="n">test</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_offset</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_comp_cpu_keys</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">test</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">copy_to_sk</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_key</span> <span class="o">*</span><span class="n">key</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_ioctl_search_key</span> <span class="o">*</span><span class="n">sk</span><span class="p">,</span>
			       <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span>
			       <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="n">sk_offset</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="o">*</span><span class="n">num_found</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">u64</span> <span class="n">found_transid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_search_header</span> <span class="n">sh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">item_off</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">item_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_transid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">nritems</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">advance_key</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">found_transid</span> <span class="o">=</span> <span class="n">btrfs_header_generation</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nritems</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">item_off</span> <span class="o">=</span> <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="n">item_len</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">item_len</span> <span class="o">&gt;</span> <span class="n">BTRFS_SEARCH_ARGS_BUFSIZE</span><span class="p">)</span>
			<span class="n">item_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="p">)</span> <span class="o">+</span> <span class="n">item_len</span> <span class="o">+</span> <span class="o">*</span><span class="n">sk_offset</span> <span class="o">&gt;</span>
		    <span class="n">BTRFS_SEARCH_ARGS_BUFSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">overflow</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">key_in_sk</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">sk</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">sh</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">;</span>
		<span class="n">sh</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">sh</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>
		<span class="n">sh</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">item_len</span><span class="p">;</span>
		<span class="n">sh</span><span class="p">.</span><span class="n">transid</span> <span class="o">=</span> <span class="n">found_transid</span><span class="p">;</span>

		<span class="cm">/* copy search result header */</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">buf</span> <span class="o">+</span> <span class="o">*</span><span class="n">sk_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sh</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="p">));</span>
		<span class="o">*</span><span class="n">sk_offset</span> <span class="o">+=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">sh</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">item_len</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="o">*</span><span class="n">sk_offset</span><span class="p">;</span>
			<span class="cm">/* copy the item */</span>
			<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span>
					   <span class="n">item_off</span><span class="p">,</span> <span class="n">item_len</span><span class="p">);</span>
			<span class="o">*</span><span class="n">sk_offset</span> <span class="o">+=</span> <span class="n">item_len</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="p">(</span><span class="o">*</span><span class="n">num_found</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">num_found</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">nr_items</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">advance_key:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_offset</span><span class="p">)</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u8</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_type</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">key</span><span class="o">-&gt;</span><span class="n">objectid</span> <span class="o">&lt;</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_objectid</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">key</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="nl">overflow:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">search_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_ioctl_search_args</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">max_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_search_key</span> <span class="o">*</span><span class="n">sk</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_found</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sk_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sk</span><span class="o">-&gt;</span><span class="n">tree_id</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* search the root of the inode that was passed */</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">tree_id</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;could not find root %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">sk</span><span class="o">-&gt;</span><span class="n">tree_id</span><span class="p">);</span>
			<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">min_objectid</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">min_type</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">min_offset</span><span class="p">;</span>

	<span class="n">max_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_objectid</span><span class="p">;</span>
	<span class="n">max_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_type</span><span class="p">;</span>
	<span class="n">max_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">max_offset</span><span class="p">;</span>

	<span class="n">path</span><span class="o">-&gt;</span><span class="n">keep_locks</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_forward</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">max_key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">sk</span><span class="o">-&gt;</span><span class="n">min_transid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">err</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_sk</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">sk</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">buf</span><span class="p">,</span>
				 <span class="o">&amp;</span><span class="n">sk_offset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_found</span><span class="p">);</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">||</span> <span class="n">num_found</span> <span class="o">&gt;=</span> <span class="n">sk</span><span class="o">-&gt;</span><span class="n">nr_items</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">err:</span>
	<span class="n">sk</span><span class="o">-&gt;</span><span class="n">nr_items</span> <span class="o">=</span> <span class="n">num_found</span><span class="p">;</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_tree_search</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	 <span class="k">struct</span> <span class="n">btrfs_ioctl_search_args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	 <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">search_ioctl</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Search INODE_REFs to identify path name of &#39;dirid&#39; directory</span>
<span class="cm"> * in a &#39;tree_id&#39; tree. and sets path name to &#39;name&#39;.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_search_path_in_tree</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
				<span class="n">u64</span> <span class="n">tree_id</span><span class="p">,</span> <span class="n">u64</span> <span class="n">dirid</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">name</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">total_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_inode_ref</span> <span class="o">*</span><span class="n">iref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">dirid</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">ptr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">name</span><span class="p">[</span><span class="n">BTRFS_INO_LOOKUP_PATH_MAX</span><span class="p">];</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">tree_id</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;could not find root %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">tree_id</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">dirid</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_INODE_REF_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">l</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">slot</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">slot</span><span class="o">--</span><span class="p">;</span>
		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">dirid</span> <span class="o">||</span>
				<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_INODE_REF_KEY</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iref</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_inode_ref</span><span class="p">);</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">btrfs_inode_ref_name_len</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">iref</span><span class="p">);</span>
		<span class="n">ptr</span> <span class="o">-=</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">total_len</span> <span class="o">+=</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">name</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="o">*</span><span class="p">(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">=</span> <span class="sc">&#39;/&#39;</span><span class="p">;</span>
		<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)(</span><span class="n">iref</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">len</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">dirid</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">&lt;</span> <span class="n">name</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">memmove</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">ptr</span><span class="p">,</span> <span class="n">total_len</span><span class="p">);</span>
	<span class="n">name</span><span class="p">[</span><span class="n">total_len</span><span class="p">]</span><span class="o">=</span><span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_ino_lookup</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					   <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	 <span class="k">struct</span> <span class="n">btrfs_ioctl_ino_lookup_args</span> <span class="o">*</span><span class="n">args</span><span class="p">;</span>
	 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	 <span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">args</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">args</span><span class="o">-&gt;</span><span class="n">treeid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">args</span><span class="o">-&gt;</span><span class="n">treeid</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_path_in_tree</span><span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">treeid</span><span class="p">,</span> <span class="n">args</span><span class="o">-&gt;</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_snap_destroy</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					     <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">dir</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">dir</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_vol_args</span> <span class="o">*</span><span class="n">vol_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">namelen</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">vol_args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vol_args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>

	<span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">BTRFS_PATH_NAME_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">namelen</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">strchr</span><span class="p">(</span><span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">strncmp</span><span class="p">(</span><span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;..&quot;</span><span class="p">,</span> <span class="n">namelen</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">mnt_want_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
	<span class="n">dentry</span> <span class="o">=</span> <span class="n">lookup_one_len</span><span class="p">(</span><span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">namelen</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_unlock_dir</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">dest</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">)){</span>
		<span class="cm">/*</span>
<span class="cm">		 * Regular user.  Only allow this with a special mount</span>
<span class="cm">		 * option, when the user has write+exec access to the</span>
<span class="cm">		 * subvol root, and when rmdir(2) would have been</span>
<span class="cm">		 * allowed.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Note that this is _not_ check that the subvol is</span>
<span class="cm">		 * empty or doesn&#39;t contain data that we wouldn&#39;t</span>
<span class="cm">		 * otherwise be able to delete.</span>
<span class="cm">		 *</span>
<span class="cm">		 * Users who want to delete empty subvols should try</span>
<span class="cm">		 * rmdir(2).</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">USER_SUBVOL_RM_ALLOWED</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * Do not allow deletion if the parent dir is the same</span>
<span class="cm">		 * as the dir to be deleted.  That means the ioctl</span>
<span class="cm">		 * must be called on the dentry referencing the root</span>
<span class="cm">		 * of the subvol, not a random directory contained</span>
<span class="cm">		 * within it.</span>
<span class="cm">		 */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="n">dest</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>

		<span class="n">err</span> <span class="o">=</span> <span class="n">inode_permission</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">MAY_WRITE</span> <span class="o">|</span> <span class="n">MAY_EXEC</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>

		<span class="cm">/* check if subvolume may be deleted by a non-root user */</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_may_delete</span><span class="p">(</span><span class="n">dir</span><span class="p">,</span> <span class="n">dentry</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_FIRST_FREE_OBJECTID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_dput</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">d_invalidate</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">may_destroy_subvol</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_up_write</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_up_write</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">trans</span><span class="o">-&gt;</span><span class="n">block_rsv</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">global_block_rsv</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_unlink_subvol</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dir</span><span class="p">,</span>
				<span class="n">dest</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
				<span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_name</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_record_root_in_trans</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">dest</span><span class="p">);</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">.</span><span class="n">drop_progress</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
		<span class="k">sizeof</span><span class="p">(</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">.</span><span class="n">drop_progress</span><span class="p">));</span>
	<span class="n">dest</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">.</span><span class="n">drop_level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfs_set_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">xchg</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dest</span><span class="o">-&gt;</span><span class="n">orphan_item_inserted</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_orphan_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
					<span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span>
					<span class="n">dest</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out_end_trans</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out_end_trans:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">err</span><span class="p">)</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_flags</span> <span class="o">|=</span> <span class="n">S_DEAD</span><span class="p">;</span>
<span class="nl">out_up_write:</span>
	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">subvol_sem</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">shrink_dcache_sb</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">);</span>
		<span class="n">btrfs_invalidate_inodes</span><span class="p">(</span><span class="n">dest</span><span class="p">);</span>
		<span class="n">d_delete</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_dput:</span>
	<span class="n">dput</span><span class="p">(</span><span class="n">dentry</span><span class="p">);</span>
<span class="nl">out_unlock_dir:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">dir</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">mnt_drop_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_ioctl_defrag</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_defrag_range_args</span> <span class="o">*</span><span class="n">range</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mnt_want_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span> <span class="o">&amp;</span> <span class="n">S_IFMT</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">S_IFDIR</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_defrag_root</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_defrag_root</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">extent_root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">S_IFREG</span>:
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">range</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">range</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">range</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">argp</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="n">range</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span>
					   <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">range</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">range</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="cm">/* compression requires us to start the IO */</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">range</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_DEFRAG_RANGE_COMPRESS</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">range</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_DEFRAG_RANGE_START_IO</span><span class="p">;</span>
				<span class="n">range</span><span class="o">-&gt;</span><span class="n">extent_thresh</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* the rest are all set to zero by kzalloc */</span>
			<span class="n">range</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_defrag_file</span><span class="p">(</span><span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span>
					<span class="n">range</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">range</span><span class="p">);</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mnt_drop_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_add_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_vol_args</span> <span class="o">*</span><span class="n">vol_args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: balance in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol_args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vol_args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">BTRFS_PATH_NAME_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_init_new_device</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_rm_dev</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_vol_args</span> <span class="o">*</span><span class="n">vol_args</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: balance in progress</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol_args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">vol_args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">BTRFS_PATH_NAME_MAX</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_rm_device</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">vol_args</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">vol_args</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_fs_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_fs_info_args</span> <span class="o">*</span><span class="n">fi_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_devices</span> <span class="o">*</span><span class="n">fs_devices</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">fi_args</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fi_args</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fi_args</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">fi_args</span><span class="o">-&gt;</span><span class="n">num_devices</span> <span class="o">=</span> <span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">num_devices</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fi_args</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">fi_args</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">));</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">devid</span> <span class="o">&gt;</span> <span class="n">fi_args</span><span class="o">-&gt;</span><span class="n">max_id</span><span class="p">)</span>
			<span class="n">fi_args</span><span class="o">-&gt;</span><span class="n">max_id</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">devid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">fi_args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">fi_args</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">fi_args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_dev_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_dev_info_args</span> <span class="o">*</span><span class="n">di_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_devices</span> <span class="o">*</span><span class="n">fs_devices</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_devices</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">s_uuid</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">empty_uuid</span><span class="p">[</span><span class="n">BTRFS_UUID_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">di_args</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">di_args</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">di_args</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">di_args</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">empty_uuid</span><span class="p">,</span> <span class="n">di_args</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">BTRFS_UUID_SIZE</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">s_uuid</span> <span class="o">=</span> <span class="n">di_args</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>
	<span class="n">dev</span> <span class="o">=</span> <span class="n">btrfs_find_device</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">di_args</span><span class="o">-&gt;</span><span class="n">devid</span><span class="p">,</span> <span class="n">s_uuid</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">device_list_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENODEV</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">di_args</span><span class="o">-&gt;</span><span class="n">devid</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">devid</span><span class="p">;</span>
	<span class="n">di_args</span><span class="o">-&gt;</span><span class="n">bytes_used</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">bytes_used</span><span class="p">;</span>
	<span class="n">di_args</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">;</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="n">di_args</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">dev</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">di_args</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">rcu_string</span> <span class="o">*</span><span class="n">name</span><span class="p">;</span>

		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">name</span> <span class="o">=</span> <span class="n">rcu_dereference</span><span class="p">(</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">strncpy</span><span class="p">(</span><span class="n">di_args</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">,</span> <span class="n">name</span><span class="o">-&gt;</span><span class="n">str</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">di_args</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">));</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>
		<span class="n">di_args</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">di_args</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">di_args</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">di_args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">di_args</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">di_args</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_clone</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">srcfd</span><span class="p">,</span>
				       <span class="n">u64</span> <span class="n">off</span><span class="p">,</span> <span class="n">u64</span> <span class="n">olen</span><span class="p">,</span> <span class="n">u64</span> <span class="n">destoff</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">src_file</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nritems</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span> <span class="o">=</span> <span class="n">olen</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bs</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">hint_byte</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * TODO:</span>
<span class="cm">	 * - split compressed inline extents.  annoying: we need to</span>
<span class="cm">	 *   decompress into destination&#39;s address_space (the file offset</span>
<span class="cm">	 *   may change, so source mapping won&#39;t do), then recompress (or</span>
<span class="cm">	 *   otherwise reinsert) a subrange.</span>
<span class="cm">	 * - allow ranges within the same file to be cloned (provided</span>
<span class="cm">	 *   they don&#39;t overlap)?</span>
<span class="cm">	 */</span>

	<span class="cm">/* the destination must be opened for writing */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_WRITE</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_APPEND</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mnt_want_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">src_file</span> <span class="o">=</span> <span class="n">fget</span><span class="p">(</span><span class="n">srcfd</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">src_file</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EBADF</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_drop_write</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">src</span> <span class="o">=</span> <span class="n">src_file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">src</span> <span class="o">==</span> <span class="n">inode</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>

	<span class="cm">/* the src must be open for reading */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">src_file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_READ</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>

	<span class="cm">/* don&#39;t make the dst file partly checksummed */</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATASUM</span><span class="p">)</span> <span class="o">!=</span>
	    <span class="p">(</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_INODE_NODATASUM</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EISDIR</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">S_ISDIR</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">)</span> <span class="o">||</span> <span class="n">S_ISDIR</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EXDEV</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">!=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span> <span class="o">||</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">!=</span> <span class="n">root</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">buf</span> <span class="o">=</span> <span class="n">vmalloc</span><span class="p">(</span><span class="n">btrfs_level_size</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_fput</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">reada</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span> <span class="o">&lt;</span> <span class="n">src</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_PARENT</span><span class="p">);</span>
		<span class="n">mutex_lock_nested</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">,</span> <span class="n">I_MUTEX_CHILD</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* determine range to clone */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">||</span> <span class="n">off</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&lt;</span> <span class="n">off</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">olen</span> <span class="o">=</span> <span class="n">len</span> <span class="o">=</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>
	<span class="cm">/* if we extend to eof, continue to block boundary */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">len</span> <span class="o">==</span> <span class="n">src</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
		<span class="n">len</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>

	<span class="cm">/* verify the end result is block aligned */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span> <span class="n">bs</span><span class="p">)</span> <span class="o">||</span>
	    <span class="o">!</span><span class="n">IS_ALIGNED</span><span class="p">(</span><span class="n">destoff</span><span class="p">,</span> <span class="n">bs</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">destoff</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cont_expand</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="n">destoff</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* truncate page cache pages from target inode range */</span>
	<span class="n">truncate_inode_pages_range</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_data</span><span class="p">,</span> <span class="n">destoff</span><span class="p">,</span>
				   <span class="n">PAGE_CACHE_ALIGN</span><span class="p">(</span><span class="n">destoff</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="cm">/* do any pending delalloc/csum calc on src, one way or</span>
<span class="cm">	   another, and lock file content */</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
		<span class="n">lock_extent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_ordered_extent</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ordered</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="n">test_range_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">,</span>
				   <span class="n">EXTENT_DELALLOC</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">unlock_extent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
		<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* clone data */</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">src</span><span class="p">);</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * note the key will change type as we walk through the</span>
<span class="cm">		 * tree.</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

		<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">nritems</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">nritems</span> <span class="o">=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="p">}</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span> <span class="o">||</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">src</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">extent</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">type</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">size</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">new_key</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">disko</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">diskl</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">datao</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">datal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">comp</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">endoff</span><span class="p">;</span>

			<span class="n">size</span> <span class="o">=</span> <span class="n">btrfs_item_size_nr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
			<span class="n">read_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
					   <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">),</span>
					   <span class="n">size</span><span class="p">);</span>

			<span class="n">extent</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">comp</span> <span class="o">=</span> <span class="n">btrfs_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent</span><span class="p">);</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">||</span>
			    <span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">disko</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
								      <span class="n">extent</span><span class="p">);</span>
				<span class="n">diskl</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
								 <span class="n">extent</span><span class="p">);</span>
				<span class="n">datao</span> <span class="o">=</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent</span><span class="p">);</span>
				<span class="n">datal</span> <span class="o">=</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
								    <span class="n">extent</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* take upper bound, may be compressed */</span>
				<span class="n">datal</span> <span class="o">=</span> <span class="n">btrfs_file_extent_ram_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span>
								    <span class="n">extent</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">datal</span> <span class="o">&lt;=</span> <span class="n">off</span> <span class="o">||</span>
			    <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_key</span><span class="p">));</span>
			<span class="n">new_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span>
				<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">destoff</span> <span class="o">-</span> <span class="n">off</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">destoff</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * 1 - adjusting old extent (we may have to split it)</span>
<span class="cm">			 * 1 - add new extent</span>
<span class="cm">			 * 1 - inode update</span>
<span class="cm">			 */</span>
			<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">||</span>
			    <span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 *    a  | --- range to clone ---|  b</span>
<span class="cm">				 * | ------------- extent ------------- |</span>
<span class="cm">				 */</span>

				<span class="cm">/* substract range b */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">datal</span> <span class="o">&gt;</span> <span class="n">off</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span>
					<span class="n">datal</span> <span class="o">=</span> <span class="n">off</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>

				<span class="cm">/* substract range a */</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">datao</span> <span class="o">+=</span> <span class="n">off</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
					<span class="n">datal</span> <span class="o">-=</span> <span class="n">off</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_drop_extents</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
							 <span class="n">new_key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
							 <span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">datal</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">hint_byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
								<span class="n">ret</span><span class="p">);</span>
					<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
							      <span class="o">&amp;</span><span class="n">new_key</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
								<span class="n">ret</span><span class="p">);</span>
					<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
					    <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">),</span>
					    <span class="n">size</span><span class="p">);</span>

				<span class="n">extent</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span>
						<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>

				<span class="cm">/* disko == 0 means it&#39;s a hole */</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">disko</span><span class="p">)</span>
					<span class="n">datao</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

				<span class="n">btrfs_set_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span>
							     <span class="n">datao</span><span class="p">);</span>
				<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">extent</span><span class="p">,</span>
								<span class="n">datal</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">disko</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">datal</span><span class="p">);</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_extent_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
							<span class="n">disko</span><span class="p">,</span> <span class="n">diskl</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
							<span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
							<span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
							<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">datao</span><span class="p">,</span>
							<span class="mi">0</span><span class="p">);</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
									<span class="n">root</span><span class="p">,</span>
									<span class="n">ret</span><span class="p">);</span>
						<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span>
								      <span class="n">root</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

					<span class="p">}</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">u64</span> <span class="n">skip</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">u64</span> <span class="n">trim</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">off</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">skip</span> <span class="o">=</span> <span class="n">off</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
					<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+=</span> <span class="n">skip</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">datal</span> <span class="o">&gt;</span> <span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">)</span>
					<span class="n">trim</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">datal</span> <span class="o">-</span> <span class="p">(</span><span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">comp</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">skip</span> <span class="o">||</span> <span class="n">trim</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
					<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">size</span> <span class="o">-=</span> <span class="n">skip</span> <span class="o">+</span> <span class="n">trim</span><span class="p">;</span>
				<span class="n">datal</span> <span class="o">-=</span> <span class="n">skip</span> <span class="o">+</span> <span class="n">trim</span><span class="p">;</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_drop_extents</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span>
							 <span class="n">new_key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span>
							 <span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">datal</span><span class="p">,</span>
							 <span class="o">&amp;</span><span class="n">hint_byte</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
								<span class="n">ret</span><span class="p">);</span>
					<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_insert_empty_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
							      <span class="o">&amp;</span><span class="n">new_key</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
								<span class="n">ret</span><span class="p">);</span>
					<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
					<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">if</span> <span class="p">(</span><span class="n">skip</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">u32</span> <span class="n">start</span> <span class="o">=</span>
					  <span class="n">btrfs_file_extent_calc_inline_size</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
					<span class="n">memmove</span><span class="p">(</span><span class="n">buf</span><span class="o">+</span><span class="n">start</span><span class="p">,</span> <span class="n">buf</span><span class="o">+</span><span class="n">start</span><span class="o">+</span><span class="n">skip</span><span class="p">,</span>
						<span class="n">datal</span><span class="p">);</span>
				<span class="p">}</span>

				<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">write_extent_buffer</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span>
					    <span class="n">btrfs_item_ptr_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">),</span>
					    <span class="n">size</span><span class="p">);</span>
				<span class="n">inode_add_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">datal</span><span class="p">);</span>
			<span class="p">}</span>

			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

			<span class="n">inode_inc_iversion</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mtime</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>

			<span class="cm">/*</span>
<span class="cm">			 * we round up to the block size at eof when</span>
<span class="cm">			 * determining which extents to clone above,</span>
<span class="cm">			 * but shouldn&#39;t round up the file size</span>
<span class="cm">			 */</span>
			<span class="n">endoff</span> <span class="o">=</span> <span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">datal</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">endoff</span> <span class="o">&gt;</span> <span class="n">destoff</span><span class="o">+</span><span class="n">olen</span><span class="p">)</span>
				<span class="n">endoff</span> <span class="o">=</span> <span class="n">destoff</span><span class="o">+</span><span class="n">olen</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">endoff</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span>
				<span class="n">btrfs_i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">endoff</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_update_inode</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="p">}</span>
<span class="nl">next:</span>
		<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out:</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">unlock_extent</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">src</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">off</span><span class="p">,</span> <span class="n">off</span><span class="o">+</span><span class="n">len</span><span class="p">);</span>
<span class="nl">out_unlock:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">src</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">vfree</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
<span class="nl">out_fput:</span>
	<span class="n">fput</span><span class="p">(</span><span class="n">src_file</span><span class="p">);</span>
<span class="nl">out_drop_write:</span>
	<span class="n">mnt_drop_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_clone_range</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_clone_range_args</span> <span class="n">args</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">args</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">btrfs_ioctl_clone</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">src_fd</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">src_offset</span><span class="p">,</span>
				 <span class="n">args</span><span class="p">.</span><span class="n">src_length</span><span class="p">,</span> <span class="n">args</span><span class="p">.</span><span class="n">dest_offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * there are many ways the trans_start and trans_end ioctls can lead</span>
<span class="cm"> * to deadlocks.  They should only be used by applications that</span>
<span class="cm"> * basically own the machine, and have a very in depth understanding</span>
<span class="cm"> * of all the possible deadlocks and enospc problems.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_trans_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_readonly</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mnt_want_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">open_ioctl_trans</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_ioctl_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_drop</span><span class="p">;</span>

	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="n">trans</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out_drop:</span>
	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">open_ioctl_trans</span><span class="p">);</span>
	<span class="n">mnt_drop_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_default_subvol</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">new_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_dir_item</span> <span class="o">*</span><span class="n">di</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">location</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">disk_super</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">features</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dir_id</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">objectid</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">objectid</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">objectid</span><span class="p">)</span>
		<span class="n">objectid</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>

	<span class="n">location</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">objectid</span><span class="p">;</span>
	<span class="n">location</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
	<span class="n">location</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">new_root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">location</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">new_root</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_root_refs</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_root</span><span class="o">-&gt;</span><span class="n">root_item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">path</span><span class="o">-&gt;</span><span class="n">leave_spinning</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dir_id</span> <span class="o">=</span> <span class="n">btrfs_super_root_dir</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">);</span>
	<span class="n">di</span> <span class="o">=</span> <span class="n">btrfs_lookup_dir_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">tree_root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
				   <span class="n">dir_id</span><span class="p">,</span> <span class="s">&quot;default&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">di</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_ERR</span> <span class="s">&quot;Umm, you don&#39;t have the default dir item, &quot;</span>
		       <span class="s">&quot;this isn&#39;t going to work</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfs_cpu_key_to_disk</span><span class="p">(</span><span class="o">&amp;</span><span class="n">disk_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">);</span>
	<span class="n">btrfs_set_dir_item_key</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">di</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">disk_key</span><span class="p">);</span>
	<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="n">disk_super</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">super_copy</span><span class="p">;</span>
	<span class="n">features</span> <span class="o">=</span> <span class="n">btrfs_super_incompat_flags</span><span class="p">(</span><span class="n">disk_super</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">features</span> <span class="o">&amp;</span> <span class="n">BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">features</span> <span class="o">|=</span> <span class="n">BTRFS_FEATURE_INCOMPAT_DEFAULT_SUBVOL</span><span class="p">;</span>
		<span class="n">btrfs_set_super_incompat_flags</span><span class="p">(</span><span class="n">disk_super</span><span class="p">,</span> <span class="n">features</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">get_block_group_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">groups_list</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">btrfs_ioctl_space_info</span> <span class="o">*</span><span class="n">space</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_block_group_cache</span> <span class="o">*</span><span class="n">block_group</span><span class="p">;</span>

	<span class="n">space</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">space</span><span class="o">-&gt;</span><span class="n">used_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">space</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">block_group</span><span class="p">,</span> <span class="n">groups_list</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">space</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
		<span class="n">space</span><span class="o">-&gt;</span><span class="n">total_bytes</span> <span class="o">+=</span> <span class="n">block_group</span><span class="o">-&gt;</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
		<span class="n">space</span><span class="o">-&gt;</span><span class="n">used_bytes</span> <span class="o">+=</span>
			<span class="n">btrfs_block_group_used</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_group</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">btrfs_ioctl_space_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_space_args</span> <span class="n">space_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_space_info</span> <span class="n">space</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_space_info</span> <span class="o">*</span><span class="n">dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_space_info</span> <span class="o">*</span><span class="n">dest_orig</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_space_info</span> <span class="n">__user</span> <span class="o">*</span><span class="n">user_dest</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">info</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">types</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="n">BTRFS_BLOCK_GROUP_DATA</span><span class="p">,</span>
		       <span class="n">BTRFS_BLOCK_GROUP_SYSTEM</span><span class="p">,</span>
		       <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">,</span>
		       <span class="n">BTRFS_BLOCK_GROUP_DATA</span> <span class="o">|</span> <span class="n">BTRFS_BLOCK_GROUP_METADATA</span><span class="p">};</span>
	<span class="kt">int</span> <span class="n">num_types</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">alloc_size</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">slot_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">space_args</span><span class="p">,</span>
			   <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ioctl_space_args</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">,</span>
			   <span class="k">sizeof</span><span class="p">(</span><span class="n">space_args</span><span class="p">)))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_types</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">,</span>
					<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">info</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">BTRFS_NR_RAID_TYPES</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span>
				<span class="n">slot_count</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* space_slots == 0 means they are asking for a count */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">space_args</span><span class="p">.</span><span class="n">space_slots</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">space_args</span><span class="p">.</span><span class="n">total_spaces</span> <span class="o">=</span> <span class="n">slot_count</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">slot_count</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">space_args</span><span class="p">.</span><span class="n">space_slots</span><span class="p">,</span> <span class="n">slot_count</span><span class="p">);</span>

	<span class="n">alloc_size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">dest</span><span class="p">)</span> <span class="o">*</span> <span class="n">slot_count</span><span class="p">;</span>

	<span class="cm">/* we generally have at most 6 or so space infos, one for each raid</span>
<span class="cm">	 * level.  So, a whole page should be more than enough for everyone</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_size</span> <span class="o">&gt;</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">space_args</span><span class="p">.</span><span class="n">total_spaces</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">dest</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">alloc_size</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dest</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="n">dest_orig</span> <span class="o">=</span> <span class="n">dest</span><span class="p">;</span>

	<span class="cm">/* now we have a buffer to copy into */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_types</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_space_info</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot_count</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">rcu_read_lock</span><span class="p">();</span>
		<span class="n">list_for_each_entry_rcu</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">space_info</span><span class="p">,</span>
					<span class="n">list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">tmp</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">==</span> <span class="n">types</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">info</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">rcu_read_unlock</span><span class="p">();</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">info</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">down_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">c</span> <span class="o">&lt;</span> <span class="n">BTRFS_NR_RAID_TYPES</span><span class="p">;</span> <span class="n">c</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">c</span><span class="p">]))</span> <span class="p">{</span>
				<span class="n">get_block_group_info</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">block_groups</span><span class="p">[</span><span class="n">c</span><span class="p">],</span>
						     <span class="o">&amp;</span><span class="n">space</span><span class="p">);</span>
				<span class="n">memcpy</span><span class="p">(</span><span class="n">dest</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">space</span><span class="p">));</span>
				<span class="n">dest</span><span class="o">++</span><span class="p">;</span>
				<span class="n">space_args</span><span class="p">.</span><span class="n">total_spaces</span><span class="o">++</span><span class="p">;</span>
				<span class="n">slot_count</span><span class="o">--</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot_count</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">up_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">info</span><span class="o">-&gt;</span><span class="n">groups_sem</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">user_dest</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ioctl_space_info</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span>
		<span class="p">(</span><span class="n">arg</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_ioctl_space_args</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">user_dest</span><span class="p">,</span> <span class="n">dest_orig</span><span class="p">,</span> <span class="n">alloc_size</span><span class="p">))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">dest_orig</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">space_args</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">space_args</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * there are many ways the trans_start and trans_end ioctls can lead</span>
<span class="cm"> * to deadlocks.  They should only be used by applications that</span>
<span class="cm"> * basically own the machine, and have a very in depth understanding</span>
<span class="cm"> * of all the possible deadlocks and enospc problems.</span>
<span class="cm"> */</span>
<span class="kt">long</span> <span class="nf">btrfs_ioctl_trans_end</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">trans</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
	<span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">open_ioctl_trans</span><span class="p">);</span>

	<span class="n">mnt_drop_write_file</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_start_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transid</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
	<span class="n">transid</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction_async</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argp</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">argp</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">transid</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">transid</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_wait_sync</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">argp</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_from_user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">transid</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">transid</span><span class="p">)))</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">transid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="cm">/* current trans */</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">btrfs_wait_for_commit</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">transid</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_scrub</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_scrub_args</span> <span class="o">*</span><span class="n">sa</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sa</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sa</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_scrub_dev</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">devid</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">,</span>
			      <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">progress</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_SCRUB_READONLY</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sa</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_scrub_cancel</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">return</span> <span class="n">btrfs_scrub_cancel</span><span class="p">(</span><span class="n">root</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_scrub_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				       <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_scrub_args</span> <span class="o">*</span><span class="n">sa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sa</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sa</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_scrub_progress</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sa</span><span class="o">-&gt;</span><span class="n">devid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sa</span><span class="o">-&gt;</span><span class="n">progress</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sa</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_get_dev_stats</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
				      <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">reset_after_read</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_get_dev_stats</span> <span class="o">*</span><span class="n">sa</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">reset_after_read</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">sa</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sa</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">sa</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_get_dev_stats</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">reset_after_read</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sa</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sa</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_ino_to_path</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">rel_ptr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_ino_path_args</span> <span class="o">*</span><span class="n">ipa</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_fs_paths</span> <span class="o">*</span><span class="n">ipath</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ipa</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ipa</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ipa</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ipa</span><span class="p">);</span>
		<span class="n">ipa</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">ipa</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="n">ipath</span> <span class="o">=</span> <span class="n">init_ipath</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">ipath</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">ipath</span><span class="p">);</span>
		<span class="n">ipath</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">paths_from_inode</span><span class="p">(</span><span class="n">ipa</span><span class="o">-&gt;</span><span class="n">inum</span><span class="p">,</span> <span class="n">ipath</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">elem_cnt</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">rel_ptr</span> <span class="o">=</span> <span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span>
			  <span class="p">(</span><span class="n">u64</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
		<span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">rel_ptr</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ipa</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">ipath</span><span class="o">-&gt;</span><span class="n">fspath</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">free_ipath</span><span class="p">(</span><span class="n">ipath</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ipa</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">build_ino_list</span><span class="p">(</span><span class="n">u64</span> <span class="n">inum</span><span class="p">,</span> <span class="n">u64</span> <span class="n">offset</span><span class="p">,</span> <span class="n">u64</span> <span class="n">root</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_data_container</span> <span class="o">*</span><span class="n">inodes</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">;</span>
	<span class="k">const</span> <span class="kt">size_t</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">u64</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">inodes</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">&gt;=</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">-=</span> <span class="n">c</span><span class="p">;</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">inodes</span><span class="o">-&gt;</span><span class="n">elem_cnt</span><span class="p">]</span> <span class="o">=</span> <span class="n">inum</span><span class="p">;</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">inodes</span><span class="o">-&gt;</span><span class="n">elem_cnt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">[</span><span class="n">inodes</span><span class="o">-&gt;</span><span class="n">elem_cnt</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">elem_cnt</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">bytes_missing</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">-</span> <span class="n">inodes</span><span class="o">-&gt;</span><span class="n">bytes_left</span><span class="p">;</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">bytes_left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">inodes</span><span class="o">-&gt;</span><span class="n">elem_missed</span> <span class="o">+=</span> <span class="mi">3</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_logical_to_ino</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_item_pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_logical_ino_args</span> <span class="o">*</span><span class="n">loi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_data_container</span> <span class="o">*</span><span class="n">inodes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">loi</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">loi</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">loi</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">loi</span><span class="p">);</span>
		<span class="n">loi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">size</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">loi</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">,</span> <span class="mi">4096</span><span class="p">);</span>
	<span class="n">inodes</span> <span class="o">=</span> <span class="n">init_data_container</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inodes</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">inodes</span><span class="p">);</span>
		<span class="n">inodes</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">extent_from_logical</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">loi</span><span class="o">-&gt;</span><span class="n">logical</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
	<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&amp;</span> <span class="n">BTRFS_EXTENT_FLAG_TREE_BLOCK</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOENT</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">extent_item_pos</span> <span class="o">=</span> <span class="n">loi</span><span class="o">-&gt;</span><span class="n">logical</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">iterate_extent_inodes</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">extent_item_pos</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">build_ino_list</span><span class="p">,</span>
					<span class="n">inodes</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">copy_to_user</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">loi</span><span class="o">-&gt;</span><span class="n">inodes</span><span class="p">,</span>
			   <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">inodes</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">inodes</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">loi</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">update_ioctl_balance_args</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lock</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">btrfs_ioctl_balance_args</span> <span class="o">*</span><span class="n">bargs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_balance_control</span> <span class="o">*</span><span class="n">bctl</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">;</span>

	<span class="n">bargs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">bctl</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_running</span><span class="p">))</span>
		<span class="n">bargs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">BTRFS_BALANCE_STATE_RUNNING</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_pause_req</span><span class="p">))</span>
		<span class="n">bargs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">BTRFS_BALANCE_STATE_PAUSE_REQ</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">atomic_read</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_cancel_req</span><span class="p">))</span>
		<span class="n">bargs</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">|=</span> <span class="n">BTRFS_BALANCE_STATE_CANCEL_REQ</span><span class="p">;</span>

	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">));</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">lock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_lock</span><span class="p">);</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">));</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_lock</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">stat</span><span class="p">));</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_balance</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_balance_args</span> <span class="o">*</span><span class="n">bargs</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_balance_control</span> <span class="o">*</span><span class="n">bctl</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">mnt_want_write</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bargs</span> <span class="o">=</span> <span class="n">memdup_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bargs</span><span class="p">));</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">bargs</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">bargs</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">BTRFS_BALANCE_RESUME</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">out_bargs</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">bctl</span> <span class="o">=</span> <span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">;</span>
			<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_lock</span><span class="p">);</span>
			<span class="n">bctl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_BALANCE_RESUME</span><span class="p">;</span>
			<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_lock</span><span class="p">);</span>

			<span class="k">goto</span> <span class="n">do_balance</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">bargs</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINPROGRESS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_bargs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bctl</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bctl</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out_bargs</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bctl</span><span class="o">-&gt;</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">fs_info</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">data</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">meta</span><span class="p">));</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bargs</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">bctl</span><span class="o">-&gt;</span><span class="n">sys</span><span class="p">));</span>

		<span class="n">bctl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">bargs</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* balance everything - no filters */</span>
		<span class="n">bctl</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">BTRFS_BALANCE_TYPE_MASK</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">do_balance:</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_balance</span><span class="p">(</span><span class="n">bctl</span><span class="p">,</span> <span class="n">bargs</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * bctl is freed in __cancel_balance or in free_fs_info if</span>
<span class="cm">	 * restriper was paused all the way until unmount</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">bargs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bargs</span><span class="p">)))</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
	<span class="p">}</span>

<span class="nl">out_bargs:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">bargs</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_mutex</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">volume_mutex</span><span class="p">);</span>
	<span class="n">mnt_drop_write</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">mnt</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_balance_ctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">cmd</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">BTRFS_BALANCE_CTL_PAUSE</span>:
		<span class="k">return</span> <span class="n">btrfs_pause_balance</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_BALANCE_CTL_CANCEL</span>:
		<span class="k">return</span> <span class="n">btrfs_cancel_balance</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_ioctl_balance_progress</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
					 <span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_balance_args</span> <span class="o">*</span><span class="n">bargs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">capable</span><span class="p">(</span><span class="n">CAP_SYS_ADMIN</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EPERM</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_ctl</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOTCONN</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bargs</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bargs</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bargs</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">update_ioctl_balance_args</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">bargs</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">copy_to_user</span><span class="p">(</span><span class="n">arg</span><span class="p">,</span> <span class="n">bargs</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">bargs</span><span class="p">)))</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">bargs</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">balance_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">long</span> <span class="nf">btrfs_ioctl</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span>
		<span class="n">cmd</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">arg</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="n">argp</span> <span class="o">=</span> <span class="p">(</span><span class="kt">void</span> <span class="n">__user</span> <span class="o">*</span><span class="p">)</span><span class="n">arg</span><span class="p">;</span>

	<span class="k">switch</span> <span class="p">(</span><span class="n">cmd</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">FS_IOC_GETFLAGS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_getflags</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FS_IOC_SETFLAGS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_setflags</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FS_IOC_GETVERSION</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_getversion</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">FITRIM</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_fitrim</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SNAP_CREATE</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_snap_create</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SNAP_CREATE_V2</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_snap_create_v2</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SUBVOL_CREATE</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_snap_create</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SNAP_DESTROY</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_snap_destroy</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SUBVOL_GETFLAGS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_subvol_getflags</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SUBVOL_SETFLAGS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_subvol_setflags</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_DEFAULT_SUBVOL</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_default_subvol</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_DEFRAG</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_defrag</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_DEFRAG_RANGE</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_defrag</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_RESIZE</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_resize</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_ADD_DEV</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_add_dev</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_RM_DEV</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_rm_dev</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_FS_INFO</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_fs_info</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_DEV_INFO</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_dev_info</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_BALANCE</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_balance</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_CLONE</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_clone</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_CLONE_RANGE</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_clone_range</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_TRANS_START</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_trans_start</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_TRANS_END</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_trans_end</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_TREE_SEARCH</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_tree_search</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_INO_LOOKUP</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_ino_lookup</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_INO_PATHS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_ino_to_path</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_LOGICAL_INO</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_logical_to_ino</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SPACE_INFO</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_space_info</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SYNC</span>:
		<span class="n">btrfs_sync_fs</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_START_SYNC</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_start_sync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_WAIT_SYNC</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_wait_sync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SCRUB</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_scrub</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SCRUB_CANCEL</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_scrub_cancel</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_SCRUB_PROGRESS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_scrub_progress</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_BALANCE_V2</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_balance</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_BALANCE_CTL</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_balance_ctl</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">arg</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_BALANCE_PROGRESS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_balance_progress</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_GET_DEV_STATS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_get_dev_stats</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">case</span> <span class="n">BTRFS_IOC_GET_AND_RESET_DEV_STATS</span>:
		<span class="k">return</span> <span class="n">btrfs_ioctl_get_dev_stats</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">argp</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">ENOTTY</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
