<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › check-integrity.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>check-integrity.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) STRATO AG 2011.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cm">/*</span>
<span class="cm"> * This module can be used to catch cases when the btrfs kernel</span>
<span class="cm"> * code executes write requests to the disk that bring the file</span>
<span class="cm"> * system in an inconsistent state. In such a state, a power-loss</span>
<span class="cm"> * or kernel panic event would cause that the data on disk is</span>
<span class="cm"> * lost or at least damaged.</span>
<span class="cm"> *</span>
<span class="cm"> * Code is added that examines all block write requests during</span>
<span class="cm"> * runtime (including writes of the super block). Three rules</span>
<span class="cm"> * are verified and an error is printed on violation of the</span>
<span class="cm"> * rules:</span>
<span class="cm"> * 1. It is not allowed to write a disk block which is</span>
<span class="cm"> *    currently referenced by the super block (either directly</span>
<span class="cm"> *    or indirectly).</span>
<span class="cm"> * 2. When a super block is written, it is verified that all</span>
<span class="cm"> *    referenced (directly or indirectly) blocks fulfill the</span>
<span class="cm"> *    following requirements:</span>
<span class="cm"> *    2a. All referenced blocks have either been present when</span>
<span class="cm"> *        the file system was mounted, (i.e., they have been</span>
<span class="cm"> *        referenced by the super block) or they have been</span>
<span class="cm"> *        written since then and the write completion callback</span>
<span class="cm"> *        was called and a FLUSH request to the device where</span>
<span class="cm"> *        these blocks are located was received and completed.</span>
<span class="cm"> *    2b. All referenced blocks need to have a generation</span>
<span class="cm"> *        number which is equal to the parent&#39;s number.</span>
<span class="cm"> *</span>
<span class="cm"> * One issue that was found using this module was that the log</span>
<span class="cm"> * tree on disk became temporarily corrupted because disk blocks</span>
<span class="cm"> * that had been in use for the log tree had been freed and</span>
<span class="cm"> * reused too early, while being referenced by the written super</span>
<span class="cm"> * block.</span>
<span class="cm"> *</span>
<span class="cm"> * The search term in the kernel log that can be used to filter</span>
<span class="cm"> * on the existence of detected integrity issues is</span>
<span class="cm"> * &quot;btrfs: attempt&quot;.</span>
<span class="cm"> *</span>
<span class="cm"> * The integrity check is enabled via mount options. These</span>
<span class="cm"> * mount options are only supported if the integrity check</span>
<span class="cm"> * tool is compiled by defining BTRFS_FS_CHECK_INTEGRITY.</span>
<span class="cm"> *</span>
<span class="cm"> * Example #1, apply integrity checks to all metadata:</span>
<span class="cm"> * mount /dev/sdb1 /mnt -o check_int</span>
<span class="cm"> *</span>
<span class="cm"> * Example #2, apply integrity checks to all metadata and</span>
<span class="cm"> * to data extents:</span>
<span class="cm"> * mount /dev/sdb1 /mnt -o check_int_data</span>
<span class="cm"> *</span>
<span class="cm"> * Example #3, apply integrity checks to all metadata and dump</span>
<span class="cm"> * the tree that the super block references to kernel messages</span>
<span class="cm"> * each time after a super block was written:</span>
<span class="cm"> * mount /dev/sdb1 /mnt -o check_int,check_int_print_mask=263</span>
<span class="cm"> *</span>
<span class="cm"> * If the integrity check tool is included and activated in</span>
<span class="cm"> * the mount options, plenty of kernel memory is used, and</span>
<span class="cm"> * plenty of additional CPU cycles are spent. Enabling this</span>
<span class="cm"> * functionality is not intended for normal use. In most</span>
<span class="cm"> * cases, unless you are a btrfs developer who needs to verify</span>
<span class="cm"> * the integrity of (super)-block write requests, do not</span>
<span class="cm"> * enable the config option BTRFS_FS_CHECK_INTEGRITY to</span>
<span class="cm"> * include and compile the integrity check tool.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/crc32c.h&gt;</span>
<span class="cp">#include &lt;linux/genhd.h&gt;</span>
<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;extent_io.h&quot;</span>
<span class="cp">#include &quot;volumes.h&quot;</span>
<span class="cp">#include &quot;print-tree.h&quot;</span>
<span class="cp">#include &quot;locking.h&quot;</span>
<span class="cp">#include &quot;check-integrity.h&quot;</span>
<span class="cp">#include &quot;rcu-string.h&quot;</span>

<span class="cp">#define BTRFSIC_BLOCK_HASHTABLE_SIZE 0x10000</span>
<span class="cp">#define BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE 0x10000</span>
<span class="cp">#define BTRFSIC_DEV2STATE_HASHTABLE_SIZE 0x100</span>
<span class="cp">#define BTRFSIC_BLOCK_MAGIC_NUMBER 0x14491051</span>
<span class="cp">#define BTRFSIC_BLOCK_LINK_MAGIC_NUMBER 0x11070807</span>
<span class="cp">#define BTRFSIC_DEV2STATE_MAGIC_NUMBER 0x20111530</span>
<span class="cp">#define BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER 20111300</span>
<span class="cp">#define BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL (200 - 6)	</span><span class="cm">/* in characters,</span>
<span class="cm">							 * excluding &quot; [...]&quot; */</span><span class="cp"></span>
<span class="cp">#define BTRFSIC_GENERATION_UNKNOWN ((u64)-1)</span>

<span class="cm">/*</span>
<span class="cm"> * The definition of the bitmask fields for the print_mask.</span>
<span class="cm"> * They are specified with the mount option check_integrity_print_mask.</span>
<span class="cm"> */</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE			0x00000001</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION		0x00000002</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE			0x00000004</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE			0x00000008</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH			0x00000010</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_END_IO_BIO_BH			0x00000020</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_VERBOSE				0x00000040</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_VERY_VERBOSE				0x00000080</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_INITIAL_TREE				0x00000100</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES			0x00000200</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_INITIAL_DATABASE			0x00000400</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_NUM_COPIES				0x00000800</span>
<span class="cp">#define BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS		0x00001000</span>

<span class="k">struct</span> <span class="n">btrfsic_dev_state</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">btrfsic_state</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">magic_num</span><span class="p">;</span>		<span class="cm">/* only used for debug purposes */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_metadata</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* if it is meta-data, not data-data */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_superblock</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* if it is one of the superblocks */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">is_iodone</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* if is done by lower subsystem */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">iodone_w_error</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* error was indicated to endio */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">never_written</span><span class="o">:</span><span class="mi">1</span><span class="p">;</span>	<span class="cm">/* block was added because it was</span>
<span class="cm">					 * referenced, not because it was</span>
<span class="cm">					 * written */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">mirror_num</span><span class="o">:</span><span class="mi">2</span><span class="p">;</span>	<span class="cm">/* large enough to hold</span>
<span class="cm">					 * BTRFS_SUPER_MIRROR_MAX */</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">;</span>		<span class="cm">/* key, physical byte num on disk */</span>
	<span class="n">u64</span> <span class="n">logical_bytenr</span><span class="p">;</span>	<span class="cm">/* logical byte num on disk */</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">disk_key</span><span class="p">;</span>	<span class="cm">/* extra info to print in case of</span>
<span class="cm">					 * issues, will not always be correct */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">collision_resolving_node</span><span class="p">;</span>	<span class="cm">/* list node */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">all_blocks_node</span><span class="p">;</span>	<span class="cm">/* list node */</span>

	<span class="cm">/* the following two lists contain block_link items */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ref_to_list</span><span class="p">;</span>	<span class="cm">/* list */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">ref_from_list</span><span class="p">;</span>	<span class="cm">/* list */</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_in_same_bio</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">orig_bio_bh_private</span><span class="p">;</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="n">bio_end_io_t</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
		<span class="n">bh_end_io_t</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span> <span class="n">orig_bio_bh_end_io</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">submit_bio_bh_rw</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">flush_gen</span><span class="p">;</span> <span class="cm">/* only valid if !never_written */</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Elements of this type are allocated dynamically and required because</span>
<span class="cm"> * each block object can refer to and can be ref from multiple blocks.</span>
<span class="cm"> * The key to lookup them in the hashtable is the dev_bytenr of</span>
<span class="cm"> * the block ref to plus the one from the block refered from.</span>
<span class="cm"> * The fact that they are searchable via a hashtable and that a</span>
<span class="cm"> * ref_cnt is maintained is not required for the btrfs integrity</span>
<span class="cm"> * check algorithm itself, it is only used to make the output more</span>
<span class="cm"> * beautiful in case that an error is detected (an error is defined</span>
<span class="cm"> * as a write operation to a block while that block is still referenced).</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">magic_num</span><span class="p">;</span>		<span class="cm">/* only used for debug purposes */</span>
	<span class="n">u32</span> <span class="n">ref_cnt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node_ref_to</span><span class="p">;</span>	<span class="cm">/* list node */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">node_ref_from</span><span class="p">;</span>	<span class="cm">/* list node */</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">collision_resolving_node</span><span class="p">;</span>	<span class="cm">/* list node */</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block_ref_to</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block_ref_from</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">parent_generation</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">magic_num</span><span class="p">;</span>		<span class="cm">/* only used for debug purposes */</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">collision_resolving_node</span><span class="p">;</span>	<span class="cm">/* list node */</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="n">dummy_block_for_bio_bh_flush</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_flush_gen</span><span class="p">;</span>
	<span class="kt">char</span> <span class="n">name</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">table</span><span class="p">[</span><span class="n">BTRFSIC_BLOCK_HASHTABLE_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">table</span><span class="p">[</span><span class="n">BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">table</span><span class="p">[</span><span class="n">BTRFSIC_DEV2STATE_HASHTABLE_SIZE</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="p">{</span>
	<span class="n">u64</span> <span class="n">start</span><span class="p">;</span>		<span class="cm">/* virtual bytenr */</span>
	<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">;</span>		<span class="cm">/* physical bytenr on device */</span>
	<span class="n">u32</span> <span class="n">len</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">**</span><span class="n">datav</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pagev</span><span class="p">;</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">mem_to_free</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* This structure is used to implement recursion without occupying</span>
<span class="cm"> * any stack space, refer to btrfsic_process_metablock() */</span>
<span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">magic</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">nr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">limit_nesting</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_copies</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="n">next_block_ctx</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="n">hdr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="n">prev</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* Some state per mounted filesystem */</span>
<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="p">{</span>
	<span class="n">u32</span> <span class="n">print_mask</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">include_extent_data</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">csum_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="n">all_blocks_list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="n">block_hashtable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="n">block_link_hashtable</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">max_superblock_generation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">latest_superblock</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">metablock_size</span><span class="p">;</span>
	<span class="n">u32</span> <span class="n">datablock_size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">btrfsic_block_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_link_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">btrfsic_block_link_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_link_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">n</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dev_state_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">btrfsic_dev_state_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dev_state_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_hashtable_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_hashtable_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_hashtable_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">btrfsic_block_hashtable_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_link_hashtable_init</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_link_hashtable_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_block_link_hashtable_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">btrfsic_block_link_hashtable_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev_ref_to</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dev_bytenr_ref_to</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev_ref_from</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dev_bytenr_ref_from</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dev_state_hashtable_init</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dev_state_hashtable_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dev_state_hashtable_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">btrfsic_dev_state_hashtable_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="n">btrfsic_stack_frame_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_stack_frame_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="n">sf</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_process_superblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_fs_devices</span> <span class="o">*</span><span class="n">fs_devices</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_process_metablock</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
				     <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
				     <span class="kt">int</span> <span class="n">limit_nesting</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_iodone_flag</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_read_from_block_data</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dst</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_create_link_to_next_block</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span>
		<span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span> <span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">limit_nesting</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">next_block_ctx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">**</span><span class="n">next_blockp</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">force_iodone_flag</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">num_copiesp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mirror_nump</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">disk_key</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">parent_generation</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_handle_extent_data</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
				      <span class="n">u32</span> <span class="n">item_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_iodone_flag</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx_out</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_map_superblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx_out</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_read_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dump_database</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_complete_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_test_for_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				     <span class="kt">char</span> <span class="o">**</span><span class="n">datav</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_process_written_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">mapped_datav</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bio_is_patched</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">submit_bio_bh_rw</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_process_written_superblock</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">block</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">super_hdr</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bio_error_status</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_bh_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_is_block_ref_by_superblock</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					      <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
					      <span class="kt">int</span> <span class="n">recursion_level</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_check_all_ref_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">block</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">recursion_level</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_print_add_link</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_print_rem_link</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">char</span> <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dump_tree</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_dump_tree_sub</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">indent_level</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">btrfsic_block_link_lookup_or_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">next_block_ctx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">from_block</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">parent_generation</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">btrfsic_block_lookup_or_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">additional_string</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_iodone</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">never_written</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">was_created</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_process_superblock_dev_mirror</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">superblock_mirror_num</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">**</span><span class="n">selected_dev_state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">selected_super</span><span class="p">);</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">btrfsic_dev_state_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">btrfsic_cmp_log_and_dev_bytenr</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">);</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">mutex</span> <span class="n">btrfsic_mutex</span><span class="p">;</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">btrfsic_is_initialized</span><span class="p">;</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="n">btrfsic_dev_state_hashtable</span><span class="p">;</span>


<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">magic_num</span> <span class="o">=</span> <span class="n">BTRFSIC_BLOCK_MAGIC_NUMBER</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">BTRFSIC_GENERATION_UNKNOWN</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">disk_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">disk_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">disk_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">is_superblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">iodone_w_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">never_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">all_blocks_node</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">ref_from_list</span><span class="p">);</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">b</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="nf">btrfsic_block_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">;</span>

	<span class="n">b</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">b</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span>
		<span class="n">btrfsic_block_init</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">b</span> <span class="o">||</span> <span class="n">BTRFSIC_BLOCK_MAGIC_NUMBER</span> <span class="o">==</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">magic_num</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_link_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">magic_num</span> <span class="o">=</span> <span class="n">BTRFSIC_BLOCK_LINK_MAGIC_NUMBER</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_to</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_from</span><span class="p">);</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">);</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="nf">btrfsic_block_link_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">l</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">l</span><span class="p">)</span>
		<span class="n">btrfsic_block_link_init</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_link_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span> <span class="o">||</span> <span class="n">BTRFSIC_BLOCK_LINK_MAGIC_NUMBER</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">magic_num</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dev_state_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">magic_num</span> <span class="o">=</span> <span class="n">BTRFSIC_DEV2STATE_MAGIC_NUMBER</span><span class="p">;</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">);</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">btrfsic_block_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">dummy_block_for_bio_bh_flush</span><span class="p">);</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">dummy_block_for_bio_bh_flush</span><span class="p">.</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">ds</span><span class="o">-&gt;</span><span class="n">dummy_block_for_bio_bh_flush</span><span class="p">.</span><span class="n">dev_state</span> <span class="o">=</span> <span class="n">ds</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="nf">btrfsic_dev_state_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">;</span>

	<span class="n">ds</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">ds</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">ds</span><span class="p">)</span>
		<span class="n">btrfsic_dev_state_init</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ds</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dev_state_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">ds</span> <span class="o">||</span>
		 <span class="n">BTRFSIC_DEV2STATE_MAGIC_NUMBER</span> <span class="o">==</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">magic_num</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_hashtable_init</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFSIC_BLOCK_HASHTABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_hashtable_add</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hashval</span> <span class="o">=</span>
	    <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)))</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">BTRFSIC_BLOCK_HASHTABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_hashtable_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="nf">btrfsic_block_hashtable_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hashval</span> <span class="o">=</span>
	    <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">dev_bytenr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">bdev</span><span class="p">)))</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">BTRFSIC_BLOCK_HASHTABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">b</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_block</span><span class="p">,</span>
			       <span class="n">collision_resolving_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span> <span class="n">bdev</span> <span class="o">&amp;&amp;</span> <span class="n">b</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">==</span> <span class="n">dev_bytenr</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">b</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_link_hashtable_init</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_link_hashtable_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hashval</span> <span class="o">=</span>
	    <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)))</span>
	     <span class="o">&amp;</span> <span class="p">(</span><span class="n">BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="p">);</span>
	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_block_link_hashtable_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="nf">btrfsic_block_link_hashtable_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev_ref_to</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dev_bytenr_ref_to</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev_ref_from</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">dev_bytenr_ref_from</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hashval</span> <span class="o">=</span>
	    <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">dev_bytenr_ref_to</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">dev_bytenr_ref_from</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">bdev_ref_to</span><span class="p">))</span> <span class="o">^</span>
	     <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">bdev_ref_from</span><span class="p">)))</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">BTRFSIC_BLOCK_LINK_HASHTABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
			       <span class="n">collision_resolving_node</span><span class="p">);</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span> <span class="n">bdev_ref_to</span> <span class="o">&amp;&amp;</span>
		    <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">==</span> <span class="n">dev_bytenr_ref_to</span> <span class="o">&amp;&amp;</span>
		    <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span> <span class="n">bdev_ref_from</span> <span class="o">&amp;&amp;</span>
		    <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">==</span> <span class="n">dev_bytenr_ref_from</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dev_state_hashtable_init</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFSIC_DEV2STATE_HASHTABLE_SIZE</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">i</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dev_state_hashtable_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hashval</span> <span class="o">=</span>
	    <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">))</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">BTRFSIC_DEV2STATE_HASHTABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

	<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">hashval</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dev_state_hashtable_remove</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">collision_resolving_node</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="nf">btrfsic_dev_state_hashtable_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state_hashtable</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hashval</span> <span class="o">=</span>
	    <span class="p">(((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)((</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">bdev</span><span class="p">))</span> <span class="o">&amp;</span>
	     <span class="p">(</span><span class="n">BTRFSIC_DEV2STATE_HASHTABLE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">table</span> <span class="o">+</span> <span class="n">hashval</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="k">const</span> <span class="n">ds</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state</span><span class="p">,</span>
			       <span class="n">collision_resolving_node</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span> <span class="n">bdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ds</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_process_superblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				      <span class="k">struct</span> <span class="n">btrfs_fs_devices</span> <span class="o">*</span><span class="n">fs_devices</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">selected_super</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dev_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">selected_dev_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pass</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">state</span><span class="p">);</span>
	<span class="n">selected_super</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">selected_super</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">selected_super</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: error, kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">dev_head</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">||</span> <span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">dev_state</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_lookup</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dev_state</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BTRFS_SUPER_MIRROR_MAX</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_process_superblock_dev_mirror</span><span class="p">(</span>
					<span class="n">state</span><span class="p">,</span> <span class="n">dev_state</span><span class="p">,</span> <span class="n">device</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">selected_dev_state</span><span class="p">,</span> <span class="n">selected_super</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="mi">0</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
				<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: no superblock found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">state</span><span class="o">-&gt;</span><span class="n">csum_size</span> <span class="o">=</span> <span class="n">btrfs_super_csum_size</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">num_copies</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_root</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			    <span class="n">BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;root@%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_chunk_root</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			    <span class="n">BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;chunk@%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_log_root</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">next_bytenr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			    <span class="n">BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;log@%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">num_copies</span> <span class="o">=</span>
		    <span class="n">btrfs_num_copies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span>
				     <span class="n">next_bytenr</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_NUM_COPIES</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;num_copies(log_bytenr=%llu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span> <span class="n">num_copies</span><span class="p">);</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">mirror_num</span> <span class="o">&lt;=</span> <span class="n">num_copies</span><span class="p">;</span> <span class="n">mirror_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="n">tmp_next_block_ctx</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_bytenr</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
						<span class="n">mirror_num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic:&quot;</span>
				       <span class="s">&quot; btrfsic_map_block(root @%llu,&quot;</span>
				       <span class="s">&quot; mirror %d) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
				       <span class="n">mirror_num</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_block</span> <span class="o">=</span> <span class="n">btrfsic_block_hashtable_lookup</span><span class="p">(</span>
					<span class="n">tmp_next_block_ctx</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
					<span class="n">tmp_next_block_ctx</span><span class="p">.</span><span class="n">dev_bytenr</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next_block</span><span class="p">);</span>

			<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_hashtable_lookup</span><span class="p">(</span>
					<span class="n">tmp_next_block_ctx</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
					<span class="n">tmp_next_block_ctx</span><span class="p">.</span><span class="n">dev_bytenr</span><span class="p">,</span>
					<span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span>
					<span class="n">bdev</span><span class="p">,</span>
					<span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_link_hashtable</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_read_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: read @logical %llu failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">tmp_next_block_ctx</span><span class="p">.</span><span class="n">start</span><span class="p">);</span>
				<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">);</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_process_metablock</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
							<span class="n">next_block</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
							<span class="n">BTRFS_MAX_LEVEL</span> <span class="o">+</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">selected_super</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_process_superblock_dev_mirror</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">superblock_mirror_num</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">**</span><span class="n">selected_dev_state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">selected_super</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="n">super_tmp</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">superblock_tmp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pass</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="k">const</span> <span class="n">superblock_bdev</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>

	<span class="cm">/* super block bytenr is always the unmapped device bytenr */</span>
	<span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">btrfs_sb_offset</span><span class="p">(</span><span class="n">superblock_mirror_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">dev_bytenr</span> <span class="o">+</span> <span class="n">BTRFS_SUPER_INFO_SIZE</span> <span class="o">&gt;</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">total_bytes</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">__bread</span><span class="p">(</span><span class="n">superblock_bdev</span><span class="p">,</span> <span class="n">dev_bytenr</span> <span class="o">/</span> <span class="mi">4096</span><span class="p">,</span>
		     <span class="n">BTRFS_SUPER_INFO_SIZE</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">super_tmp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="p">)</span>
	    <span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span> <span class="p">(</span><span class="n">dev_bytenr</span> <span class="o">&amp;</span> <span class="mi">4095</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_super_bytenr</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">dev_bytenr</span> <span class="o">||</span>
	    <span class="n">strncmp</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">super_tmp</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">)),</span> <span class="n">BTRFS_MAGIC</span><span class="p">,</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="n">super_tmp</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">))</span> <span class="o">||</span>
	    <span class="n">memcmp</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">uuid</span><span class="p">,</span> <span class="n">super_tmp</span><span class="o">-&gt;</span><span class="n">dev_item</span><span class="p">.</span><span class="n">uuid</span><span class="p">,</span> <span class="n">BTRFS_UUID_SIZE</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">btrfs_super_nodesize</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span> <span class="o">||</span>
	    <span class="n">btrfs_super_leafsize</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span> <span class="o">||</span>
	    <span class="n">btrfs_super_sectorsize</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">)</span> <span class="o">!=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">superblock_tmp</span> <span class="o">=</span>
	    <span class="n">btrfsic_block_hashtable_lookup</span><span class="p">(</span><span class="n">superblock_bdev</span><span class="p">,</span>
					   <span class="n">dev_bytenr</span><span class="p">,</span>
					   <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">superblock_tmp</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">superblock_tmp</span> <span class="o">=</span> <span class="n">btrfsic_block_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">superblock_tmp</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: error, kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/* for superblock, only the dev_bytenr makes sense */</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">dev_bytenr</span><span class="p">;</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">dev_state</span> <span class="o">=</span> <span class="n">dev_state</span><span class="p">;</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="n">dev_bytenr</span><span class="p">;</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">);</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">is_superblock</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">never_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">superblock_mirror_num</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE</span><span class="p">)</span>
			<span class="n">printk_in_rcu</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;New initial S-block (bdev %p, %s)&quot;</span>
				     <span class="s">&quot; @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				     <span class="n">superblock_bdev</span><span class="p">,</span>
				     <span class="n">rcu_str_deref</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">),</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
				     <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
				     <span class="n">superblock_mirror_num</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">superblock_tmp</span><span class="o">-&gt;</span><span class="n">all_blocks_node</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">all_blocks_list</span><span class="p">);</span>
		<span class="n">btrfsic_block_hashtable_add</span><span class="p">(</span><span class="n">superblock_tmp</span><span class="p">,</span>
					    <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* select the one with the highest generation field */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span> <span class="o">||</span>
	    <span class="mi">0</span> <span class="o">==</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">selected_super</span><span class="p">,</span> <span class="n">super_tmp</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">selected_super</span><span class="p">));</span>
		<span class="o">*</span><span class="n">selected_dev_state</span> <span class="o">=</span> <span class="n">dev_state</span><span class="p">;</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span> <span class="o">=</span>
		    <span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span> <span class="o">=</span> <span class="n">superblock_tmp</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num_copies</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">additional_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">tmp_disk_key</span><span class="p">;</span>

		<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
		<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span>
			    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">BTRFS_ROOT_TREE_OBJECTID</span><span class="p">);</span>
			<span class="n">additional_string</span> <span class="o">=</span> <span class="s">&quot;initial root &quot;</span><span class="p">;</span>
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_root</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span>
			    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">BTRFS_CHUNK_TREE_OBJECTID</span><span class="p">);</span>
			<span class="n">additional_string</span> <span class="o">=</span> <span class="s">&quot;initial chunk &quot;</span><span class="p">;</span>
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_chunk_root</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span>
			    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">);</span>
			<span class="n">additional_string</span> <span class="o">=</span> <span class="s">&quot;initial log &quot;</span><span class="p">;</span>
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_log_root</span><span class="p">(</span><span class="n">super_tmp</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">next_bytenr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">num_copies</span> <span class="o">=</span>
		    <span class="n">btrfs_num_copies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span>
				     <span class="n">next_bytenr</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_NUM_COPIES</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;num_copies(log_bytenr=%llu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span> <span class="n">num_copies</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">mirror_num</span> <span class="o">&lt;=</span> <span class="n">num_copies</span><span class="p">;</span> <span class="n">mirror_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="n">tmp_next_block_ctx</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_bytenr</span><span class="p">,</span>
					      <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
					      <span class="n">mirror_num</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: btrfsic_map_block(&quot;</span>
				       <span class="s">&quot;bytenr @%llu, mirror %d) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
				       <span class="n">mirror_num</span><span class="p">);</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_block</span> <span class="o">=</span> <span class="n">btrfsic_block_lookup_or_add</span><span class="p">(</span>
					<span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
					<span class="n">additional_string</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					<span class="n">mirror_num</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next_block</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">);</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">disk_key</span> <span class="o">=</span> <span class="n">tmp_disk_key</span><span class="p">;</span>
			<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">BTRFSIC_GENERATION_UNKNOWN</span><span class="p">;</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_lookup_or_add</span><span class="p">(</span>
					<span class="n">state</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
					<span class="n">next_block</span><span class="p">,</span> <span class="n">superblock_tmp</span><span class="p">,</span>
					<span class="n">BTRFSIC_GENERATION_UNKNOWN</span><span class="p">);</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_INITIAL_ALL_TREES</span><span class="p">)</span>
		<span class="n">btrfsic_dump_tree_sub</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">superblock_tmp</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="nf">btrfsic_stack_frame_alloc</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>

	<span class="n">sf</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">sf</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">sf</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: alloc memory failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sf</span><span class="o">-&gt;</span><span class="n">magic</span> <span class="o">=</span> <span class="n">BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">sf</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_stack_frame_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="n">sf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">sf</span> <span class="o">||</span>
		 <span class="n">BTRFSIC_BLOCK_STACK_FRAME_MAGIC_NUMBER</span> <span class="o">==</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">magic</span><span class="p">));</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sf</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_process_metablock</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">first_block</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="k">const</span> <span class="n">first_block_ctx</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">first_limit_nesting</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_iodone_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="n">initial_stack_frame</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>
	<span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="n">sf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="n">next_stack</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="k">const</span> <span class="n">first_hdr</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span><span class="n">first_block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">first_hdr</span><span class="p">);</span>
	<span class="n">sf</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">initial_stack_frame</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit_nesting</span> <span class="o">=</span> <span class="n">first_limit_nesting</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">first_block</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span> <span class="o">=</span> <span class="n">first_block_ctx</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">first_hdr</span><span class="p">;</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

<span class="nl">continue_with_new_stack_frame:</span>
	<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="o">-&gt;</span><span class="n">level</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_leaf</span> <span class="o">*</span><span class="k">const</span> <span class="n">leafhdr</span> <span class="o">=</span>
		    <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_leaf</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sf</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">leafhdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nritems</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;leaf %llu items %d generation %llu&quot;</span>
				       <span class="s">&quot; owner %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				       <span class="n">sf</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">leafhdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">generation</span><span class="p">),</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">leafhdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">owner</span><span class="p">));</span>
		<span class="p">}</span>

<span class="nl">continue_with_current_leaf_stack_frame:</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span> <span class="o">||</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">&gt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_item</span> <span class="n">disk_item</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">disk_item_offset</span> <span class="o">=</span>
				<span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)(</span><span class="n">leafhdr</span><span class="o">-&gt;</span><span class="n">items</span> <span class="o">+</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span>
				<span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">leafhdr</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">disk_key</span><span class="p">;</span>
			<span class="n">u8</span> <span class="n">type</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">item_offset</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">disk_item_offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">)</span> <span class="o">&gt;</span>
			    <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
<span class="nl">leaf_item_out_of_bounce_error:</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: leaf item out of bounce at logical %llu, dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				       <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">btrfsic_read_from_block_data</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="p">,</span>
						     <span class="o">&amp;</span><span class="n">disk_item</span><span class="p">,</span>
						     <span class="n">disk_item_offset</span><span class="p">,</span>
						     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_item</span><span class="p">));</span>
			<span class="n">item_offset</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">disk_item</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">disk_key</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">disk_item</span><span class="p">.</span><span class="n">key</span><span class="p">;</span>
			<span class="n">type</span> <span class="o">=</span> <span class="n">disk_key</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_ROOT_ITEM_KEY</span> <span class="o">==</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">btrfs_root_item</span> <span class="n">root_item</span><span class="p">;</span>
				<span class="n">u32</span> <span class="n">root_item_offset</span><span class="p">;</span>
				<span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">;</span>

				<span class="n">root_item_offset</span> <span class="o">=</span> <span class="n">item_offset</span> <span class="o">+</span>
					<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_leaf</span><span class="p">,</span> <span class="n">items</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">root_item_offset</span> <span class="o">+</span>
				    <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root_item</span><span class="p">)</span> <span class="o">&gt;</span>
				    <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">leaf_item_out_of_bounce_error</span><span class="p">;</span>
				<span class="n">btrfsic_read_from_block_data</span><span class="p">(</span>
					<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root_item</span><span class="p">,</span>
					<span class="n">root_item_offset</span><span class="p">,</span>
					<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root_item</span><span class="p">));</span>
				<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">root_item</span><span class="p">.</span><span class="n">bytenr</span><span class="p">);</span>

				<span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span>
				    <span class="n">btrfsic_create_link_to_next_block</span><span class="p">(</span>
						<span class="n">state</span><span class="p">,</span>
						<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span>
						<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="p">,</span>
						<span class="n">next_bytenr</span><span class="p">,</span>
						<span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit_nesting</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block_ctx</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block</span><span class="p">,</span>
						<span class="n">force_iodone_flag</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
						<span class="n">disk_key</span><span class="p">,</span>
						<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">root_item</span><span class="p">.</span>
						<span class="n">generation</span><span class="p">));</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>

				<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="k">const</span> <span class="n">next_hdr</span> <span class="o">=</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block_ctx</span><span class="p">.</span><span class="n">datav</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

					<span class="n">next_stack</span> <span class="o">=</span>
					    <span class="n">btrfsic_stack_frame_alloc</span><span class="p">();</span>
					<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next_stack</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span>
								<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span>
								<span class="n">next_block_ctx</span><span class="p">);</span>
						<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>
					<span class="p">}</span>

					<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
					<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block</span><span class="p">;</span>
					<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">block_ctx</span> <span class="o">=</span>
					    <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block_ctx</span><span class="p">;</span>
					<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">next_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">next_hdr</span><span class="p">;</span>
					<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">limit_nesting</span> <span class="o">=</span>
					    <span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit_nesting</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
					<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">sf</span><span class="p">;</span>
					<span class="n">sf</span> <span class="o">=</span> <span class="n">next_stack</span><span class="p">;</span>
					<span class="k">goto</span> <span class="n">continue_with_new_stack_frame</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_EXTENT_DATA_KEY</span> <span class="o">==</span> <span class="n">type</span> <span class="o">&amp;&amp;</span>
				   <span class="n">state</span><span class="o">-&gt;</span><span class="n">include_extent_data</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">btrfsic_handle_extent_data</span><span class="p">(</span>
						<span class="n">state</span><span class="p">,</span>
						<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span>
						<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="p">,</span>
						<span class="n">item_offset</span><span class="p">,</span>
						<span class="n">force_iodone_flag</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">goto</span> <span class="n">continue_with_current_leaf_stack_frame</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_node</span> <span class="o">*</span><span class="k">const</span> <span class="n">nodehdr</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_node</span> <span class="o">*</span><span class="p">)</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">hdr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sf</span><span class="o">-&gt;</span><span class="n">nr</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">nodehdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">nritems</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;node %llu level %d items %d&quot;</span>
				       <span class="s">&quot; generation %llu owner %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				       <span class="n">nodehdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">level</span><span class="p">,</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">nodehdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">generation</span><span class="p">),</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">nodehdr</span><span class="o">-&gt;</span><span class="n">header</span><span class="p">.</span><span class="n">owner</span><span class="p">));</span>
		<span class="p">}</span>

<span class="nl">continue_with_current_node_stack_frame:</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span> <span class="o">||</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">&gt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
			<span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">nr</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfs_key_ptr</span> <span class="n">key_ptr</span><span class="p">;</span>
			<span class="n">u32</span> <span class="n">key_ptr_offset</span><span class="p">;</span>
			<span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">;</span>

			<span class="n">key_ptr_offset</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)(</span><span class="n">nodehdr</span><span class="o">-&gt;</span><span class="n">ptrs</span> <span class="o">+</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span>
					  <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">nodehdr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key_ptr_offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">)</span> <span class="o">&gt;</span>
			    <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: node item out of bounce at logical %llu, dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span>
				       <span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">btrfsic_read_from_block_data</span><span class="p">(</span>
				<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key_ptr</span><span class="p">,</span> <span class="n">key_ptr_offset</span><span class="p">,</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_key_ptr</span><span class="p">));</span>
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">key_ptr</span><span class="p">.</span><span class="n">blockptr</span><span class="p">);</span>

			<span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">btrfsic_create_link_to_next_block</span><span class="p">(</span>
					<span class="n">state</span><span class="p">,</span>
					<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">,</span>
					<span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="p">,</span>
					<span class="n">next_bytenr</span><span class="p">,</span>
					<span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit_nesting</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block_ctx</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block</span><span class="p">,</span>
					<span class="n">force_iodone_flag</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">num_copies</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">key_ptr</span><span class="p">.</span><span class="n">key</span><span class="p">,</span>
					<span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">key_ptr</span><span class="p">.</span><span class="n">generation</span><span class="p">));</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span>
				<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="k">const</span> <span class="n">next_hdr</span> <span class="o">=</span>
				    <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span>
				    <span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block_ctx</span><span class="p">.</span><span class="n">datav</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

				<span class="n">next_stack</span> <span class="o">=</span> <span class="n">btrfsic_stack_frame_alloc</span><span class="p">();</span>
				<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next_stack</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>

				<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
				<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block</span><span class="p">;</span>
				<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">block_ctx</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">next_block_ctx</span><span class="p">;</span>
				<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">next_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">hdr</span> <span class="o">=</span> <span class="n">next_hdr</span><span class="p">;</span>
				<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">limit_nesting</span> <span class="o">=</span>
				    <span class="n">sf</span><span class="o">-&gt;</span><span class="n">limit_nesting</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">next_stack</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">sf</span><span class="p">;</span>
				<span class="n">sf</span> <span class="o">=</span> <span class="n">next_stack</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">continue_with_new_stack_frame</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">goto</span> <span class="n">continue_with_current_node_stack_frame</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

<span class="nl">one_stack_frame_backwards:</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_stack_frame</span> <span class="o">*</span><span class="k">const</span> <span class="n">prev</span> <span class="o">=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>

		<span class="cm">/* the one for the initial block is freed in the caller */</span>
		<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">block_ctx</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">prev</span><span class="o">-&gt;</span><span class="n">error</span> <span class="o">=</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>
			<span class="n">btrfsic_stack_frame_free</span><span class="p">(</span><span class="n">sf</span><span class="p">);</span>
			<span class="n">sf</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">one_stack_frame_backwards</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">btrfsic_stack_frame_free</span><span class="p">(</span><span class="n">sf</span><span class="p">);</span>
		<span class="n">sf</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">continue_with_new_stack_frame</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">&amp;</span><span class="n">initial_stack_frame</span> <span class="o">!=</span> <span class="n">sf</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">sf</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_read_from_block_data</span><span class="p">(</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
	<span class="kt">void</span> <span class="o">*</span><span class="n">dstv</span><span class="p">,</span> <span class="n">u32</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">cur</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">offset_in_page</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">kaddr</span><span class="p">;</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">dst</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">dstv</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">start_offset</span> <span class="o">=</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">i</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_offset</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">&gt;</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
	<span class="n">offset_in_page</span> <span class="o">=</span> <span class="p">(</span><span class="n">start_offset</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span>
			 <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">cur</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">len</span><span class="p">,</span> <span class="p">((</span><span class="kt">size_t</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset_in_page</span><span class="p">));</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			    <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
		<span class="n">kaddr</span> <span class="o">=</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">memcpy</span><span class="p">(</span><span class="n">dst</span><span class="p">,</span> <span class="n">kaddr</span> <span class="o">+</span> <span class="n">offset_in_page</span><span class="p">,</span> <span class="n">cur</span><span class="p">);</span>

		<span class="n">dst</span> <span class="o">+=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="n">len</span> <span class="o">-=</span> <span class="n">cur</span><span class="p">;</span>
		<span class="n">offset_in_page</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_create_link_to_next_block</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">limit_nesting</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">next_block_ctx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">**</span><span class="n">next_blockp</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">force_iodone_flag</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">num_copiesp</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">mirror_nump</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="o">*</span><span class="n">disk_key</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">parent_generation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">did_alloc_block_link</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block_was_created</span><span class="p">;</span>

	<span class="o">*</span><span class="n">next_blockp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="o">*</span><span class="n">num_copiesp</span><span class="p">)</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">num_copiesp</span> <span class="o">=</span>
		    <span class="n">btrfs_num_copies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span>
				     <span class="n">next_bytenr</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_NUM_COPIES</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;num_copies(log_bytenr=%llu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span> <span class="o">*</span><span class="n">num_copiesp</span><span class="p">);</span>
		<span class="o">*</span><span class="n">mirror_nump</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">mirror_nump</span> <span class="o">&gt;</span> <span class="o">*</span><span class="n">num_copiesp</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic_create_link_to_next_block(mirror_num=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="o">*</span><span class="n">mirror_nump</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_bytenr</span><span class="p">,</span>
				<span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">,</span>
				<span class="n">next_block_ctx</span><span class="p">,</span> <span class="o">*</span><span class="n">mirror_nump</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: btrfsic_map_block(@%llu, mirror=%d) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span> <span class="o">*</span><span class="n">mirror_nump</span><span class="p">);</span>
		<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="n">next_block_ctx</span><span class="p">);</span>
		<span class="o">*</span><span class="n">next_blockp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">next_block</span> <span class="o">=</span> <span class="n">btrfsic_block_lookup_or_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
						 <span class="n">next_block_ctx</span><span class="p">,</span> <span class="s">&quot;referenced &quot;</span><span class="p">,</span>
						 <span class="mi">1</span><span class="p">,</span> <span class="n">force_iodone_flag</span><span class="p">,</span>
						 <span class="o">!</span><span class="n">force_iodone_flag</span><span class="p">,</span>
						 <span class="o">*</span><span class="n">mirror_nump</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">block_was_created</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next_block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="n">next_block_ctx</span><span class="p">);</span>
		<span class="o">*</span><span class="n">next_blockp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_was_created</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">BTRFSIC_GENERATION_UNKNOWN</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">!=</span> <span class="n">next_bytenr</span> <span class="o">&amp;&amp;</span>
		    <span class="o">!</span><span class="p">(</span><span class="o">!</span><span class="n">next_block</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">&amp;&amp;</span>
		      <span class="mi">0</span> <span class="o">==</span> <span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;Referenced block @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; found in hash table, %c,&quot;</span>
			       <span class="s">&quot; bytenr mismatch (!= stored %llu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
			       <span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="o">*</span><span class="n">mirror_nump</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_block</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;Referenced block @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; found in hash table, %c.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
			       <span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="o">*</span><span class="n">mirror_nump</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_block</span><span class="p">));</span>
		<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="n">next_bytenr</span><span class="p">;</span>

		<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="o">*</span><span class="n">mirror_nump</span><span class="p">;</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_hashtable_lookup</span><span class="p">(</span>
				<span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
				<span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
				<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
				<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_link_hashtable</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">disk_key</span> <span class="o">=</span> <span class="o">*</span><span class="n">disk_key</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: error, kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="n">next_block_ctx</span><span class="p">);</span>
			<span class="o">*</span><span class="n">next_blockp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">did_alloc_block_link</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span> <span class="o">=</span> <span class="n">next_block</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">parent_generation</span> <span class="o">=</span> <span class="n">parent_generation</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">btrfsic_print_add_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_block</span><span class="o">-&gt;</span><span class="n">ref_from_list</span><span class="p">);</span>

		<span class="n">btrfsic_block_link_hashtable_add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_link_hashtable</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">did_alloc_block_link</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">limit_nesting</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="o">++</span><span class="p">;</span>
			<span class="n">l</span><span class="o">-&gt;</span><span class="n">parent_generation</span> <span class="o">=</span> <span class="n">parent_generation</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">btrfsic_print_add_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">limit_nesting</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">did_alloc_block_link</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_read_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_block_ctx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: read block @logical %llu failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">);</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="n">next_block_ctx</span><span class="p">);</span>
			<span class="o">*</span><span class="n">next_blockp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="o">*</span><span class="n">next_blockp</span> <span class="o">=</span> <span class="n">next_block</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="o">*</span><span class="n">next_blockp</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="p">(</span><span class="o">*</span><span class="n">mirror_nump</span><span class="p">)</span><span class="o">++</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_handle_extent_data</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
		<span class="n">u32</span> <span class="n">item_offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">force_iodone_flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="n">file_extent_item</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">file_extent_item_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">generation</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="n">file_extent_item_offset</span> <span class="o">=</span> <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_leaf</span><span class="p">,</span> <span class="n">items</span><span class="p">)</span> <span class="o">+</span>
				  <span class="n">item_offset</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file_extent_item_offset</span> <span class="o">+</span>
	    <span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">,</span> <span class="n">disk_num_bytes</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: file item out of bounce at logical %llu, dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">btrfsic_read_from_block_data</span><span class="p">(</span><span class="n">block_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_extent_item</span><span class="p">,</span>
		<span class="n">file_extent_item_offset</span><span class="p">,</span>
		<span class="n">offsetof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">,</span> <span class="n">disk_num_bytes</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">!=</span> <span class="n">file_extent_item</span><span class="p">.</span><span class="n">type</span> <span class="o">||</span>
	    <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">disk_bytenr</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERY_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;extent_data: type %u, disk_bytenr = %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">file_extent_item</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">disk_bytenr</span><span class="p">));</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">file_extent_item_offset</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">)</span> <span class="o">&gt;</span>
	    <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: file item out of bounce at logical %llu, dev %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">btrfsic_read_from_block_data</span><span class="p">(</span><span class="n">block_ctx</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">file_extent_item</span><span class="p">,</span>
				     <span class="n">file_extent_item_offset</span><span class="p">,</span>
				     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">));</span>
	<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">disk_bytenr</span><span class="p">)</span> <span class="o">+</span>
		      <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
	<span class="n">generation</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">generation</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">num_bytes</span><span class="p">);</span>
	<span class="n">generation</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">generation</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERY_VERBOSE</span><span class="p">)</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;extent_data: type %u, disk_bytenr = %llu,&quot;</span>
		       <span class="s">&quot; offset = %llu, num_bytes = %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">file_extent_item</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
		       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">disk_bytenr</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">file_extent_item</span><span class="p">.</span><span class="n">offset</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">num_bytes</span><span class="p">);</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">chunk_len</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num_copies</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">num_bytes</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span><span class="p">)</span>
			<span class="n">chunk_len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">chunk_len</span> <span class="o">=</span> <span class="n">num_bytes</span><span class="p">;</span>

		<span class="n">num_copies</span> <span class="o">=</span>
		    <span class="n">btrfs_num_copies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span>
				     <span class="n">next_bytenr</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_NUM_COPIES</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;num_copies(log_bytenr=%llu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span> <span class="n">num_copies</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">mirror_num</span> <span class="o">&lt;=</span> <span class="n">num_copies</span><span class="p">;</span> <span class="n">mirror_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="n">next_block_ctx</span><span class="p">;</span>
			<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">;</span>
			<span class="kt">int</span> <span class="n">block_was_created</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic_handle_extent_data(&quot;</span>
				       <span class="s">&quot;mirror_num=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERY_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;</span><span class="se">\t</span><span class="s">disk_bytenr = %llu, num_bytes %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
				       <span class="n">chunk_len</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_bytenr</span><span class="p">,</span>
						<span class="n">chunk_len</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_block_ctx</span><span class="p">,</span>
						<span class="n">mirror_num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: btrfsic_map_block(@%llu,&quot;</span>
				       <span class="s">&quot; mirror=%d) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
				       <span class="n">mirror_num</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_block</span> <span class="o">=</span> <span class="n">btrfsic_block_lookup_or_add</span><span class="p">(</span>
					<span class="n">state</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">next_block_ctx</span><span class="p">,</span>
					<span class="s">&quot;referenced &quot;</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span>
					<span class="n">force_iodone_flag</span><span class="p">,</span>
					<span class="o">!</span><span class="n">force_iodone_flag</span><span class="p">,</span>
					<span class="n">mirror_num</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">block_was_created</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next_block</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: error, kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_block_ctx</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_was_created</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">!=</span> <span class="n">next_bytenr</span> <span class="o">&amp;&amp;</span>
				    <span class="o">!</span><span class="p">(</span><span class="o">!</span><span class="n">next_block</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">&amp;&amp;</span>
				      <span class="mi">0</span> <span class="o">==</span> <span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">))</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
					       <span class="s">&quot;Referenced block&quot;</span>
					       <span class="s">&quot; @%llu (%s/%llu/%d)&quot;</span>
					       <span class="s">&quot; found in hash table, D,&quot;</span>
					       <span class="s">&quot; bytenr mismatch&quot;</span>
					       <span class="s">&quot; (!= stored %llu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
					       <span class="n">next_block_ctx</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
					       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
					       <span class="n">next_block_ctx</span><span class="p">.</span><span class="n">dev_bytenr</span><span class="p">,</span>
					       <span class="n">mirror_num</span><span class="p">,</span>
					       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
					       <span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="n">next_bytenr</span><span class="p">;</span>
				<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="n">mirror_num</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_lookup_or_add</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
							     <span class="o">&amp;</span><span class="n">next_block_ctx</span><span class="p">,</span>
							     <span class="n">next_block</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
							     <span class="n">generation</span><span class="p">);</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">next_block_ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">next_bytenr</span> <span class="o">+=</span> <span class="n">chunk_len</span><span class="p">;</span>
		<span class="n">num_bytes</span> <span class="o">-=</span> <span class="n">chunk_len</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_map_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u32</span> <span class="n">len</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx_out</span><span class="p">,</span>
			     <span class="kt">int</span> <span class="n">mirror_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">length</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_bio</span> <span class="o">*</span><span class="n">multi</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="n">length</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_map_block</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span> <span class="n">READ</span><span class="p">,</span>
			      <span class="n">bytenr</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">length</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">multi</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">);</span>

	<span class="n">device</span> <span class="o">=</span> <span class="n">multi</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">dev</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_lookup</span><span class="p">(</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">multi</span><span class="o">-&gt;</span><span class="n">stripes</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">physical</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">datav</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">mem_to_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">ret</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">multi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: error, cannot lookup dev (#1)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_map_superblock</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
				  <span class="n">u32</span> <span class="n">len</span><span class="p">,</span> <span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">dev</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_lookup</span><span class="p">(</span><span class="n">bdev</span><span class="p">);</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">len</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">datav</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">mem_to_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">block_ctx_out</span><span class="o">-&gt;</span><span class="n">dev</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: error, cannot lookup dev (#2)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_release_block_ctx</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">mem_to_free</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">;</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">);</span>
		<span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
			    <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">num_pages</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">[</span><span class="n">num_pages</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">kunmap</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">num_pages</span><span class="p">]);</span>
				<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">[</span><span class="n">num_pages</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">num_pages</span><span class="p">])</span> <span class="p">{</span>
				<span class="n">__free_page</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">num_pages</span><span class="p">]);</span>
				<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">num_pages</span><span class="p">]</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">kfree</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">mem_to_free</span><span class="p">);</span>
		<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">mem_to_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_read_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">mem_to_free</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: read_block() with unaligned bytenr %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">+</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
		    <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">mem_to_free</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">((</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">)</span> <span class="o">+</span>
					  <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">))</span> <span class="o">*</span>
					 <span class="n">num_pages</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">mem_to_free</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span> <span class="o">=</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">mem_to_free</span><span class="p">;</span>
	<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="p">)(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span> <span class="o">+</span> <span class="n">num_pages</span><span class="p">);</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">alloc_page</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">;</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
		<span class="n">DECLARE_COMPLETION_ONSTACK</span><span class="p">(</span><span class="n">complete</span><span class="p">);</span>

		<span class="n">bio</span> <span class="o">=</span> <span class="n">bio_alloc</span><span class="p">(</span><span class="n">GFP_NOFS</span><span class="p">,</span> <span class="n">num_pages</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: bio_alloc() for %u pages failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">num_pages</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span> <span class="o">=</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span> <span class="o">=</span> <span class="n">dev_bytenr</span> <span class="o">&gt;&gt;</span> <span class="mi">9</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfsic_complete_bio_end_io</span><span class="p">;</span>
		<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">complete</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">bio_add_page</span><span class="p">(</span><span class="n">bio</span><span class="p">,</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">j</span><span class="p">],</span>
					   <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: error, failed to add a single page!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">submit_bio</span><span class="p">(</span><span class="n">READ</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>

		<span class="cm">/* this will also unplug the queue */</span>
		<span class="n">wait_for_completion</span><span class="p">(</span><span class="o">&amp;</span><span class="n">complete</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BIO_UPTODATE</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: read error at logical %llu dev %s!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">,</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">bio_put</span><span class="p">(</span><span class="n">bio</span><span class="p">);</span>
		<span class="n">dev_bytenr</span> <span class="o">+=</span> <span class="p">(</span><span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">;</span>
		<span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">pagev</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">datav</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: kmap() failed (dev %s)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_complete_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="n">err</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">complete</span><span class="p">((</span><span class="k">struct</span> <span class="n">completion</span> <span class="o">*</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dump_database</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_all</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">state</span><span class="p">);</span>

	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;all_blocks_list:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">all_blocks_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">b_all</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_all</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_block</span><span class="p">,</span>
			       <span class="n">all_blocks_node</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_ref_to</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_ref_from</span><span class="p">;</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;%c-block @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">b_all</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
		       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
		       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>

		<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
			    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
				       <span class="n">node_ref_to</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot; %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; refers %u* to&quot;</span>
			       <span class="s">&quot; %c @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">b_all</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem_ref_from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">ref_from_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
			    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_ref_from</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
				       <span class="n">node_ref_from</span><span class="p">);</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot; %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; is ref %u* from&quot;</span>
			       <span class="s">&quot; %c @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">b_all</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Test whether the disk block contains a tree block (leaf or node)</span>
<span class="cm"> * (note that this test fails for the super block)</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_test_for_metadata</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				     <span class="kt">char</span> <span class="o">**</span><span class="n">datav</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="n">h</span><span class="p">;</span>
	<span class="n">u8</span> <span class="n">csum</span><span class="p">[</span><span class="n">BTRFS_CSUM_SIZE</span><span class="p">];</span>
	<span class="n">u32</span> <span class="n">crc</span> <span class="o">=</span> <span class="o">~</span><span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">*</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&lt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* not metadata */</span>
	<span class="n">num_pages</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">h</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span><span class="n">datav</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fsid</span><span class="p">,</span> <span class="n">BTRFS_UUID_SIZE</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u8</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="n">i</span> <span class="o">?</span> <span class="n">datav</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">:</span> <span class="p">(</span><span class="n">datav</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">sublen</span> <span class="o">=</span> <span class="n">i</span> <span class="o">?</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">:</span>
				    <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">BTRFS_CSUM_SIZE</span><span class="p">);</span>

		<span class="n">crc</span> <span class="o">=</span> <span class="n">crc32c</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">sublen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">btrfs_csum_final</span><span class="p">(</span><span class="n">crc</span><span class="p">,</span> <span class="n">csum</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">memcmp</span><span class="p">(</span><span class="n">csum</span><span class="p">,</span> <span class="n">h</span><span class="o">-&gt;</span><span class="n">csum</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">csum_size</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* is metadata */</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_process_written_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">,</span>
					  <span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">mapped_datav</span><span class="p">,</span>
					  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">bio_is_patched</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
					  <span class="kt">int</span> <span class="n">submit_bio_bh_rw</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">is_metadata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="n">block_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span> <span class="o">=</span> <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">processed_len</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">bio_is_patched</span><span class="p">)</span>
		<span class="o">*</span><span class="n">bio_is_patched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">processed_len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">is_metadata</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">btrfsic_test_for_metadata</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">mapped_datav</span><span class="p">,</span>
						      <span class="n">num_pages</span><span class="p">));</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">btrfsic_block_hashtable_lookup</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span> <span class="n">dev_bytenr</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">bytenr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_ref_to</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp_ref_to</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_superblock</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">bytenr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="p">)</span>
					      <span class="n">mapped_datav</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">*</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&lt;</span>
			    <span class="n">BTRFS_SUPER_INFO_SIZE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: cannot work with too short bios!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">is_metadata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">BTRFS_SUPER_INFO_SIZE</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>
			<span class="n">processed_len</span> <span class="o">=</span> <span class="n">BTRFS_SUPER_INFO_SIZE</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			    <span class="n">BTRFSIC_PRINT_MASK_TREE_BEFORE_SB_WRITE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;[before new superblock is written]:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">btrfsic_dump_tree_sub</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_metadata</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_superblock</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">*</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&lt;</span>
				    <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
					       <span class="s">&quot;btrfsic: cannot work with too short bios!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="k">return</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="n">processed_len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">;</span>
				<span class="n">bytenr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span>
						      <span class="n">mapped_datav</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">);</span>
				<span class="n">btrfsic_cmp_log_and_dev_bytenr</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
							       <span class="n">dev_state</span><span class="p">,</span>
							       <span class="n">dev_bytenr</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">!=</span> <span class="n">bytenr</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;Written block @%llu (%s/%llu/%d)&quot;</span>
				       <span class="s">&quot; found in hash table, %c,&quot;</span>
				       <span class="s">&quot; bytenr mismatch&quot;</span>
				       <span class="s">&quot; (!= stored %llu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
				       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
				       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">);</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
				   <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;Written block @%llu (%s/%llu/%d)&quot;</span>
				       <span class="s">&quot; found in hash table, %c.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
				       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
				       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">));</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">*</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">&lt;</span>
			    <span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: cannot work with too short bios!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">return</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">processed_len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span><span class="p">;</span>
			<span class="n">bytenr</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;Written block @%llu (%s/%llu/%d)&quot;</span>
				       <span class="s">&quot; found in hash table, %c.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
				       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
				       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">));</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;ref_to_list: %cE, ref_from_list: %cE</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">,</span>
			       <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_from_list</span><span class="p">)</span> <span class="o">?</span> <span class="sc">&#39; &#39;</span> <span class="o">:</span> <span class="sc">&#39;!&#39;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">btrfsic_is_block_ref_by_superblock</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to overwrite %c-block&quot;</span>
			       <span class="s">&quot; @%llu (%s/%llu/%d), old(gen=%llu,&quot;</span>
			       <span class="s">&quot; objectid=%llu, type=%d, offset=%llu),&quot;</span>
			       <span class="s">&quot; new(gen=%llu),&quot;</span>
			       <span class="s">&quot; which is referenced by most recent superblock&quot;</span>
			       <span class="s">&quot; (superblockgen=%llu)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
			       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">disk_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">),</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">disk_key</span><span class="p">.</span><span class="n">type</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">disk_key</span><span class="p">.</span><span class="n">offset</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">le64_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">mapped_datav</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span><span class="p">);</span>
			<span class="n">btrfsic_dump_tree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">never_written</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to overwrite %c-block&quot;</span>
			       <span class="s">&quot; @%llu (%s/%llu/%d), oldgen=%llu, newgen=%llu,&quot;</span>
			       <span class="s">&quot; which is not yet iodone!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
			       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">le64_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">mapped_datav</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">));</span>
			<span class="cm">/* it would not be safe to go on */</span>
			<span class="n">btrfsic_dump_tree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">continue_loop</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * Clear all references of this block. Do not free</span>
<span class="cm">		 * the block itself even if is not referenced anymore</span>
<span class="cm">		 * because it still carries valueable information</span>
<span class="cm">		 * like whether it was ever written and IO completed.</span>
<span class="cm">		 */</span>
		<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span> <span class="n">tmp_ref_to</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
			    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
				       <span class="n">node_ref_to</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">btrfsic_print_rem_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
			<span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_to</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_from</span><span class="p">);</span>
				<span class="n">btrfsic_block_link_hashtable_remove</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
				<span class="n">btrfsic_block_link_free</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_superblock</span><span class="p">)</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_superblock</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
						     <span class="n">processed_len</span><span class="p">,</span>
						     <span class="n">bdev</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">processed_len</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: btrfsic_map_block(root @%llu)&quot;</span>
			       <span class="s">&quot; failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">continue_loop</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">block_ctx</span><span class="p">.</span><span class="n">datav</span> <span class="o">=</span> <span class="n">mapped_datav</span><span class="p">;</span>
		<span class="cm">/* the following is required in case of writes to mirrors,</span>
<span class="cm">		 * use the same that was used for the lookup */</span>
		<span class="n">block_ctx</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_state</span><span class="p">;</span>
		<span class="n">block_ctx</span><span class="p">.</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">dev_bytenr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_metadata</span> <span class="o">||</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">include_extent_data</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">never_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">iodone_w_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">bio_is_patched</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">bio_is_patched</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span>
					    <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
					<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span>
					    <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">;</span>
					<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
					<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfsic_bio_end_io</span><span class="p">;</span>
					<span class="o">*</span><span class="n">bio_is_patched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">chained_block</span> <span class="o">=</span>
					    <span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="p">)</span>
					    <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

					<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">chained_block</span><span class="p">);</span>
					<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span>
					    <span class="n">chained_block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span><span class="p">;</span>
					<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span>
					    <span class="n">chained_block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span>
					    <span class="n">bio</span><span class="p">;</span>
					<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="n">chained_block</span><span class="p">;</span>
					<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
				<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">btrfsic_bh_end_io</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">block</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">=</span> <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">=</span> <span class="n">submit_bio_bh_rw</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">is_metadata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_superblock</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">!=</span>
				       <span class="n">BTRFS_SUPER_INFO_SIZE</span><span class="p">);</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_process_written_superblock</span><span class="p">(</span>
						<span class="n">state</span><span class="p">,</span>
						<span class="n">block</span><span class="p">,</span>
						<span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="p">)</span>
						<span class="n">mapped_datav</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
				    <span class="n">BTRFSIC_PRINT_MASK_TREE_AFTER_SB_WRITE</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
					<span class="s">&quot;[after new superblock is written]:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
					<span class="n">btrfsic_dump_tree_sub</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* unknown */</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_process_metablock</span><span class="p">(</span>
						<span class="n">state</span><span class="p">,</span>
						<span class="n">block</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">,</span>
						<span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: btrfsic_process_metablock&quot;</span>
				       <span class="s">&quot;(root @%llu) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* unknown */</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">BTRFSIC_GENERATION_UNKNOWN</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">include_extent_data</span>
			    <span class="o">&amp;&amp;</span> <span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_from_list</span><span class="p">))</span> <span class="p">{</span>
				<span class="cm">/*</span>
<span class="cm">				 * disk block is overwritten with extent</span>
<span class="cm">				 * data (not meta data) and we are configured</span>
<span class="cm">				 * to not include extent data: take the</span>
<span class="cm">				 * chance and free the block&#39;s memory</span>
<span class="cm">				 */</span>
				<span class="n">btrfsic_block_hashtable_remove</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
				<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">all_blocks_node</span><span class="p">);</span>
				<span class="n">btrfsic_block_free</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* block has not been found in hash table */</span>
		<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_metadata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">processed_len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Written block (%s/%llu/?)&quot;</span>
				       <span class="s">&quot; !found in hash table, D.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">include_extent_data</span><span class="p">)</span> <span class="p">{</span>
				<span class="cm">/* ignore that written D block */</span>
				<span class="k">goto</span> <span class="n">continue_loop</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="cm">/* this is getting ugly for the</span>
<span class="cm">			 * include_extent_data case... */</span>
			<span class="n">bytenr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* unknown */</span>
			<span class="n">block_ctx</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
			<span class="n">block_ctx</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="n">processed_len</span><span class="p">;</span>
			<span class="n">block_ctx</span><span class="p">.</span><span class="n">mem_to_free</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">block_ctx</span><span class="p">.</span><span class="n">pagev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">processed_len</span> <span class="o">=</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">;</span>
			<span class="n">bytenr</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(((</span><span class="k">struct</span> <span class="n">btrfs_header</span> <span class="o">*</span><span class="p">)</span>
					      <span class="n">mapped_datav</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">bytenr</span><span class="p">);</span>
			<span class="n">btrfsic_cmp_log_and_dev_bytenr</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">dev_state</span><span class="p">,</span>
						       <span class="n">dev_bytenr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;Written block @%llu (%s/%llu/?)&quot;</span>
				       <span class="s">&quot; !found in hash table, M.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">);</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">processed_len</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: btrfsic_map_block(root @%llu)&quot;</span>
				       <span class="s">&quot; failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">continue_loop</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
		<span class="n">block_ctx</span><span class="p">.</span><span class="n">datav</span> <span class="o">=</span> <span class="n">mapped_datav</span><span class="p">;</span>
		<span class="cm">/* the following is required in case of writes to mirrors,</span>
<span class="cm">		 * use the same that was used for the lookup */</span>
		<span class="n">block_ctx</span><span class="p">.</span><span class="n">dev</span> <span class="o">=</span> <span class="n">dev_state</span><span class="p">;</span>
		<span class="n">block_ctx</span><span class="p">.</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">dev_bytenr</span><span class="p">;</span>

		<span class="n">block</span> <span class="o">=</span> <span class="n">btrfsic_block_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: error, kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">continue_loop</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span> <span class="o">=</span> <span class="n">dev_state</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">dev_bytenr</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="n">bytenr</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">=</span> <span class="n">is_metadata</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">never_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">iodone_w_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>	<span class="cm">/* unknown */</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">=</span> <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">=</span> <span class="n">submit_bio_bh_rw</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">bio</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">bio_is_patched</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">bio_is_patched</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
				<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
				<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfsic_bio_end_io</span><span class="p">;</span>
				<span class="o">*</span><span class="n">bio_is_patched</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">chained_block</span> <span class="o">=</span>
				    <span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="p">)</span>
				    <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>

				<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">chained_block</span><span class="p">);</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span>
				    <span class="n">chained_block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span>
				    <span class="n">chained_block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span><span class="p">;</span>
				<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="n">chained_block</span><span class="p">;</span>
				<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">btrfsic_bh_end_io</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;New written %c-block @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">is_metadata</span> <span class="o">?</span> <span class="sc">&#39;M&#39;</span> <span class="o">:</span> <span class="sc">&#39;D&#39;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">all_blocks_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">all_blocks_list</span><span class="p">);</span>
		<span class="n">btrfsic_block_hashtable_add</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">is_metadata</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_process_metablock</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: process_metablock(root @%llu)&quot;</span>
				       <span class="s">&quot; failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">continue_loop:</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">processed_len</span><span class="p">);</span>
	<span class="n">dev_bytenr</span> <span class="o">+=</span> <span class="n">processed_len</span><span class="p">;</span>
	<span class="n">mapped_datav</span> <span class="o">+=</span> <span class="n">processed_len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="n">num_pages</span> <span class="o">-=</span> <span class="n">processed_len</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_bio_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bp</span><span class="p">,</span> <span class="kt">int</span> <span class="n">bio_error_status</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="p">)</span><span class="n">bp</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iodone_w_error</span><span class="p">;</span>

	<span class="cm">/* mutex is not held! This is not save if IO is not yet completed</span>
<span class="cm">	 * on umount */</span>
	<span class="n">iodone_w_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">bio_error_status</span><span class="p">)</span>
		<span class="n">iodone_w_error</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span><span class="p">;</span>
	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span><span class="p">;</span>

	<span class="k">do</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="k">const</span> <span class="n">dev_state</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">((</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
		     <span class="n">BTRFSIC_PRINT_MASK_END_IO_BIO_BH</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;bio_end_io(err=%d) for %c @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">bio_error_status</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="n">next_block</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">iodone_w_error</span> <span class="o">=</span> <span class="n">iodone_w_error</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span><span class="o">++</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			     <span class="n">BTRFSIC_PRINT_MASK_END_IO_BIO_BH</span><span class="p">))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;bio_end_io() new %s flush_gen=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">)</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* FUA completed means block is</span>
<span class="cm">					       * on disk */</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* for FLUSH, this releases the block */</span>
		<span class="n">block</span> <span class="o">=</span> <span class="n">next_block</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">block</span><span class="p">);</span>

	<span class="n">bp</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">(</span><span class="n">bp</span><span class="p">,</span> <span class="n">bio_error_status</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_bh_end_io</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span> <span class="kt">int</span> <span class="n">uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">iodone_w_error</span> <span class="o">=</span> <span class="o">!</span><span class="n">uptodate</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">block</span><span class="p">);</span>
	<span class="n">dev_state</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_END_IO_BIO_BH</span><span class="p">))</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;bh_end_io(error=%d) for %c @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">iodone_w_error</span><span class="p">,</span>
		       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
		       <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
		       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>

	<span class="n">block</span><span class="o">-&gt;</span><span class="n">iodone_w_error</span> <span class="o">=</span> <span class="n">iodone_w_error</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span><span class="o">++</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">((</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
		     <span class="n">BTRFSIC_PRINT_MASK_END_IO_BIO_BH</span><span class="p">))</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;bh_end_io() new %s flush_gen=%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">&amp;</span> <span class="n">REQ_FUA</span><span class="p">)</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="cm">/* FUA completed means block is on disk */</span>

	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span><span class="p">;</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bh</span><span class="p">;</span>
	<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="cm">/* for FLUSH, this releases the block */</span>
	<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span><span class="p">(</span><span class="n">bh</span><span class="p">,</span> <span class="n">uptodate</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_process_written_superblock</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">superblock</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfs_super_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">super_hdr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">pass</span><span class="p">;</span>

	<span class="n">superblock</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">super_hdr</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">superblock</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">&gt;</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span> <span class="o">||</span>
	      <span class="mi">0</span> <span class="o">==</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: superblock @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; with old gen %llu &lt;= %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">superblock</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">superblock</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">superblock</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">superblock</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">super_hdr</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_SUPERBLOCK_WRITE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: got new superblock @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; with new gen %llu &gt; %llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">superblock</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">superblock</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">superblock</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">superblock</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">super_hdr</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span><span class="p">);</span>

		<span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span> <span class="o">=</span>
		    <span class="n">btrfs_super_generation</span><span class="p">(</span><span class="n">super_hdr</span><span class="p">);</span>
		<span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span> <span class="o">=</span> <span class="n">superblock</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">pass</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">pass</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">pass</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">next_bytenr</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="n">tmp_next_block_ctx</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">num_copies</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">;</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">additional_string</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">btrfs_disk_key</span> <span class="n">tmp_disk_key</span><span class="p">;</span>

		<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">;</span>
		<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="k">switch</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="mi">0</span>:
			<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span>
			    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">BTRFS_ROOT_TREE_OBJECTID</span><span class="p">);</span>
			<span class="n">additional_string</span> <span class="o">=</span> <span class="s">&quot;root &quot;</span><span class="p">;</span>
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_root</span><span class="p">(</span><span class="n">super_hdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			    <span class="n">BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;root@%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">1</span>:
			<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span>
			    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">BTRFS_CHUNK_TREE_OBJECTID</span><span class="p">);</span>
			<span class="n">additional_string</span> <span class="o">=</span> <span class="s">&quot;chunk &quot;</span><span class="p">;</span>
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_chunk_root</span><span class="p">(</span><span class="n">super_hdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			    <span class="n">BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;chunk@%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="mi">2</span>:
			<span class="n">tmp_disk_key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span>
			    <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">BTRFS_TREE_LOG_OBJECTID</span><span class="p">);</span>
			<span class="n">additional_string</span> <span class="o">=</span> <span class="s">&quot;log &quot;</span><span class="p">;</span>
			<span class="n">next_bytenr</span> <span class="o">=</span> <span class="n">btrfs_super_log_root</span><span class="p">(</span><span class="n">super_hdr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">next_bytenr</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			    <span class="n">BTRFSIC_PRINT_MASK_ROOT_CHUNK_LOG_TREE_LOCATION</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;log@%llu</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">num_copies</span> <span class="o">=</span>
		    <span class="n">btrfs_num_copies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span>
				     <span class="n">next_bytenr</span><span class="p">,</span> <span class="n">BTRFS_SUPER_INFO_SIZE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_NUM_COPIES</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;num_copies(log_bytenr=%llu) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span> <span class="n">num_copies</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">mirror_num</span> <span class="o">&lt;=</span> <span class="n">num_copies</span><span class="p">;</span> <span class="n">mirror_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="kt">int</span> <span class="n">was_created</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic_process_written_superblock(&quot;</span>
				       <span class="s">&quot;mirror_num=%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">next_bytenr</span><span class="p">,</span>
						<span class="n">BTRFS_SUPER_INFO_SIZE</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
						<span class="n">mirror_num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: btrfsic_map_block(@%llu,&quot;</span>
				       <span class="s">&quot; mirror=%d) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">next_bytenr</span><span class="p">,</span>
				       <span class="n">mirror_num</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_block</span> <span class="o">=</span> <span class="n">btrfsic_block_lookup_or_add</span><span class="p">(</span>
					<span class="n">state</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
					<span class="n">additional_string</span><span class="p">,</span>
					<span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
					<span class="n">mirror_num</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">was_created</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next_block</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic: error, kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">disk_key</span> <span class="o">=</span> <span class="n">tmp_disk_key</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">was_created</span><span class="p">)</span>
				<span class="n">next_block</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span>
				    <span class="n">BTRFSIC_GENERATION_UNKNOWN</span><span class="p">;</span>
			<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_lookup_or_add</span><span class="p">(</span>
					<span class="n">state</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">,</span>
					<span class="n">next_block</span><span class="p">,</span>
					<span class="n">superblock</span><span class="p">,</span>
					<span class="n">BTRFSIC_GENERATION_UNKNOWN</span><span class="p">);</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp_next_block_ctx</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">btrfsic_check_all_ref_blocks</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">superblock</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
		<span class="n">btrfsic_dump_tree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_check_all_ref_blocks</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">block</span><span class="p">,</span>
					<span class="kt">int</span> <span class="n">recursion_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_ref_to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">recursion_level</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Note that this situation can happen and does not</span>
<span class="cm">		 * indicate an error in regular cases. It happens</span>
<span class="cm">		 * when disk blocks are freed and later reused.</span>
<span class="cm">		 * The check-integrity module is not aware of any</span>
<span class="cm">		 * block free operations, it just recognizes block</span>
<span class="cm">		 * write operations. Therefore it keeps the linkage</span>
<span class="cm">		 * information for a block until a block is</span>
<span class="cm">		 * rewritten. This can temporarily cause incorrect</span>
<span class="cm">		 * and even circular linkage informations. This</span>
<span class="cm">		 * causes no harm unless such blocks are referenced</span>
<span class="cm">		 * by the most recent super block.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: abort cyclic linkage (case 1).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This algorithm is recursive because the amount of used stack</span>
<span class="cm">	 * space is very small and the max recursion depth is limited.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
			       <span class="n">node_ref_to</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;rl=%d, %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; %u* refers to %c @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">recursion_level</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">never_written</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to write superblock&quot;</span>
			       <span class="s">&quot; which references block %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; which is never written!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">is_iodone</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to write superblock&quot;</span>
			       <span class="s">&quot; which references block %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; which is not yet iodone!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">parent_generation</span> <span class="o">!=</span>
			   <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">&amp;&amp;</span>
			   <span class="n">BTRFSIC_GENERATION_UNKNOWN</span> <span class="o">!=</span>
			   <span class="n">l</span><span class="o">-&gt;</span><span class="n">parent_generation</span> <span class="o">&amp;&amp;</span>
			   <span class="n">BTRFSIC_GENERATION_UNKNOWN</span> <span class="o">!=</span>
			   <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to write superblock&quot;</span>
			       <span class="s">&quot; which references block %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; with generation %llu !=&quot;</span>
			       <span class="s">&quot; parent generation %llu!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">parent_generation</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">&gt;</span>
			   <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to write superblock&quot;</span>
			       <span class="s">&quot; which references block %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; which is not flushed out of disk&#39;s write cache&quot;</span>
			       <span class="s">&quot; (block flush_gen=%llu,&quot;</span>
			       <span class="s">&quot; dev-&gt;flush_gen=%llu)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">flush_gen</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span> <span class="o">==</span> <span class="n">btrfsic_check_all_ref_blocks</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
							      <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">,</span>
							      <span class="n">recursion_level</span> <span class="o">+</span>
							      <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfsic_is_block_ref_by_superblock</span><span class="p">(</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">recursion_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_ref_from</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">recursion_level</span> <span class="o">&gt;=</span> <span class="mi">3</span> <span class="o">+</span> <span class="n">BTRFS_MAX_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* refer to comment at &quot;abort cyclic linkage (case 1)&quot; */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: abort cyclic linkage (case 2).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * This algorithm is recursive because the amount of used stack space</span>
<span class="cm">	 * is very small and the max recursion depth is limited.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem_ref_from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_from_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_ref_from</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
			       <span class="n">node_ref_from</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;rl=%d, %c @%llu (%s/%llu/%d)&quot;</span>
			       <span class="s">&quot; is ref %u* from %c @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">recursion_level</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">is_superblock</span> <span class="o">&amp;&amp;</span>
		    <span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">==</span>
		    <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">&amp;&amp;</span>
		    <span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span>
		    <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">btrfsic_is_block_ref_by_superblock</span><span class="p">(</span><span class="n">state</span><span class="p">,</span>
							    <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="p">,</span>
							    <span class="n">recursion_level</span> <span class="o">+</span>
							    <span class="mi">1</span><span class="p">))</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_print_add_link</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;Add %u* link from %c @%llu (%s/%llu/%d)&quot;</span>
	       <span class="s">&quot; to %c @%llu (%s/%llu/%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">,</span>
	       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="p">),</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
	       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_print_rem_link</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
	       <span class="s">&quot;Rem %u* link from %c @%llu (%s/%llu/%d)&quot;</span>
	       <span class="s">&quot; to %c @%llu (%s/%llu/%d).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">,</span>
	       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="p">),</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">,</span>
	       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">),</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
	       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
	       <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">char</span> <span class="nf">btrfsic_get_block_type</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				   <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_superblock</span> <span class="o">&amp;&amp;</span>
	    <span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">==</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">&amp;&amp;</span>
	    <span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span> <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;S&#39;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_superblock</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;s&#39;</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">is_metadata</span><span class="p">)</span>
		<span class="k">return</span> <span class="sc">&#39;M&#39;</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dump_tree</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">btrfsic_dump_tree_sub</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_dump_tree_sub</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
				  <span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">,</span>
				  <span class="kt">int</span> <span class="n">indent_level</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_ref_to</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">indent_add</span><span class="p">;</span>
	<span class="k">static</span> <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">cursor_position</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Should better fill an on-stack buffer with a complete line and</span>
<span class="cm">	 * dump it at once when it is time to print a newline character.</span>
<span class="cm">	 */</span>

	<span class="cm">/*</span>
<span class="cm">	 * This algorithm is recursive because the amount of used stack space</span>
<span class="cm">	 * is very small and the max recursion depth is limited.</span>
<span class="cm">	 */</span>
	<span class="n">indent_add</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;%c-%llu(%s/%llu/%d)&quot;</span><span class="p">,</span>
			     <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			     <span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			     <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			     <span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">indent_level</span> <span class="o">+</span> <span class="n">indent_add</span> <span class="o">&gt;</span> <span class="n">BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[...]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">printk</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>
	<span class="n">indent_level</span> <span class="o">+=</span> <span class="n">indent_add</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">list_empty</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_TREE_WITH_ALL_MIRRORS</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="s">&quot; [...]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">cursor_position</span> <span class="o">=</span> <span class="n">indent_level</span><span class="p">;</span>
	<span class="n">list_for_each</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">const</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
			       <span class="n">node_ref_to</span><span class="p">);</span>

		<span class="k">while</span> <span class="p">(</span><span class="n">cursor_position</span> <span class="o">&lt;</span> <span class="n">indent_level</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot; &quot;</span><span class="p">);</span>
			<span class="n">cursor_position</span><span class="o">++</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">indent_add</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; %d*--&gt; &quot;</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">indent_add</span> <span class="o">=</span> <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; --&gt; &quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">indent_level</span> <span class="o">+</span> <span class="n">indent_add</span> <span class="o">&gt;</span>
		    <span class="n">BTRFSIC_TREE_DUMP_MAX_INDENT_LEVEL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="s">&quot;[...]</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">cursor_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">printk</span><span class="p">(</span><span class="n">buf</span><span class="p">);</span>

		<span class="n">btrfsic_dump_tree_sub</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span><span class="p">,</span>
				      <span class="n">indent_level</span> <span class="o">+</span> <span class="n">indent_add</span><span class="p">);</span>
		<span class="n">cursor_position</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="nf">btrfsic_block_link_lookup_or_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">next_block_ctx</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">next_block</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">from_block</span><span class="p">,</span>
		<span class="n">u64</span> <span class="n">parent_generation</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="n">l</span><span class="p">;</span>

	<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_hashtable_lookup</span><span class="p">(</span><span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
						<span class="n">next_block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
						<span class="n">from_block</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
						<span class="n">from_block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_link_hashtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">l</span> <span class="o">=</span> <span class="n">btrfsic_block_link_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: error, kmalloc&quot;</span> <span class="s">&quot; failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_to</span> <span class="o">=</span> <span class="n">next_block</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">block_ref_from</span> <span class="o">=</span> <span class="n">from_block</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">parent_generation</span> <span class="o">=</span> <span class="n">parent_generation</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">btrfsic_print_add_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_to</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">from_block</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">l</span><span class="o">-&gt;</span><span class="n">node_ref_from</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">next_block</span><span class="o">-&gt;</span><span class="n">ref_from_list</span><span class="p">);</span>

		<span class="n">btrfsic_block_link_hashtable_add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span>
						 <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_link_hashtable</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="o">++</span><span class="p">;</span>
		<span class="n">l</span><span class="o">-&gt;</span><span class="n">parent_generation</span> <span class="o">=</span> <span class="n">parent_generation</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">btrfsic_print_add_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">l</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="nf">btrfsic_block_lookup_or_add</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="o">*</span><span class="n">block_ctx</span><span class="p">,</span>
		<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">additional_string</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_metadata</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">is_iodone</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">never_written</span><span class="p">,</span>
		<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">,</span>
		<span class="kt">int</span> <span class="o">*</span><span class="n">was_created</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="n">block</span><span class="p">;</span>

	<span class="n">block</span> <span class="o">=</span> <span class="n">btrfsic_block_hashtable_lookup</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
					       <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
					       <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">;</span>

		<span class="n">block</span> <span class="o">=</span> <span class="n">btrfsic_block_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">block</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic: error, kmalloc failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">dev_state</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_lookup</span><span class="p">(</span><span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">dev_state</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfsic: error, lookup dev_state failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">btrfsic_block_free</span><span class="p">(</span><span class="n">block</span><span class="p">);</span>
			<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_state</span> <span class="o">=</span> <span class="n">dev_state</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span> <span class="o">=</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span> <span class="o">=</span> <span class="n">block_ctx</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_metadata</span> <span class="o">=</span> <span class="n">is_metadata</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="n">is_iodone</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">never_written</span> <span class="o">=</span> <span class="n">never_written</span><span class="p">;</span>
		<span class="n">block</span><span class="o">-&gt;</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="n">mirror_num</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;New %s%c-block @%llu (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">additional_string</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">block</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">mirror_num</span><span class="p">);</span>
		<span class="n">list_add</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block</span><span class="o">-&gt;</span><span class="n">all_blocks_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">all_blocks_list</span><span class="p">);</span>
		<span class="n">btrfsic_block_hashtable_add</span><span class="p">(</span><span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">was_created</span><span class="p">)</span>
			<span class="o">*</span><span class="n">was_created</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">was_created</span><span class="p">)</span>
			<span class="o">*</span><span class="n">was_created</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">block</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">btrfsic_cmp_log_and_dev_bytenr</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span>
					   <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">,</span>
					   <span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">num_copies</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">mirror_num</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_block_data_ctx</span> <span class="n">block_ctx</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">match</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">num_copies</span> <span class="o">=</span> <span class="n">btrfs_num_copies</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">mapping_tree</span><span class="p">,</span>
				      <span class="n">bytenr</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">mirror_num</span> <span class="o">&lt;=</span> <span class="n">num_copies</span><span class="p">;</span> <span class="n">mirror_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">,</span>
					<span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfsic:&quot;</span>
			       <span class="s">&quot; btrfsic_map_block(logical @%llu,&quot;</span>
			       <span class="s">&quot; mirror %d) failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">==</span> <span class="n">block_ctx</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">&amp;&amp;</span>
		    <span class="n">dev_bytenr</span> <span class="o">==</span> <span class="n">block_ctx</span><span class="p">.</span><span class="n">dev_bytenr</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">match</span><span class="o">++</span><span class="p">;</span>
			<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">btrfsic_release_block_ctx</span><span class="p">(</span><span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">match</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to write M-block which contains logical bytenr that doesn&#39;t map to dev+physical bytenr of submit_bio,&quot;</span>
		       <span class="s">&quot; buffer-&gt;log_bytenr=%llu, submit_bio(bdev=%s,&quot;</span>
		       <span class="s">&quot; phys_bytenr=%llu)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span> <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
		       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">);</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">mirror_num</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">mirror_num</span> <span class="o">&lt;=</span> <span class="n">num_copies</span><span class="p">;</span> <span class="n">mirror_num</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_map_block</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span>
						<span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">block_ctx</span><span class="p">,</span> <span class="n">mirror_num</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;Read logical bytenr @%llu maps to&quot;</span>
			       <span class="s">&quot; (%s/%llu/%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">bytenr</span><span class="p">,</span>
			       <span class="n">block_ctx</span><span class="p">.</span><span class="n">dev</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block_ctx</span><span class="p">.</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">mirror_num</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="nf">btrfsic_dev_state_lookup</span><span class="p">(</span>
		<span class="k">struct</span> <span class="n">block_device</span> <span class="o">*</span><span class="n">bdev</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">;</span>

	<span class="n">ds</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_hashtable_lookup</span><span class="p">(</span><span class="n">bdev</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">btrfsic_dev_state_hashtable</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ds</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfsic_submit_bh</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfsic_is_initialized</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">submit_bh</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
	<span class="cm">/* since btrfsic_submit_bh() might also be called before</span>
<span class="cm">	 * btrfsic_mount(), this might return NULL */</span>
	<span class="n">dev_state</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_lookup</span><span class="p">(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">);</span>

	<span class="cm">/* Only called to write the superblock (incl. FLUSH/FUA) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">dev_state</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">;</span>

		<span class="n">dev_bytenr</span> <span class="o">=</span> <span class="mi">4096</span> <span class="o">*</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
		    <span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;submit_bh(rw=0x%x, blocknr=%lu (bytenr %llu),&quot;</span>
			       <span class="s">&quot; size=%lu, data=%p, bdev=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rw</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_blocknr</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_size</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span>
			       <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">);</span>
		<span class="n">btrfsic_process_written_block</span><span class="p">(</span><span class="n">dev_state</span><span class="p">,</span> <span class="n">dev_bytenr</span><span class="p">,</span>
					      <span class="o">&amp;</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span>
					      <span class="nb">NULL</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">dev_state</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
		    <span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;submit_bh(rw=0x%x FLUSH, bdev=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rw</span><span class="p">,</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_bdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">dummy_block_for_bio_bh_flush</span><span class="p">.</span><span class="n">is_iodone</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			     <span class="p">(</span><span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span> <span class="o">|</span>
			      <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic_submit_bh(%s) with FLUSH&quot;</span>
				       <span class="s">&quot; but dummy block already in use&quot;</span>
				       <span class="s">&quot; (ignored)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">block</span> <span class="o">=</span>
				<span class="o">&amp;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">dummy_block_for_bio_bh_flush</span><span class="p">;</span>

			<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">never_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">iodone_w_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">=</span> <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">=</span> <span class="n">rw</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_end_io</span> <span class="o">=</span> <span class="n">btrfsic_bh_end_io</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">submit_bh</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfsic_submit_bio</span><span class="p">(</span><span class="kt">int</span> <span class="n">rw</span><span class="p">,</span> <span class="k">struct</span> <span class="n">bio</span> <span class="o">*</span><span class="n">bio</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">dev_state</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfsic_is_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">submit_bio</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
	<span class="cm">/* since btrfsic_submit_bio() is also called before</span>
<span class="cm">	 * btrfsic_mount(), this might return NULL */</span>
	<span class="n">dev_state</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_lookup</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">dev_state</span> <span class="o">&amp;&amp;</span>
	    <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">WRITE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nb">NULL</span> <span class="o">!=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
		<span class="n">u64</span> <span class="n">dev_bytenr</span><span class="p">;</span>
		<span class="kt">int</span> <span class="n">bio_is_patched</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">**</span><span class="n">mapped_datav</span><span class="p">;</span>

		<span class="n">dev_bytenr</span> <span class="o">=</span> <span class="mi">512</span> <span class="o">*</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">;</span>
		<span class="n">bio_is_patched</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
		    <span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;submit_bio(rw=0x%x, bi_vcnt=%u,&quot;</span>
			       <span class="s">&quot; bi_sector=%lu (bytenr %llu), bi_bdev=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_sector</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>

		<span class="n">mapped_datav</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">mapped_datav</span><span class="p">)</span> <span class="o">*</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">,</span>
				       <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapped_datav</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_len</span> <span class="o">!=</span> <span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
			<span class="n">mapped_datav</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">kmap</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapped_datav</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
				<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">i</span><span class="o">--</span><span class="p">;</span>
					<span class="n">kunmap</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span><span class="p">);</span>
				<span class="p">}</span>
				<span class="n">kfree</span><span class="p">(</span><span class="n">mapped_datav</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">leave</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span> <span class="o">|</span>
			     <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span> <span class="o">==</span>
			    <span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			     <span class="p">(</span><span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span> <span class="o">|</span>
			      <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;#%u: page=%p, len=%u, offset=%u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">i</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span><span class="p">,</span>
				       <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_len</span><span class="p">,</span>
				       <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_offset</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">btrfsic_process_written_block</span><span class="p">(</span><span class="n">dev_state</span><span class="p">,</span> <span class="n">dev_bytenr</span><span class="p">,</span>
					      <span class="n">mapped_datav</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_vcnt</span><span class="p">,</span>
					      <span class="n">bio</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">bio_is_patched</span><span class="p">,</span>
					      <span class="nb">NULL</span><span class="p">,</span> <span class="n">rw</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">i</span><span class="o">--</span><span class="p">;</span>
			<span class="n">kunmap</span><span class="p">(</span><span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_io_vec</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">bv_page</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">mapped_datav</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">dev_state</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">rw</span> <span class="o">&amp;</span> <span class="n">REQ_FLUSH</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
		    <span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span><span class="p">)</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;submit_bio(rw=0x%x FLUSH, bdev=%p)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_bdev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">dummy_block_for_bio_bh_flush</span><span class="p">.</span><span class="n">is_iodone</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">((</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span>
			     <span class="p">(</span><span class="n">BTRFSIC_PRINT_MASK_SUBMIT_BIO_BH</span> <span class="o">|</span>
			      <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)))</span>
				<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
				       <span class="s">&quot;btrfsic_submit_bio(%s) with FLUSH&quot;</span>
				       <span class="s">&quot; but dummy block already in use&quot;</span>
				       <span class="s">&quot; (ignored)!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				       <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">block</span> <span class="o">=</span>
				<span class="o">&amp;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">dummy_block_for_bio_bh_flush</span><span class="p">;</span>

			<span class="n">block</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">never_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">iodone_w_error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">flush_gen</span> <span class="o">=</span> <span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">last_flush_gen</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">submit_bio_bh_rw</span> <span class="o">=</span> <span class="n">rw</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_private</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">orig_bio_bh_end_io</span><span class="p">.</span><span class="n">bio</span> <span class="o">=</span> <span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span><span class="p">;</span>
			<span class="n">block</span><span class="o">-&gt;</span><span class="n">next_in_same_bio</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_private</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="n">bio</span><span class="o">-&gt;</span><span class="n">bi_end_io</span> <span class="o">=</span> <span class="n">btrfsic_bio_end_io</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">leave:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>

	<span class="n">submit_bio</span><span class="p">(</span><span class="n">rw</span><span class="p">,</span> <span class="n">bio</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfsic_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		  <span class="k">struct</span> <span class="n">btrfs_fs_devices</span> <span class="o">*</span><span class="n">fs_devices</span><span class="p">,</span>
		  <span class="kt">int</span> <span class="n">including_extent_data</span><span class="p">,</span> <span class="n">u32</span> <span class="n">print_mask</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dev_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">!=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: cannot handle nodesize %d != leafsize %d!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: cannot handle nodesize %d not being a multiple of PAGE_CACHE_SIZE %ld!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: cannot handle leafsize %d not being a multiple of PAGE_CACHE_SIZE %ld!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">&amp;</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: cannot handle sectorsize %d not being a multiple of PAGE_CACHE_SIZE %ld!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">state</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">state</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs check-integrity: kmalloc() failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfsic_is_initialized</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
		<span class="n">btrfsic_dev_state_hashtable_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_dev_state_hashtable</span><span class="p">);</span>
		<span class="n">btrfsic_is_initialized</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">=</span> <span class="n">print_mask</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">include_extent_data</span> <span class="o">=</span> <span class="n">including_extent_data</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">csum_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">metablock_size</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">nodesize</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">datablock_size</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>
	<span class="n">INIT_LIST_HEAD</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">all_blocks_list</span><span class="p">);</span>
	<span class="n">btrfsic_block_hashtable_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_hashtable</span><span class="p">);</span>
	<span class="n">btrfsic_block_link_hashtable_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">block_link_hashtable</span><span class="p">);</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">max_superblock_generation</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">state</span><span class="o">-&gt;</span><span class="n">latest_superblock</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">dev_head</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">;</span>
		<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">||</span> <span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ds</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_alloc</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
			       <span class="s">&quot;btrfs check-integrity: kmalloc() failed!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ds</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
		<span class="n">ds</span><span class="o">-&gt;</span><span class="n">state</span> <span class="o">=</span> <span class="n">state</span><span class="p">;</span>
		<span class="n">bdevname</span><span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">);</span>
		<span class="n">ds</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">[</span><span class="n">BDEVNAME_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">);</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">&gt;</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
			<span class="n">p</span><span class="o">--</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span> <span class="o">==</span> <span class="sc">&#39;/&#39;</span><span class="p">)</span>
			<span class="n">p</span><span class="o">++</span><span class="p">;</span>
		<span class="n">strlcpy</span><span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ds</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">));</span>
		<span class="n">btrfsic_dev_state_hashtable_add</span><span class="p">(</span><span class="n">ds</span><span class="p">,</span>
						<span class="o">&amp;</span><span class="n">btrfsic_dev_state_hashtable</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfsic_process_superblock</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">fs_devices</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
		<span class="n">btrfsic_unmount</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">fs_devices</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_INITIAL_DATABASE</span><span class="p">)</span>
		<span class="n">btrfsic_dump_database</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_INITIAL_TREE</span><span class="p">)</span>
		<span class="n">btrfsic_dump_tree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">btrfsic_unmount</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">btrfs_fs_devices</span> <span class="o">*</span><span class="n">fs_devices</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_all</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp_all</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfsic_state</span> <span class="o">*</span><span class="n">state</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">dev_head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">fs_devices</span><span class="o">-&gt;</span><span class="n">devices</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_device</span> <span class="o">*</span><span class="n">device</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfsic_is_initialized</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>

	<span class="n">state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">device</span><span class="p">,</span> <span class="n">dev_head</span><span class="p">,</span> <span class="n">dev_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_dev_state</span> <span class="o">*</span><span class="n">ds</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">||</span> <span class="o">!</span><span class="n">device</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">ds</span> <span class="o">=</span> <span class="n">btrfsic_dev_state_hashtable_lookup</span><span class="p">(</span>
				<span class="n">device</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">,</span>
				<span class="o">&amp;</span><span class="n">btrfsic_dev_state_hashtable</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">ds</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">state</span> <span class="o">=</span> <span class="n">ds</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">;</span>
			<span class="n">btrfsic_dev_state_hashtable_remove</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
			<span class="n">btrfsic_dev_state_free</span><span class="p">(</span><span class="n">ds</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">state</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span>
		       <span class="s">&quot;btrfsic: error, cannot find state information&quot;</span>
		       <span class="s">&quot; on umount!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * Don&#39;t care about keeping the lists&#39; state up to date,</span>
<span class="cm">	 * just free all memory that was allocated dynamically.</span>
<span class="cm">	 * Free the blocks and the block_links.</span>
<span class="cm">	 */</span>
	<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">elem_all</span><span class="p">,</span> <span class="n">tmp_all</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">all_blocks_list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfsic_block</span> <span class="o">*</span><span class="k">const</span> <span class="n">b_all</span> <span class="o">=</span>
		    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_all</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfsic_block</span><span class="p">,</span>
			       <span class="n">all_blocks_node</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">elem_ref_to</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp_ref_to</span><span class="p">;</span>

		<span class="n">list_for_each_safe</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span> <span class="n">tmp_ref_to</span><span class="p">,</span>
				   <span class="o">&amp;</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">ref_to_list</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">btrfsic_block_link</span> <span class="o">*</span><span class="k">const</span> <span class="n">l</span> <span class="o">=</span>
			    <span class="n">list_entry</span><span class="p">(</span><span class="n">elem_ref_to</span><span class="p">,</span>
				       <span class="k">struct</span> <span class="n">btrfsic_block_link</span><span class="p">,</span>
				       <span class="n">node_ref_to</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">state</span><span class="o">-&gt;</span><span class="n">print_mask</span> <span class="o">&amp;</span> <span class="n">BTRFSIC_PRINT_MASK_VERBOSE</span><span class="p">)</span>
				<span class="n">btrfsic_print_rem_link</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">l</span><span class="p">);</span>

			<span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="o">--</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">==</span> <span class="n">l</span><span class="o">-&gt;</span><span class="n">ref_cnt</span><span class="p">)</span>
				<span class="n">btrfsic_block_link_free</span><span class="p">(</span><span class="n">l</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">is_iodone</span> <span class="o">||</span> <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">never_written</span><span class="p">)</span>
			<span class="n">btrfsic_block_free</span><span class="p">(</span><span class="n">b_all</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">printk</span><span class="p">(</span><span class="n">KERN_INFO</span> <span class="s">&quot;btrfs: attempt to free %c-block&quot;</span>
			       <span class="s">&quot; @%llu (%s/%llu/%d) on umount which is&quot;</span>
			       <span class="s">&quot; not yet iodone!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			       <span class="n">btrfsic_get_block_type</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="n">b_all</span><span class="p">),</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">logical_bytenr</span><span class="p">,</span>
			       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_state</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">,</span>
			       <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">b_all</span><span class="o">-&gt;</span><span class="n">dev_bytenr</span><span class="p">,</span>
			       <span class="n">b_all</span><span class="o">-&gt;</span><span class="n">mirror_num</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">btrfsic_mutex</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">state</span><span class="p">);</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
