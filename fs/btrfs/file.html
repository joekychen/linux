<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › btrfs › file.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>file.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * Copyright (C) 2007 Oracle.  All rights reserved.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is free software; you can redistribute it and/or</span>
<span class="cm"> * modify it under the terms of the GNU General Public</span>
<span class="cm"> * License v2 as published by the Free Software Foundation.</span>
<span class="cm"> *</span>
<span class="cm"> * This program is distributed in the hope that it will be useful,</span>
<span class="cm"> * but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</span>
<span class="cm"> * General Public License for more details.</span>
<span class="cm"> *</span>
<span class="cm"> * You should have received a copy of the GNU General Public</span>
<span class="cm"> * License along with this program; if not, write to the</span>
<span class="cm"> * Free Software Foundation, Inc., 59 Temple Place - Suite 330,</span>
<span class="cm"> * Boston, MA 021110-1307, USA.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/fs.h&gt;</span>
<span class="cp">#include &lt;linux/pagemap.h&gt;</span>
<span class="cp">#include &lt;linux/highmem.h&gt;</span>
<span class="cp">#include &lt;linux/time.h&gt;</span>
<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;linux/string.h&gt;</span>
<span class="cp">#include &lt;linux/backing-dev.h&gt;</span>
<span class="cp">#include &lt;linux/mpage.h&gt;</span>
<span class="cp">#include &lt;linux/falloc.h&gt;</span>
<span class="cp">#include &lt;linux/swap.h&gt;</span>
<span class="cp">#include &lt;linux/writeback.h&gt;</span>
<span class="cp">#include &lt;linux/statfs.h&gt;</span>
<span class="cp">#include &lt;linux/compat.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &quot;ctree.h&quot;</span>
<span class="cp">#include &quot;disk-io.h&quot;</span>
<span class="cp">#include &quot;transaction.h&quot;</span>
<span class="cp">#include &quot;btrfs_inode.h&quot;</span>
<span class="cp">#include &quot;ioctl.h&quot;</span>
<span class="cp">#include &quot;print-tree.h&quot;</span>
<span class="cp">#include &quot;tree-log.h&quot;</span>
<span class="cp">#include &quot;locking.h&quot;</span>
<span class="cp">#include &quot;compat.h&quot;</span>

<span class="cm">/*</span>
<span class="cm"> * when auto defrag is enabled we</span>
<span class="cm"> * queue up these defrag structs to remember which</span>
<span class="cm"> * inodes need defragging passes</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode_defrag</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="n">rb_node</span><span class="p">;</span>
	<span class="cm">/* objectid */</span>
	<span class="n">u64</span> <span class="n">ino</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * transid where the defrag was added, we search for</span>
<span class="cm">	 * extents newer than this</span>
<span class="cm">	 */</span>
	<span class="n">u64</span> <span class="n">transid</span><span class="p">;</span>

	<span class="cm">/* root objectid */</span>
	<span class="n">u64</span> <span class="n">root</span><span class="p">;</span>

	<span class="cm">/* last offset we were able to defrag */</span>
	<span class="n">u64</span> <span class="n">last_offset</span><span class="p">;</span>

	<span class="cm">/* if we&#39;ve wrapped around back to zero once already */</span>
	<span class="kt">int</span> <span class="n">cycled</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">__compare_inode_defrag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="n">defrag1</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="n">defrag2</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">defrag1</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">&gt;</span> <span class="n">defrag2</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">defrag1</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">&lt;</span> <span class="n">defrag2</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">defrag1</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&gt;</span> <span class="n">defrag2</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">defrag1</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">&lt;</span> <span class="n">defrag2</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* pop a record for an inode into the defrag tree.  The lock</span>
<span class="cm"> * must be held already</span>
<span class="cm"> *</span>
<span class="cm"> * If you&#39;re inserting a record for an older transid than an</span>
<span class="cm"> * existing record, the transid already in the tree is lowered</span>
<span class="cm"> *</span>
<span class="cm"> * If an existing record is found the defrag item you</span>
<span class="cm"> * pass in is freed</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">__btrfs_add_inode_defrag</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="n">defrag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="n">entry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode_defrag</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__compare_inode_defrag</span><span class="p">(</span><span class="n">defrag</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* if we&#39;re reinserting an entry for</span>
<span class="cm">			 * an old defrag run, make sure to</span>
<span class="cm">			 * lower the transid of our existing record</span>
<span class="cm">			 */</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">defrag</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">&lt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">)</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">=</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">defrag</span><span class="o">-&gt;</span><span class="n">last_offset</span> <span class="o">&gt;</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">last_offset</span><span class="p">)</span>
				<span class="n">entry</span><span class="o">-&gt;</span><span class="n">last_offset</span> <span class="o">=</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">last_offset</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">exists</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_IN_DEFRAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>
	<span class="n">rb_link_node</span><span class="p">(</span><span class="o">&amp;</span><span class="n">defrag</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
	<span class="n">rb_insert_color</span><span class="p">(</span><span class="o">&amp;</span><span class="n">defrag</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="nl">exists:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">defrag</span><span class="p">);</span>
	<span class="k">return</span><span class="p">;</span>

<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * insert a defrag record for this inode if auto defrag is</span>
<span class="cm"> * enabled</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_add_inode_defrag</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="n">defrag</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">transid</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">btrfs_test_opt</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">AUTO_DEFRAG</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_fs_closing</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_IN_DEFRAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">trans</span><span class="p">)</span>
		<span class="n">transid</span> <span class="o">=</span> <span class="n">trans</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="n">transid</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">last_trans</span><span class="p">;</span>

	<span class="n">defrag</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">defrag</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">defrag</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">defrag</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">defrag</span><span class="o">-&gt;</span><span class="n">transid</span> <span class="o">=</span> <span class="n">transid</span><span class="p">;</span>
	<span class="n">defrag</span><span class="o">-&gt;</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes_lock</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_IN_DEFRAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span>
		<span class="n">__btrfs_add_inode_defrag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">defrag</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">defrag</span><span class="p">);</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes_lock</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * must be called with the defrag_inodes lock held</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="nf">btrfs_find_defrag_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">info</span><span class="p">,</span>
					     <span class="n">u64</span> <span class="n">root</span><span class="p">,</span> <span class="n">u64</span> <span class="n">ino</span><span class="p">,</span>
					     <span class="k">struct</span> <span class="n">rb_node</span> <span class="o">**</span><span class="n">next</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="n">entry</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode_defrag</span> <span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">tmp</span><span class="p">.</span><span class="n">ino</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">tmp</span><span class="p">.</span><span class="n">root</span> <span class="o">=</span> <span class="n">root</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="n">info</span><span class="o">-&gt;</span><span class="n">defrag_inodes</span><span class="p">.</span><span class="n">rb_node</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">parent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
		<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode_defrag</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">__compare_inode_defrag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">entry</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_left</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">p</span> <span class="o">=</span> <span class="n">parent</span><span class="o">-&gt;</span><span class="n">rb_right</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="k">return</span> <span class="n">entry</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">next</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">while</span> <span class="p">(</span><span class="n">parent</span> <span class="o">&amp;&amp;</span> <span class="n">__compare_inode_defrag</span><span class="p">(</span><span class="o">&amp;</span><span class="n">tmp</span><span class="p">,</span> <span class="n">entry</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">parent</span> <span class="o">=</span> <span class="n">rb_next</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
			<span class="n">entry</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode_defrag</span><span class="p">,</span> <span class="n">rb_node</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">parent</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * run through the list of inodes in the FS that need</span>
<span class="cm"> * defragging</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_run_defrag_inodes</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_fs_info</span> <span class="o">*</span><span class="n">fs_info</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode_defrag</span> <span class="o">*</span><span class="n">defrag</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">inode_root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_node</span> <span class="o">*</span><span class="n">n</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_ioctl_defrag_range_args</span> <span class="n">range</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">first_ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">root_objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num_defrag</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">defrag_batch</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="o">&amp;</span><span class="n">range</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">range</span><span class="p">));</span>
	<span class="n">range</span><span class="p">.</span><span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">atomic_inc</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_running</span><span class="p">);</span>
	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes_lock</span><span class="p">);</span>
	<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">n</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="cm">/* find an inode to defrag */</span>
		<span class="n">defrag</span> <span class="o">=</span> <span class="n">btrfs_find_defrag_inode</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="n">root_objectid</span><span class="p">,</span>
						 <span class="n">first_ino</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">n</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">defrag</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">defrag</span> <span class="o">=</span> <span class="n">rb_entry</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode_defrag</span><span class="p">,</span>
						  <span class="n">rb_node</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">root_objectid</span> <span class="o">||</span> <span class="n">first_ino</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">root_objectid</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="n">first_ino</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="cm">/* remove it from the rbtree */</span>
		<span class="n">first_ino</span> <span class="o">=</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">ino</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">root_objectid</span> <span class="o">=</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
		<span class="n">rb_erase</span><span class="p">(</span><span class="o">&amp;</span><span class="n">defrag</span><span class="o">-&gt;</span><span class="n">rb_node</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_fs_closing</span><span class="p">(</span><span class="n">fs_info</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next_free</span><span class="p">;</span>

		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes_lock</span><span class="p">);</span>

		<span class="cm">/* get the inode */</span>
		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
		<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_ROOT_ITEM_KEY</span><span class="p">);</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">inode_root</span> <span class="o">=</span> <span class="n">btrfs_read_fs_root_no_name</span><span class="p">(</span><span class="n">fs_info</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode_root</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">ino</span><span class="p">;</span>
		<span class="n">btrfs_set_key_type</span><span class="p">(</span><span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">BTRFS_INODE_ITEM_KEY</span><span class="p">);</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">inode</span> <span class="o">=</span> <span class="n">btrfs_iget</span><span class="p">(</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">inode_root</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span>
			<span class="k">goto</span> <span class="n">next</span><span class="p">;</span>

		<span class="cm">/* do a chunk of defrag */</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_IN_DEFRAG</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">);</span>
		<span class="n">range</span><span class="p">.</span><span class="n">start</span> <span class="o">=</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">last_offset</span><span class="p">;</span>
		<span class="n">num_defrag</span> <span class="o">=</span> <span class="n">btrfs_defrag_file</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">range</span><span class="p">,</span> <span class="n">defrag</span><span class="o">-&gt;</span><span class="n">transid</span><span class="p">,</span>
					       <span class="n">defrag_batch</span><span class="p">);</span>
		<span class="cm">/*</span>
<span class="cm">		 * if we filled the whole defrag batch, there</span>
<span class="cm">		 * must be more work to do.  Queue this defrag</span>
<span class="cm">		 * again</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_defrag</span> <span class="o">==</span> <span class="n">defrag_batch</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">defrag</span><span class="o">-&gt;</span><span class="n">last_offset</span> <span class="o">=</span> <span class="n">range</span><span class="p">.</span><span class="n">start</span><span class="p">;</span>
			<span class="n">__btrfs_add_inode_defrag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">defrag</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * we don&#39;t want to kfree defrag, we added it back to</span>
<span class="cm">			 * the rbtree</span>
<span class="cm">			 */</span>
			<span class="n">defrag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">defrag</span><span class="o">-&gt;</span><span class="n">last_offset</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">defrag</span><span class="o">-&gt;</span><span class="n">cycled</span><span class="p">)</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * we didn&#39;t fill our defrag batch, but</span>
<span class="cm">			 * we didn&#39;t start at zero.  Make sure we loop</span>
<span class="cm">			 * around to the start of the file.</span>
<span class="cm">			 */</span>
			<span class="n">defrag</span><span class="o">-&gt;</span><span class="n">last_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">defrag</span><span class="o">-&gt;</span><span class="n">cycled</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">__btrfs_add_inode_defrag</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">defrag</span><span class="p">);</span>
			<span class="n">defrag</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">iput</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
<span class="nl">next:</span>
		<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes_lock</span><span class="p">);</span>
<span class="nl">next_free:</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">defrag</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_inodes_lock</span><span class="p">);</span>

	<span class="n">atomic_dec</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">defrag_running</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * during unmount, we use the transaction_wait queue to</span>
<span class="cm">	 * wait for the defragger to stop</span>
<span class="cm">	 */</span>
	<span class="n">wake_up</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">transaction_wait</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* simple helper to fault in pages and copy.  This should go away</span>
<span class="cm"> * and be replaced with calls into generic code.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">btrfs_copy_from_user</span><span class="p">(</span><span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_pages</span><span class="p">,</span>
					 <span class="kt">size_t</span> <span class="n">write_bytes</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">prepared_pages</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">total_copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">write_bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">count</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="kt">size_t</span><span class="p">,</span>
				     <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">,</span> <span class="n">write_bytes</span><span class="p">);</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span> <span class="o">=</span> <span class="n">prepared_pages</span><span class="p">[</span><span class="n">pg</span><span class="p">];</span>
		<span class="cm">/*</span>
<span class="cm">		 * Copy data from userspace to the current page</span>
<span class="cm">		 *</span>
<span class="cm">		 * Disable pagefault to avoid recursive lock since</span>
<span class="cm">		 * the pages are already locked</span>
<span class="cm">		 */</span>
		<span class="n">pagefault_disable</span><span class="p">();</span>
		<span class="n">copied</span> <span class="o">=</span> <span class="n">iov_iter_copy_from_user_atomic</span><span class="p">(</span><span class="n">page</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
		<span class="n">pagefault_enable</span><span class="p">();</span>

		<span class="cm">/* Flush processor&#39;s dcache for this page */</span>
		<span class="n">flush_dcache_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * if we get a partial write, we can end up with</span>
<span class="cm">		 * partially up to date pages.  These add</span>
<span class="cm">		 * a lot of complexity, so make sure they don&#39;t</span>
<span class="cm">		 * happen by forcing this copy to be retried.</span>
<span class="cm">		 *</span>
<span class="cm">		 * The rest of the btrfs_file_write code will fall</span>
<span class="cm">		 * back to page at a time copies after we return 0.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">copied</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">)</span>
			<span class="n">copied</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

		<span class="n">iov_iter_advance</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">copied</span><span class="p">);</span>
		<span class="n">write_bytes</span> <span class="o">-=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="n">total_copied</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>

		<span class="cm">/* Return to btrfs_file_aio_write to fault page */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="n">offset</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">offset</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">pg</span><span class="o">++</span><span class="p">;</span>
			<span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">total_copied</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * unlocks pages after btrfs_file_write is done with them</span>
<span class="cm"> */</span>
<span class="kt">void</span> <span class="nf">btrfs_drop_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_pages</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">size_t</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* page checked is some magic around finding pages that</span>
<span class="cm">		 * have been modified without going through btrfs_set_page_dirty</span>
<span class="cm">		 * clear it here</span>
<span class="cm">		 */</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">mark_page_accessed</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * after copy_from_user, pages need to be dirtied and we need to make</span>
<span class="cm"> * sure holes are created between the current EOF and the start of</span>
<span class="cm"> * any next extents (if required).</span>
<span class="cm"> *</span>
<span class="cm"> * this also makes the decision about creating an inline extent vs</span>
<span class="cm"> * doing real data extents, marking pages dirty and delalloc as required.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_dirty_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_pages</span><span class="p">,</span>
		      <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">write_bytes</span><span class="p">,</span>
		      <span class="k">struct</span> <span class="n">extent_state</span> <span class="o">**</span><span class="n">cached</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start_pos</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end_of_last_block</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">end_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">write_bytes</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">isize</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">start_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">write_bytes</span> <span class="o">+</span> <span class="n">pos</span> <span class="o">-</span> <span class="n">start_pos</span> <span class="o">+</span>
		    <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

	<span class="n">end_of_last_block</span> <span class="o">=</span> <span class="n">start_pos</span> <span class="o">+</span> <span class="n">num_bytes</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_set_extent_delalloc</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span> <span class="n">end_of_last_block</span><span class="p">,</span>
					<span class="n">cached</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">SetPageUptodate</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">ClearPageChecked</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
		<span class="n">set_page_dirty</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * we&#39;ve only changed i_size in ram, and we haven&#39;t updated</span>
<span class="cm">	 * the disk i_size.  There is no need to log the inode</span>
<span class="cm">	 * at this time.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end_pos</span> <span class="o">&gt;</span> <span class="n">isize</span><span class="p">)</span>
		<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end_pos</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this drops all the extents in the cache that intersect the range</span>
<span class="cm"> * [start, end].  Existing extents are split as required.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_drop_extent_cache</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">skip_pinned</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">split</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">split2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map_tree</span> <span class="o">*</span><span class="n">em_tree</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">extent_tree</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">testend</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">flags</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">compressed</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">WARN_ON</span><span class="p">(</span><span class="n">end</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">len</span> <span class="o">=</span> <span class="p">(</span><span class="n">u64</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="n">testend</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">split</span><span class="p">)</span>
			<span class="n">split</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">split2</span><span class="p">)</span>
			<span class="n">split2</span> <span class="o">=</span> <span class="n">alloc_extent_map</span><span class="p">();</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">split</span> <span class="o">||</span> <span class="o">!</span><span class="n">split2</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

		<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">lookup_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">flags</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">skip_pinned</span> <span class="o">&amp;&amp;</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PINNED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">testend</span> <span class="o">&amp;&amp;</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">testend</span><span class="p">)</span>
				<span class="n">len</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">);</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">compressed</span> <span class="o">=</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_COMPRESSED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">clear_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PINNED</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
		<span class="n">remove_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">em</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">EXTENT_MAP_LAST_BYTE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">&lt;</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">compressed</span><span class="p">)</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

			<span class="n">split</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">split</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* Logic error */</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>
			<span class="n">split</span> <span class="o">=</span> <span class="n">split2</span><span class="p">;</span>
			<span class="n">split2</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">&lt;</span> <span class="n">EXTENT_MAP_LAST_BYTE</span> <span class="o">&amp;&amp;</span>
		    <span class="n">testend</span> <span class="o">&amp;&amp;</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">u64</span> <span class="n">diff</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span> <span class="o">-</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>

			<span class="n">split</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">-</span> <span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">bdev</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">bdev</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span><span class="p">;</span>
			<span class="n">split</span><span class="o">-&gt;</span><span class="n">compress_type</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">compress_type</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">compressed</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_len</span><span class="p">;</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span><span class="p">;</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">orig_start</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">block_len</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">+</span> <span class="n">diff</span><span class="p">;</span>
				<span class="n">split</span><span class="o">-&gt;</span><span class="n">orig_start</span> <span class="o">=</span> <span class="n">split</span><span class="o">-&gt;</span><span class="n">start</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">add_extent_mapping</span><span class="p">(</span><span class="n">em_tree</span><span class="p">,</span> <span class="n">split</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* Logic error */</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>
			<span class="n">split</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">em_tree</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>

		<span class="cm">/* once for us */</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="cm">/* once for the tree*/</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">split</span><span class="p">)</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">split</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">split2</span><span class="p">)</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">split2</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this is very complex, but the basic idea is to drop all extents</span>
<span class="cm"> * in the range start - end.  hint_block is filled in with a block number</span>
<span class="cm"> * that would be a good hint to the block allocator for this file.</span>
<span class="cm"> *</span>
<span class="cm"> * If an extent intersects the range but is not entirely inside the range</span>
<span class="cm"> * it is either truncated or split.  Anything entirely inside the range</span>
<span class="cm"> * is deleted from the tree.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_drop_extents</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span>
		       <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">hint_byte</span><span class="p">,</span> <span class="kt">int</span> <span class="n">drop_cache</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">new_key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">search_start</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">disk_bytenr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">del_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">del_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">extent_type</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">modify_tree</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">drop_cache</span><span class="p">)</span>
		<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span><span class="p">)</span>
		<span class="n">modify_tree</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">recow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_lookup_file_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">ino</span><span class="p">,</span>
					       <span class="n">search_start</span><span class="p">,</span> <span class="n">modify_tree</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">search_start</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">==</span> <span class="n">ino</span> <span class="o">&amp;&amp;</span>
			    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">next_slot:</span>
		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">del_nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_next_leaf</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">recow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">&gt;</span> <span class="n">ino</span> <span class="o">||</span>
		    <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">&gt;</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span> <span class="o">||</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">end</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">extent_type</span> <span class="o">=</span> <span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">||</span>
		    <span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">disk_bytenr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">extent_offset</span> <span class="o">=</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span>
				<span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span>
				<span class="n">btrfs_file_extent_inline_len</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">WARN_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">search_start</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">extent_end</span> <span class="o">&lt;=</span> <span class="n">search_start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_slot</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">search_start</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">,</span> <span class="n">start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">recow</span> <span class="o">||</span> <span class="o">!</span><span class="n">modify_tree</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">modify_tree</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *     | - range to drop - |</span>
<span class="cm">		 *  | -------- extent -------- |</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">del_nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">);</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_key</span><span class="p">));</span>
			<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_duplicate_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span>
						   <span class="o">&amp;</span><span class="n">new_key</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">start</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>

			<span class="n">extent_offset</span> <span class="o">+=</span> <span class="n">start</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">btrfs_set_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">extent_offset</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">extent_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">disk_bytenr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_extent_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						<span class="n">disk_bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
						<span class="n">new_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
						<span class="n">start</span> <span class="o">-</span> <span class="n">extent_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
				<span class="o">*</span><span class="n">hint_byte</span> <span class="o">=</span> <span class="n">disk_bytenr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="cm">/*</span>
<span class="cm">		 *  | ---- range to drop ----- |</span>
<span class="cm">		 *      | -------- extent -------- |</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">);</span>

			<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_key</span><span class="p">));</span>
			<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="n">btrfs_set_item_key_safe</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_key</span><span class="p">);</span>

			<span class="n">extent_offset</span> <span class="o">+=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
			<span class="n">btrfs_set_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">extent_offset</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">extent_end</span> <span class="o">-</span> <span class="n">end</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">disk_bytenr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
				<span class="o">*</span><span class="n">hint_byte</span> <span class="o">=</span> <span class="n">disk_bytenr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">search_start</span> <span class="o">=</span> <span class="n">extent_end</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 *       | ---- range to drop ----- |</span>
<span class="cm">		 *  | -------- extent -------- |</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">del_nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">);</span>

			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">start</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">disk_bytenr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">extent_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
				<span class="o">*</span><span class="n">hint_byte</span> <span class="o">=</span> <span class="n">disk_bytenr</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">extent_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">next_slot</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 *  | ---- range to drop ----- |</span>
<span class="cm">		 *    | ------ extent ------ |</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&gt;=</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">del_nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">del_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
				<span class="n">del_nr</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">del_slot</span> <span class="o">+</span> <span class="n">del_nr</span> <span class="o">!=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="n">del_nr</span><span class="o">++</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">extent_type</span> <span class="o">==</span> <span class="n">BTRFS_FILE_EXTENT_INLINE</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">extent_end</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
				<span class="n">extent_end</span> <span class="o">=</span> <span class="n">ALIGN</span><span class="p">(</span><span class="n">extent_end</span><span class="p">,</span>
						   <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">disk_bytenr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span>
						<span class="n">disk_bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						<span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
						<span class="n">key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span>
						<span class="n">extent_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
				<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
				<span class="n">inode_sub_bytes</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
						<span class="n">extent_end</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
				<span class="o">*</span><span class="n">hint_byte</span> <span class="o">=</span> <span class="n">disk_bytenr</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">end</span> <span class="o">==</span> <span class="n">extent_end</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span> <span class="p">{</span>
				<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
				<span class="k">goto</span> <span class="n">next_slot</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">del_slot</span><span class="p">,</span>
					      <span class="n">del_nr</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="n">del_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">del_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">BUG_ON</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">del_nr</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">del_slot</span><span class="p">,</span> <span class="n">del_nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
	<span class="p">}</span>

<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">extent_mergeable</span><span class="p">(</span><span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">slot</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="n">objectid</span><span class="p">,</span> <span class="n">u64</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">u64</span> <span class="n">orig_offset</span><span class="p">,</span>
			    <span class="n">u64</span> <span class="o">*</span><span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_end</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">slot</span> <span class="o">&gt;=</span> <span class="n">btrfs_header_nritems</span><span class="p">(</span><span class="n">leaf</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">slot</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">objectid</span> <span class="o">||</span> <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">slot</span><span class="p">,</span> <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">!=</span> <span class="n">BTRFS_FILE_EXTENT_REG</span> <span class="o">||</span>
	    <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">!=</span> <span class="n">bytenr</span> <span class="o">||</span>
	    <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">!=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">orig_offset</span> <span class="o">||</span>
	    <span class="n">btrfs_file_extent_compression</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">btrfs_file_extent_encryption</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">btrfs_file_extent_other_encoding</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">extent_end</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">start</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">start</span> <span class="o">!=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="o">*</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">end</span> <span class="o">!=</span> <span class="n">extent_end</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="o">*</span><span class="n">start</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">;</span>
	<span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">extent_end</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Mark extent in the range start - end as written.</span>
<span class="cm"> *</span>
<span class="cm"> * This changes extent type from &#39;pre-allocated&#39; to &#39;regular&#39;. If only</span>
<span class="cm"> * part of extent is marked as written, the extent will be split into</span>
<span class="cm"> * two or three.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_mark_extent_written</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">,</span>
			      <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">u64</span> <span class="n">start</span><span class="p">,</span> <span class="n">u64</span> <span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_buffer</span> <span class="o">*</span><span class="n">leaf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_path</span> <span class="o">*</span><span class="n">path</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_file_extent_item</span> <span class="o">*</span><span class="n">fi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">key</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_key</span> <span class="n">new_key</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">bytenr</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">num_bytes</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">extent_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">orig_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">other_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">other_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">split</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">del_nr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">del_slot</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">recow</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ino</span> <span class="o">=</span> <span class="n">btrfs_ino</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>

	<span class="n">btrfs_drop_extent_cache</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">path</span> <span class="o">=</span> <span class="n">btrfs_alloc_path</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
<span class="nl">again:</span>
	<span class="n">recow</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">split</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">=</span> <span class="n">ino</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">;</span>
	<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">split</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_search_slot</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>

	<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="n">btrfs_item_key_to_cpu</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">objectid</span> <span class="o">!=</span> <span class="n">ino</span> <span class="o">||</span> <span class="n">key</span><span class="p">.</span><span class="n">type</span> <span class="o">!=</span> <span class="n">BTRFS_EXTENT_DATA_KEY</span><span class="p">);</span>
	<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">btrfs_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">)</span> <span class="o">!=</span>
	       <span class="n">BTRFS_FILE_EXTENT_PREALLOC</span><span class="p">);</span>
	<span class="n">extent_end</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">+</span> <span class="n">btrfs_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">start</span> <span class="o">||</span> <span class="n">extent_end</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">);</span>

	<span class="n">bytenr</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_bytenr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="n">num_bytes</span> <span class="o">=</span> <span class="n">btrfs_file_extent_disk_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="n">orig_offset</span> <span class="o">=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">-</span> <span class="n">btrfs_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">);</span>
	<span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">new_key</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">key</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">new_key</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">==</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">other_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">other_end</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extent_mergeable</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="n">ino</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">other_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_end</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
			<span class="n">btrfs_set_item_key_safe</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_key</span><span class="p">);</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">extent_end</span> <span class="o">-</span> <span class="n">end</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
						     <span class="n">end</span> <span class="o">-</span> <span class="n">orig_offset</span><span class="p">);</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">end</span> <span class="o">-</span> <span class="n">other_start</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">&amp;&amp;</span> <span class="n">end</span> <span class="o">==</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">other_start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="n">other_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">extent_mergeable</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
				     <span class="n">ino</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span>
				     <span class="o">&amp;</span><span class="n">other_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_end</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">start</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span><span class="p">;</span>
			<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
			<span class="n">btrfs_set_item_key_safe</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_key</span><span class="p">);</span>

			<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
					    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
							<span class="n">other_end</span> <span class="o">-</span> <span class="n">start</span><span class="p">);</span>
			<span class="n">btrfs_set_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
						     <span class="n">start</span> <span class="o">-</span> <span class="n">orig_offset</span><span class="p">);</span>
			<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">||</span> <span class="n">end</span> <span class="o">&lt;</span> <span class="n">extent_end</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span>
			<span class="n">split</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>

		<span class="n">new_key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">split</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_duplicate_item</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">new_key</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="n">EAGAIN</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">leaf</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
				    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
						<span class="n">split</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>

		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
				    <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>

		<span class="n">btrfs_set_file_extent_offset</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span> <span class="n">split</span> <span class="o">-</span> <span class="n">orig_offset</span><span class="p">);</span>
		<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
						<span class="n">extent_end</span> <span class="o">-</span> <span class="n">split</span><span class="p">);</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_inc_extent_ref</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
					   <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					   <span class="n">ino</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">split</span> <span class="o">==</span> <span class="n">start</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">BUG_ON</span><span class="p">(</span><span class="n">start</span> <span class="o">!=</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
			<span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">--</span><span class="p">;</span>
			<span class="n">extent_end</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">recow</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">other_start</span> <span class="o">=</span> <span class="n">end</span><span class="p">;</span>
	<span class="n">other_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extent_mergeable</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">ino</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">other_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">recow</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">extent_end</span> <span class="o">=</span> <span class="n">other_end</span><span class="p">;</span>
		<span class="n">del_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">del_nr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">ino</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span>
	<span class="n">other_start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">other_end</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">extent_mergeable</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			     <span class="n">ino</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">other_start</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">other_end</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">recow</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_release_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">key</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="n">other_start</span><span class="p">;</span>
		<span class="n">del_slot</span> <span class="o">=</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
		<span class="n">del_nr</span><span class="o">++</span><span class="p">;</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_free_extent</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">bytenr</span><span class="p">,</span> <span class="n">num_bytes</span><span class="p">,</span>
					<span class="mi">0</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">root_key</span><span class="p">.</span><span class="n">objectid</span><span class="p">,</span>
					<span class="n">ino</span><span class="p">,</span> <span class="n">orig_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ret</span><span class="p">);</span> <span class="cm">/* -ENOMEM */</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">del_nr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">path</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
			   <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">btrfs_set_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
					   <span class="n">BTRFS_FILE_EXTENT_REG</span><span class="p">);</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">fi</span> <span class="o">=</span> <span class="n">btrfs_item_ptr</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">del_slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">btrfs_file_extent_item</span><span class="p">);</span>
		<span class="n">btrfs_set_file_extent_type</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
					   <span class="n">BTRFS_FILE_EXTENT_REG</span><span class="p">);</span>
		<span class="n">btrfs_set_file_extent_num_bytes</span><span class="p">(</span><span class="n">leaf</span><span class="p">,</span> <span class="n">fi</span><span class="p">,</span>
						<span class="n">extent_end</span> <span class="o">-</span> <span class="n">key</span><span class="p">.</span><span class="n">offset</span><span class="p">);</span>
		<span class="n">btrfs_mark_buffer_dirty</span><span class="p">(</span><span class="n">leaf</span><span class="p">);</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_del_items</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">del_slot</span><span class="p">,</span> <span class="n">del_nr</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_abort_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">ret</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">btrfs_free_path</span><span class="p">(</span><span class="n">path</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * on error we return an unlocked page and the error value</span>
<span class="cm"> * on success we return a locked page and 0</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">prepare_uptodate_page</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="n">page</span><span class="p">,</span> <span class="n">u64</span> <span class="n">pos</span><span class="p">,</span>
				 <span class="n">bool</span> <span class="n">force_uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(((</span><span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">||</span> <span class="n">force_uptodate</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_readpage</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="n">lock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">PageUptodate</span><span class="p">(</span><span class="n">page</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">unlock_page</span><span class="p">(</span><span class="n">page</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * this gets pages into the page cache and locks them down, it also properly</span>
<span class="cm"> * waits for data=ordered extents to finish before allowing the pages to be</span>
<span class="cm"> * modified.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">prepare_pages</span><span class="p">(</span><span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
			 <span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">num_pages</span><span class="p">,</span>
			 <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_index</span><span class="p">,</span>
			 <span class="kt">size_t</span> <span class="n">write_bytes</span><span class="p">,</span> <span class="n">bool</span> <span class="n">force_uptodate</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="n">gfp_t</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">btrfs_alloc_write_mask</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">faili</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start_pos</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_pos</span><span class="p">;</span>

	<span class="n">start_pos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="o">~</span><span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">last_pos</span> <span class="o">=</span> <span class="p">((</span><span class="n">u64</span><span class="p">)</span><span class="n">index</span> <span class="o">+</span> <span class="n">num_pages</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

<span class="nl">again:</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">find_or_create_page</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span> <span class="n">index</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span>
					       <span class="n">mask</span> <span class="o">|</span> <span class="n">__GFP_WRITE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
			<span class="n">faili</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">prepare_uptodate_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">pos</span><span class="p">,</span>
						    <span class="n">force_uptodate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">num_pages</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">err</span> <span class="o">=</span> <span class="n">prepare_uptodate_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">],</span>
						    <span class="n">pos</span> <span class="o">+</span> <span class="n">write_bytes</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="n">faili</span> <span class="o">=</span> <span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">wait_on_page_writeback</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="p">}</span>
	<span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_pos</span> <span class="o">&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>
		<span class="n">lock_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
				 <span class="n">start_pos</span><span class="p">,</span> <span class="n">last_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
							    <span class="n">last_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">start_pos</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">last_pos</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
					     <span class="n">start_pos</span><span class="p">,</span> <span class="n">last_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
				<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
			<span class="p">}</span>
			<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span>
						 <span class="n">last_pos</span> <span class="o">-</span> <span class="n">start_pos</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">again</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>

		<span class="n">clear_extent_bit</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">start_pos</span><span class="p">,</span>
				  <span class="n">last_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">EXTENT_DIRTY</span> <span class="o">|</span> <span class="n">EXTENT_DELALLOC</span> <span class="o">|</span>
				  <span class="n">EXTENT_DO_ACCOUNTING</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span>
				  <span class="n">GFP_NOFS</span><span class="p">);</span>
		<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
				     <span class="n">start_pos</span><span class="p">,</span> <span class="n">last_pos</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span>
				     <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_pages</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">clear_page_dirty_for_io</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
			<span class="n">account_page_redirty</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">set_page_extent_mapped</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">WARN_ON</span><span class="p">(</span><span class="o">!</span><span class="n">PageLocked</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span><span class="p">]));</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">fail:</span>
	<span class="k">while</span> <span class="p">(</span><span class="n">faili</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">unlock_page</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">faili</span><span class="p">]);</span>
		<span class="n">page_cache_release</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">faili</span><span class="p">]);</span>
		<span class="n">faili</span><span class="o">--</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>

<span class="p">}</span>

<span class="k">static</span> <span class="n">noinline</span> <span class="kt">ssize_t</span> <span class="nf">__btrfs_buffered_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span>
					       <span class="k">struct</span> <span class="n">iov_iter</span> <span class="o">*</span><span class="n">i</span><span class="p">,</span>
					       <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">page</span> <span class="o">**</span><span class="n">pages</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">first_index</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">num_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nrptrs</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">bool</span> <span class="n">force_page_uptodate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

	<span class="n">nrptrs</span> <span class="o">=</span> <span class="n">min</span><span class="p">((</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
		     <span class="n">PAGE_CACHE_SIZE</span><span class="p">,</span> <span class="n">PAGE_CACHE_SIZE</span> <span class="o">/</span>
		     <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">)));</span>
	<span class="n">nrptrs</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">nrptrs</span><span class="p">,</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied_pause</span> <span class="o">-</span> <span class="n">current</span><span class="o">-&gt;</span><span class="n">nr_dirtied</span><span class="p">);</span>
	<span class="n">nrptrs</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">nrptrs</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
	<span class="n">pages</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="n">nrptrs</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">page</span> <span class="o">*</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">pages</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">first_index</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">size_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">write_bytes</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">iov_iter_count</span><span class="p">(</span><span class="n">i</span><span class="p">),</span>
					 <span class="n">nrptrs</span> <span class="o">*</span> <span class="p">(</span><span class="kt">size_t</span><span class="p">)</span><span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span>
					 <span class="n">offset</span><span class="p">);</span>
		<span class="kt">size_t</span> <span class="n">num_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">write_bytes</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span>
				    <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">dirty_pages</span><span class="p">;</span>
		<span class="kt">size_t</span> <span class="n">copied</span><span class="p">;</span>

		<span class="n">WARN_ON</span><span class="p">(</span><span class="n">num_pages</span> <span class="o">&gt;</span> <span class="n">nrptrs</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * Fault pages before locking them in prepare_pages</span>
<span class="cm">		 * to avoid recursive lock</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">iov_iter_fault_in_readable</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">write_bytes</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">EFAULT</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_delalloc_reserve_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					<span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/*</span>
<span class="cm">		 * This is going to setup the pages array with the number of</span>
<span class="cm">		 * pages we want, so we don&#39;t really need to worry about the</span>
<span class="cm">		 * contents of pages from loop to loop</span>
<span class="cm">		 */</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">prepare_pages</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">file</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">,</span>
				    <span class="n">pos</span><span class="p">,</span> <span class="n">first_index</span><span class="p">,</span> <span class="n">write_bytes</span><span class="p">,</span>
				    <span class="n">force_page_uptodate</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					<span class="n">num_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">copied</span> <span class="o">=</span> <span class="n">btrfs_copy_from_user</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">,</span>
					   <span class="n">write_bytes</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

		<span class="cm">/*</span>
<span class="cm">		 * if we have trouble faulting in the pages, fall</span>
<span class="cm">		 * back to one page at a time</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&lt;</span> <span class="n">write_bytes</span><span class="p">)</span>
			<span class="n">nrptrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">force_page_uptodate</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
			<span class="n">dirty_pages</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">force_page_uptodate</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
			<span class="n">dirty_pages</span> <span class="o">=</span> <span class="p">(</span><span class="n">copied</span> <span class="o">+</span> <span class="n">offset</span> <span class="o">+</span>
				       <span class="n">PAGE_CACHE_SIZE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span>
				       <span class="n">PAGE_CACHE_SHIFT</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/*</span>
<span class="cm">		 * If we had a short copy we need to release the excess delaloc</span>
<span class="cm">		 * bytes we reserved.  We need to increment outstanding_extents</span>
<span class="cm">		 * because btrfs_delalloc_release_space will decrement it, but</span>
<span class="cm">		 * we still have an outstanding extent for the chunk we actually</span>
<span class="cm">		 * managed to copy.</span>
<span class="cm">		 */</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_pages</span> <span class="o">&gt;</span> <span class="n">dirty_pages</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
				<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">outstanding_extents</span><span class="o">++</span><span class="p">;</span>
				<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">lock</span><span class="p">);</span>
			<span class="p">}</span>
			<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					<span class="p">(</span><span class="n">num_pages</span> <span class="o">-</span> <span class="n">dirty_pages</span><span class="p">)</span> <span class="o">&lt;&lt;</span>
					<span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">copied</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_dirty_pages</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">,</span> <span class="n">pages</span><span class="p">,</span>
						<span class="n">dirty_pages</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">copied</span><span class="p">,</span>
						<span class="nb">NULL</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">btrfs_delalloc_release_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
					<span class="n">dirty_pages</span> <span class="o">&lt;&lt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
				<span class="n">btrfs_drop_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">btrfs_drop_pages</span><span class="p">(</span><span class="n">pages</span><span class="p">,</span> <span class="n">num_pages</span><span class="p">);</span>

		<span class="n">cond_resched</span><span class="p">();</span>

		<span class="n">balance_dirty_pages_ratelimited_nr</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">,</span>
						   <span class="n">dirty_pages</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dirty_pages</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">leafsize</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
			<span class="n">btrfs_btree_balance_dirty</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>

		<span class="n">pos</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
		<span class="n">num_written</span> <span class="o">+=</span> <span class="n">copied</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">pages</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">num_written</span> <span class="o">?</span> <span class="n">num_written</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">__btrfs_direct_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">,</span>
				    <span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">ocount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">iov_iter</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">written</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">written_buffered</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">endbyte</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">written</span> <span class="o">=</span> <span class="n">generic_file_direct_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span>
					    <span class="n">count</span><span class="p">,</span> <span class="n">ocount</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * the generic O_DIRECT will update in-memory i_size after the</span>
<span class="cm">	 * DIOs are done.  But our endio handlers that update the on</span>
<span class="cm">	 * disk i_size never update past the in memory i_size.  So we</span>
<span class="cm">	 * need one more update here to catch any additions to the</span>
<span class="cm">	 * file</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">!=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">disk_i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="n">mark_inode_dirty</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">written</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">written</span> <span class="o">==</span> <span class="n">count</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">written</span><span class="p">;</span>

	<span class="n">pos</span> <span class="o">+=</span> <span class="n">written</span><span class="p">;</span>
	<span class="n">count</span> <span class="o">-=</span> <span class="n">written</span><span class="p">;</span>
	<span class="n">iov_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">written</span><span class="p">);</span>
	<span class="n">written_buffered</span> <span class="o">=</span> <span class="n">__btrfs_buffered_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">written_buffered</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">written_buffered</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">endbyte</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">written_buffered</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">filemap_write_and_wait_range</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">endbyte</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="n">written</span> <span class="o">+=</span> <span class="n">written_buffered</span><span class="p">;</span>
	<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">written_buffered</span><span class="p">;</span>
	<span class="n">invalidate_mapping_pages</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">,</span> <span class="n">pos</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">,</span>
				 <span class="n">endbyte</span> <span class="o">&gt;&gt;</span> <span class="n">PAGE_CACHE_SHIFT</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">written</span> <span class="o">?</span> <span class="n">written</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">ssize_t</span> <span class="nf">btrfs_file_aio_write</span><span class="p">(</span><span class="k">struct</span> <span class="n">kiocb</span> <span class="o">*</span><span class="n">iocb</span><span class="p">,</span>
				    <span class="k">const</span> <span class="k">struct</span> <span class="n">iovec</span> <span class="o">*</span><span class="n">iov</span><span class="p">,</span>
				    <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">pos</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_filp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">fdentry</span><span class="p">(</span><span class="n">file</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">iocb</span><span class="o">-&gt;</span><span class="n">ki_pos</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">start_pos</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">num_written</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">ssize_t</span> <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="n">ocount</span><span class="p">;</span>

	<span class="n">vfs_check_frozen</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="p">,</span> <span class="n">SB_FREEZE_WRITE</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_segment_checks</span><span class="p">(</span><span class="n">iov</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nr_segs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ocount</span><span class="p">,</span> <span class="n">VERIFY_READ</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">count</span> <span class="o">=</span> <span class="n">ocount</span><span class="p">;</span>

	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">generic_write_checks</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">pos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">,</span> <span class="n">S_ISBLK</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mode</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">file_remove_suid</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * If BTRFS flips readonly due to some impossible error</span>
<span class="cm">	 * (fs_info-&gt;fs_state now has BTRFS_SUPER_FLAG_ERROR),</span>
<span class="cm">	 * although we have opened a file as writable, we have</span>
<span class="cm">	 * to stop this write operation to ensure FS consistency.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">fs_state</span> <span class="o">&amp;</span> <span class="n">BTRFS_SUPER_FLAG_ERROR</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="n">err</span> <span class="o">=</span> <span class="o">-</span><span class="n">EROFS</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">file_update_time</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">start_pos</span> <span class="o">=</span> <span class="n">round_down</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">start_pos</span> <span class="o">&gt;</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">btrfs_cont_expand</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span> <span class="n">start_pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">unlikely</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_flags</span> <span class="o">&amp;</span> <span class="n">O_DIRECT</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">num_written</span> <span class="o">=</span> <span class="n">__btrfs_direct_write</span><span class="p">(</span><span class="n">iocb</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span>
						   <span class="n">pos</span><span class="p">,</span> <span class="n">ppos</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">ocount</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">iov_iter</span> <span class="n">i</span><span class="p">;</span>

		<span class="n">iov_iter_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">iov</span><span class="p">,</span> <span class="n">nr_segs</span><span class="p">,</span> <span class="n">count</span><span class="p">,</span> <span class="n">num_written</span><span class="p">);</span>

		<span class="n">num_written</span> <span class="o">=</span> <span class="n">__btrfs_buffered_write</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">num_written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">*</span><span class="n">ppos</span> <span class="o">=</span> <span class="n">pos</span> <span class="o">+</span> <span class="n">num_written</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we want to make sure fsync finds this change</span>
<span class="cm">	 * but we haven&#39;t joined a transaction running right now.</span>
<span class="cm">	 *</span>
<span class="cm">	 * Later on, someone is sure to update the inode and get the</span>
<span class="cm">	 * real transid recorded.</span>
<span class="cm">	 *</span>
<span class="cm">	 * We set last_trans now to the fs_info generation + 1,</span>
<span class="cm">	 * this will either be one more than the running transaction</span>
<span class="cm">	 * or the generation used for the next transaction if there isn&#39;t</span>
<span class="cm">	 * one running right now.</span>
<span class="cm">	 */</span>
	<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_trans</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">num_written</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">num_written</span> <span class="o">==</span> <span class="o">-</span><span class="n">EIOCBQUEUED</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">err</span> <span class="o">=</span> <span class="n">generic_write_sync</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">pos</span><span class="p">,</span> <span class="n">num_written</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">err</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">num_written</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
			<span class="n">num_written</span> <span class="o">=</span> <span class="n">err</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">current</span><span class="o">-&gt;</span><span class="n">backing_dev_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">num_written</span> <span class="o">?</span> <span class="n">num_written</span> <span class="o">:</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">btrfs_release_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">filp</span><span class="p">)</span>
<span class="p">{</span>
	<span class="cm">/*</span>
<span class="cm">	 * ordered_data_close is set by settattr when we are about to truncate</span>
<span class="cm">	 * a file from a non-zero size to a zero size.  This tries to</span>
<span class="cm">	 * flush down new bytes that may have been written if the</span>
<span class="cm">	 * application were using truncate to replace a file in place.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">BTRFS_INODE_ORDERED_DATA_CLOSE</span><span class="p">,</span>
			       <span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">runtime_flags</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">btrfs_add_ordered_operation</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">,</span> <span class="n">inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;</span> <span class="n">BTRFS_ORDERED_OPERATIONS_FLUSH_LIMIT</span><span class="p">)</span>
			<span class="n">filemap_flush</span><span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mapping</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">filp</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span>
		<span class="n">btrfs_ioctl_trans_end</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * fsync call for both files and directories.  This logs the inode into</span>
<span class="cm"> * the tree log instead of forcing full commits whenever possible.</span>
<span class="cm"> *</span>
<span class="cm"> * It needs to call filemap_fdatawait so that all ordered extent updates are</span>
<span class="cm"> * in the metadata btree are up to date for copying to the log.</span>
<span class="cm"> *</span>
<span class="cm"> * It drops the inode mutex before doing the tree log commit.  This is an</span>
<span class="cm"> * important optimization for directories because holding the mutex prevents</span>
<span class="cm"> * new operations on the dir while we write to disk.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">btrfs_sync_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">start</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">datasync</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">btrfs_trans_handle</span> <span class="o">*</span><span class="n">trans</span><span class="p">;</span>

	<span class="n">trace_btrfs_sync_file</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">datasync</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * we wait first, since the writeback may change the inode, also wait</span>
<span class="cm">	 * ordered range does a filemape_write_and_wait_range which is why we</span>
<span class="cm">	 * don&#39;t do it above like other file systems.</span>
<span class="cm">	 */</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">log_batch</span><span class="o">++</span><span class="p">;</span>
	<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
	<span class="n">root</span><span class="o">-&gt;</span><span class="n">log_batch</span><span class="o">++</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * check the transaction that last modified this inode</span>
<span class="cm">	 * and see if its already been committed</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_trans</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * if the last transaction that changed this file was before</span>
<span class="cm">	 * the current transaction, we can bail out now without any</span>
<span class="cm">	 * syncing</span>
<span class="cm">	 */</span>
	<span class="n">smp_mb</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">btrfs_inode_in_log</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">)</span> <span class="o">||</span>
	    <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_trans</span> <span class="o">&lt;=</span>
	    <span class="n">root</span><span class="o">-&gt;</span><span class="n">fs_info</span><span class="o">-&gt;</span><span class="n">last_trans_committed</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">last_trans</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * ok we haven&#39;t committed the transaction yet, lets do a commit</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">private_data</span><span class="p">)</span>
		<span class="n">btrfs_ioctl_trans_end</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

	<span class="n">trans</span> <span class="o">=</span> <span class="n">btrfs_start_transaction</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">trans</span><span class="p">);</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_log_dentry_safe</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">,</span> <span class="n">dentry</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* we&#39;ve logged all the items and now have a consistent</span>
<span class="cm">	 * version of the file in the log.  It is possible that</span>
<span class="cm">	 * someone will come in and modify the file, but that&#39;s</span>
<span class="cm">	 * fine because the log is consistent on disk, and we</span>
<span class="cm">	 * have references to all of the file&#39;s extents</span>
<span class="cm">	 *</span>
<span class="cm">	 * It is possible that someone will come in and log the</span>
<span class="cm">	 * file again, but that will end up using the synchronization</span>
<span class="cm">	 * inside btrfs_sync_log to keep things safe.</span>
<span class="cm">	 */</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">!=</span> <span class="n">BTRFS_NO_LOG_SYNC</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_sync_log</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_commit_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_end_transaction</span><span class="p">(</span><span class="n">trans</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">ret</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="o">-</span><span class="n">EIO</span> <span class="o">:</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">vm_operations_struct</span> <span class="n">btrfs_file_vm_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">fault</span>		<span class="o">=</span> <span class="n">filemap_fault</span><span class="p">,</span>
	<span class="p">.</span><span class="n">page_mkwrite</span>	<span class="o">=</span> <span class="n">btrfs_page_mkwrite</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">btrfs_file_mmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span>	<span class="o">*</span><span class="n">filp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">vm_area_struct</span> <span class="o">*</span><span class="n">vma</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">address_space</span> <span class="o">*</span><span class="n">mapping</span> <span class="o">=</span> <span class="n">filp</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">mapping</span><span class="o">-&gt;</span><span class="n">a_ops</span><span class="o">-&gt;</span><span class="n">readpage</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOEXEC</span><span class="p">;</span>

	<span class="n">file_accessed</span><span class="p">(</span><span class="n">filp</span><span class="p">);</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_ops</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">btrfs_file_vm_ops</span><span class="p">;</span>
	<span class="n">vma</span><span class="o">-&gt;</span><span class="n">vm_flags</span> <span class="o">|=</span> <span class="n">VM_CAN_NONLINEAR</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">long</span> <span class="nf">btrfs_fallocate</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">,</span>
			    <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_path</span><span class="p">.</span><span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_inode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">cur_offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">last_byte</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_start</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">alloc_hint</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">locked_end</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">mask</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">alloc_start</span> <span class="o">=</span> <span class="n">offset</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>
	<span class="n">alloc_end</span> <span class="o">=</span>  <span class="p">(</span><span class="n">offset</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

	<span class="cm">/* We only support the FALLOC_FL_KEEP_SIZE mode */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EOPNOTSUPP</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Make sure we have enough space before we do the</span>
<span class="cm">	 * allocation.</span>
<span class="cm">	 */</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_check_data_free_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * wait for ordered IO before we have any locks.  We&#39;ll loop again</span>
<span class="cm">	 * below with the locks held.</span>
<span class="cm">	 */</span>
	<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">alloc_start</span><span class="p">,</span> <span class="n">alloc_end</span> <span class="o">-</span> <span class="n">alloc_start</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">inode_newsize_ok</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">alloc_end</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">alloc_start</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_cont_expand</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">),</span>
					<span class="n">alloc_start</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">locked_end</span> <span class="o">=</span> <span class="n">alloc_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">btrfs_ordered_extent</span> <span class="o">*</span><span class="n">ordered</span><span class="p">;</span>

		<span class="cm">/* the extent lock is ordered inside the running</span>
<span class="cm">		 * transaction</span>
<span class="cm">		 */</span>
		<span class="n">lock_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">alloc_start</span><span class="p">,</span>
				 <span class="n">locked_end</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>
		<span class="n">ordered</span> <span class="o">=</span> <span class="n">btrfs_lookup_first_ordered_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span>
							    <span class="n">alloc_end</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">+</span> <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">len</span> <span class="o">&gt;</span> <span class="n">alloc_start</span> <span class="o">&amp;&amp;</span>
		    <span class="n">ordered</span><span class="o">-&gt;</span><span class="n">file_offset</span> <span class="o">&lt;</span> <span class="n">alloc_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span>
					     <span class="n">alloc_start</span><span class="p">,</span> <span class="n">locked_end</span><span class="p">,</span>
					     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
			<span class="cm">/*</span>
<span class="cm">			 * we can&#39;t wait on the range with the transaction</span>
<span class="cm">			 * running or with the extent lock held</span>
<span class="cm">			 */</span>
			<span class="n">btrfs_wait_ordered_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">alloc_start</span><span class="p">,</span>
						 <span class="n">alloc_end</span> <span class="o">-</span> <span class="n">alloc_start</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ordered</span><span class="p">)</span>
				<span class="n">btrfs_put_ordered_extent</span><span class="p">(</span><span class="n">ordered</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">alloc_start</span><span class="p">;</span>
	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u64</span> <span class="n">actual_end</span><span class="p">;</span>

		<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cur_offset</span><span class="p">,</span>
				      <span class="n">alloc_end</span> <span class="o">-</span> <span class="n">cur_offset</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR_OR_NULL</span><span class="p">(</span><span class="n">em</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">em</span><span class="p">)</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
			<span class="k">else</span>
				<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_byte</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">),</span> <span class="n">alloc_end</span><span class="p">);</span>
		<span class="n">actual_end</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">extent_map_end</span><span class="p">(</span><span class="n">em</span><span class="p">),</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">);</span>
		<span class="n">last_byte</span> <span class="o">=</span> <span class="p">(</span><span class="n">last_byte</span> <span class="o">+</span> <span class="n">mask</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">~</span><span class="n">mask</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_HOLE</span> <span class="o">||</span>
		    <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span>
		     <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_PREALLOC</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">)))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">btrfs_prealloc_file_range</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">cur_offset</span><span class="p">,</span>
							<span class="n">last_byte</span> <span class="o">-</span> <span class="n">cur_offset</span><span class="p">,</span>
							<span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_blkbits</span><span class="p">,</span>
							<span class="n">offset</span> <span class="o">+</span> <span class="n">len</span><span class="p">,</span>
							<span class="o">&amp;</span><span class="n">alloc_hint</span><span class="p">);</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">actual_end</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&amp;&amp;</span>
			   <span class="o">!</span><span class="p">(</span><span class="n">mode</span> <span class="o">&amp;</span> <span class="n">FALLOC_FL_KEEP_SIZE</span><span class="p">))</span> <span class="p">{</span>
			<span class="cm">/*</span>
<span class="cm">			 * We didn&#39;t need to allocate any more space, but we</span>
<span class="cm">			 * still extended the size of the file so we need to</span>
<span class="cm">			 * update i_size.</span>
<span class="cm">			 */</span>
			<span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_ctime</span> <span class="o">=</span> <span class="n">CURRENT_TIME</span><span class="p">;</span>
			<span class="n">i_size_write</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">actual_end</span><span class="p">);</span>
			<span class="n">btrfs_ordered_update_i_size</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">actual_end</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>

		<span class="n">cur_offset</span> <span class="o">=</span> <span class="n">last_byte</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">cur_offset</span> <span class="o">&gt;=</span> <span class="n">alloc_end</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">alloc_start</span><span class="p">,</span> <span class="n">locked_end</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="cm">/* Let go of our reservation. */</span>
	<span class="n">btrfs_free_reserved_data_space</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">find_desired_extent</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">,</span> <span class="n">loff_t</span> <span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">btrfs_root</span> <span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">root</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_map</span> <span class="o">*</span><span class="n">em</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_state</span> <span class="o">*</span><span class="n">cached_state</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lockstart</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">lockend</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">start</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">orig_start</span> <span class="o">=</span> <span class="o">*</span><span class="n">offset</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">len</span> <span class="o">=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="n">u64</span> <span class="n">last_end</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lockend</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span> <span class="n">lockend</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lockend</span> <span class="o">&lt;=</span> <span class="n">lockstart</span><span class="p">)</span>
		<span class="n">lockend</span> <span class="o">=</span> <span class="n">lockstart</span> <span class="o">+</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">lockend</span> <span class="o">-</span> <span class="n">lockstart</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">len</span> <span class="o">=</span> <span class="n">max_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>

	<span class="n">lock_extent_bits</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">lockstart</span><span class="p">,</span> <span class="n">lockend</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
			 <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Delalloc is such a pain.  If we have a hole and we have pending</span>
<span class="cm">	 * delalloc for a portion of the hole we will get back a hole that</span>
<span class="cm">	 * exists for the entire range since it hasn&#39;t been actually written</span>
<span class="cm">	 * yet.  So to take care of this case we need to look for an extent just</span>
<span class="cm">	 * before the position we want in case there is outstanding delalloc</span>
<span class="cm">	 * going on here.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_HOLE</span> <span class="o">&amp;&amp;</span> <span class="n">start</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&lt;=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">)</span>
			<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						     <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						     <span class="n">start</span> <span class="o">-</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span>
						     <span class="n">root</span><span class="o">-&gt;</span><span class="n">sectorsize</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">last_end</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_DELALLOC</span><span class="p">)</span>
			<span class="n">last_end</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">last_end</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">em</span> <span class="o">=</span> <span class="n">btrfs_get_extent_fiemap</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">IS_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">PTR_ERR</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_HOLE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_VACANCY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">last_end</span> <span class="o">&lt;=</span> <span class="n">orig_start</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
					<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_HOLE</span><span class="p">)</span> <span class="p">{</span>
				<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">origin</span> <span class="o">==</span> <span class="n">SEEK_DATA</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_DELALLOC</span><span class="p">)</span> <span class="p">{</span>
					<span class="k">if</span> <span class="p">(</span><span class="n">start</span> <span class="o">&gt;=</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">)</span> <span class="p">{</span>
						<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
						<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
						<span class="k">break</span><span class="p">;</span>
					<span class="p">}</span>
				<span class="p">}</span>

				<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">start</span><span class="p">;</span>
				<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>

		<span class="n">start</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>
		<span class="n">last_end</span> <span class="o">=</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">start</span> <span class="o">+</span> <span class="n">em</span><span class="o">-&gt;</span><span class="n">len</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">block_start</span> <span class="o">==</span> <span class="n">EXTENT_MAP_DELALLOC</span><span class="p">)</span>
			<span class="n">last_end</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u64</span><span class="p">,</span> <span class="n">last_end</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">test_bit</span><span class="p">(</span><span class="n">EXTENT_FLAG_VACANCY</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">em</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">free_extent_map</span><span class="p">(</span><span class="n">em</span><span class="p">);</span>
		<span class="n">cond_resched</span><span class="p">();</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span>
		<span class="o">*</span><span class="n">offset</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="o">*</span><span class="n">offset</span><span class="p">,</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_size</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="n">unlock_extent_cached</span><span class="p">(</span><span class="o">&amp;</span><span class="n">BTRFS_I</span><span class="p">(</span><span class="n">inode</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">io_tree</span><span class="p">,</span> <span class="n">lockstart</span><span class="p">,</span> <span class="n">lockend</span><span class="p">,</span>
			     <span class="o">&amp;</span><span class="n">cached_state</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">btrfs_file_llseek</span><span class="p">(</span><span class="k">struct</span> <span class="n">file</span> <span class="o">*</span><span class="n">file</span><span class="p">,</span> <span class="n">loff_t</span> <span class="n">offset</span><span class="p">,</span> <span class="kt">int</span> <span class="n">origin</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mapping</span><span class="o">-&gt;</span><span class="n">host</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">switch</span> <span class="p">(</span><span class="n">origin</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="n">SEEK_END</span>:
	<span class="k">case</span> <span class="n">SEEK_CUR</span>:
		<span class="n">offset</span> <span class="o">=</span> <span class="n">generic_file_llseek</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="k">case</span> <span class="n">SEEK_DATA</span>:
	<span class="k">case</span> <span class="n">SEEK_HOLE</span>:
		<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;=</span> <span class="n">i_size_read</span><span class="p">(</span><span class="n">inode</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="n">ENXIO</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">ret</span> <span class="o">=</span> <span class="n">find_desired_extent</span><span class="p">(</span><span class="n">inode</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">offset</span><span class="p">,</span> <span class="n">origin</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
			<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="p">(</span><span class="n">file</span><span class="o">-&gt;</span><span class="n">f_mode</span> <span class="o">&amp;</span> <span class="n">FMODE_UNSIGNED_OFFSET</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">&gt;</span> <span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">offset</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Special lock needed here? */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">offset</span> <span class="o">!=</span> <span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_pos</span> <span class="o">=</span> <span class="n">offset</span><span class="p">;</span>
		<span class="n">file</span><span class="o">-&gt;</span><span class="n">f_version</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_mutex</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">offset</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="k">struct</span> <span class="n">file_operations</span> <span class="n">btrfs_file_operations</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">llseek</span>		<span class="o">=</span> <span class="n">btrfs_file_llseek</span><span class="p">,</span>
	<span class="p">.</span><span class="n">read</span>		<span class="o">=</span> <span class="n">do_sync_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write</span>		<span class="o">=</span> <span class="n">do_sync_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_read</span>       <span class="o">=</span> <span class="n">generic_file_aio_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">splice_read</span>	<span class="o">=</span> <span class="n">generic_file_splice_read</span><span class="p">,</span>
	<span class="p">.</span><span class="n">aio_write</span>	<span class="o">=</span> <span class="n">btrfs_file_aio_write</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mmap</span>		<span class="o">=</span> <span class="n">btrfs_file_mmap</span><span class="p">,</span>
	<span class="p">.</span><span class="n">open</span>		<span class="o">=</span> <span class="n">generic_file_open</span><span class="p">,</span>
	<span class="p">.</span><span class="n">release</span>	<span class="o">=</span> <span class="n">btrfs_release_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fsync</span>		<span class="o">=</span> <span class="n">btrfs_sync_file</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fallocate</span>	<span class="o">=</span> <span class="n">btrfs_fallocate</span><span class="p">,</span>
	<span class="p">.</span><span class="n">unlocked_ioctl</span>	<span class="o">=</span> <span class="n">btrfs_ioctl</span><span class="p">,</span>
<span class="cp">#ifdef CONFIG_COMPAT</span>
	<span class="p">.</span><span class="n">compat_ioctl</span>	<span class="o">=</span> <span class="n">btrfs_ioctl</span><span class="p">,</span>
<span class="cp">#endif</span>
<span class="p">};</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
