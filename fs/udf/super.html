<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › udf › super.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>super.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * super.c</span>
<span class="cm"> *</span>
<span class="cm"> * PURPOSE</span>
<span class="cm"> *  Super block routines for the OSTA-UDF(tm) filesystem.</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION</span>
<span class="cm"> *  OSTA-UDF(tm) = Optical Storage Technology Association</span>
<span class="cm"> *  Universal Disk Format.</span>
<span class="cm"> *</span>
<span class="cm"> *  This code is based on version 2.00 of the UDF specification,</span>
<span class="cm"> *  and revision 3 of the ECMA 167 standard [equivalent to ISO 13346].</span>
<span class="cm"> *    http://www.osta.org/</span>
<span class="cm"> *    http://www.ecma.ch/</span>
<span class="cm"> *    http://www.iso.org/</span>
<span class="cm"> *</span>
<span class="cm"> * COPYRIGHT</span>
<span class="cm"> *  This file is distributed under the terms of the GNU General Public</span>
<span class="cm"> *  License (GPL). Copies of the GPL can be obtained from:</span>
<span class="cm"> *    ftp://prep.ai.mit.edu/pub/gnu/GPL</span>
<span class="cm"> *  Each contributing author retains all rights to their own work.</span>
<span class="cm"> *</span>
<span class="cm"> *  (C) 1998 Dave Boynton</span>
<span class="cm"> *  (C) 1998-2004 Ben Fennema</span>
<span class="cm"> *  (C) 2000 Stelias Computing Inc</span>
<span class="cm"> *</span>
<span class="cm"> * HISTORY</span>
<span class="cm"> *</span>
<span class="cm"> *  09/24/98 dgb  changed to allow compiling outside of kernel, and</span>
<span class="cm"> *                added some debugging.</span>
<span class="cm"> *  10/01/98 dgb  updated to allow (some) possibility of compiling w/2.0.34</span>
<span class="cm"> *  10/16/98      attempting some multi-session support</span>
<span class="cm"> *  10/17/98      added freespace count for &quot;df&quot;</span>
<span class="cm"> *  11/11/98 gr   added novrs option</span>
<span class="cm"> *  11/26/98 dgb  added fileset,anchor mount options</span>
<span class="cm"> *  12/06/98 blf  really hosed things royally. vat/sparing support. sequenced</span>
<span class="cm"> *                vol descs. rewrote option handling based on isofs</span>
<span class="cm"> *  12/20/98      find the free space bitmap (if it exists)</span>
<span class="cm"> */</span>

<span class="cp">#include &quot;udfdecl.h&quot;</span>

<span class="cp">#include &lt;linux/blkdev.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/parser.h&gt;</span>
<span class="cp">#include &lt;linux/stat.h&gt;</span>
<span class="cp">#include &lt;linux/cdrom.h&gt;</span>
<span class="cp">#include &lt;linux/nls.h&gt;</span>
<span class="cp">#include &lt;linux/buffer_head.h&gt;</span>
<span class="cp">#include &lt;linux/vfs.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/mount.h&gt;</span>
<span class="cp">#include &lt;linux/seq_file.h&gt;</span>
<span class="cp">#include &lt;linux/bitmap.h&gt;</span>
<span class="cp">#include &lt;linux/crc-itu-t.h&gt;</span>
<span class="cp">#include &lt;linux/log2.h&gt;</span>
<span class="cp">#include &lt;asm/byteorder.h&gt;</span>

<span class="cp">#include &quot;udf_sb.h&quot;</span>
<span class="cp">#include &quot;udf_i.h&quot;</span>

<span class="cp">#include &lt;linux/init.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#define VDS_POS_PRIMARY_VOL_DESC	0</span>
<span class="cp">#define VDS_POS_UNALLOC_SPACE_DESC	1</span>
<span class="cp">#define VDS_POS_LOGICAL_VOL_DESC	2</span>
<span class="cp">#define VDS_POS_PARTITION_DESC		3</span>
<span class="cp">#define VDS_POS_IMP_USE_VOL_DESC	4</span>
<span class="cp">#define VDS_POS_VOL_DESC_PTR		5</span>
<span class="cp">#define VDS_POS_TERMINATING_DESC	6</span>
<span class="cp">#define VDS_POS_LENGTH			7</span>

<span class="cp">#define UDF_DEFAULT_BLOCKSIZE 2048</span>

<span class="k">enum</span> <span class="p">{</span> <span class="n">UDF_MAX_LINKS</span> <span class="o">=</span> <span class="mh">0xffff</span> <span class="p">};</span>

<span class="cm">/* These are the &quot;meat&quot; - everything else is stuffing */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">udf_put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_sync_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_remount_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">udf_load_logicalvolint</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_extent_ad</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_find_fileset</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">udf_load_fileset</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">udf_open_lvid</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">void</span> <span class="n">udf_close_lvid</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">udf_count_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="p">);</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="p">);</span>

<span class="k">struct</span> <span class="n">logicalVolIntegrityDescImpUse</span> <span class="o">*</span><span class="nf">udf_sb_lvidiu</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="n">lvid</span> <span class="o">=</span>
		<span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">__u32</span> <span class="n">number_of_partitions</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">numOfPartitions</span><span class="p">);</span>
	<span class="n">__u32</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">number_of_partitions</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span>
				<span class="k">sizeof</span><span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span><span class="o">/</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">uint8_t</span><span class="p">);</span>
	<span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolIntegrityDescImpUse</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">impUse</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
<span class="p">}</span>

<span class="cm">/* UDF filesystem type */</span>
<span class="k">static</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="nf">udf_mount</span><span class="p">(</span><span class="k">struct</span> <span class="n">file_system_type</span> <span class="o">*</span><span class="n">fs_type</span><span class="p">,</span>
		      <span class="kt">int</span> <span class="n">flags</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">dev_name</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">mount_bdev</span><span class="p">(</span><span class="n">fs_type</span><span class="p">,</span> <span class="n">flags</span><span class="p">,</span> <span class="n">dev_name</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">udf_fill_super</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">file_system_type</span> <span class="n">udf_fstype</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">owner</span>		<span class="o">=</span> <span class="n">THIS_MODULE</span><span class="p">,</span>
	<span class="p">.</span><span class="n">name</span>		<span class="o">=</span> <span class="s">&quot;udf&quot;</span><span class="p">,</span>
	<span class="p">.</span><span class="n">mount</span>		<span class="o">=</span> <span class="n">udf_mount</span><span class="p">,</span>
	<span class="p">.</span><span class="n">kill_sb</span>	<span class="o">=</span> <span class="n">kill_block_super</span><span class="p">,</span>
	<span class="p">.</span><span class="n">fs_flags</span>	<span class="o">=</span> <span class="n">FS_REQUIRES_DEV</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">kmem_cache</span> <span class="o">*</span><span class="n">udf_inode_cachep</span><span class="p">;</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">udf_alloc_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_inode_info</span> <span class="o">*</span><span class="n">ei</span><span class="p">;</span>
	<span class="n">ei</span> <span class="o">=</span> <span class="n">kmem_cache_alloc</span><span class="p">(</span><span class="n">udf_inode_cachep</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ei</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_unique</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_lenExtents</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_next_alloc_block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_next_alloc_goal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_strat4096</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">init_rwsem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_data_sem</span><span class="p">);</span>

	<span class="k">return</span> <span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_i_callback</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcu_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="n">container_of</span><span class="p">(</span><span class="n">head</span><span class="p">,</span> <span class="k">struct</span> <span class="n">inode</span><span class="p">,</span> <span class="n">i_rcu</span><span class="p">);</span>
	<span class="n">kmem_cache_free</span><span class="p">(</span><span class="n">udf_inode_cachep</span><span class="p">,</span> <span class="n">UDF_I</span><span class="p">(</span><span class="n">inode</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_destroy_inode</span><span class="p">(</span><span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">call_rcu</span><span class="p">(</span><span class="o">&amp;</span><span class="n">inode</span><span class="o">-&gt;</span><span class="n">i_rcu</span><span class="p">,</span> <span class="n">udf_i_callback</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">init_once</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_inode_info</span> <span class="o">*</span><span class="n">ei</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">udf_inode_info</span> <span class="o">*</span><span class="p">)</span><span class="n">foo</span><span class="p">;</span>

	<span class="n">ei</span><span class="o">-&gt;</span><span class="n">i_ext</span><span class="p">.</span><span class="n">i_data</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">inode_init_once</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ei</span><span class="o">-&gt;</span><span class="n">vfs_inode</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">init_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">udf_inode_cachep</span> <span class="o">=</span> <span class="n">kmem_cache_create</span><span class="p">(</span><span class="s">&quot;udf_inode_cache&quot;</span><span class="p">,</span>
					     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_inode_info</span><span class="p">),</span>
					     <span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">SLAB_RECLAIM_ACCOUNT</span> <span class="o">|</span>
						 <span class="n">SLAB_MEM_SPREAD</span><span class="p">),</span>
					     <span class="n">init_once</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udf_inode_cachep</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">destroy_inodecache</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">kmem_cache_destroy</span><span class="p">(</span><span class="n">udf_inode_cachep</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/* Superblock operations */</span>
<span class="k">static</span> <span class="k">const</span> <span class="k">struct</span> <span class="n">super_operations</span> <span class="n">udf_sb_ops</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">.</span><span class="n">alloc_inode</span>	<span class="o">=</span> <span class="n">udf_alloc_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">destroy_inode</span>	<span class="o">=</span> <span class="n">udf_destroy_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">write_inode</span>	<span class="o">=</span> <span class="n">udf_write_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">evict_inode</span>	<span class="o">=</span> <span class="n">udf_evict_inode</span><span class="p">,</span>
	<span class="p">.</span><span class="n">put_super</span>	<span class="o">=</span> <span class="n">udf_put_super</span><span class="p">,</span>
	<span class="p">.</span><span class="n">sync_fs</span>	<span class="o">=</span> <span class="n">udf_sync_fs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">statfs</span>		<span class="o">=</span> <span class="n">udf_statfs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">remount_fs</span>	<span class="o">=</span> <span class="n">udf_remount_fs</span><span class="p">,</span>
	<span class="p">.</span><span class="n">show_options</span>	<span class="o">=</span> <span class="n">udf_show_options</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">udf_options</span> <span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">novrs</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">blocksize</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">session</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">anchor</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">volume</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">short</span> <span class="n">partition</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">fileset</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">rootdir</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">flags</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">umask</span><span class="p">;</span>
	<span class="n">gid_t</span> <span class="n">gid</span><span class="p">;</span>
	<span class="n">uid_t</span> <span class="n">uid</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">fmode</span><span class="p">;</span>
	<span class="n">umode_t</span> <span class="n">dmode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">nls_table</span> <span class="o">*</span><span class="n">nls_map</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">__init</span> <span class="nf">init_udf_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">err</span><span class="p">;</span>

	<span class="n">err</span> <span class="o">=</span> <span class="n">init_inodecache</span><span class="p">();</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>
	<span class="n">err</span> <span class="o">=</span> <span class="n">register_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udf_fstype</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">err</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">out:</span>
	<span class="n">destroy_inodecache</span><span class="p">();</span>

<span class="nl">out1:</span>
	<span class="k">return</span> <span class="n">err</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">__exit</span> <span class="nf">exit_udf_fs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">unregister_filesystem</span><span class="p">(</span><span class="o">&amp;</span><span class="n">udf_fstype</span><span class="p">);</span>
	<span class="n">destroy_inodecache</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">module_init</span><span class="p">(</span><span class="n">init_udf_fs</span><span class="p">)</span>
<span class="n">module_exit</span><span class="p">(</span><span class="n">exit_udf_fs</span><span class="p">)</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_sb_alloc_partition_maps</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">count</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span> <span class="o">=</span> <span class="n">kcalloc</span><span class="p">(</span><span class="n">count</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_part_map</span><span class="p">),</span>
				  <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Unable to allocate space for %d partition maps</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="n">count</span><span class="p">);</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">udf_show_options</span><span class="p">(</span><span class="k">struct</span> <span class="n">seq_file</span> <span class="o">*</span><span class="n">seq</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_STRICT</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,nostrict&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_BLOCKSIZE_SET</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,bs=%lu&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_UNHIDE</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,unhide&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_UNDELETE</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,undelete&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_USE_AD_IN_ICB</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,noadinicb&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_USE_SHORT_AD</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,shortad&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_UID_FORGET</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,uid=forget&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_UID_IGNORE</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,uid=ignore&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_GID_FORGET</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,gid=forget&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_GID_IGNORE</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,gid=ignore&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_UID_SET</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,uid=%u&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_uid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_GID_SET</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,gid=%u&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_gid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_umask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,umask=%ho&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_umask</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_fmode</span> <span class="o">!=</span> <span class="n">UDF_INVALID_MODE</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,mode=%ho&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_fmode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dmode</span> <span class="o">!=</span> <span class="n">UDF_INVALID_MODE</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,dmode=%ho&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dmode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_SESSION_SET</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,session=%u&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_LASTBLOCK_SET</span><span class="p">))</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,lastblock=%u&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_anchor</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,anchor=%u&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_anchor</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * volume, partition, fileset and rootdir seem to be ignored</span>
<span class="cm">	 * currently</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_UTF8</span><span class="p">))</span>
		<span class="n">seq_puts</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,utf8&quot;</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_nls_map</span><span class="p">)</span>
		<span class="n">seq_printf</span><span class="p">(</span><span class="n">seq</span><span class="p">,</span> <span class="s">&quot;,iocharset=%s&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_nls_map</span><span class="o">-&gt;</span><span class="n">charset</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * udf_parse_options</span>
<span class="cm"> *</span>
<span class="cm"> * PURPOSE</span>
<span class="cm"> *	Parse mount options.</span>
<span class="cm"> *</span>
<span class="cm"> * DESCRIPTION</span>
<span class="cm"> *	The following mount options are supported:</span>
<span class="cm"> *</span>
<span class="cm"> *	gid=		Set the default group.</span>
<span class="cm"> *	umask=		Set the default umask.</span>
<span class="cm"> *	mode=		Set the default file permissions.</span>
<span class="cm"> *	dmode=		Set the default directory permissions.</span>
<span class="cm"> *	uid=		Set the default user.</span>
<span class="cm"> *	bs=		Set the block size.</span>
<span class="cm"> *	unhide		Show otherwise hidden files.</span>
<span class="cm"> *	undelete	Show deleted files in lists.</span>
<span class="cm"> *	adinicb		Embed data in the inode (default)</span>
<span class="cm"> *	noadinicb	Don&#39;t embed data in the inode</span>
<span class="cm"> *	shortad		Use short ad&#39;s</span>
<span class="cm"> *	longad		Use long ad&#39;s (default)</span>
<span class="cm"> *	nostrict	Unset strict conformance</span>
<span class="cm"> *	iocharset=	Set the NLS character set</span>
<span class="cm"> *</span>
<span class="cm"> *	The remaining are for debugging and disaster recovery:</span>
<span class="cm"> *</span>
<span class="cm"> *	novrs		Skip volume sequence recognition</span>
<span class="cm"> *</span>
<span class="cm"> *	The following expect a offset from 0.</span>
<span class="cm"> *</span>
<span class="cm"> *	session=	Set the CDROM session (default= last session)</span>
<span class="cm"> *	anchor=		Override standard anchor location. (default= 256)</span>
<span class="cm"> *	volume=		Override the VolumeDesc location. (unused)</span>
<span class="cm"> *	partition=	Override the PartitionDesc location. (unused)</span>
<span class="cm"> *	lastblock=	Set the last block of the filesystem/</span>
<span class="cm"> *</span>
<span class="cm"> *	The following expect a offset from the partition root.</span>
<span class="cm"> *</span>
<span class="cm"> *	fileset=	Override the fileset block location. (unused)</span>
<span class="cm"> *	rootdir=	Override the root directory location. (unused)</span>
<span class="cm"> *		WARNING: overriding the rootdir to a non-directory may</span>
<span class="cm"> *		yield highly unpredictable results.</span>
<span class="cm"> *</span>
<span class="cm"> * PRE-CONDITIONS</span>
<span class="cm"> *	options		Pointer to mount options string.</span>
<span class="cm"> *	uopts		Pointer to mount options variable.</span>
<span class="cm"> *</span>
<span class="cm"> * POST-CONDITIONS</span>
<span class="cm"> *	&lt;return&gt;	1	Mount options parsed okay.</span>
<span class="cm"> *	&lt;return&gt;	0	Error parsing mount options.</span>
<span class="cm"> *</span>
<span class="cm"> * HISTORY</span>
<span class="cm"> *	July 1, 1997 - Andrew E. Mileski</span>
<span class="cm"> *	Written, tested, and released.</span>
<span class="cm"> */</span>

<span class="k">enum</span> <span class="p">{</span>
	<span class="n">Opt_novrs</span><span class="p">,</span> <span class="n">Opt_nostrict</span><span class="p">,</span> <span class="n">Opt_bs</span><span class="p">,</span> <span class="n">Opt_unhide</span><span class="p">,</span> <span class="n">Opt_undelete</span><span class="p">,</span>
	<span class="n">Opt_noadinicb</span><span class="p">,</span> <span class="n">Opt_adinicb</span><span class="p">,</span> <span class="n">Opt_shortad</span><span class="p">,</span> <span class="n">Opt_longad</span><span class="p">,</span>
	<span class="n">Opt_gid</span><span class="p">,</span> <span class="n">Opt_uid</span><span class="p">,</span> <span class="n">Opt_umask</span><span class="p">,</span> <span class="n">Opt_session</span><span class="p">,</span> <span class="n">Opt_lastblock</span><span class="p">,</span>
	<span class="n">Opt_anchor</span><span class="p">,</span> <span class="n">Opt_volume</span><span class="p">,</span> <span class="n">Opt_partition</span><span class="p">,</span> <span class="n">Opt_fileset</span><span class="p">,</span>
	<span class="n">Opt_rootdir</span><span class="p">,</span> <span class="n">Opt_utf8</span><span class="p">,</span> <span class="n">Opt_iocharset</span><span class="p">,</span>
	<span class="n">Opt_err</span><span class="p">,</span> <span class="n">Opt_uforget</span><span class="p">,</span> <span class="n">Opt_uignore</span><span class="p">,</span> <span class="n">Opt_gforget</span><span class="p">,</span> <span class="n">Opt_gignore</span><span class="p">,</span>
	<span class="n">Opt_fmode</span><span class="p">,</span> <span class="n">Opt_dmode</span>
<span class="p">};</span>

<span class="k">static</span> <span class="k">const</span> <span class="n">match_table_t</span> <span class="n">tokens</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">{</span><span class="n">Opt_novrs</span><span class="p">,</span>	<span class="s">&quot;novrs&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_nostrict</span><span class="p">,</span>	<span class="s">&quot;nostrict&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_bs</span><span class="p">,</span>	<span class="s">&quot;bs=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_unhide</span><span class="p">,</span>	<span class="s">&quot;unhide&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_undelete</span><span class="p">,</span>	<span class="s">&quot;undelete&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_noadinicb</span><span class="p">,</span>	<span class="s">&quot;noadinicb&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_adinicb</span><span class="p">,</span>	<span class="s">&quot;adinicb&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_shortad</span><span class="p">,</span>	<span class="s">&quot;shortad&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_longad</span><span class="p">,</span>	<span class="s">&quot;longad&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_uforget</span><span class="p">,</span>	<span class="s">&quot;uid=forget&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_uignore</span><span class="p">,</span>	<span class="s">&quot;uid=ignore&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_gforget</span><span class="p">,</span>	<span class="s">&quot;gid=forget&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_gignore</span><span class="p">,</span>	<span class="s">&quot;gid=ignore&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_gid</span><span class="p">,</span>	<span class="s">&quot;gid=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_uid</span><span class="p">,</span>	<span class="s">&quot;uid=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_umask</span><span class="p">,</span>	<span class="s">&quot;umask=%o&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_session</span><span class="p">,</span>	<span class="s">&quot;session=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_lastblock</span><span class="p">,</span>	<span class="s">&quot;lastblock=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_anchor</span><span class="p">,</span>	<span class="s">&quot;anchor=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_volume</span><span class="p">,</span>	<span class="s">&quot;volume=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_partition</span><span class="p">,</span>	<span class="s">&quot;partition=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_fileset</span><span class="p">,</span>	<span class="s">&quot;fileset=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_rootdir</span><span class="p">,</span>	<span class="s">&quot;rootdir=%u&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_utf8</span><span class="p">,</span>	<span class="s">&quot;utf8&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_iocharset</span><span class="p">,</span>	<span class="s">&quot;iocharset=%s&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_fmode</span><span class="p">,</span>     <span class="s">&quot;mode=%o&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_dmode</span><span class="p">,</span>     <span class="s">&quot;dmode=%o&quot;</span><span class="p">},</span>
	<span class="p">{</span><span class="n">Opt_err</span><span class="p">,</span>	<span class="nb">NULL</span><span class="p">}</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_parse_options</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udf_options</span> <span class="o">*</span><span class="n">uopt</span><span class="p">,</span>
			     <span class="n">bool</span> <span class="n">remount</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">option</span><span class="p">;</span>

	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">novrs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">partition</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">lastblock</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">anchor</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">volume</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">rootdir</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">fileset</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">nls_map</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">options</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">p</span> <span class="o">=</span> <span class="n">strsep</span><span class="p">(</span><span class="o">&amp;</span><span class="n">options</span><span class="p">,</span> <span class="s">&quot;,&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">substring_t</span> <span class="n">args</span><span class="p">[</span><span class="n">MAX_OPT_ARGS</span><span class="p">];</span>
		<span class="kt">int</span> <span class="n">token</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">p</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">token</span> <span class="o">=</span> <span class="n">match_token</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">tokens</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">token</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">Opt_novrs</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">novrs</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_bs</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="o">&amp;</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_BLOCKSIZE_SET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_unhide</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UNHIDE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_undelete</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UNDELETE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_noadinicb</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_USE_AD_IN_ICB</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_adinicb</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_USE_AD_IN_ICB</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_shortad</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_USE_SHORT_AD</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_longad</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_USE_SHORT_AD</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_gid</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">gid</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_GID_SET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_uid</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">uid</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UID_SET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_umask</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_octal</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">umask</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_nostrict</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_STRICT</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_session</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">session</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remount</span><span class="p">)</span>
				<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_SESSION_SET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_lastblock</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">lastblock</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">remount</span><span class="p">)</span>
				<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_LASTBLOCK_SET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_anchor</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">anchor</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_volume</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">volume</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_partition</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">partition</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_fileset</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">fileset</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_rootdir</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_int</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">rootdir</span> <span class="o">=</span> <span class="n">option</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_utf8</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UTF8</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_UDF_NLS</span>
		<span class="k">case</span> <span class="n">Opt_iocharset</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">nls_map</span> <span class="o">=</span> <span class="n">load_nls</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">from</span><span class="p">);</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
		<span class="k">case</span> <span class="n">Opt_uignore</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UID_IGNORE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_uforget</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UID_FORGET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_gignore</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_GID_IGNORE</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_gforget</span>:
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_GID_FORGET</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_fmode</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_octal</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">fmode</span> <span class="o">=</span> <span class="n">option</span> <span class="o">&amp;</span> <span class="mo">0777</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">Opt_dmode</span>:
			<span class="k">if</span> <span class="p">(</span><span class="n">match_octal</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">uopt</span><span class="o">-&gt;</span><span class="n">dmode</span> <span class="o">=</span> <span class="n">option</span> <span class="o">&amp;</span> <span class="mo">0777</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="nl">default:</span>
			<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;bad mount option </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s"> or missing value</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_remount_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">flags</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">options</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_options</span> <span class="n">uopt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">uid</span>   <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_uid</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">gid</span>   <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_gid</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">umask</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_umask</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">fmode</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_fmode</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">dmode</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dmode</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udf_parse_options</span><span class="p">(</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uopt</span><span class="p">,</span> <span class="nb">true</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>

	<span class="n">write_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cred_lock</span><span class="p">);</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_uid</span>   <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_gid</span>   <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">gid</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_umask</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">umask</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_fmode</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">fmode</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dmode</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">dmode</span><span class="p">;</span>
	<span class="n">write_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cred_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="kt">int</span> <span class="n">write_rev</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">udf_sb_lvidiu</span><span class="p">(</span><span class="n">sbi</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">minUDFWriteRev</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">write_rev</span> <span class="o">&gt;</span> <span class="n">UDF_MAX_WRITE_VERSION</span><span class="p">)</span>
			<span class="o">*</span><span class="n">flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span> <span class="o">==</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">out_unlock</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
		<span class="n">udf_close_lvid</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">udf_open_lvid</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

<span class="nl">out_unlock:</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Check Volume Structure Descriptors (ECMA 167 2/9.1) */</span>
<span class="cm">/* We also check any &quot;CD-ROM Volume Descriptor Set&quot; (ECMA 167 2/8.3.1) */</span>
<span class="k">static</span> <span class="n">loff_t</span> <span class="nf">udf_check_vsd</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">volStructDesc</span> <span class="o">*</span><span class="n">vsd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">loff_t</span> <span class="n">sector</span> <span class="o">=</span> <span class="mi">32768</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">sectorsize</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nsr02</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nsr03</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>

	<span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">volStructDesc</span><span class="p">))</span>
		<span class="n">sectorsize</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">volStructDesc</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sectorsize</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>

	<span class="n">sector</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span> <span class="o">&lt;&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>

	<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Starting at sector %u (%ld byte sectors)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">),</span>
		  <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">);</span>
	<span class="cm">/* Process the sequence (if applicable) */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="o">!</span><span class="n">nsr02</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">nsr03</span><span class="p">;</span> <span class="n">sector</span> <span class="o">+=</span> <span class="n">sectorsize</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Read a block */</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_tread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>

		<span class="cm">/* Look for ISO  descriptors */</span>
		<span class="n">vsd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">volStructDesc</span> <span class="o">*</span><span class="p">)(</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span> <span class="o">+</span>
					      <span class="p">(</span><span class="n">sector</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">stdIdent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">stdIdent</span><span class="p">,</span> <span class="n">VSD_STD_ID_CD001</span><span class="p">,</span>
				    <span class="n">VSD_STD_ID_LEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="k">switch</span> <span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">structType</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">case</span> <span class="mi">0</span>:
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;ISO9660 Boot Record found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">1</span>:
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;ISO9660 Primary Volume Descriptor found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">2</span>:
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;ISO9660 Supplementary Volume Descriptor found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">3</span>:
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;ISO9660 Volume Partition Descriptor found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="k">case</span> <span class="mi">255</span>:
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;ISO9660 Volume Descriptor Set Terminator found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="nl">default:</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;ISO9660 VRS (%u) found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">vsd</span><span class="o">-&gt;</span><span class="n">structType</span><span class="p">);</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">stdIdent</span><span class="p">,</span> <span class="n">VSD_STD_ID_BEA01</span><span class="p">,</span>
				    <span class="n">VSD_STD_ID_LEN</span><span class="p">))</span>
			<span class="p">;</span> <span class="cm">/* nothing */</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">stdIdent</span><span class="p">,</span> <span class="n">VSD_STD_ID_TEA01</span><span class="p">,</span>
				    <span class="n">VSD_STD_ID_LEN</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">stdIdent</span><span class="p">,</span> <span class="n">VSD_STD_ID_NSR02</span><span class="p">,</span>
				    <span class="n">VSD_STD_ID_LEN</span><span class="p">))</span>
			<span class="n">nsr02</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
		<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">vsd</span><span class="o">-&gt;</span><span class="n">stdIdent</span><span class="p">,</span> <span class="n">VSD_STD_ID_NSR03</span><span class="p">,</span>
				    <span class="n">VSD_STD_ID_LEN</span><span class="p">))</span>
			<span class="n">nsr03</span> <span class="o">=</span> <span class="n">sector</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">nsr03</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nsr03</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">nsr02</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">nsr02</span><span class="p">;</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">sector</span> <span class="o">-</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span> <span class="o">&lt;&lt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32768</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="k">else</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_find_fileset</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fileset</span><span class="o">-&gt;</span><span class="n">logicalBlockNum</span> <span class="o">!=</span> <span class="mh">0xFFFFFFFF</span> <span class="o">||</span>
	    <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span> <span class="o">!=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_ptagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fileset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ident</span> <span class="o">!=</span> <span class="n">TAG_IDENT_FSD</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

	<span class="p">}</span>

	<span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Search backwards through the partitions */</span>
		<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">newfileset</span><span class="p">;</span>

<span class="cm">/* --&gt; cvg: FIXME - is it reasonable? */</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">newfileset</span><span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
		     <span class="p">(</span><span class="n">newfileset</span><span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">!=</span> <span class="mh">0xFFFF</span> <span class="o">&amp;&amp;</span>
		      <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">logicalBlockNum</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span> <span class="o">&amp;&amp;</span>
		      <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		     <span class="n">newfileset</span><span class="p">.</span><span class="n">partitionReferenceNum</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">lastblock</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span>
					<span class="p">[</span><span class="n">newfileset</span><span class="p">.</span><span class="n">partitionReferenceNum</span><span class="p">]</span>
						<span class="p">.</span><span class="n">s_partition_len</span><span class="p">;</span>
			<span class="n">newfileset</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

			<span class="k">do</span> <span class="p">{</span>
				<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_ptagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">newfileset</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
						      <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">newfileset</span><span class="p">.</span><span class="n">logicalBlockNum</span><span class="o">++</span><span class="p">;</span>
					<span class="k">continue</span><span class="p">;</span>
				<span class="p">}</span>

				<span class="k">switch</span> <span class="p">(</span><span class="n">ident</span><span class="p">)</span> <span class="p">{</span>
				<span class="k">case</span> <span class="n">TAG_IDENT_SBD</span>:
				<span class="p">{</span>
					<span class="k">struct</span> <span class="n">spaceBitmapDesc</span> <span class="o">*</span><span class="n">sp</span><span class="p">;</span>
					<span class="n">sp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">spaceBitmapDesc</span> <span class="o">*</span><span class="p">)</span>
								<span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
					<span class="n">newfileset</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">+=</span> <span class="mi">1</span> <span class="o">+</span>
						<span class="p">((</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">sp</span><span class="o">-&gt;</span><span class="n">numOfBytes</span><span class="p">)</span> <span class="o">+</span>
						  <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spaceBitmapDesc</span><span class="p">)</span>
						  <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>
					<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
				<span class="k">case</span> <span class="n">TAG_IDENT_FSD</span>:
					<span class="o">*</span><span class="n">fileset</span> <span class="o">=</span> <span class="n">newfileset</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="nl">default:</span>
					<span class="n">newfileset</span><span class="p">.</span><span class="n">logicalBlockNum</span><span class="o">++</span><span class="p">;</span>
					<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
					<span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
					<span class="k">break</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">newfileset</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">&lt;</span> <span class="n">lastblock</span> <span class="o">&amp;&amp;</span>
				 <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">logicalBlockNum</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span> <span class="o">&amp;&amp;</span>
				 <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span> <span class="o">==</span> <span class="mh">0xFFFF</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">((</span><span class="n">fileset</span><span class="o">-&gt;</span><span class="n">logicalBlockNum</span> <span class="o">!=</span> <span class="mh">0xFFFFFFFF</span> <span class="o">||</span>
	     <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span> <span class="o">!=</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Fileset at block=%d, partition=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">logicalBlockNum</span><span class="p">,</span>
			  <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span><span class="p">);</span>

		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partition</span> <span class="o">=</span> <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span><span class="p">;</span>
		<span class="n">udf_load_fileset</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">root</span><span class="p">);</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_pvoldesc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">primaryVolDesc</span> <span class="o">*</span><span class="n">pvoldesc</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">ustr</span> <span class="o">*</span><span class="n">instr</span><span class="p">,</span> <span class="o">*</span><span class="n">outstr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">instr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ustr</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">instr</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">outstr</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">ustr</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">outstr</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out1</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_tagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out2</span><span class="p">;</span>

	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ident</span> <span class="o">!=</span> <span class="n">TAG_IDENT_PVD</span><span class="p">);</span>

	<span class="n">pvoldesc</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">primaryVolDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udf_disk_stamp_to_time</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_record_time</span><span class="p">,</span>
			      <span class="n">pvoldesc</span><span class="o">-&gt;</span><span class="n">recordingDateAndTime</span><span class="p">))</span> <span class="p">{</span>
<span class="cp">#ifdef UDFFS_DEBUG</span>
		<span class="k">struct</span> <span class="n">timestamp</span> <span class="o">*</span><span class="n">ts</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">pvoldesc</span><span class="o">-&gt;</span><span class="n">recordingDateAndTime</span><span class="p">;</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;recording time %04u/%02u/%02u %02u:%02u (%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">year</span><span class="p">),</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">month</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">day</span><span class="p">,</span> <span class="n">ts</span><span class="o">-&gt;</span><span class="n">hour</span><span class="p">,</span>
			  <span class="n">ts</span><span class="o">-&gt;</span><span class="n">minute</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ts</span><span class="o">-&gt;</span><span class="n">typeAndTimezone</span><span class="p">));</span>
<span class="cp">#endif</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udf_build_ustr</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">pvoldesc</span><span class="o">-&gt;</span><span class="n">volIdent</span><span class="p">,</span> <span class="mi">32</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udf_CS0toUTF8</span><span class="p">(</span><span class="n">outstr</span><span class="p">,</span> <span class="n">instr</span><span class="p">))</span> <span class="p">{</span>
			<span class="n">strncpy</span><span class="p">(</span><span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_volume_ident</span><span class="p">,</span> <span class="n">outstr</span><span class="o">-&gt;</span><span class="n">u_name</span><span class="p">,</span>
				<span class="n">outstr</span><span class="o">-&gt;</span><span class="n">u_len</span> <span class="o">&gt;</span> <span class="mi">31</span> <span class="o">?</span> <span class="mi">31</span> <span class="o">:</span> <span class="n">outstr</span><span class="o">-&gt;</span><span class="n">u_len</span><span class="p">);</span>
			<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;volIdent[] = &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_volume_ident</span><span class="p">);</span>
		<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udf_build_ustr</span><span class="p">(</span><span class="n">instr</span><span class="p">,</span> <span class="n">pvoldesc</span><span class="o">-&gt;</span><span class="n">volSetIdent</span><span class="p">,</span> <span class="mi">128</span><span class="p">))</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udf_CS0toUTF8</span><span class="p">(</span><span class="n">outstr</span><span class="p">,</span> <span class="n">instr</span><span class="p">))</span>
			<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;volSetIdent[] = &#39;%s&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">outstr</span><span class="o">-&gt;</span><span class="n">u_name</span><span class="p">);</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">out2:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">outstr</span><span class="p">);</span>
<span class="nl">out1:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">instr</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="nf">udf_find_metadata_inode_efe</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					<span class="n">u32</span> <span class="n">meta_file_loc</span><span class="p">,</span> <span class="n">u32</span> <span class="n">partition_num</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">addr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">metadata_fe</span><span class="p">;</span>

	<span class="n">addr</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="n">meta_file_loc</span><span class="p">;</span>
	<span class="n">addr</span><span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="n">partition_num</span><span class="p">;</span>

	<span class="n">metadata_fe</span> <span class="o">=</span> <span class="n">udf_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">metadata_fe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;metadata inode efe not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">UDF_I</span><span class="p">(</span><span class="n">metadata_fe</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_alloc_type</span> <span class="o">!=</span> <span class="n">ICBTAG_FLAG_AD_SHORT</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;metadata inode efe does not have short allocation descriptors!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">metadata_fe</span><span class="p">);</span>
		<span class="n">metadata_fe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">metadata_fe</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_metadata_files</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">partition</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_meta_data</span> <span class="o">*</span><span class="n">mdata</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">addr</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">partition</span><span class="p">];</span>
	<span class="n">mdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_metadata</span><span class="p">;</span>

	<span class="cm">/* metadata address */</span>
	<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Metadata file location: block = %d part = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_meta_file_loc</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span><span class="p">);</span>

	<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_metadata_fe</span> <span class="o">=</span> <span class="n">udf_find_metadata_inode_efe</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
		<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_meta_file_loc</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_metadata_fe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* mirror file entry */</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Mirror metadata file location: block = %d part = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_mirror_file_loc</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span><span class="p">);</span>

		<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_mirror_fe</span> <span class="o">=</span> <span class="n">udf_find_metadata_inode_efe</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
			<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_mirror_file_loc</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_mirror_fe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Both metadata and mirror metadata inode efe can not found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="cm">/*</span>
<span class="cm">	 * bitmap file entry</span>
<span class="cm">	 * Note:</span>
<span class="cm">	 * Load only if bitmap file location differs from 0xFFFFFFFF (DCN-5102)</span>
<span class="cm">	*/</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_bitmap_file_loc</span> <span class="o">!=</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">addr</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_bitmap_file_loc</span><span class="p">;</span>
		<span class="n">addr</span><span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span><span class="p">;</span>

		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Bitmap file location: block = %d part = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">addr</span><span class="p">.</span><span class="n">logicalBlockNum</span><span class="p">,</span> <span class="n">addr</span><span class="p">.</span><span class="n">partitionReferenceNum</span><span class="p">);</span>

		<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_bitmap_fe</span> <span class="o">=</span> <span class="n">udf_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">addr</span><span class="p">);</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_bitmap_fe</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">)</span>
				<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;bitmap inode efe not found but it&#39;s ok since the disc is mounted read-only</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">else</span> <span class="p">{</span>
				<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;bitmap inode efe not found and attempted read-write mount</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">error_exit</span><span class="p">;</span>
			<span class="p">}</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;udf_load_metadata_files Ok</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_exit:</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_load_fileset</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">fileSetDesc</span> <span class="o">*</span><span class="n">fset</span><span class="p">;</span>

	<span class="n">fset</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">fileSetDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="o">*</span><span class="n">root</span> <span class="o">=</span> <span class="n">lelb_to_cpu</span><span class="p">(</span><span class="n">fset</span><span class="o">-&gt;</span><span class="n">rootDirectoryICB</span><span class="p">.</span><span class="n">extLocation</span><span class="p">);</span>

	<span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_serial_number</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">fset</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">.</span><span class="n">tagSerialNum</span><span class="p">);</span>

	<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Rootdir at block=%d, partition=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">root</span><span class="o">-&gt;</span><span class="n">logicalBlockNum</span><span class="p">,</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">udf_compute_nr_groups</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">partition</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">partition</span><span class="p">];</span>
	<span class="k">return</span> <span class="n">DIV_ROUND_UP</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_len</span> <span class="o">+</span>
			    <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spaceBitmapDesc</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">),</span>
			    <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">udf_bitmap</span> <span class="o">*</span><span class="nf">udf_sb_alloc_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">u32</span> <span class="n">index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_groups</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span><span class="p">;</span>

	<span class="n">nr_groups</span> <span class="o">=</span> <span class="n">udf_compute_nr_groups</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
	<span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_bitmap</span><span class="p">)</span> <span class="o">+</span>
		<span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span> <span class="n">nr_groups</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">bitmap</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">bitmap</span> <span class="o">=</span> <span class="n">vzalloc</span><span class="p">(</span><span class="n">size</span><span class="p">);</span> <span class="cm">/* TODO: get rid of vzalloc */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_block_bitmap</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">**</span><span class="p">)(</span><span class="n">bitmap</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
	<span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_nr_groups</span> <span class="o">=</span> <span class="n">nr_groups</span><span class="p">;</span>
	<span class="k">return</span> <span class="n">bitmap</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_fill_partdesc_info</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
		<span class="k">struct</span> <span class="n">partitionDesc</span> <span class="o">*</span><span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">partitionHeaderDesc</span> <span class="o">*</span><span class="n">phd</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">p_index</span><span class="p">];</span>

	<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">partitionLength</span><span class="p">);</span> <span class="cm">/* blocks */</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_root</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">partitionStartingLocation</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">accessType</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PD_ACCESS_TYPE_READ_ONLY</span><span class="p">))</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_READ_ONLY</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">accessType</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PD_ACCESS_TYPE_WRITE_ONCE</span><span class="p">))</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_WRITE_ONCE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">accessType</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PD_ACCESS_TYPE_REWRITABLE</span><span class="p">))</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_REWRITABLE</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">accessType</span> <span class="o">==</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">PD_ACCESS_TYPE_OVERWRITABLE</span><span class="p">))</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_OVERWRITABLE</span><span class="p">;</span>

	<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Partition (%d type %x) starts at physical %d, block length %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		  <span class="n">p_index</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span><span class="p">,</span>
		  <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_root</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_len</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">partitionContents</span><span class="p">.</span><span class="n">ident</span><span class="p">,</span> <span class="n">PD_PARTITION_CONTENTS_NSR02</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">strcmp</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">partitionContents</span><span class="p">.</span><span class="n">ident</span><span class="p">,</span> <span class="n">PD_PARTITION_CONTENTS_NSR03</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">phd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">partitionHeaderDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">partitionContentsUse</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">phd</span><span class="o">-&gt;</span><span class="n">unallocSpaceTable</span><span class="p">.</span><span class="n">extLength</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">loc</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
				<span class="n">phd</span><span class="o">-&gt;</span><span class="n">unallocSpaceTable</span><span class="p">.</span><span class="n">extPosition</span><span class="p">),</span>
			<span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="n">p_index</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_table</span> <span class="o">=</span> <span class="n">udf_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_table</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;cannot load unallocSpaceTable (part %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">p_index</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_UNALLOC_TABLE</span><span class="p">;</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;unallocSpaceTable (part %d) @ %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">p_index</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_table</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phd</span><span class="o">-&gt;</span><span class="n">unallocSpaceBitmap</span><span class="p">.</span><span class="n">extLength</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">udf_bitmap</span> <span class="o">*</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">udf_sb_alloc_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_bitmap</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">;</span>
		<span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_extLength</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
				<span class="n">phd</span><span class="o">-&gt;</span><span class="n">unallocSpaceBitmap</span><span class="p">.</span><span class="n">extLength</span><span class="p">);</span>
		<span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_extPosition</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
				<span class="n">phd</span><span class="o">-&gt;</span><span class="n">unallocSpaceBitmap</span><span class="p">.</span><span class="n">extPosition</span><span class="p">);</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_UNALLOC_BITMAP</span><span class="p">;</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;unallocSpaceBitmap (part %d) @ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">p_index</span><span class="p">,</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_extPosition</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phd</span><span class="o">-&gt;</span><span class="n">partitionIntegrityTable</span><span class="p">.</span><span class="n">extLength</span><span class="p">)</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;partitionIntegrityTable (part %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">p_index</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phd</span><span class="o">-&gt;</span><span class="n">freedSpaceTable</span><span class="p">.</span><span class="n">extLength</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">loc</span> <span class="o">=</span> <span class="p">{</span>
			<span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
				<span class="n">phd</span><span class="o">-&gt;</span><span class="n">freedSpaceTable</span><span class="p">.</span><span class="n">extPosition</span><span class="p">),</span>
			<span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="n">p_index</span><span class="p">,</span>
		<span class="p">};</span>

		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_table</span> <span class="o">=</span> <span class="n">udf_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loc</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_table</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;cannot load freedSpaceTable (part %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				  <span class="n">p_index</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_FREED_TABLE</span><span class="p">;</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;freedSpaceTable (part %d) @ %ld</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">p_index</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_table</span><span class="o">-&gt;</span><span class="n">i_ino</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">phd</span><span class="o">-&gt;</span><span class="n">freedSpaceBitmap</span><span class="p">.</span><span class="n">extLength</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">udf_bitmap</span> <span class="o">*</span><span class="n">bitmap</span> <span class="o">=</span> <span class="n">udf_sb_alloc_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p_index</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bitmap</span><span class="p">)</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_bitmap</span> <span class="o">=</span> <span class="n">bitmap</span><span class="p">;</span>
		<span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_extLength</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
				<span class="n">phd</span><span class="o">-&gt;</span><span class="n">freedSpaceBitmap</span><span class="p">.</span><span class="n">extLength</span><span class="p">);</span>
		<span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_extPosition</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
				<span class="n">phd</span><span class="o">-&gt;</span><span class="n">freedSpaceBitmap</span><span class="p">.</span><span class="n">extPosition</span><span class="p">);</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">|=</span> <span class="n">UDF_PART_FLAG_FREED_BITMAP</span><span class="p">;</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;freedSpaceBitmap (part %d) @ %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">p_index</span><span class="p">,</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_extPosition</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_find_vat_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_index</span><span class="p">,</span>
			       <span class="kt">int</span> <span class="n">type1_index</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">start_block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">p_index</span><span class="p">];</span>
	<span class="n">sector_t</span> <span class="n">vat_block</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">ino</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * VAT file entry is in the last recorded block. Some broken disks have</span>
<span class="cm">	 * it a few blocks before so try a bit harder...</span>
<span class="cm">	 */</span>
	<span class="n">ino</span><span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="n">type1_index</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">vat_block</span> <span class="o">=</span> <span class="n">start_block</span><span class="p">;</span>
	     <span class="n">vat_block</span> <span class="o">&gt;=</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_root</span> <span class="o">&amp;&amp;</span>
	     <span class="n">vat_block</span> <span class="o">&gt;=</span> <span class="n">start_block</span> <span class="o">-</span> <span class="mi">3</span> <span class="o">&amp;&amp;</span>
	     <span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">;</span> <span class="n">vat_block</span><span class="o">--</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ino</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="n">vat_block</span> <span class="o">-</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_root</span><span class="p">;</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span> <span class="o">=</span> <span class="n">udf_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ino</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_vat</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">p_index</span><span class="p">,</span> <span class="kt">int</span> <span class="n">type1_index</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">p_index</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_inode_info</span> <span class="o">*</span><span class="n">vati</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">pos</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">virtualAllocationTable20</span> <span class="o">*</span><span class="n">vat20</span><span class="p">;</span>
	<span class="n">sector_t</span> <span class="n">blocks</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>

	<span class="n">udf_find_vat_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p_index</span><span class="p">,</span> <span class="n">type1_index</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span> <span class="o">&amp;&amp;</span>
	    <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span> <span class="o">!=</span> <span class="n">blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Failed to read VAT inode from the last recorded block (%lu), retrying with the last block of the device (%lu).</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span><span class="p">)</span><span class="n">blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
		<span class="n">udf_find_vat_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p_index</span><span class="p">,</span> <span class="n">type1_index</span><span class="p">,</span> <span class="n">blocks</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_VIRTUAL_MAP15</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_virtual</span><span class="p">.</span><span class="n">s_start_offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_virtual</span><span class="p">.</span><span class="n">s_num_entries</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span> <span class="mi">36</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_VIRTUAL_MAP20</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">vati</span> <span class="o">=</span> <span class="n">UDF_I</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">vati</span><span class="o">-&gt;</span><span class="n">i_alloc_type</span> <span class="o">!=</span> <span class="n">ICBTAG_FLAG_AD_IN_ICB</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">pos</span> <span class="o">=</span> <span class="n">udf_block_map</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">sb_bread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">pos</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">vat20</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtualAllocationTable20</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="n">vat20</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">virtualAllocationTable20</span> <span class="o">*</span><span class="p">)</span>
							<span class="n">vati</span><span class="o">-&gt;</span><span class="n">i_ext</span><span class="p">.</span><span class="n">i_data</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_virtual</span><span class="p">.</span><span class="n">s_start_offset</span> <span class="o">=</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">vat20</span><span class="o">-&gt;</span><span class="n">lengthHeader</span><span class="p">);</span>
		<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_virtual</span><span class="p">.</span><span class="n">s_num_entries</span> <span class="o">=</span>
			<span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">-</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_virtual</span><span class="p">.</span>
					<span class="n">s_start_offset</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">2</span><span class="p">;</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_partdesc</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">partitionDesc</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">type1_idx</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">partitionNumber</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_tagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ident</span> <span class="o">!=</span> <span class="n">TAG_IDENT_PD</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>

	<span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">partitionDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">partitionNumber</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">p</span><span class="o">-&gt;</span><span class="n">partitionNumber</span><span class="p">);</span>

	<span class="cm">/* First scan for TYPE1, SPARABLE and METADATA partitions */</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Searching map: (%d == %d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span><span class="p">,</span> <span class="n">partitionNumber</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span> <span class="o">==</span> <span class="n">partitionNumber</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_TYPE1_MAP15</span> <span class="o">||</span>
		     <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_SPARABLE_MAP15</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Partition (%d) not found in partition map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">partitionNumber</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_fill_partdesc_info</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Now rescan for VIRTUAL or METADATA partitions when SPARABLE and</span>
<span class="cm">	 * PHYSICAL partitions are already set up</span>
<span class="cm">	 */</span>
	<span class="n">type1_idx</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span> <span class="o">==</span> <span class="n">partitionNumber</span> <span class="o">&amp;&amp;</span>
		    <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_VIRTUAL_MAP15</span> <span class="o">||</span>
		     <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_VIRTUAL_MAP20</span> <span class="o">||</span>
		     <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_METADATA_MAP25</span><span class="p">))</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_fill_partdesc_info</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">p</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_METADATA_MAP25</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_load_metadata_files</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;error loading MetaData partition map %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">i</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_load_vat</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">type1_idx</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
			<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>
		<span class="cm">/*</span>
<span class="cm">		 * Mark filesystem read-only if we have a partition with</span>
<span class="cm">		 * virtual map since we don&#39;t handle writing to it (we</span>
<span class="cm">		 * overwrite blocks instead of relocating them).</span>
<span class="cm">		 */</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Filesystem marked read-only because writing to pseudooverwrite partition is not implemented</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="nl">out_bh:</span>
	<span class="cm">/* In case loading failed, we handle cleanup in udf_fill_super */</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_sparable_map</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">sparablePartitionMap</span> <span class="o">*</span><span class="n">spm</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">uint32_t</span> <span class="n">loc</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">sparingTable</span> <span class="o">*</span><span class="n">st</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sparing_data</span> <span class="o">*</span><span class="n">sdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_sparing</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>

	<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">=</span> <span class="n">UDF_SPARABLE_MAP15</span><span class="p">;</span>
	<span class="n">sdata</span><span class="o">-&gt;</span><span class="n">s_packet_len</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">spm</span><span class="o">-&gt;</span><span class="n">packetLength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_power_of_2</span><span class="p">(</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">s_packet_len</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;error loading logical volume descriptor: &quot;</span>
			<span class="s">&quot;Invalid packet length %u</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">sdata</span><span class="o">-&gt;</span><span class="n">s_packet_len</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">spm</span><span class="o">-&gt;</span><span class="n">numSparingTables</span> <span class="o">&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;error loading logical volume descriptor: &quot;</span>
			<span class="s">&quot;Too many sparing tables (%d)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			<span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">spm</span><span class="o">-&gt;</span><span class="n">numSparingTables</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">EIO</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spm</span><span class="o">-&gt;</span><span class="n">numSparingTables</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">loc</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">spm</span><span class="o">-&gt;</span><span class="n">locSparingTable</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
		<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_tagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="n">loc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="n">st</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sparingTable</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">ident</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">||</span>
		    <span class="n">strncmp</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">sparingIdent</span><span class="p">.</span><span class="n">ident</span><span class="p">,</span> <span class="n">UDF_ID_SPARING</span><span class="p">,</span>
			    <span class="n">strlen</span><span class="p">(</span><span class="n">UDF_ID_SPARING</span><span class="p">))</span> <span class="o">||</span>
		    <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">st</span><span class="p">)</span> <span class="o">+</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">st</span><span class="o">-&gt;</span><span class="n">reallocationTableLen</span><span class="p">)</span> <span class="o">&gt;</span>
							<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">sdata</span><span class="o">-&gt;</span><span class="n">s_spar_map</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_func</span> <span class="o">=</span> <span class="n">udf_get_pblock_spar15</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_logicalvol</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
			       <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">logicalVolDesc</span> <span class="o">*</span><span class="n">lvd</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">offset</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="n">type</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">genericPartitionMap</span> <span class="o">*</span><span class="n">gpm</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">table_len</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_tagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">BUG_ON</span><span class="p">(</span><span class="n">ident</span> <span class="o">!=</span> <span class="n">TAG_IDENT_LVD</span><span class="p">);</span>
	<span class="n">lvd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">table_len</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lvd</span><span class="o">-&gt;</span><span class="n">mapTableLength</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lvd</span><span class="p">)</span> <span class="o">+</span> <span class="n">table_len</span> <span class="o">&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;error loading logical volume descriptor: &quot;</span>
			<span class="s">&quot;Partition table too long (%u &gt; %lu)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">table_len</span><span class="p">,</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">lvd</span><span class="p">));</span>
		<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_sb_alloc_partition_maps</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lvd</span><span class="o">-&gt;</span><span class="n">numPartitionMaps</span><span class="p">));</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ret</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	     <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span> <span class="o">&amp;&amp;</span> <span class="n">offset</span> <span class="o">&lt;</span> <span class="n">table_len</span><span class="p">;</span>
	     <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+=</span> <span class="n">gpm</span><span class="o">-&gt;</span><span class="n">partitionMapLength</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="n">gpm</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">genericPartitionMap</span> <span class="o">*</span><span class="p">)</span>
				<span class="o">&amp;</span><span class="p">(</span><span class="n">lvd</span><span class="o">-&gt;</span><span class="n">partitionMaps</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
		<span class="n">type</span> <span class="o">=</span> <span class="n">gpm</span><span class="o">-&gt;</span><span class="n">partitionMapType</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">genericPartitionMap1</span> <span class="o">*</span><span class="n">gpm1</span> <span class="o">=</span>
				<span class="p">(</span><span class="k">struct</span> <span class="n">genericPartitionMap1</span> <span class="o">*</span><span class="p">)</span><span class="n">gpm</span><span class="p">;</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">=</span> <span class="n">UDF_TYPE1_MAP15</span><span class="p">;</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_volumeseqnum</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gpm1</span><span class="o">-&gt;</span><span class="n">volSeqNum</span><span class="p">);</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">gpm1</span><span class="o">-&gt;</span><span class="n">partitionNum</span><span class="p">);</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_func</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">struct</span> <span class="n">udfPartitionMap2</span> <span class="o">*</span><span class="n">upm2</span> <span class="o">=</span>
						<span class="p">(</span><span class="k">struct</span> <span class="n">udfPartitionMap2</span> <span class="o">*</span><span class="p">)</span><span class="n">gpm</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">upm2</span><span class="o">-&gt;</span><span class="n">partIdent</span><span class="p">.</span><span class="n">ident</span><span class="p">,</span> <span class="n">UDF_ID_VIRTUAL</span><span class="p">,</span>
						<span class="n">strlen</span><span class="p">(</span><span class="n">UDF_ID_VIRTUAL</span><span class="p">)))</span> <span class="p">{</span>
				<span class="n">u16</span> <span class="n">suf</span> <span class="o">=</span>
					<span class="n">le16_to_cpu</span><span class="p">(((</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span><span class="n">upm2</span><span class="o">-&gt;</span><span class="n">partIdent</span><span class="p">.</span>
							<span class="n">identSuffix</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">suf</span> <span class="o">&lt;</span> <span class="mh">0x0200</span><span class="p">)</span> <span class="p">{</span>
					<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">=</span>
							<span class="n">UDF_VIRTUAL_MAP15</span><span class="p">;</span>
					<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_func</span> <span class="o">=</span>
							<span class="n">udf_get_pblock_virt15</span><span class="p">;</span>
				<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
					<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">=</span>
							<span class="n">UDF_VIRTUAL_MAP20</span><span class="p">;</span>
					<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_func</span> <span class="o">=</span>
							<span class="n">udf_get_pblock_virt20</span><span class="p">;</span>
				<span class="p">}</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">upm2</span><span class="o">-&gt;</span><span class="n">partIdent</span><span class="p">.</span><span class="n">ident</span><span class="p">,</span>
						<span class="n">UDF_ID_SPARABLE</span><span class="p">,</span>
						<span class="n">strlen</span><span class="p">(</span><span class="n">UDF_ID_SPARABLE</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">udf_load_sparable_map</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">map</span><span class="p">,</span>
				    <span class="p">(</span><span class="k">struct</span> <span class="n">sparablePartitionMap</span> <span class="o">*</span><span class="p">)</span><span class="n">gpm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
					<span class="k">goto</span> <span class="n">out_bh</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">strncmp</span><span class="p">(</span><span class="n">upm2</span><span class="o">-&gt;</span><span class="n">partIdent</span><span class="p">.</span><span class="n">ident</span><span class="p">,</span>
						<span class="n">UDF_ID_METADATA</span><span class="p">,</span>
						<span class="n">strlen</span><span class="p">(</span><span class="n">UDF_ID_METADATA</span><span class="p">)))</span> <span class="p">{</span>
				<span class="k">struct</span> <span class="n">udf_meta_data</span> <span class="o">*</span><span class="n">mdata</span> <span class="o">=</span>
					<span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_metadata</span><span class="p">;</span>
				<span class="k">struct</span> <span class="n">metadataPartitionMap</span> <span class="o">*</span><span class="n">mdm</span> <span class="o">=</span>
						<span class="p">(</span><span class="k">struct</span> <span class="n">metadataPartitionMap</span> <span class="o">*</span><span class="p">)</span>
						<span class="o">&amp;</span><span class="p">(</span><span class="n">lvd</span><span class="o">-&gt;</span><span class="n">partitionMaps</span><span class="p">[</span><span class="n">offset</span><span class="p">]);</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Parsing Logical vol part %d type %d  id=%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">i</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">UDF_ID_METADATA</span><span class="p">);</span>

				<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">=</span> <span class="n">UDF_METADATA_MAP25</span><span class="p">;</span>
				<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_func</span> <span class="o">=</span> <span class="n">udf_get_pblock_meta25</span><span class="p">;</span>

				<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_meta_file_loc</span>   <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">metadataFileLoc</span><span class="p">);</span>
				<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_mirror_file_loc</span> <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">metadataMirrorFileLoc</span><span class="p">);</span>
				<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_bitmap_file_loc</span> <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">metadataBitmapFileLoc</span><span class="p">);</span>
				<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_alloc_unit_size</span> <span class="o">=</span>
					<span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">allocUnitSize</span><span class="p">);</span>
				<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_align_unit_size</span> <span class="o">=</span>
					<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">alignUnitSize</span><span class="p">);</span>
				<span class="k">if</span> <span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="mh">0x01</span><span class="p">)</span>
					<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MF_DUPLICATE_MD</span><span class="p">;</span>

				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Metadata Ident suffix=0x%x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__le16</span> <span class="o">*</span><span class="p">)</span>
						      <span class="n">mdm</span><span class="o">-&gt;</span><span class="n">partIdent</span><span class="p">.</span><span class="n">identSuffix</span><span class="p">));</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Metadata part num=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">partitionNum</span><span class="p">));</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Metadata part alloc unit size=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">allocUnitSize</span><span class="p">));</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Metadata file loc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">metadataFileLoc</span><span class="p">));</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Mirror file loc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">metadataMirrorFileLoc</span><span class="p">));</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Bitmap file loc=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">mdm</span><span class="o">-&gt;</span><span class="n">metadataBitmapFileLoc</span><span class="p">));</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Flags: %d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_flags</span><span class="p">,</span> <span class="n">mdm</span><span class="o">-&gt;</span><span class="n">flags</span><span class="p">);</span>
			<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Unknown ident: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">upm2</span><span class="o">-&gt;</span><span class="n">partIdent</span><span class="p">.</span><span class="n">ident</span><span class="p">);</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_volumeseqnum</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">upm2</span><span class="o">-&gt;</span><span class="n">volSeqNum</span><span class="p">);</span>
			<span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">upm2</span><span class="o">-&gt;</span><span class="n">partitionNum</span><span class="p">);</span>
		<span class="p">}</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Partition (%d:%d) type %d on volume %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">i</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_num</span><span class="p">,</span> <span class="n">type</span><span class="p">,</span> <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_volumeseqnum</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">fileset</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">long_ad</span> <span class="o">*</span><span class="n">la</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">long_ad</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="p">(</span><span class="n">lvd</span><span class="o">-&gt;</span><span class="n">logicalVolContentsUse</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>

		<span class="o">*</span><span class="n">fileset</span> <span class="o">=</span> <span class="n">lelb_to_cpu</span><span class="p">(</span><span class="n">la</span><span class="o">-&gt;</span><span class="n">extLocation</span><span class="p">);</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;FileSet found in LogicalVolDesc at block=%d, partition=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			  <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">logicalBlockNum</span><span class="p">,</span>
			  <span class="n">fileset</span><span class="o">-&gt;</span><span class="n">partitionReferenceNum</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lvd</span><span class="o">-&gt;</span><span class="n">integritySeqExt</span><span class="p">.</span><span class="n">extLength</span><span class="p">)</span>
		<span class="n">udf_load_logicalvolint</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">leea_to_cpu</span><span class="p">(</span><span class="n">lvd</span><span class="o">-&gt;</span><span class="n">integritySeqExt</span><span class="p">));</span>

<span class="nl">out_bh:</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * udf_load_logicalvolint</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_load_logicalvolint</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_extent_ad</span> <span class="n">loc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="n">lvid</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">loc</span><span class="p">.</span><span class="n">extLength</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
	       <span class="p">(</span><span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_tagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">loc</span><span class="p">.</span><span class="n">extLocation</span><span class="p">,</span>
				     <span class="n">loc</span><span class="p">.</span><span class="n">extLocation</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">))</span> <span class="o">&amp;&amp;</span>
	       <span class="n">ident</span> <span class="o">==</span> <span class="n">TAG_IDENT_LVID</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span> <span class="o">=</span> <span class="n">bh</span><span class="p">;</span>
		<span class="n">lvid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">nextIntegrityExt</span><span class="p">.</span><span class="n">extLength</span><span class="p">)</span>
			<span class="n">udf_load_logicalvolint</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				<span class="n">leea_to_cpu</span><span class="p">(</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">nextIntegrityExt</span><span class="p">));</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">)</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">loc</span><span class="p">.</span><span class="n">extLength</span> <span class="o">-=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
		<span class="n">loc</span><span class="p">.</span><span class="n">extLocation</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span> <span class="o">!=</span> <span class="n">bh</span><span class="p">)</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * udf_process_sequence</span>
<span class="cm"> *</span>
<span class="cm"> * PURPOSE</span>
<span class="cm"> *	Process a main/reserve volume descriptor sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * PRE-CONDITIONS</span>
<span class="cm"> *	sb			Pointer to _locked_ superblock.</span>
<span class="cm"> *	block			First block of first extent of the sequence.</span>
<span class="cm"> *	lastblock		Lastblock of first extent of the sequence.</span>
<span class="cm"> *</span>
<span class="cm"> * HISTORY</span>
<span class="cm"> *	July 1, 1997 - Andrew E. Mileski</span>
<span class="cm"> *	Written, tested, and released.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="n">noinline</span> <span class="kt">int</span> <span class="nf">udf_process_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">long</span> <span class="n">block</span><span class="p">,</span>
				<span class="kt">long</span> <span class="n">lastblock</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_vds_record</span> <span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_LENGTH</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">udf_vds_record</span> <span class="o">*</span><span class="n">curr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">generic_desc</span> <span class="o">*</span><span class="n">gd</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">volDescPtr</span> <span class="o">*</span><span class="n">vdp</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">done</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">vdsn</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">next_s</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">next_e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">vds</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_vds_record</span><span class="p">)</span> <span class="o">*</span> <span class="n">VDS_POS_LENGTH</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Read the main descriptor sequence and find which descriptors</span>
<span class="cm">	 * are in it.</span>
<span class="cm">	 */</span>
	<span class="k">for</span> <span class="p">(;</span> <span class="p">(</span><span class="o">!</span><span class="n">done</span> <span class="o">&amp;&amp;</span> <span class="n">block</span> <span class="o">&lt;=</span> <span class="n">lastblock</span><span class="p">);</span> <span class="n">block</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>

		<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_tagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				<span class="s">&quot;Block %llu of volume descriptor sequence is corrupted or we could not read it</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">block</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="cm">/* Process each descriptor (ISO 13346 3/8.3-8.4) */</span>
		<span class="n">gd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">generic_desc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="n">vdsn</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">gd</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span><span class="p">);</span>
		<span class="k">switch</span> <span class="p">(</span><span class="n">ident</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">case</span> <span class="n">TAG_IDENT_PVD</span>: <span class="cm">/* ISO 13346 3/10.1 */</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_PRIMARY_VOL_DESC</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vdsn</span> <span class="o">&gt;=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span> <span class="o">=</span> <span class="n">vdsn</span><span class="p">;</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TAG_IDENT_VDP</span>: <span class="cm">/* ISO 13346 3/10.3 */</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_VOL_DESC_PTR</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vdsn</span> <span class="o">&gt;=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span> <span class="o">=</span> <span class="n">vdsn</span><span class="p">;</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>

				<span class="n">vdp</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">volDescPtr</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
				<span class="n">next_s</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
					<span class="n">vdp</span><span class="o">-&gt;</span><span class="n">nextVolDescSeqExt</span><span class="p">.</span><span class="n">extLocation</span><span class="p">);</span>
				<span class="n">next_e</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
					<span class="n">vdp</span><span class="o">-&gt;</span><span class="n">nextVolDescSeqExt</span><span class="p">.</span><span class="n">extLength</span><span class="p">);</span>
				<span class="n">next_e</span> <span class="o">=</span> <span class="n">next_e</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
				<span class="n">next_e</span> <span class="o">+=</span> <span class="n">next_s</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TAG_IDENT_IUVD</span>: <span class="cm">/* ISO 13346 3/10.4 */</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_IMP_USE_VOL_DESC</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vdsn</span> <span class="o">&gt;=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span> <span class="o">=</span> <span class="n">vdsn</span><span class="p">;</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TAG_IDENT_PD</span>: <span class="cm">/* ISO 13346 3/10.5 */</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_PARTITION_DESC</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">curr</span><span class="o">-&gt;</span><span class="n">block</span><span class="p">)</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TAG_IDENT_LVD</span>: <span class="cm">/* ISO 13346 3/10.6 */</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_LOGICAL_VOL_DESC</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vdsn</span> <span class="o">&gt;=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span> <span class="o">=</span> <span class="n">vdsn</span><span class="p">;</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TAG_IDENT_USD</span>: <span class="cm">/* ISO 13346 3/10.8 */</span>
			<span class="n">curr</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_UNALLOC_SPACE_DESC</span><span class="p">];</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">vdsn</span> <span class="o">&gt;=</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">volDescSeqNum</span> <span class="o">=</span> <span class="n">vdsn</span><span class="p">;</span>
				<span class="n">curr</span><span class="o">-&gt;</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="k">case</span> <span class="n">TAG_IDENT_TD</span>: <span class="cm">/* ISO 13346 3/10.9 */</span>
			<span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_TERMINATING_DESC</span><span class="p">].</span><span class="n">block</span> <span class="o">=</span> <span class="n">block</span><span class="p">;</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">next_e</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">block</span> <span class="o">=</span> <span class="n">next_s</span><span class="p">;</span>
				<span class="n">lastblock</span> <span class="o">=</span> <span class="n">next_e</span><span class="p">;</span>
				<span class="n">next_s</span> <span class="o">=</span> <span class="n">next_e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="p">}</span> <span class="k">else</span>
				<span class="n">done</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * Now read interesting descriptors again and process them</span>
<span class="cm">	 * in a suitable order</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_PRIMARY_VOL_DESC</span><span class="p">].</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Primary Volume Descriptor not found!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udf_load_pvoldesc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_PRIMARY_VOL_DESC</span><span class="p">].</span><span class="n">block</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_LOGICAL_VOL_DESC</span><span class="p">].</span><span class="n">block</span> <span class="o">&amp;&amp;</span> <span class="n">udf_load_logicalvol</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
	    <span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_LOGICAL_VOL_DESC</span><span class="p">].</span><span class="n">block</span><span class="p">,</span> <span class="n">fileset</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_PARTITION_DESC</span><span class="p">].</span><span class="n">block</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * We rescan the whole descriptor sequence to find</span>
<span class="cm">		 * partition descriptor blocks and process them.</span>
<span class="cm">		 */</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">block</span> <span class="o">=</span> <span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_PARTITION_DESC</span><span class="p">].</span><span class="n">block</span><span class="p">;</span>
		     <span class="n">block</span> <span class="o">&lt;</span> <span class="n">vds</span><span class="p">[</span><span class="n">VDS_POS_TERMINATING_DESC</span><span class="p">].</span><span class="n">block</span><span class="p">;</span>
		     <span class="n">block</span><span class="o">++</span><span class="p">)</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">udf_load_partdesc</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">))</span>
				<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_sequence</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">,</span>
			     <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">anchorVolDescPtr</span> <span class="o">*</span><span class="n">anchor</span><span class="p">;</span>
	<span class="kt">long</span> <span class="n">main_s</span><span class="p">,</span> <span class="n">main_e</span><span class="p">,</span> <span class="n">reserve_s</span><span class="p">,</span> <span class="n">reserve_e</span><span class="p">;</span>

	<span class="n">anchor</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">anchorVolDescPtr</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="cm">/* Locate the main sequence */</span>
	<span class="n">main_s</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">mainVolDescSeqExt</span><span class="p">.</span><span class="n">extLocation</span><span class="p">);</span>
	<span class="n">main_e</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">mainVolDescSeqExt</span><span class="p">.</span><span class="n">extLength</span><span class="p">);</span>
	<span class="n">main_e</span> <span class="o">=</span> <span class="n">main_e</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">main_e</span> <span class="o">+=</span> <span class="n">main_s</span><span class="p">;</span>

	<span class="cm">/* Locate the reserve sequence */</span>
	<span class="n">reserve_s</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">reserveVolDescSeqExt</span><span class="p">.</span><span class="n">extLocation</span><span class="p">);</span>
	<span class="n">reserve_e</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">anchor</span><span class="o">-&gt;</span><span class="n">reserveVolDescSeqExt</span><span class="p">.</span><span class="n">extLength</span><span class="p">);</span>
	<span class="n">reserve_e</span> <span class="o">=</span> <span class="n">reserve_e</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">;</span>
	<span class="n">reserve_e</span> <span class="o">+=</span> <span class="n">reserve_s</span><span class="p">;</span>

	<span class="cm">/* Process the main &amp; reserve sequences */</span>
	<span class="cm">/* responsible for finding the PartitionDesc(s) */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udf_process_sequence</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">main_s</span><span class="p">,</span> <span class="n">main_e</span><span class="p">,</span> <span class="n">fileset</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">udf_process_sequence</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">reserve_s</span><span class="p">,</span> <span class="n">reserve_e</span><span class="p">,</span> <span class="n">fileset</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check whether there is an anchor block in the given block and</span>
<span class="cm"> * load Volume Descriptor Sequence if so.</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_check_anchor_block</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">block</span><span class="p">,</span>
				  <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_VARCONV</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">udf_fixed_to_variable</span><span class="p">(</span><span class="n">block</span><span class="p">)</span> <span class="o">&gt;=</span>
	    <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_tagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="n">block</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">ident</span> <span class="o">!=</span> <span class="n">TAG_IDENT_AVDP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_load_sequence</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">bh</span><span class="p">,</span> <span class="n">fileset</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Search for an anchor volume descriptor pointer */</span>
<span class="k">static</span> <span class="n">sector_t</span> <span class="nf">udf_scan_anchors</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="n">sector_t</span> <span class="n">lastblock</span><span class="p">,</span>
				 <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">last</span><span class="p">[</span><span class="mi">6</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="kt">int</span> <span class="n">last_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* First try user provided anchor */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_anchor</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udf_check_anchor_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_anchor</span><span class="p">,</span> <span class="n">fileset</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="cm">/*</span>
<span class="cm">	 * according to spec, anchor is in either:</span>
<span class="cm">	 *     block 256</span>
<span class="cm">	 *     lastblock-256</span>
<span class="cm">	 *     lastblock</span>
<span class="cm">	 *  however, if the disc isn&#39;t closed, it could be 512.</span>
<span class="cm">	 */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udf_check_anchor_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span> <span class="o">+</span> <span class="mi">256</span><span class="p">,</span> <span class="n">fileset</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="cm">/*</span>
<span class="cm">	 * The trouble is which block is the last one. Drives often misreport</span>
<span class="cm">	 * this so we try various possibilities.</span>
<span class="cm">	 */</span>
	<span class="n">last</span><span class="p">[</span><span class="n">last_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
		<span class="n">last</span><span class="p">[</span><span class="n">last_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastblock</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="n">last</span><span class="p">[</span><span class="n">last_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastblock</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span> <span class="o">&gt;=</span> <span class="mi">2</span><span class="p">)</span>
		<span class="n">last</span><span class="p">[</span><span class="n">last_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastblock</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span> <span class="o">&gt;=</span> <span class="mi">150</span><span class="p">)</span>
		<span class="n">last</span><span class="p">[</span><span class="n">last_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastblock</span> <span class="o">-</span> <span class="mi">150</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span> <span class="o">&gt;=</span> <span class="mi">152</span><span class="p">)</span>
		<span class="n">last</span><span class="p">[</span><span class="n">last_count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">lastblock</span> <span class="o">-</span> <span class="mi">152</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">last_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_inode</span><span class="o">-&gt;</span><span class="n">i_size</span> <span class="o">&gt;&gt;</span>
				<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udf_check_anchor_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">last</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">fileset</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">last</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">last</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">256</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">udf_check_anchor_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">last</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">256</span><span class="p">,</span> <span class="n">fileset</span><span class="p">))</span>
			<span class="k">return</span> <span class="n">last</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>

	<span class="cm">/* Finally try block 512 in case media is open */</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">udf_check_anchor_block</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span> <span class="o">+</span> <span class="mi">512</span><span class="p">,</span> <span class="n">fileset</span><span class="p">))</span>
		<span class="k">return</span> <span class="n">last</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Find an anchor volume descriptor and load Volume Descriptor Sequence from</span>
<span class="cm"> * area specified by it. The function expects sbi-&gt;s_lastblock to be the last</span>
<span class="cm"> * block on the media.</span>
<span class="cm"> *</span>
<span class="cm"> * Return 1 if ok, 0 if not found.</span>
<span class="cm"> *</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_find_anchor</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
			   <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">sector_t</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">lastblock</span> <span class="o">=</span> <span class="n">udf_scan_anchors</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">,</span> <span class="n">fileset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* No anchor found? Try VARCONV conversion of block numbers */</span>
	<span class="n">UDF_SET_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_VARCONV</span><span class="p">);</span>
	<span class="cm">/* Firstly, we try to not convert number of the last block */</span>
	<span class="n">lastblock</span> <span class="o">=</span> <span class="n">udf_scan_anchors</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
				<span class="n">udf_variable_to_fixed</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">),</span>
				<span class="n">fileset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">lastblock</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>

	<span class="cm">/* Secondly, we try with converted number of the last block */</span>
	<span class="n">lastblock</span> <span class="o">=</span> <span class="n">udf_scan_anchors</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">,</span> <span class="n">fileset</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lastblock</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* VARCONV didn&#39;t help. Clear it. */</span>
		<span class="n">UDF_CLEAR_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_VARCONV</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
<span class="nl">out:</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span> <span class="o">=</span> <span class="n">lastblock</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * Check Volume Structure Descriptor, find Anchor block and load Volume</span>
<span class="cm"> * Descriptor Sequence</span>
<span class="cm"> */</span>
<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_load_vrs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">struct</span> <span class="n">udf_options</span> <span class="o">*</span><span class="n">uopt</span><span class="p">,</span>
			<span class="kt">int</span> <span class="n">silent</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="o">*</span><span class="n">fileset</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">loff_t</span> <span class="n">nsr_off</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb_set_blocksize</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">uopt</span><span class="o">-&gt;</span><span class="n">blocksize</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Bad block size</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span> <span class="o">=</span> <span class="n">uopt</span><span class="o">-&gt;</span><span class="n">lastblock</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uopt</span><span class="o">-&gt;</span><span class="n">novrs</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* Check that it is NSR02 compliant */</span>
		<span class="n">nsr_off</span> <span class="o">=</span> <span class="n">udf_check_vsd</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">nsr_off</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
				<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;No VRS found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
			<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">nsr_off</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Failed to read byte 32768. Assuming open disc. Skipping validity check</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">)</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span> <span class="o">=</span> <span class="n">udf_get_last_block</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Validity check skipped because of novrs option</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* Look for anchor block and load Volume Descriptor Sequence */</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_anchor</span> <span class="o">=</span> <span class="n">uopt</span><span class="o">-&gt;</span><span class="n">anchor</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udf_find_anchor</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">fileset</span><span class="p">))</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
			<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;No anchor found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_open_lvid</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="n">lvid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDescImpUse</span> <span class="o">*</span><span class="n">lvidiu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
	<span class="n">lvid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">lvidiu</span> <span class="o">=</span> <span class="n">udf_sb_lvidiu</span><span class="p">(</span><span class="n">sbi</span><span class="p">);</span>

	<span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">impIdent</span><span class="p">.</span><span class="n">identSuffix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">UDF_OS_CLASS_UNIX</span><span class="p">;</span>
	<span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">impIdent</span><span class="p">.</span><span class="n">identSuffix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">UDF_OS_ID_LINUX</span><span class="p">;</span>
	<span class="n">udf_time_to_disk_stamp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">recordingDateAndTime</span><span class="p">,</span>
				<span class="n">CURRENT_TIME</span><span class="p">);</span>
	<span class="n">lvid</span><span class="o">-&gt;</span><span class="n">integrityType</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LVID_INTEGRITY_TYPE_OPEN</span><span class="p">);</span>

	<span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">.</span><span class="n">descCRC</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span>
		<span class="n">crc_itu_t</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lvid</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tag</span><span class="p">),</span>
			<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">.</span><span class="n">descCRCLength</span><span class="p">)));</span>

	<span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">.</span><span class="n">tagChecksum</span> <span class="o">=</span> <span class="n">udf_tag_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">);</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_close_lvid</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="n">lvid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDescImpUse</span> <span class="o">*</span><span class="n">lvidiu</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
	<span class="n">lvid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">lvidiu</span> <span class="o">=</span> <span class="n">udf_sb_lvidiu</span><span class="p">(</span><span class="n">sbi</span><span class="p">);</span>
	<span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">impIdent</span><span class="p">.</span><span class="n">identSuffix</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">UDF_OS_CLASS_UNIX</span><span class="p">;</span>
	<span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">impIdent</span><span class="p">.</span><span class="n">identSuffix</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">UDF_OS_ID_LINUX</span><span class="p">;</span>
	<span class="n">udf_time_to_disk_stamp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">recordingDateAndTime</span><span class="p">,</span> <span class="n">CURRENT_TIME</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_MAX_WRITE_VERSION</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">maxUDFWriteRev</span><span class="p">))</span>
		<span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">maxUDFWriteRev</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">UDF_MAX_WRITE_VERSION</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_udfrev</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">minUDFReadRev</span><span class="p">))</span>
		<span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">minUDFReadRev</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_udfrev</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_udfrev</span> <span class="o">&gt;</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">minUDFWriteRev</span><span class="p">))</span>
		<span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">minUDFWriteRev</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_udfrev</span><span class="p">);</span>
	<span class="n">lvid</span><span class="o">-&gt;</span><span class="n">integrityType</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">LVID_INTEGRITY_TYPE_CLOSE</span><span class="p">);</span>

	<span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">.</span><span class="n">descCRC</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span>
			<span class="n">crc_itu_t</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">lvid</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">tag</span><span class="p">),</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">.</span><span class="n">descCRCLength</span><span class="p">)));</span>

	<span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">.</span><span class="n">tagChecksum</span> <span class="o">=</span> <span class="n">udf_tag_checksum</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">descTag</span><span class="p">);</span>
	<span class="cm">/*</span>
<span class="cm">	 * We set buffer uptodate unconditionally here to avoid spurious</span>
<span class="cm">	 * warnings from mark_buffer_dirty() when previous EIO has marked</span>
<span class="cm">	 * the buffer as !uptodate</span>
<span class="cm">	 */</span>
	<span class="n">set_buffer_uptodate</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">u64</span> <span class="nf">lvid_get_unique_id</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="n">lvid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">logicalVolHeaderDesc</span> <span class="o">*</span><span class="n">lvhd</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">uniqueID</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">ret</span><span class="p">;</span>

	<span class="n">bh</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">;</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">lvid</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">lvhd</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolHeaderDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">logicalVolContentsUse</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
	<span class="n">ret</span> <span class="o">=</span> <span class="n">uniqueID</span> <span class="o">=</span> <span class="n">le64_to_cpu</span><span class="p">(</span><span class="n">lvhd</span><span class="o">-&gt;</span><span class="n">uniqueID</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="o">++</span><span class="n">uniqueID</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFFF</span><span class="p">))</span>
		<span class="n">uniqueID</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">;</span>
	<span class="n">lvhd</span><span class="o">-&gt;</span><span class="n">uniqueID</span> <span class="o">=</span> <span class="n">cpu_to_le64</span><span class="p">(</span><span class="n">uniqueID</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
	<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_sb_free_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">nr_groups</span> <span class="o">=</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_nr_groups</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_bitmap</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="p">)</span> <span class="o">*</span>
						<span class="n">nr_groups</span><span class="p">);</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nr_groups</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_block_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_block_bitmap</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="n">PAGE_SIZE</span><span class="p">)</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">vfree</span><span class="p">(</span><span class="n">bitmap</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_free_partition</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_meta_data</span> <span class="o">*</span><span class="n">mdata</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_UNALLOC_TABLE</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_FREED_TABLE</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_table</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_UNALLOC_BITMAP</span><span class="p">)</span>
		<span class="n">udf_sb_free_bitmap</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_bitmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_FREED_BITMAP</span><span class="p">)</span>
		<span class="n">udf_sb_free_bitmap</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_bitmap</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_SPARABLE_MAP15</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_sparing</span><span class="p">.</span><span class="n">s_spar_map</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
	<span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_type</span> <span class="o">==</span> <span class="n">UDF_METADATA_MAP25</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">mdata</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_type_specific</span><span class="p">.</span><span class="n">s_metadata</span><span class="p">;</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_metadata_fe</span><span class="p">);</span>
		<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_metadata_fe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">iput</span><span class="p">(</span><span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_mirror_fe</span><span class="p">);</span>
		<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_mirror_fe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

		<span class="n">iput</span><span class="p">(</span><span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_bitmap_fe</span><span class="p">);</span>
		<span class="n">mdata</span><span class="o">-&gt;</span><span class="n">s_bitmap_fe</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_fill_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">options</span><span class="p">,</span> <span class="kt">int</span> <span class="n">silent</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">inode</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_options</span> <span class="n">uopt</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">rootdir</span><span class="p">,</span> <span class="n">fileset</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>

	<span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_USE_AD_IN_ICB</span><span class="p">)</span> <span class="o">|</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_STRICT</span><span class="p">);</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">uid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">gid</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">umask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">fmode</span> <span class="o">=</span> <span class="n">UDF_INVALID_MODE</span><span class="p">;</span>
	<span class="n">uopt</span><span class="p">.</span><span class="n">dmode</span> <span class="o">=</span> <span class="n">UDF_INVALID_MODE</span><span class="p">;</span>

	<span class="n">sbi</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">udf_sb_info</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="n">sbi</span><span class="p">;</span>

	<span class="n">mutex_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">udf_parse_options</span><span class="p">((</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">options</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uopt</span><span class="p">,</span> <span class="nb">false</span><span class="p">))</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UTF8</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
	    <span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;utf8 cannot be combined with iocharset</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>
<span class="cp">#ifdef CONFIG_UDF_NLS</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">uopt</span><span class="p">.</span><span class="n">nls_map</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">uopt</span><span class="p">.</span><span class="n">nls_map</span> <span class="o">=</span> <span class="n">load_nls_default</span><span class="p">();</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">uopt</span><span class="p">.</span><span class="n">nls_map</span><span class="p">)</span>
			<span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">);</span>
		<span class="k">else</span>
			<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Using default NLS map</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
	<span class="p">}</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">)))</span>
		<span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_UTF8</span><span class="p">);</span>

	<span class="n">fileset</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="mh">0xFFFFFFFF</span><span class="p">;</span>
	<span class="n">fileset</span><span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="mh">0xFFFF</span><span class="p">;</span>

	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">flags</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_uid</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">uid</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_gid</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">gid</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_umask</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">umask</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_fmode</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">fmode</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_dmode</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">dmode</span><span class="p">;</span>
	<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_nls_map</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">nls_map</span><span class="p">;</span>
	<span class="n">rwlock_init</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_cred_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uopt</span><span class="p">.</span><span class="n">session</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span> <span class="o">=</span> <span class="n">udf_get_last_session</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span> <span class="o">=</span> <span class="n">uopt</span><span class="p">.</span><span class="n">session</span><span class="p">;</span>

	<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Multi-session=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_session</span><span class="p">);</span>

	<span class="cm">/* Fill in the rest of the superblock */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udf_sb_ops</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_export_op</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">udf_export_ops</span><span class="p">;</span>

	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dirt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_magic</span> <span class="o">=</span> <span class="n">UDF_SUPER_MAGIC</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_time_gran</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">uopt</span><span class="p">.</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">UDF_FLAG_BLOCKSIZE_SET</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_load_vrs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uopt</span><span class="p">,</span> <span class="n">silent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileset</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
		<span class="n">uopt</span><span class="p">.</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">bdev_logical_block_size</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="p">);</span>
		<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_load_vrs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uopt</span><span class="p">,</span> <span class="n">silent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileset</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span> <span class="o">&amp;&amp;</span> <span class="n">uopt</span><span class="p">.</span><span class="n">blocksize</span> <span class="o">!=</span> <span class="n">UDF_DEFAULT_BLOCKSIZE</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span>
				<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Rescanning with blocksize %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
					  <span class="n">UDF_DEFAULT_BLOCKSIZE</span><span class="p">);</span>
			<span class="n">uopt</span><span class="p">.</span><span class="n">blocksize</span> <span class="o">=</span> <span class="n">UDF_DEFAULT_BLOCKSIZE</span><span class="p">;</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">udf_load_vrs</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">uopt</span><span class="p">,</span> <span class="n">silent</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileset</span><span class="p">);</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ret</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;No partition found (1)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;Lastblock=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_last_block</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">logicalVolIntegrityDescImpUse</span> <span class="o">*</span><span class="n">lvidiu</span> <span class="o">=</span>
							<span class="n">udf_sb_lvidiu</span><span class="p">(</span><span class="n">sbi</span><span class="p">);</span>
		<span class="kt">uint16_t</span> <span class="n">minUDFReadRev</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">minUDFReadRev</span><span class="p">);</span>
		<span class="kt">uint16_t</span> <span class="n">minUDFWriteRev</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">minUDFWriteRev</span><span class="p">);</span>
		<span class="cm">/* uint16_t maxUDFWriteRev =</span>
<span class="cm">				le16_to_cpu(lvidiu-&gt;maxUDFWriteRev); */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">minUDFReadRev</span> <span class="o">&gt;</span> <span class="n">UDF_MAX_READ_VERSION</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;minUDFReadRev=%x (max is %x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
				<span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">minUDFReadRev</span><span class="p">),</span>
				<span class="n">UDF_MAX_READ_VERSION</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
		<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">minUDFWriteRev</span> <span class="o">&gt;</span> <span class="n">UDF_MAX_WRITE_VERSION</span><span class="p">)</span>
			<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>

		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_udfrev</span> <span class="o">=</span> <span class="n">minUDFWriteRev</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">minUDFReadRev</span> <span class="o">&gt;=</span> <span class="n">UDF_VERS_USE_EXTENDED_FE</span><span class="p">)</span>
			<span class="n">UDF_SET_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_USE_EXTENDED_FE</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">minUDFReadRev</span> <span class="o">&gt;=</span> <span class="n">UDF_VERS_USE_STREAMS</span><span class="p">)</span>
			<span class="n">UDF_SET_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_USE_STREAMS</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;No partition found (2)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partition</span><span class="p">].</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span>
			<span class="n">UDF_PART_FLAG_READ_ONLY</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">pr_notice</span><span class="p">(</span><span class="s">&quot;Partition marked readonly; forcing readonly mount</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">|=</span> <span class="n">MS_RDONLY</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">udf_find_fileset</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fileset</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rootdir</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">udf_warn</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;No fileset found</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">silent</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">timestamp</span> <span class="n">ts</span><span class="p">;</span>
		<span class="n">udf_time_to_disk_stamp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ts</span><span class="p">,</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_record_time</span><span class="p">);</span>
		<span class="n">udf_info</span><span class="p">(</span><span class="s">&quot;Mounting volume &#39;%s&#39;, timestamp %04u/%02u/%02u %02u:%02u (%x)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
			 <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_volume_ident</span><span class="p">,</span>
			 <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">year</span><span class="p">),</span> <span class="n">ts</span><span class="p">.</span><span class="n">month</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">day</span><span class="p">,</span>
			 <span class="n">ts</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">ts</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ts</span><span class="p">.</span><span class="n">typeAndTimezone</span><span class="p">));</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="n">udf_open_lvid</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="cm">/* Assign the root inode */</span>
	<span class="cm">/* assign inodes by physical block number */</span>
	<span class="cm">/* perhaps it&#39;s not extensible enough, but for now ... */</span>
	<span class="n">inode</span> <span class="o">=</span> <span class="n">udf_iget</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">rootdir</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">inode</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Error in udf_iget, block=%d, partition=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span>
		       <span class="n">rootdir</span><span class="p">.</span><span class="n">logicalBlockNum</span><span class="p">,</span> <span class="n">rootdir</span><span class="p">.</span><span class="n">partitionReferenceNum</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* Allocate a dentry for the root inode */</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span> <span class="o">=</span> <span class="n">d_make_root</span><span class="p">(</span><span class="n">inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_root</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t allocate root dentry</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">error_out</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_maxbytes</span> <span class="o">=</span> <span class="n">MAX_LFS_FILESIZE</span><span class="p">;</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_max_links</span> <span class="o">=</span> <span class="n">UDF_MAX_LINKS</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

<span class="nl">error_out:</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">udf_free_partition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#ifdef CONFIG_UDF_NLS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">))</span>
		<span class="n">unload_nls</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_nls_map</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="n">udf_close_lvid</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">);</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sbi</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">return</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">_udf_err</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span>
	      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="cm">/* mark sb error */</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dirt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">pr_err</span><span class="p">(</span><span class="s">&quot;error (device %s): %s: %pV&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">_udf_warn</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">function</span><span class="p">,</span>
	       <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">fmt</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">va_format</span> <span class="n">vaf</span><span class="p">;</span>
	<span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>

	<span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">fmt</span><span class="p">);</span>

	<span class="n">vaf</span><span class="p">.</span><span class="n">fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="p">;</span>
	<span class="n">vaf</span><span class="p">.</span><span class="n">va</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">args</span><span class="p">;</span>

	<span class="n">pr_warn</span><span class="p">(</span><span class="s">&quot;warning (device %s): %s: %pV&quot;</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_id</span><span class="p">,</span> <span class="n">function</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">vaf</span><span class="p">);</span>

	<span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">udf_put_super</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>

	<span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">)</span>
		<span class="n">iput</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_vat_inode</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">)</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partitions</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">udf_free_partition</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
<span class="cp">#ifdef CONFIG_UDF_NLS</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">UDF_QUERY_FLAG</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">UDF_FLAG_NLS_MAP</span><span class="p">))</span>
		<span class="n">unload_nls</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_nls_map</span><span class="p">);</span>
<span class="cp">#endif</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_flags</span> <span class="o">&amp;</span> <span class="n">MS_RDONLY</span><span class="p">))</span>
		<span class="n">udf_close_lvid</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span><span class="p">);</span>
	<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_fs_info</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_sync_fs</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span> <span class="kt">int</span> <span class="n">wait</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_dirty</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/*</span>
<span class="cm">		 * Blockdevice will be synced later so we don&#39;t have to submit</span>
<span class="cm">		 * the buffer for IO</span>
<span class="cm">		 */</span>
		<span class="n">mark_buffer_dirty</span><span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">);</span>
		<span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_dirt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_dirty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">udf_statfs</span><span class="p">(</span><span class="k">struct</span> <span class="n">dentry</span> <span class="o">*</span><span class="n">dentry</span><span class="p">,</span> <span class="k">struct</span> <span class="n">kstatfs</span> <span class="o">*</span><span class="n">buf</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span> <span class="o">=</span> <span class="n">dentry</span><span class="o">-&gt;</span><span class="n">d_sb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">struct</span> <span class="n">logicalVolIntegrityDescImpUse</span> <span class="o">*</span><span class="n">lvidiu</span><span class="p">;</span>
	<span class="n">u64</span> <span class="n">id</span> <span class="o">=</span> <span class="n">huge_encode_dev</span><span class="p">(</span><span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_bdev</span><span class="o">-&gt;</span><span class="n">bd_dev</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
		<span class="n">lvidiu</span> <span class="o">=</span> <span class="n">udf_sb_lvidiu</span><span class="p">(</span><span class="n">sbi</span><span class="p">);</span>
	<span class="k">else</span>
		<span class="n">lvidiu</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_type</span> <span class="o">=</span> <span class="n">UDF_SUPER_MAGIC</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bsize</span> <span class="o">=</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_blocks</span> <span class="o">=</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partition</span><span class="p">].</span><span class="n">s_partition_len</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span> <span class="o">=</span> <span class="n">udf_count_free</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bavail</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_files</span> <span class="o">=</span> <span class="p">(</span><span class="n">lvidiu</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">?</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">numFiles</span><span class="p">)</span> <span class="o">+</span>
					  <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lvidiu</span><span class="o">-&gt;</span><span class="n">numDirs</span><span class="p">))</span> <span class="o">:</span> <span class="mi">0</span><span class="p">)</span>
			<span class="o">+</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_ffree</span> <span class="o">=</span> <span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_bfree</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_namelen</span> <span class="o">=</span> <span class="n">UDF_NAME_LEN</span> <span class="o">-</span> <span class="mi">2</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)</span><span class="n">id</span><span class="p">;</span>
	<span class="n">buf</span><span class="o">-&gt;</span><span class="n">f_fsid</span><span class="p">.</span><span class="n">val</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">u32</span><span class="p">)(</span><span class="n">id</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">);</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">udf_count_free_bitmap</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					  <span class="k">struct</span> <span class="n">udf_bitmap</span> <span class="o">*</span><span class="n">bitmap</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">buffer_head</span> <span class="o">*</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">index</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">block</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">newblock</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">loc</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">bytes</span><span class="p">;</span>
	<span class="kt">uint8_t</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
	<span class="kt">uint16_t</span> <span class="n">ident</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">spaceBitmapDesc</span> <span class="o">*</span><span class="n">bm</span><span class="p">;</span>

	<span class="n">loc</span><span class="p">.</span><span class="n">logicalBlockNum</span> <span class="o">=</span> <span class="n">bitmap</span><span class="o">-&gt;</span><span class="n">s_extPosition</span><span class="p">;</span>
	<span class="n">loc</span><span class="p">.</span><span class="n">partitionReferenceNum</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_partition</span><span class="p">;</span>
	<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_read_ptagged</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loc</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ident</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;udf_count_free failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ident</span> <span class="o">!=</span> <span class="n">TAG_IDENT_SBD</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
		<span class="n">udf_err</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="s">&quot;udf_count_free failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
		<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">bm</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">spaceBitmapDesc</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
	<span class="n">bytes</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">bm</span><span class="o">-&gt;</span><span class="n">numOfBytes</span><span class="p">);</span>
	<span class="n">index</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">spaceBitmapDesc</span><span class="p">);</span> <span class="cm">/* offset in first block only */</span>
	<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="n">bytes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">u32</span> <span class="n">cur_bytes</span> <span class="o">=</span> <span class="n">min_t</span><span class="p">(</span><span class="n">u32</span><span class="p">,</span> <span class="n">bytes</span><span class="p">,</span> <span class="n">sb</span><span class="o">-&gt;</span><span class="n">s_blocksize</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
		<span class="n">accum</span> <span class="o">+=</span> <span class="n">bitmap_weight</span><span class="p">((</span><span class="k">const</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="o">*</span><span class="p">)(</span><span class="n">ptr</span> <span class="o">+</span> <span class="n">index</span><span class="p">),</span>
					<span class="n">cur_bytes</span> <span class="o">*</span> <span class="mi">8</span><span class="p">);</span>
		<span class="n">bytes</span> <span class="o">-=</span> <span class="n">cur_bytes</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">bytes</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
			<span class="n">newblock</span> <span class="o">=</span> <span class="n">udf_get_lb_pblock</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">loc</span><span class="p">,</span> <span class="o">++</span><span class="n">block</span><span class="p">);</span>
			<span class="n">bh</span> <span class="o">=</span> <span class="n">udf_tread</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span> <span class="n">newblock</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">bh</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">udf_debug</span><span class="p">(</span><span class="s">&quot;read failed</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
				<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
			<span class="p">}</span>
			<span class="n">index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
			<span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="p">)</span><span class="n">bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>
	<span class="n">brelse</span><span class="p">(</span><span class="n">bh</span><span class="p">);</span>
<span class="nl">out:</span>
	<span class="k">return</span> <span class="n">accum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">udf_count_free_table</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">,</span>
					 <span class="k">struct</span> <span class="n">inode</span> <span class="o">*</span><span class="n">table</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">elen</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kernel_lb_addr</span> <span class="n">eloc</span><span class="p">;</span>
	<span class="kt">int8_t</span> <span class="n">etype</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">extent_position</span> <span class="n">epos</span><span class="p">;</span>

	<span class="n">mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>
	<span class="n">epos</span><span class="p">.</span><span class="n">block</span> <span class="o">=</span> <span class="n">UDF_I</span><span class="p">(</span><span class="n">table</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">i_location</span><span class="p">;</span>
	<span class="n">epos</span><span class="p">.</span><span class="n">offset</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">unallocSpaceEntry</span><span class="p">);</span>
	<span class="n">epos</span><span class="p">.</span><span class="n">bh</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">((</span><span class="n">etype</span> <span class="o">=</span> <span class="n">udf_next_aext</span><span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">epos</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eloc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">elen</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
		<span class="n">accum</span> <span class="o">+=</span> <span class="p">(</span><span class="n">elen</span> <span class="o">&gt;&gt;</span> <span class="n">table</span><span class="o">-&gt;</span><span class="n">i_sb</span><span class="o">-&gt;</span><span class="n">s_blocksize_bits</span><span class="p">);</span>

	<span class="n">brelse</span><span class="p">(</span><span class="n">epos</span><span class="p">.</span><span class="n">bh</span><span class="p">);</span>
	<span class="n">mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">s_alloc_mutex</span><span class="p">);</span>

	<span class="k">return</span> <span class="n">accum</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">udf_count_free</span><span class="p">(</span><span class="k">struct</span> <span class="n">super_block</span> <span class="o">*</span><span class="n">sb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_sb_info</span> <span class="o">*</span><span class="n">sbi</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">udf_part_map</span> <span class="o">*</span><span class="n">map</span><span class="p">;</span>

	<span class="n">sbi</span> <span class="o">=</span> <span class="n">UDF_SB</span><span class="p">(</span><span class="n">sb</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="n">lvid</span> <span class="o">=</span>
			<span class="p">(</span><span class="k">struct</span> <span class="n">logicalVolIntegrityDesc</span> <span class="o">*</span><span class="p">)</span>
			<span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_lvid_bh</span><span class="o">-&gt;</span><span class="n">b_data</span><span class="p">;</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">lvid</span><span class="o">-&gt;</span><span class="n">numOfPartitions</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partition</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">accum</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span>
					<span class="n">lvid</span><span class="o">-&gt;</span><span class="n">freeSpaceTable</span><span class="p">[</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partition</span><span class="p">]);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">accum</span> <span class="o">==</span> <span class="mh">0xFFFFFFFF</span><span class="p">)</span>
				<span class="n">accum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">accum</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">accum</span><span class="p">;</span>

	<span class="n">map</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partmaps</span><span class="p">[</span><span class="n">sbi</span><span class="o">-&gt;</span><span class="n">s_partition</span><span class="p">];</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_UNALLOC_BITMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">accum</span> <span class="o">+=</span> <span class="n">udf_count_free_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					       <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_bitmap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_FREED_BITMAP</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">accum</span> <span class="o">+=</span> <span class="n">udf_count_free_bitmap</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					       <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_bitmap</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">accum</span><span class="p">)</span>
		<span class="k">return</span> <span class="n">accum</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_UNALLOC_TABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">accum</span> <span class="o">+=</span> <span class="n">udf_count_free_table</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					      <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_uspace</span><span class="p">.</span><span class="n">s_table</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="o">-&gt;</span><span class="n">s_partition_flags</span> <span class="o">&amp;</span> <span class="n">UDF_PART_FLAG_FREED_TABLE</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">accum</span> <span class="o">+=</span> <span class="n">udf_count_free_table</span><span class="p">(</span><span class="n">sb</span><span class="p">,</span>
					      <span class="n">map</span><span class="o">-&gt;</span><span class="n">s_fspace</span><span class="p">.</span><span class="n">s_table</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="n">accum</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
