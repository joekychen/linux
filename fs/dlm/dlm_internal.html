<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › dlm › dlm_internal.h

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>dlm_internal.h</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**  Copyright (C) Sistina Software, Inc.  1997-2003  All rights reserved.</span>
<span class="cm">**  Copyright (C) 2004-2011 Red Hat, Inc.  All rights reserved.</span>
<span class="cm">**</span>
<span class="cm">**  This copyrighted material is made available to anyone wishing to use,</span>
<span class="cm">**  modify, copy, or redistribute it subject to the terms and conditions</span>
<span class="cm">**  of the GNU General Public License v.2.</span>
<span class="cm">**</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">******************************************************************************/</span>

<span class="cp">#ifndef __DLM_INTERNAL_DOT_H__</span>
<span class="cp">#define __DLM_INTERNAL_DOT_H__</span>

<span class="cm">/*</span>
<span class="cm"> * This is the main header file to be included in each DLM source file.</span>
<span class="cm"> */</span>

<span class="cp">#include &lt;linux/module.h&gt;</span>
<span class="cp">#include &lt;linux/slab.h&gt;</span>
<span class="cp">#include &lt;linux/sched.h&gt;</span>
<span class="cp">#include &lt;linux/types.h&gt;</span>
<span class="cp">#include &lt;linux/ctype.h&gt;</span>
<span class="cp">#include &lt;linux/spinlock.h&gt;</span>
<span class="cp">#include &lt;linux/vmalloc.h&gt;</span>
<span class="cp">#include &lt;linux/list.h&gt;</span>
<span class="cp">#include &lt;linux/errno.h&gt;</span>
<span class="cp">#include &lt;linux/random.h&gt;</span>
<span class="cp">#include &lt;linux/delay.h&gt;</span>
<span class="cp">#include &lt;linux/socket.h&gt;</span>
<span class="cp">#include &lt;linux/kthread.h&gt;</span>
<span class="cp">#include &lt;linux/kobject.h&gt;</span>
<span class="cp">#include &lt;linux/kref.h&gt;</span>
<span class="cp">#include &lt;linux/kernel.h&gt;</span>
<span class="cp">#include &lt;linux/jhash.h&gt;</span>
<span class="cp">#include &lt;linux/miscdevice.h&gt;</span>
<span class="cp">#include &lt;linux/mutex.h&gt;</span>
<span class="cp">#include &lt;linux/idr.h&gt;</span>
<span class="cp">#include &lt;linux/ratelimit.h&gt;</span>
<span class="cp">#include &lt;asm/uaccess.h&gt;</span>

<span class="cp">#include &lt;linux/dlm.h&gt;</span>
<span class="cp">#include &quot;config.h&quot;</span>

<span class="cm">/* Size of the temp buffer midcomms allocates on the stack.</span>
<span class="cm">   We try to make this large enough so most messages fit.</span>
<span class="cm">   FIXME: should sctp make this unnecessary? */</span>

<span class="cp">#define DLM_INBUF_LEN		148</span>

<span class="k">struct</span> <span class="n">dlm_ls</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_lkb</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_rsb</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_member</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_rsbtable</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_dirtable</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_direntry</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_recover</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_header</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_message</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_rcom</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">dlm_mhandle</span><span class="p">;</span>

<span class="cp">#define log_print(fmt, args...) \</span>
<span class="cp">	printk(KERN_ERR &quot;dlm: &quot;fmt&quot;\n&quot; , ##args)</span>
<span class="cp">#define log_error(ls, fmt, args...) \</span>
<span class="cp">	printk(KERN_ERR &quot;dlm: %s: &quot; fmt &quot;\n&quot;, (ls)-&gt;ls_name , ##args)</span>

<span class="cp">#define log_debug(ls, fmt, args...) \</span>
<span class="cp">do { \</span>
<span class="cp">	if (dlm_config.ci_log_debug) \</span>
<span class="cp">		printk(KERN_DEBUG &quot;dlm: %s: &quot; fmt &quot;\n&quot;, \</span>
<span class="cp">		       (ls)-&gt;ls_name , ##args); \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define log_limit(ls, fmt, args...) \</span>
<span class="cp">do { \</span>
<span class="cp">	if (dlm_config.ci_log_debug) \</span>
<span class="cp">		printk_ratelimited(KERN_DEBUG &quot;dlm: %s: &quot; fmt &quot;\n&quot;, \</span>
<span class="cp">			(ls)-&gt;ls_name , ##args); \</span>
<span class="cp">} while (0)</span>

<span class="cp">#define DLM_ASSERT(x, do) \</span>
<span class="cp">{ \</span>
<span class="cp">  if (!(x)) \</span>
<span class="cp">  { \</span>
<span class="cp">    printk(KERN_ERR &quot;\nDLM:  Assertion failed on line %d of file %s\n&quot; \</span>
<span class="cp">               &quot;DLM:  assertion:  \&quot;%s\&quot;\n&quot; \</span>
<span class="cp">               &quot;DLM:  time = %lu\n&quot;, \</span>
<span class="cp">               __LINE__, __FILE__, #x, jiffies); \</span>
<span class="cp">    {do} \</span>
<span class="cp">    printk(&quot;\n&quot;); \</span>
<span class="cp">    BUG(); \</span>
<span class="cp">    panic(&quot;DLM:  Record message above and reboot.\n&quot;); \</span>
<span class="cp">  } \</span>
<span class="cp">}</span>


<span class="k">struct</span> <span class="n">dlm_direntry</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">master_nodeid</span><span class="p">;</span>
	<span class="kt">uint16_t</span>		<span class="n">length</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">name</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_dirtable</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_rsbtable</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">keep</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rb_root</span>		<span class="n">toss</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">lock</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Lockspace member (per node in a ls)</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dlm_member</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nodeid</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">weight</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">slot</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">slot_prev</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">comm_seq</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">generation</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Save and manage recovery state for a lockspace.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dlm_recover</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_config_node</span>	<span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">nodes_count</span><span class="p">;</span>
	<span class="kt">uint64_t</span>		<span class="n">seq</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/*</span>
<span class="cm"> * Pass input args to second stage locking function.</span>
<span class="cm"> */</span>

<span class="k">struct</span> <span class="n">dlm_args</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>		<span class="n">flags</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">astfn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">astparam</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">bastfn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
	<span class="kt">int</span>			<span class="n">mode</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lksb</span>		<span class="o">*</span><span class="n">lksb</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">timeout</span><span class="p">;</span>
<span class="p">};</span>


<span class="cm">/*</span>
<span class="cm"> * Lock block</span>
<span class="cm"> *</span>
<span class="cm"> * A lock can be one of three types:</span>
<span class="cm"> *</span>
<span class="cm"> * local copy      lock is mastered locally</span>
<span class="cm"> *                 (lkb_nodeid is zero and DLM_LKF_MSTCPY is not set)</span>
<span class="cm"> * process copy    lock is mastered on a remote node</span>
<span class="cm"> *                 (lkb_nodeid is non-zero and DLM_LKF_MSTCPY is not set)</span>
<span class="cm"> * master copy     master node&#39;s copy of a lock owned by remote node</span>
<span class="cm"> *                 (lkb_nodeid is non-zero and DLM_LKF_MSTCPY is set)</span>
<span class="cm"> *</span>
<span class="cm"> * lkb_exflags: a copy of the most recent flags arg provided to dlm_lock or</span>
<span class="cm"> * dlm_unlock.  The dlm does not modify these or use any private flags in</span>
<span class="cm"> * this field; it only contains DLM_LKF_ flags from dlm.h.  These flags</span>
<span class="cm"> * are sent as-is to the remote master when the lock is remote.</span>
<span class="cm"> *</span>
<span class="cm"> * lkb_flags: internal dlm flags (DLM_IFL_ prefix) from dlm_internal.h.</span>
<span class="cm"> * Some internal flags are shared between the master and process nodes;</span>
<span class="cm"> * these shared flags are kept in the lower two bytes.  One of these</span>
<span class="cm"> * flags set on the master copy will be propagated to the process copy</span>
<span class="cm"> * and v.v.  Other internal flags are private to the master or process</span>
<span class="cm"> * node (e.g. DLM_IFL_MSTCPY).  These are kept in the high two bytes.</span>
<span class="cm"> *</span>
<span class="cm"> * lkb_sbflags: status block flags.  These flags are copied directly into</span>
<span class="cm"> * the caller&#39;s lksb.sb_flags prior to the dlm_lock/dlm_unlock completion</span>
<span class="cm"> * ast.  All defined in dlm.h with DLM_SBF_ prefix.</span>
<span class="cm"> *</span>
<span class="cm"> * lkb_status: the lock status indicates which rsb queue the lock is</span>
<span class="cm"> * on, grant, convert, or wait.  DLM_LKSTS_ WAITING/GRANTED/CONVERT</span>
<span class="cm"> *</span>
<span class="cm"> * lkb_wait_type: the dlm message type (DLM_MSG_ prefix) for which a</span>
<span class="cm"> * reply is needed.  Only set when the lkb is on the lockspace waiters</span>
<span class="cm"> * list awaiting a reply from a remote node.</span>
<span class="cm"> *</span>
<span class="cm"> * lkb_nodeid: when the lkb is a local copy, nodeid is 0; when the lkb</span>
<span class="cm"> * is a master copy, nodeid specifies the remote lock holder, when the</span>
<span class="cm"> * lkb is a process copy, the nodeid specifies the lock master.</span>
<span class="cm"> */</span>

<span class="cm">/* lkb_status */</span>

<span class="cp">#define DLM_LKSTS_WAITING	1</span>
<span class="cp">#define DLM_LKSTS_GRANTED	2</span>
<span class="cp">#define DLM_LKSTS_CONVERT	3</span>

<span class="cm">/* lkb_flags */</span>

<span class="cp">#define DLM_IFL_MSTCPY		0x00010000</span>
<span class="cp">#define DLM_IFL_RESEND		0x00020000</span>
<span class="cp">#define DLM_IFL_DEAD		0x00040000</span>
<span class="cp">#define DLM_IFL_OVERLAP_UNLOCK  0x00080000</span>
<span class="cp">#define DLM_IFL_OVERLAP_CANCEL  0x00100000</span>
<span class="cp">#define DLM_IFL_ENDOFLIFE	0x00200000</span>
<span class="cp">#define DLM_IFL_WATCH_TIMEWARN	0x00400000</span>
<span class="cp">#define DLM_IFL_TIMEOUT_CANCEL	0x00800000</span>
<span class="cp">#define DLM_IFL_DEADLOCK_CANCEL	0x01000000</span>
<span class="cp">#define DLM_IFL_STUB_MS		0x02000000 </span><span class="cm">/* magic number for m_flags */</span><span class="cp"></span>
<span class="cp">#define DLM_IFL_USER		0x00000001</span>
<span class="cp">#define DLM_IFL_ORPHAN		0x00000002</span>

<span class="cp">#define DLM_CALLBACKS_SIZE	6</span>

<span class="cp">#define DLM_CB_CAST		0x00000001</span>
<span class="cp">#define DLM_CB_BAST		0x00000002</span>
<span class="cp">#define DLM_CB_SKIP		0x00000004</span>

<span class="k">struct</span> <span class="n">dlm_callback</span> <span class="p">{</span>
	<span class="kt">uint64_t</span>		<span class="n">seq</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">flags</span><span class="p">;</span>		<span class="cm">/* DLM_CBF_ */</span>
	<span class="kt">int</span>			<span class="n">sb_status</span><span class="p">;</span>	<span class="cm">/* copy to lksb status */</span>
	<span class="kt">uint8_t</span>			<span class="n">sb_flags</span><span class="p">;</span>	<span class="cm">/* copy to lksb flags */</span>
	<span class="kt">int8_t</span>			<span class="n">mode</span><span class="p">;</span> <span class="cm">/* rq mode of bast, gr mode of cast */</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_rsb</span>		<span class="o">*</span><span class="n">lkb_resource</span><span class="p">;</span>	<span class="cm">/* the rsb */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">lkb_ref</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">lkb_nodeid</span><span class="p">;</span>	<span class="cm">/* copied from rsb */</span>
	<span class="kt">int</span>			<span class="n">lkb_ownpid</span><span class="p">;</span>	<span class="cm">/* pid of lock owner */</span>
	<span class="kt">uint32_t</span>		<span class="n">lkb_id</span><span class="p">;</span>		<span class="cm">/* our lock ID */</span>
	<span class="kt">uint32_t</span>		<span class="n">lkb_remid</span><span class="p">;</span>	<span class="cm">/* lock ID on remote partner */</span>
	<span class="kt">uint32_t</span>		<span class="n">lkb_exflags</span><span class="p">;</span>	<span class="cm">/* external flags from caller */</span>
	<span class="kt">uint32_t</span>		<span class="n">lkb_sbflags</span><span class="p">;</span>	<span class="cm">/* lksb flags */</span>
	<span class="kt">uint32_t</span>		<span class="n">lkb_flags</span><span class="p">;</span>	<span class="cm">/* internal flags */</span>
	<span class="kt">uint32_t</span>		<span class="n">lkb_lvbseq</span><span class="p">;</span>	<span class="cm">/* lvb sequence number */</span>

	<span class="kt">int8_t</span>			<span class="n">lkb_status</span><span class="p">;</span>     <span class="cm">/* granted, waiting, convert */</span>
	<span class="kt">int8_t</span>			<span class="n">lkb_rqmode</span><span class="p">;</span>	<span class="cm">/* requested lock mode */</span>
	<span class="kt">int8_t</span>			<span class="n">lkb_grmode</span><span class="p">;</span>	<span class="cm">/* granted lock mode */</span>
	<span class="kt">int8_t</span>			<span class="n">lkb_highbast</span><span class="p">;</span>	<span class="cm">/* highest mode bast sent for */</span>

	<span class="kt">int8_t</span>			<span class="n">lkb_wait_type</span><span class="p">;</span>	<span class="cm">/* type of reply waiting for */</span>
	<span class="kt">int8_t</span>			<span class="n">lkb_wait_count</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">lkb_wait_nodeid</span><span class="p">;</span> <span class="cm">/* for debugging */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lkb_statequeue</span><span class="p">;</span>	<span class="cm">/* rsb g/c/w list */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lkb_rsb_lookup</span><span class="p">;</span>	<span class="cm">/* waiting for rsb lookup */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lkb_wait_reply</span><span class="p">;</span>	<span class="cm">/* waiting for remote reply */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lkb_ownqueue</span><span class="p">;</span>	<span class="cm">/* list of locks for a process */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lkb_time_list</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">lkb_timestamp</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">lkb_wait_time</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">lkb_timeout_cs</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">lkb_cb_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">work_struct</span>	<span class="n">lkb_cb_work</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">lkb_cb_list</span><span class="p">;</span> <span class="cm">/* for ls_cb_delay or proc-&gt;asts */</span>
	<span class="k">struct</span> <span class="n">dlm_callback</span>	<span class="n">lkb_callbacks</span><span class="p">[</span><span class="n">DLM_CALLBACKS_SIZE</span><span class="p">];</span>
	<span class="k">struct</span> <span class="n">dlm_callback</span>	<span class="n">lkb_last_cast</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_callback</span>	<span class="n">lkb_last_bast</span><span class="p">;</span>
	<span class="n">ktime_t</span>			<span class="n">lkb_last_cast_time</span><span class="p">;</span>	<span class="cm">/* for debugging */</span>
	<span class="n">ktime_t</span>			<span class="n">lkb_last_bast_time</span><span class="p">;</span>	<span class="cm">/* for debugging */</span>

	<span class="kt">uint64_t</span>		<span class="n">lkb_recover_seq</span><span class="p">;</span> <span class="cm">/* from ls_recover_seq */</span>

	<span class="kt">char</span>			<span class="o">*</span><span class="n">lkb_lvbptr</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lksb</span>		<span class="o">*</span><span class="n">lkb_lksb</span><span class="p">;</span>      <span class="cm">/* caller&#39;s status block */</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">lkb_astfn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">);</span>
	<span class="kt">void</span>			<span class="p">(</span><span class="o">*</span><span class="n">lkb_bastfn</span><span class="p">)</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">astparam</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mode</span><span class="p">);</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="kt">void</span>			<span class="o">*</span><span class="n">lkb_astparam</span><span class="p">;</span>	<span class="cm">/* caller&#39;s ast arg */</span>
		<span class="k">struct</span> <span class="n">dlm_user_args</span>	<span class="o">*</span><span class="n">lkb_ua</span><span class="p">;</span>
	<span class="p">};</span>
<span class="p">};</span>


<span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_ls</span>		<span class="o">*</span><span class="n">res_ls</span><span class="p">;</span>	<span class="cm">/* the lockspace */</span>
	<span class="k">struct</span> <span class="n">kref</span>		<span class="n">res_ref</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">res_mutex</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">res_flags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">res_length</span><span class="p">;</span>	<span class="cm">/* length of rsb name */</span>
	<span class="kt">int</span>			<span class="n">res_nodeid</span><span class="p">;</span>
	<span class="kt">uint32_t</span>                <span class="n">res_lvbseq</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">res_hash</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">res_bucket</span><span class="p">;</span>	<span class="cm">/* rsbtbl */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">res_toss_time</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">res_first_lkid</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">res_lookup</span><span class="p">;</span>	<span class="cm">/* lkbs waiting on first */</span>
	<span class="k">union</span> <span class="p">{</span>
		<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">res_hashchain</span><span class="p">;</span>
		<span class="k">struct</span> <span class="n">rb_node</span>		<span class="n">res_hashnode</span><span class="p">;</span>	<span class="cm">/* rsbtbl */</span>
	<span class="p">};</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">res_grantqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">res_convertqueue</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">res_waitqueue</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">res_root_list</span><span class="p">;</span>	    <span class="cm">/* used for recovery */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">res_recover_list</span><span class="p">;</span>   <span class="cm">/* used for recovery */</span>
	<span class="kt">int</span>			<span class="n">res_recover_locks_count</span><span class="p">;</span>

	<span class="kt">char</span>			<span class="o">*</span><span class="n">res_lvbptr</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">res_name</span><span class="p">[</span><span class="n">DLM_RESNAME_MAXLEN</span><span class="o">+</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cm">/* find_rsb() flags */</span>

<span class="cp">#define R_MASTER		1	</span><span class="cm">/* only return rsb if it&#39;s a master */</span><span class="cp"></span>
<span class="cp">#define R_CREATE		2	</span><span class="cm">/* create/add rsb if not found */</span><span class="cp"></span>

<span class="cm">/* rsb_flags */</span>

<span class="k">enum</span> <span class="n">rsb_flags</span> <span class="p">{</span>
	<span class="n">RSB_MASTER_UNCERTAIN</span><span class="p">,</span>
	<span class="n">RSB_VALNOTVALID</span><span class="p">,</span>
	<span class="n">RSB_VALNOTVALID_PREV</span><span class="p">,</span>
	<span class="n">RSB_NEW_MASTER</span><span class="p">,</span>
	<span class="n">RSB_NEW_MASTER2</span><span class="p">,</span>
	<span class="n">RSB_RECOVER_CONVERT</span><span class="p">,</span>
	<span class="n">RSB_RECOVER_GRANT</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rsb_set_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rsb_flags</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__set_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">rsb_clear_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rsb_flags</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">__clear_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">rsb_flag</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rsb</span> <span class="o">*</span><span class="n">r</span><span class="p">,</span> <span class="k">enum</span> <span class="n">rsb_flags</span> <span class="n">flag</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">flag</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">r</span><span class="o">-&gt;</span><span class="n">res_flags</span><span class="p">);</span>
<span class="p">}</span>


<span class="cm">/* dlm_header is first element of all structs sent between nodes */</span>

<span class="cp">#define DLM_HEADER_MAJOR	0x00030000</span>
<span class="cp">#define DLM_HEADER_MINOR	0x00000001</span>

<span class="cp">#define DLM_HEADER_SLOTS	0x00000001</span>

<span class="cp">#define DLM_MSG			1</span>
<span class="cp">#define DLM_RCOM		2</span>

<span class="k">struct</span> <span class="n">dlm_header</span> <span class="p">{</span>
	<span class="kt">uint32_t</span>		<span class="n">h_version</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">h_lockspace</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">h_nodeid</span><span class="p">;</span>	<span class="cm">/* nodeid of sender */</span>
	<span class="kt">uint16_t</span>		<span class="n">h_length</span><span class="p">;</span>
	<span class="kt">uint8_t</span>			<span class="n">h_cmd</span><span class="p">;</span>		<span class="cm">/* DLM_MSG, DLM_RCOM */</span>
	<span class="kt">uint8_t</span>			<span class="n">h_pad</span><span class="p">;</span>
<span class="p">};</span>


<span class="cp">#define DLM_MSG_REQUEST		1</span>
<span class="cp">#define DLM_MSG_CONVERT		2</span>
<span class="cp">#define DLM_MSG_UNLOCK		3</span>
<span class="cp">#define DLM_MSG_CANCEL		4</span>
<span class="cp">#define DLM_MSG_REQUEST_REPLY	5</span>
<span class="cp">#define DLM_MSG_CONVERT_REPLY	6</span>
<span class="cp">#define DLM_MSG_UNLOCK_REPLY	7</span>
<span class="cp">#define DLM_MSG_CANCEL_REPLY	8</span>
<span class="cp">#define DLM_MSG_GRANT		9</span>
<span class="cp">#define DLM_MSG_BAST		10</span>
<span class="cp">#define DLM_MSG_LOOKUP		11</span>
<span class="cp">#define DLM_MSG_REMOVE		12</span>
<span class="cp">#define DLM_MSG_LOOKUP_REPLY	13</span>
<span class="cp">#define DLM_MSG_PURGE		14</span>

<span class="k">struct</span> <span class="n">dlm_message</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_header</span>	<span class="n">m_header</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_type</span><span class="p">;</span>		<span class="cm">/* DLM_MSG_ */</span>
	<span class="kt">uint32_t</span>		<span class="n">m_nodeid</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_pid</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_lkid</span><span class="p">;</span>		<span class="cm">/* lkid on sender */</span>
	<span class="kt">uint32_t</span>		<span class="n">m_remid</span><span class="p">;</span>	<span class="cm">/* lkid on receiver */</span>
	<span class="kt">uint32_t</span>		<span class="n">m_parent_lkid</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_parent_remid</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_exflags</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_sbflags</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_flags</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_lvbseq</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">m_hash</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">m_status</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">m_grmode</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">m_rqmode</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">m_bastmode</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">m_asts</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">m_result</span><span class="p">;</span>	<span class="cm">/* 0 or -EXXX */</span>
	<span class="kt">char</span>			<span class="n">m_extra</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>	<span class="cm">/* name or lvb */</span>
<span class="p">};</span>


<span class="cp">#define DLM_RS_NODES		0x00000001</span>
<span class="cp">#define DLM_RS_NODES_ALL	0x00000002</span>
<span class="cp">#define DLM_RS_DIR		0x00000004</span>
<span class="cp">#define DLM_RS_DIR_ALL		0x00000008</span>
<span class="cp">#define DLM_RS_LOCKS		0x00000010</span>
<span class="cp">#define DLM_RS_LOCKS_ALL	0x00000020</span>
<span class="cp">#define DLM_RS_DONE		0x00000040</span>
<span class="cp">#define DLM_RS_DONE_ALL		0x00000080</span>

<span class="cp">#define DLM_RCOM_STATUS		1</span>
<span class="cp">#define DLM_RCOM_NAMES		2</span>
<span class="cp">#define DLM_RCOM_LOOKUP		3</span>
<span class="cp">#define DLM_RCOM_LOCK		4</span>
<span class="cp">#define DLM_RCOM_STATUS_REPLY	5</span>
<span class="cp">#define DLM_RCOM_NAMES_REPLY	6</span>
<span class="cp">#define DLM_RCOM_LOOKUP_REPLY	7</span>
<span class="cp">#define DLM_RCOM_LOCK_REPLY	8</span>

<span class="k">struct</span> <span class="n">dlm_rcom</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_header</span>	<span class="n">rc_header</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">rc_type</span><span class="p">;</span>	<span class="cm">/* DLM_RCOM_ */</span>
	<span class="kt">int</span>			<span class="n">rc_result</span><span class="p">;</span>	<span class="cm">/* multi-purpose */</span>
	<span class="kt">uint64_t</span>		<span class="n">rc_id</span><span class="p">;</span>		<span class="cm">/* match reply with request */</span>
	<span class="kt">uint64_t</span>		<span class="n">rc_seq</span><span class="p">;</span>		<span class="cm">/* sender&#39;s ls_recover_seq */</span>
	<span class="kt">uint64_t</span>		<span class="n">rc_seq_reply</span><span class="p">;</span>	<span class="cm">/* remote ls_recover_seq */</span>
	<span class="kt">char</span>			<span class="n">rc_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">union</span> <span class="n">dlm_packet</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_header</span>	<span class="n">header</span><span class="p">;</span>		<span class="cm">/* common to other two */</span>
	<span class="k">struct</span> <span class="n">dlm_message</span>	<span class="n">message</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rcom</span>		<span class="n">rcom</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DLM_RSF_NEED_SLOTS	0x00000001</span>

<span class="cm">/* RCOM_STATUS data */</span>
<span class="k">struct</span> <span class="n">rcom_status</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">rs_flags</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rs_unused1</span><span class="p">;</span>
	<span class="n">__le64</span>			<span class="n">rs_unused2</span><span class="p">;</span>
<span class="p">};</span>

<span class="cm">/* RCOM_STATUS_REPLY data */</span>
<span class="k">struct</span> <span class="n">rcom_config</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">rf_lvblen</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rf_lsflags</span><span class="p">;</span>

	<span class="cm">/* DLM_HEADER_SLOTS adds: */</span>
	<span class="n">__le32</span>			<span class="n">rf_flags</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">rf_our_slot</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">rf_num_slots</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rf_generation</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rf_unused1</span><span class="p">;</span>
	<span class="n">__le64</span>			<span class="n">rf_unused2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rcom_slot</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">ro_nodeid</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">ro_slot</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">ro_unused1</span><span class="p">;</span>
	<span class="n">__le64</span>			<span class="n">ro_unused2</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">rcom_lock</span> <span class="p">{</span>
	<span class="n">__le32</span>			<span class="n">rl_ownpid</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_lkid</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_remid</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_parent_lkid</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_parent_remid</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_exflags</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_flags</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_lvbseq</span><span class="p">;</span>
	<span class="n">__le32</span>			<span class="n">rl_result</span><span class="p">;</span>
	<span class="kt">int8_t</span>			<span class="n">rl_rqmode</span><span class="p">;</span>
	<span class="kt">int8_t</span>			<span class="n">rl_grmode</span><span class="p">;</span>
	<span class="kt">int8_t</span>			<span class="n">rl_status</span><span class="p">;</span>
	<span class="kt">int8_t</span>			<span class="n">rl_asts</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">rl_wait_type</span><span class="p">;</span>
	<span class="n">__le16</span>			<span class="n">rl_namelen</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">rl_name</span><span class="p">[</span><span class="n">DLM_RESNAME_MAXLEN</span><span class="p">];</span>
	<span class="kt">char</span>			<span class="n">rl_lvb</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">dlm_ls</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_list</span><span class="p">;</span>	<span class="cm">/* list of lockspaces */</span>
	<span class="n">dlm_lockspace_t</span>		<span class="o">*</span><span class="n">ls_local_handle</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">ls_global_id</span><span class="p">;</span>	<span class="cm">/* global unique lockspace ID */</span>
	<span class="kt">uint32_t</span>		<span class="n">ls_generation</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">ls_exflags</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_lvblen</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_count</span><span class="p">;</span>	<span class="cm">/* refcount of processes in</span>
<span class="cm">						   the dlm using this ls */</span>
	<span class="kt">int</span>			<span class="n">ls_create_count</span><span class="p">;</span> <span class="cm">/* create/release refcount */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ls_flags</span><span class="p">;</span>	<span class="cm">/* LSFL_ */</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ls_scan_time</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">kobject</span>		<span class="n">ls_kobj</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">idr</span>		<span class="n">ls_lkbidr</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">ls_lkbidr_spin</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dlm_rsbtable</span>	<span class="o">*</span><span class="n">ls_rsbtbl</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">ls_rsbtbl_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dlm_dirtable</span>	<span class="o">*</span><span class="n">ls_dirtbl</span><span class="p">;</span>
	<span class="kt">uint32_t</span>		<span class="n">ls_dirtbl_size</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ls_waiters_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_waiters</span><span class="p">;</span>	<span class="cm">/* lkbs needing a reply */</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ls_orphans_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_orphans</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ls_timeout_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_timeout</span><span class="p">;</span>

	<span class="n">spinlock_t</span>		<span class="n">ls_new_rsb_spin</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_new_rsb_count</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_new_rsb</span><span class="p">;</span>	<span class="cm">/* new rsb structs */</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_nodes</span><span class="p">;</span>	<span class="cm">/* current nodes in ls */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_nodes_gone</span><span class="p">;</span>	<span class="cm">/* dead node list, recovery */</span>
	<span class="kt">int</span>			<span class="n">ls_num_nodes</span><span class="p">;</span>	<span class="cm">/* number of nodes in ls */</span>
	<span class="kt">int</span>			<span class="n">ls_low_nodeid</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_total_weight</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="o">*</span><span class="n">ls_node_array</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">ls_slot</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_num_slots</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_slots_size</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_slot</span>		<span class="o">*</span><span class="n">ls_slots</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">dlm_rsb</span>		<span class="n">ls_stub_rsb</span><span class="p">;</span>	<span class="cm">/* for returning errors */</span>
	<span class="k">struct</span> <span class="n">dlm_lkb</span>		<span class="n">ls_stub_lkb</span><span class="p">;</span>	<span class="cm">/* for returning errors */</span>
	<span class="k">struct</span> <span class="n">dlm_message</span>	<span class="n">ls_stub_ms</span><span class="p">;</span>	<span class="cm">/* for faking a reply */</span>

	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">ls_debug_rsb_dentry</span><span class="p">;</span> <span class="cm">/* debugfs */</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">ls_debug_waiters_dentry</span><span class="p">;</span> <span class="cm">/* debugfs */</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">ls_debug_locks_dentry</span><span class="p">;</span> <span class="cm">/* debugfs */</span>
	<span class="k">struct</span> <span class="n">dentry</span>		<span class="o">*</span><span class="n">ls_debug_all_dentry</span><span class="p">;</span> <span class="cm">/* debugfs */</span>

	<span class="n">wait_queue_head_t</span>	<span class="n">ls_uevent_wait</span><span class="p">;</span>	<span class="cm">/* user part of join/leave */</span>
	<span class="kt">int</span>			<span class="n">ls_uevent_result</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">completion</span>	<span class="n">ls_members_done</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_members_result</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">miscdevice</span>       <span class="n">ls_device</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">workqueue_struct</span>	<span class="o">*</span><span class="n">ls_callback_wq</span><span class="p">;</span>

	<span class="cm">/* recovery related */</span>

	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ls_cb_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_cb_delay</span><span class="p">;</span> <span class="cm">/* save for queue_work later */</span>
	<span class="k">struct</span> <span class="n">timer_list</span>	<span class="n">ls_timer</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">task_struct</span>	<span class="o">*</span><span class="n">ls_recoverd_task</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ls_recoverd_active</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">ls_recover_lock</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">ls_recover_begin</span><span class="p">;</span> <span class="cm">/* jiffies timestamp */</span>
	<span class="kt">uint32_t</span>		<span class="n">ls_recover_status</span><span class="p">;</span> <span class="cm">/* DLM_RS_ */</span>
	<span class="kt">uint64_t</span>		<span class="n">ls_recover_seq</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_recover</span>	<span class="o">*</span><span class="n">ls_recover_args</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">ls_in_recovery</span><span class="p">;</span>	<span class="cm">/* block local requests */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">ls_recv_active</span><span class="p">;</span>	<span class="cm">/* block dlm_recv */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_requestqueue</span><span class="p">;</span><span class="cm">/* queue remote requests */</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ls_requestqueue_mutex</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rcom</span>		<span class="o">*</span><span class="n">ls_recover_buf</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_recover_nodeid</span><span class="p">;</span> <span class="cm">/* for debugging */</span>
	<span class="kt">unsigned</span> <span class="kt">int</span>		<span class="n">ls_recover_locks_in</span><span class="p">;</span> <span class="cm">/* for log info */</span>
	<span class="kt">uint64_t</span>		<span class="n">ls_rcom_seq</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">ls_rcom_spin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_recover_list</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">ls_recover_list_lock</span><span class="p">;</span>
	<span class="kt">int</span>			<span class="n">ls_recover_list_count</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">ls_wait_general</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">mutex</span>		<span class="n">ls_clear_proc_locks</span><span class="p">;</span>

	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">ls_root_list</span><span class="p">;</span>	<span class="cm">/* root resources */</span>
	<span class="k">struct</span> <span class="n">rw_semaphore</span>	<span class="n">ls_root_sem</span><span class="p">;</span>	<span class="cm">/* protect root_list */</span>

	<span class="k">const</span> <span class="k">struct</span> <span class="n">dlm_lockspace_ops</span> <span class="o">*</span><span class="n">ls_ops</span><span class="p">;</span>
	<span class="kt">void</span>			<span class="o">*</span><span class="n">ls_ops_arg</span><span class="p">;</span>

	<span class="kt">int</span>			<span class="n">ls_namelen</span><span class="p">;</span>
	<span class="kt">char</span>			<span class="n">ls_name</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="p">};</span>

<span class="cp">#define LSFL_WORK		0</span>
<span class="cp">#define LSFL_RUNNING		1</span>
<span class="cp">#define LSFL_RECOVERY_STOP	2</span>
<span class="cp">#define LSFL_RCOM_READY		3</span>
<span class="cp">#define LSFL_RCOM_WAIT		4</span>
<span class="cp">#define LSFL_UEVENT_WAIT	5</span>
<span class="cp">#define LSFL_TIMEWARN		6</span>
<span class="cp">#define LSFL_CB_DELAY		7</span>
<span class="cp">#define LSFL_NODIR		8</span>

<span class="cm">/* much of this is just saving user space pointers associated with the</span>
<span class="cm">   lock that we pass back to the user lib with an ast */</span>

<span class="k">struct</span> <span class="n">dlm_user_args</span> <span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_user_proc</span>	<span class="o">*</span><span class="n">proc</span><span class="p">;</span> <span class="cm">/* each process that opens the lockspace</span>
<span class="cm">					  device has private data</span>
<span class="cm">					  (dlm_user_proc) on the struct file,</span>
<span class="cm">					  the process&#39;s locks point back to it*/</span>
	<span class="k">struct</span> <span class="n">dlm_lksb</span>		<span class="n">lksb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_lksb</span> <span class="n">__user</span>	<span class="o">*</span><span class="n">user_lksb</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span>		<span class="o">*</span><span class="n">castparam</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span>		<span class="o">*</span><span class="n">castaddr</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span>		<span class="o">*</span><span class="n">bastparam</span><span class="p">;</span>
	<span class="kt">void</span> <span class="n">__user</span>		<span class="o">*</span><span class="n">bastaddr</span><span class="p">;</span>
	<span class="kt">uint64_t</span>		<span class="n">xid</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#define DLM_PROC_FLAGS_CLOSING 1</span>
<span class="cp">#define DLM_PROC_FLAGS_COMPAT  2</span>

<span class="cm">/* locks list is kept so we can remove all a process&#39;s locks when it</span>
<span class="cm">   exits (or orphan those that are persistent) */</span>

<span class="k">struct</span> <span class="n">dlm_user_proc</span> <span class="p">{</span>
	<span class="n">dlm_lockspace_t</span>		<span class="o">*</span><span class="n">lockspace</span><span class="p">;</span>
	<span class="kt">unsigned</span> <span class="kt">long</span>		<span class="n">flags</span><span class="p">;</span> <span class="cm">/* DLM_PROC_FLAGS */</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">asts</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">asts_spin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">locks</span><span class="p">;</span>
	<span class="n">spinlock_t</span>		<span class="n">locks_spin</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span>	<span class="n">unlocking</span><span class="p">;</span>
	<span class="n">wait_queue_head_t</span>	<span class="n">wait</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_locking_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="o">!</span><span class="n">test_bit</span><span class="p">(</span><span class="n">LSFL_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_recovery_stopped</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">LSFL_RECOVERY_STOP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_no_directory</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">test_bit</span><span class="p">(</span><span class="n">LSFL_NODIR</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_flags</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">dlm_netlink_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_netlink_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_timeout_warn</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_lkb</span> <span class="o">*</span><span class="n">lkb</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_plock_init</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_plock_exit</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

<span class="cp">#ifdef CONFIG_DLM_DEBUG</span>
<span class="kt">int</span> <span class="n">dlm_register_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_unregister_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="kt">int</span> <span class="n">dlm_create_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">);</span>
<span class="kt">void</span> <span class="n">dlm_delete_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">);</span>
<span class="cp">#else</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_register_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_unregister_debugfs</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">int</span> <span class="nf">dlm_create_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
<span class="k">static</span> <span class="kr">inline</span> <span class="kt">void</span> <span class="nf">dlm_delete_debug_file</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>
<span class="cp">#endif</span>

<span class="cp">#endif				</span><span class="cm">/* __DLM_INTERNAL_DOT_H__ */</span><span class="cp"></span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
