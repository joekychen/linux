<!DOCTYPE html>
<html><head><title>joekychen/linux » fs › dlm › member.c

</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta name="generator" content="Docco">
<link rel="stylesheet" media="all" href="../../stylesheets/docco.min.css" />


</head>
<body>
<div id="container">
<div id="background"></div>
<table cellpadding="0" cellspacing="0">
<thead><tr><th class="docs"><a id="home" href="../../index.html"></a><h1>member.c</h1></th><th class="code"></th></tr></thead>
<tbody>


<tr id="section-1"><td class="docs"><div class="pilwrap"><a class="pilcrow" href="#section-1">&#182;</a></div></td><td class="code"><div class="highlight"><pre><span class="cm">/******************************************************************************</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">**</span>
<span class="cm">**  Copyright (C) 2005-2011 Red Hat, Inc.  All rights reserved.</span>
<span class="cm">**</span>
<span class="cm">**  This copyrighted material is made available to anyone wishing to use,</span>
<span class="cm">**  modify, copy, or redistribute it subject to the terms and conditions</span>
<span class="cm">**  of the GNU General Public License v.2.</span>
<span class="cm">**</span>
<span class="cm">*******************************************************************************</span>
<span class="cm">******************************************************************************/</span>

<span class="cp">#include &quot;dlm_internal.h&quot;</span>
<span class="cp">#include &quot;lockspace.h&quot;</span>
<span class="cp">#include &quot;member.h&quot;</span>
<span class="cp">#include &quot;recoverd.h&quot;</span>
<span class="cp">#include &quot;recover.h&quot;</span>
<span class="cp">#include &quot;rcom.h&quot;</span>
<span class="cp">#include &quot;config.h&quot;</span>
<span class="cp">#include &quot;lowcomms.h&quot;</span>

<span class="kt">int</span> <span class="nf">dlm_slots_version</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_header</span> <span class="o">*</span><span class="n">h</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">((</span><span class="n">h</span><span class="o">-&gt;</span><span class="n">h_version</span> <span class="o">&amp;</span> <span class="mh">0x0000FFFF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">DLM_HEADER_SLOTS</span><span class="p">)</span>
		<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_slot_save</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rcom</span> <span class="o">*</span><span class="n">rc</span><span class="p">,</span>
		   <span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">rcom_config</span> <span class="o">*</span><span class="n">rf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcom_config</span> <span class="o">*</span><span class="p">)</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_buf</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_slots_version</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">))</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rf</span><span class="o">-&gt;</span><span class="n">rf_our_slot</span><span class="p">);</span>
	<span class="n">memb</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rf</span><span class="o">-&gt;</span><span class="n">rf_generation</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_slots_copy_out</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_rcom</span> <span class="o">*</span><span class="n">rc</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcom_slot</span> <span class="o">*</span><span class="n">ro</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="n">ro</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcom_slot</span> <span class="o">*</span><span class="p">)(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_buf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcom_config</span><span class="p">));</span>

	<span class="cm">/* ls_slots array is sparse, but not rcom_slots */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slots_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">slot</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slots</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_nodeid</span> <span class="o">=</span> <span class="n">cpu_to_le32</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">);</span>
		<span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_slot</span> <span class="o">=</span> <span class="n">cpu_to_le16</span><span class="p">(</span><span class="n">slot</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
		<span class="n">ro</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define SLOT_DEBUG_LINE 128</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">log_debug_slots</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="n">gen</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num_slots</span><span class="p">,</span>
			    <span class="k">struct</span> <span class="n">rcom_slot</span> <span class="o">*</span><span class="n">ro0</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span>
			    <span class="kt">int</span> <span class="n">array_size</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">char</span> <span class="n">line</span><span class="p">[</span><span class="n">SLOT_DEBUG_LINE</span><span class="p">];</span>
	<span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">SLOT_DEBUG_LINE</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">ret</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_log_debug</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">memset</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">line</span><span class="p">));</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nodeid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">ret</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot; %d:%d&quot;</span><span class="p">,</span>
				       <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slot</span><span class="p">,</span> <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nodeid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ro0</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">ret</span> <span class="o">=</span> <span class="n">snprintf</span><span class="p">(</span><span class="n">line</span> <span class="o">+</span> <span class="n">pos</span><span class="p">,</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">,</span> <span class="s">&quot; %d:%d&quot;</span><span class="p">,</span>
				       <span class="n">ro0</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ro_slot</span><span class="p">,</span> <span class="n">ro0</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">ro_nodeid</span><span class="p">);</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">&gt;=</span> <span class="n">len</span> <span class="o">-</span> <span class="n">pos</span><span class="p">)</span>
				<span class="k">break</span><span class="p">;</span>
			<span class="n">pos</span> <span class="o">+=</span> <span class="n">ret</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;generation %u slots %d%s&quot;</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">num_slots</span><span class="p">,</span> <span class="n">line</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_slots_copy_in</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_rcom</span> <span class="o">*</span><span class="n">rc</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcom_config</span> <span class="o">*</span><span class="n">rf</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcom_config</span> <span class="o">*</span><span class="p">)</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_buf</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">rcom_slot</span> <span class="o">*</span><span class="n">ro0</span><span class="p">,</span> <span class="o">*</span><span class="n">ro</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">our_nodeid</span> <span class="o">=</span> <span class="n">dlm_our_nodeid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">num_slots</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">gen</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_slots_version</span><span class="p">(</span><span class="o">&amp;</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_header</span><span class="p">))</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">gen</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">rf</span><span class="o">-&gt;</span><span class="n">rf_generation</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">gen</span> <span class="o">&lt;=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_generation</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_slots_copy_in gen %u old %u&quot;</span><span class="p">,</span>
			  <span class="n">gen</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_generation</span><span class="p">);</span>
	<span class="p">}</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_generation</span> <span class="o">=</span> <span class="n">gen</span><span class="p">;</span>

	<span class="n">num_slots</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">rf</span><span class="o">-&gt;</span><span class="n">rf_num_slots</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">num_slots</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="n">ro0</span> <span class="o">=</span> <span class="p">(</span><span class="k">struct</span> <span class="n">rcom_slot</span> <span class="o">*</span><span class="p">)(</span><span class="n">rc</span><span class="o">-&gt;</span><span class="n">rc_buf</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcom_config</span><span class="p">));</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">ro0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ro</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_nodeid</span> <span class="o">=</span> <span class="n">le32_to_cpu</span><span class="p">(</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_nodeid</span><span class="p">);</span>
		<span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_slot</span> <span class="o">=</span> <span class="n">le16_to_cpu</span><span class="p">(</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_slot</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">log_debug_slots</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">num_slots</span><span class="p">,</span> <span class="n">ro0</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">ro</span> <span class="o">=</span> <span class="n">ro0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_slots</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">,</span> <span class="n">ro</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_nodeid</span> <span class="o">!=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>
			<span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">ro</span><span class="o">-&gt;</span><span class="n">ro_slot</span><span class="p">;</span>
			<span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot_prev</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">our_nodeid</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span> <span class="o">&amp;&amp;</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span> <span class="o">!=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
				<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_slots_copy_in our slot &quot;</span>
					  <span class="s">&quot;changed %d %d&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span><span class="p">,</span>
					  <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
				<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
			<span class="p">}</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span><span class="p">)</span>
				<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_slots_copy_in nodeid %d no slot&quot;</span><span class="p">,</span>
				   <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* for any nodes that do not support slots, we will not have set memb-&gt;slot</span>
<span class="cm">   in wait_status_all(), so memb-&gt;slot will remain -1, and we will not</span>
<span class="cm">   assign slots or set ls_num_slots here */</span>

<span class="kt">int</span> <span class="nf">dlm_slots_assign</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_slots</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">slots_size</span><span class="p">,</span>
		     <span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">**</span><span class="n">slots_out</span><span class="p">,</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">gen_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">our_nodeid</span> <span class="o">=</span> <span class="n">dlm_our_nodeid</span><span class="p">();</span>
	<span class="kt">int</span> <span class="n">array_size</span><span class="p">,</span> <span class="n">max_slots</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">need</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">max</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">gen</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* our own memb struct will have slot -1 gen 0 */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">our_nodeid</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span><span class="p">;</span>
			<span class="n">memb</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_generation</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">generation</span> <span class="o">&gt;</span> <span class="n">gen</span><span class="p">)</span>
			<span class="n">gen</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">generation</span><span class="p">;</span>

		<span class="cm">/* node doesn&#39;t support slots */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

		<span class="cm">/* node needs a slot assigned */</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span>
			<span class="n">need</span><span class="o">++</span><span class="p">;</span>

		<span class="cm">/* node has a slot assigned */</span>

		<span class="n">num</span><span class="o">++</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">max</span> <span class="o">||</span> <span class="n">max</span> <span class="o">&lt;</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span>
			<span class="n">max</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>

		<span class="cm">/* sanity check, once slot is assigned it shouldn&#39;t change */</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot_prev</span> <span class="o">&amp;&amp;</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&amp;&amp;</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot_prev</span> <span class="o">!=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;nodeid %d slot changed %d %d&quot;</span><span class="p">,</span>
				  <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot_prev</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot_prev</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">array_size</span> <span class="o">=</span> <span class="n">max</span> <span class="o">+</span> <span class="n">need</span><span class="p">;</span>

	<span class="n">array</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">array_size</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_slot</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">array</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="cm">/* fill in slots (offsets) that are used */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">&gt;</span> <span class="n">array_size</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;invalid slot number %d&quot;</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="n">array</span><span class="p">[</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
		<span class="n">array</span><span class="p">[</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">slot</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
		<span class="n">num</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* assign new slots from unused offsets */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">array_size</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
			<span class="k">if</span> <span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nodeid</span><span class="p">)</span>
				<span class="k">continue</span><span class="p">;</span>

			<span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
			<span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot_prev</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
			<span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
			<span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slot</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
			<span class="n">num</span><span class="o">++</span><span class="p">;</span>

			<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span> <span class="o">&amp;&amp;</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">our_nodeid</span><span class="p">)</span>
				<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="p">}</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;no free slot found&quot;</span><span class="p">);</span>
			<span class="n">kfree</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
			<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
		<span class="p">}</span>
	<span class="p">}</span>

	<span class="n">gen</span><span class="o">++</span><span class="p">;</span>

	<span class="n">log_debug_slots</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">gen</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">array_size</span><span class="p">);</span>

	<span class="n">max_slots</span> <span class="o">=</span> <span class="p">(</span><span class="n">dlm_config</span><span class="p">.</span><span class="n">ci_buffer_size</span> <span class="o">-</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_rcom</span><span class="p">)</span> <span class="o">-</span>
		     <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcom_config</span><span class="p">))</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">rcom_slot</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&gt;</span> <span class="n">max_slots</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;num_slots %d exceeds max_slots %d&quot;</span><span class="p">,</span>
			  <span class="n">num</span><span class="p">,</span> <span class="n">max_slots</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">array</span><span class="p">);</span>
		<span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="o">*</span><span class="n">gen_out</span> <span class="o">=</span> <span class="n">gen</span><span class="p">;</span>
	<span class="o">*</span><span class="n">slots_out</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
	<span class="o">*</span><span class="n">slots_size</span> <span class="o">=</span> <span class="n">array_size</span><span class="p">;</span>
	<span class="o">*</span><span class="n">num_slots</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">add_ordered_member</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">new</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">tmp</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">newlist</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">;</span>

	<span class="n">list_for_each</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">memb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">tmp</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_member</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">&lt;</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memb</span><span class="p">)</span>
		<span class="n">list_add_tail</span><span class="p">(</span><span class="n">newlist</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
	<span class="k">else</span> <span class="p">{</span>
		<span class="cm">/* FIXME: can use list macro here */</span>
		<span class="n">newlist</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span><span class="p">;</span>
		<span class="n">newlist</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">newlist</span><span class="p">;</span>
		<span class="n">tmp</span><span class="o">-&gt;</span><span class="n">prev</span> <span class="o">=</span> <span class="n">newlist</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">dlm_add_member</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_config_node</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="n">memb</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_member</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">memb</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_lowcomms_connect_node</span><span class="p">(</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">memb</span><span class="p">);</span>
		<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
	<span class="n">memb</span><span class="o">-&gt;</span><span class="n">weight</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
	<span class="n">memb</span><span class="o">-&gt;</span><span class="n">comm_seq</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">comm_seq</span><span class="p">;</span>
	<span class="n">add_ordered_member</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">memb</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_nodes</span><span class="o">++</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="nf">find_memb</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="n">head</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">nodeid</span><span class="p">)</span>
			<span class="k">return</span> <span class="n">memb</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_is_member</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_memb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_is_removed</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">find_memb</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes_gone</span><span class="p">,</span> <span class="n">nodeid</span><span class="p">))</span>
		<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">clear_memb_list</span><span class="p">(</span><span class="k">struct</span> <span class="n">list_head</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>

	<span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list_empty</span><span class="p">(</span><span class="n">head</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">memb</span> <span class="o">=</span> <span class="n">list_entry</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_member</span><span class="p">,</span> <span class="n">list</span><span class="p">);</span>
		<span class="n">list_del</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">memb</span><span class="p">);</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_clear_members</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_memb_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_nodes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_clear_members_gone</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="n">clear_memb_list</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes_gone</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">make_member_array</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">total</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">all_zero</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">array</span><span class="p">;</span>

	<span class="n">kfree</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_node_array</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_node_array</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span>
			<span class="n">total</span> <span class="o">+=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* all nodes revert to weight of 1 if all have weight 0 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">total</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">total</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_nodes</span><span class="p">;</span>
		<span class="n">all_zero</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_total_weight</span> <span class="o">=</span> <span class="n">total</span><span class="p">;</span>

	<span class="n">array</span> <span class="o">=</span> <span class="n">kmalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">total</span><span class="p">,</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">array</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">all_zero</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="n">all_zero</span><span class="p">)</span>
			<span class="n">w</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
		<span class="k">else</span>
			<span class="n">w</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">weight</span><span class="p">;</span>

		<span class="n">DLM_ASSERT</span><span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">total</span><span class="p">,</span> <span class="n">printk</span><span class="p">(</span><span class="s">&quot;total %d x %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">total</span><span class="p">,</span> <span class="n">x</span><span class="p">););</span>

		<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">w</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
			<span class="n">array</span><span class="p">[</span><span class="n">x</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_node_array</span> <span class="o">=</span> <span class="n">array</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* send a status request to all members just to establish comms connections */</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">ping_members</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_recovery_stopped</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
		<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_rcom_status</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
			<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;ping_members aborted %d last nodeid %d&quot;</span><span class="p">,</span>
			  <span class="n">error</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_nodeid</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_lsop_recover_prep</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span><span class="o">-&gt;</span><span class="n">recover_prep</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span><span class="o">-&gt;</span><span class="n">recover_prep</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops_arg</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">dlm_lsop_recover_slot</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_slot</span> <span class="n">slot</span><span class="p">;</span>
	<span class="kt">uint32_t</span> <span class="n">seq</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span><span class="o">-&gt;</span><span class="n">recover_slot</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="cm">/* if there is no comms connection with this node</span>
<span class="cm">	   or the present comms connection is newer</span>
<span class="cm">	   than the one when this member was added, then</span>
<span class="cm">	   we consider the node to have failed (versus</span>
<span class="cm">	   being removed due to dlm_release_lockspace) */</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_comm_seq</span><span class="p">(</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">seq</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">&amp;&amp;</span> <span class="n">seq</span> <span class="o">==</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">comm_seq</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">slot</span><span class="p">.</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
	<span class="n">slot</span><span class="p">.</span><span class="n">slot</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span><span class="o">-&gt;</span><span class="n">recover_slot</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops_arg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">slot</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">dlm_lsop_recover_done</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_slot</span> <span class="o">*</span><span class="n">slots</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">num</span><span class="p">;</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span> <span class="o">||</span> <span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span><span class="o">-&gt;</span><span class="n">recover_done</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">num</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_nodes</span><span class="p">;</span>

	<span class="n">slots</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="n">num</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_slot</span><span class="p">),</span> <span class="n">GFP_KERNEL</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">slots</span><span class="p">)</span>
		<span class="k">return</span><span class="p">;</span>

	<span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_lsop_recover_done bad num %d&quot;</span><span class="p">,</span> <span class="n">num</span><span class="p">);</span>
			<span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
		<span class="p">}</span>
		<span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nodeid</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
		<span class="n">slots</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">slot</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">slot</span><span class="p">;</span>
		<span class="n">i</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops</span><span class="o">-&gt;</span><span class="n">recover_done</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_ops_arg</span><span class="p">,</span> <span class="n">slots</span><span class="p">,</span> <span class="n">num</span><span class="p">,</span>
				 <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slot</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_generation</span><span class="p">);</span>
 <span class="nl">out:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">slots</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="k">struct</span> <span class="n">dlm_config_node</span> <span class="o">*</span><span class="nf">find_config_node</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_recover</span> <span class="o">*</span><span class="n">rv</span><span class="p">,</span>
						<span class="kt">int</span> <span class="n">nodeid</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">;</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rv</span><span class="o">-&gt;</span><span class="n">nodes_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">rv</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">nodeid</span> <span class="o">==</span> <span class="n">nodeid</span><span class="p">)</span>
			<span class="k">return</span> <span class="o">&amp;</span><span class="n">rv</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_recover_members</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">,</span> <span class="k">struct</span> <span class="n">dlm_recover</span> <span class="o">*</span><span class="n">rv</span><span class="p">,</span> <span class="kt">int</span> <span class="o">*</span><span class="n">neg_out</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_member</span> <span class="o">*</span><span class="n">memb</span><span class="p">,</span> <span class="o">*</span><span class="n">safe</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_config_node</span> <span class="o">*</span><span class="n">node</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">error</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">low</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

	<span class="cm">/* previously removed members that we&#39;ve not finished removing need to</span>
<span class="cm">	   count as a negative change so the &quot;neg&quot; recovery steps will happen */</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes_gone</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;prev removed member %d&quot;</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">);</span>
		<span class="n">neg</span><span class="o">++</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="cm">/* move departed members from ls_nodes to ls_nodes_gone */</span>

	<span class="n">list_for_each_entry_safe</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="n">safe</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="n">find_config_node</span><span class="p">(</span><span class="n">rv</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">);</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">node</span><span class="o">-&gt;</span><span class="n">new</span><span class="p">)</span>
			<span class="k">continue</span><span class="p">;</span>

		<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
			<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remove member %d&quot;</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">);</span>
		<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
			<span class="cm">/* removed and re-added */</span>
			<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;remove member %d comm_seq %u %u&quot;</span><span class="p">,</span>
				  <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">,</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">comm_seq</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">comm_seq</span><span class="p">);</span>
		<span class="p">}</span>

		<span class="n">neg</span><span class="o">++</span><span class="p">;</span>
		<span class="n">list_move</span><span class="p">(</span><span class="o">&amp;</span><span class="n">memb</span><span class="o">-&gt;</span><span class="n">list</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes_gone</span><span class="p">);</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_nodes</span><span class="o">--</span><span class="p">;</span>
		<span class="n">dlm_lsop_recover_slot</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">memb</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="cm">/* add new members to ls_nodes */</span>

	<span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">rv</span><span class="o">-&gt;</span><span class="n">nodes_count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">rv</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">dlm_is_member</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">))</span>
			<span class="k">continue</span><span class="p">;</span>
		<span class="n">dlm_add_member</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
		<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;add member %d&quot;</span><span class="p">,</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">list_for_each_entry</span><span class="p">(</span><span class="n">memb</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_nodes</span><span class="p">,</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">if</span> <span class="p">(</span><span class="n">low</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span> <span class="o">||</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span> <span class="o">&lt;</span> <span class="n">low</span><span class="p">)</span>
			<span class="n">low</span> <span class="o">=</span> <span class="n">memb</span><span class="o">-&gt;</span><span class="n">nodeid</span><span class="p">;</span>
	<span class="p">}</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_low_nodeid</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>

	<span class="n">make_member_array</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="o">*</span><span class="n">neg_out</span> <span class="o">=</span> <span class="n">neg</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">ping_members</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span> <span class="o">||</span> <span class="n">error</span> <span class="o">==</span> <span class="o">-</span><span class="n">EPROTO</span><span class="p">)</span> <span class="p">{</span>
		<span class="cm">/* new_lockspace() may be waiting to know if the config</span>
<span class="cm">		   is good or bad */</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_members_result</span> <span class="o">=</span> <span class="n">error</span><span class="p">;</span>
		<span class="n">complete</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_members_done</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">log_debug</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;dlm_recover_members %d nodes&quot;</span><span class="p">,</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_nodes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* Userspace guarantees that dlm_ls_stop() has completed on all nodes before</span>
<span class="cm">   dlm_ls_start() is called on any of them to start the new recovery. */</span>

<span class="kt">int</span> <span class="nf">dlm_ls_stop</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="kt">int</span> <span class="n">new</span><span class="p">;</span>

	<span class="cm">/*</span>
<span class="cm">	 * Prevent dlm_recv from being in the middle of something when we do</span>
<span class="cm">	 * the stop.  This includes ensuring dlm_recv isn&#39;t processing a</span>
<span class="cm">	 * recovery message (rcom), while dlm_recoverd is aborting and</span>
<span class="cm">	 * resetting things from an in-progress recovery.  i.e. we want</span>
<span class="cm">	 * dlm_recoverd to abort its recovery without worrying about dlm_recv</span>
<span class="cm">	 * processing an rcom at the same time.  Stopping dlm_recv also makes</span>
<span class="cm">	 * it easy for dlm_receive_message() to check locking stopped and add a</span>
<span class="cm">	 * message to the requestqueue without races.</span>
<span class="cm">	 */</span>

	<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recv_active</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Abort any recovery that&#39;s in progress (see RECOVERY_STOP,</span>
<span class="cm">	 * dlm_recovery_stopped()) and tell any other threads running in the</span>
<span class="cm">	 * dlm to quit any processing (see RUNNING, dlm_locking_stopped()).</span>
<span class="cm">	 */</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_lock</span><span class="p">);</span>
	<span class="n">set_bit</span><span class="p">(</span><span class="n">LSFL_RECOVERY_STOP</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_flags</span><span class="p">);</span>
	<span class="n">new</span> <span class="o">=</span> <span class="n">test_and_clear_bit</span><span class="p">(</span><span class="n">LSFL_RUNNING</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_flags</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_seq</span><span class="o">++</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_lock</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * Let dlm_recv run again, now any normal messages will be saved on the</span>
<span class="cm">	 * requestqueue for later.</span>
<span class="cm">	 */</span>

	<span class="n">up_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recv_active</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * This in_recovery lock does two things:</span>
<span class="cm">	 * 1) Keeps this function from returning until all threads are out</span>
<span class="cm">	 *    of locking routines and locking is truly stopped.</span>
<span class="cm">	 * 2) Keeps any new requests from being processed until it&#39;s unlocked</span>
<span class="cm">	 *    when recovery is complete.</span>
<span class="cm">	 */</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">new</span><span class="p">)</span>
		<span class="n">down_write</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_in_recovery</span><span class="p">);</span>

	<span class="cm">/*</span>
<span class="cm">	 * The recoverd suspend/resume makes sure that dlm_recoverd (if</span>
<span class="cm">	 * running) has noticed RECOVERY_STOP above and quit processing the</span>
<span class="cm">	 * previous recovery.</span>
<span class="cm">	 */</span>

	<span class="n">dlm_recoverd_suspend</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_lock</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slots</span><span class="p">);</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slots</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_num_slots</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_slots_size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_status</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_lock</span><span class="p">);</span>

	<span class="n">dlm_recoverd_resume</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_begin</span><span class="p">)</span>
		<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_begin</span> <span class="o">=</span> <span class="n">jiffies</span><span class="p">;</span>

	<span class="n">dlm_lsop_recover_prep</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">dlm_ls_start</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_ls</span> <span class="o">*</span><span class="n">ls</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">struct</span> <span class="n">dlm_recover</span> <span class="o">*</span><span class="n">rv</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">rv_old</span><span class="p">;</span>
	<span class="k">struct</span> <span class="n">dlm_config_node</span> <span class="o">*</span><span class="n">nodes</span><span class="p">;</span>
	<span class="kt">int</span> <span class="n">error</span><span class="p">,</span> <span class="n">count</span><span class="p">;</span>

	<span class="n">rv</span> <span class="o">=</span> <span class="n">kzalloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">dlm_recover</span><span class="p">),</span> <span class="n">GFP_NOFS</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">rv</span><span class="p">)</span>
		<span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>

	<span class="n">error</span> <span class="o">=</span> <span class="n">dlm_config_nodes</span><span class="p">(</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_name</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">nodes</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">count</span><span class="p">);</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">error</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>

	<span class="n">spin_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_lock</span><span class="p">);</span>

	<span class="cm">/* the lockspace needs to be stopped before it can be started */</span>

	<span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">dlm_locking_stopped</span><span class="p">(</span><span class="n">ls</span><span class="p">))</span> <span class="p">{</span>
		<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_lock</span><span class="p">);</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;start ignored: lockspace running&quot;</span><span class="p">);</span>
		<span class="n">error</span> <span class="o">=</span> <span class="o">-</span><span class="n">EINVAL</span><span class="p">;</span>
		<span class="k">goto</span> <span class="n">fail</span><span class="p">;</span>
	<span class="p">}</span>

	<span class="n">rv</span><span class="o">-&gt;</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">nodes</span><span class="p">;</span>
	<span class="n">rv</span><span class="o">-&gt;</span><span class="n">nodes_count</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span>
	<span class="n">rv</span><span class="o">-&gt;</span><span class="n">seq</span> <span class="o">=</span> <span class="o">++</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_seq</span><span class="p">;</span>
	<span class="n">rv_old</span> <span class="o">=</span> <span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_args</span><span class="p">;</span>
	<span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_args</span> <span class="o">=</span> <span class="n">rv</span><span class="p">;</span>
	<span class="n">spin_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ls</span><span class="o">-&gt;</span><span class="n">ls_recover_lock</span><span class="p">);</span>

	<span class="k">if</span> <span class="p">(</span><span class="n">rv_old</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">log_error</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="s">&quot;unused recovery %llx %d&quot;</span><span class="p">,</span>
			  <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span><span class="p">)</span><span class="n">rv_old</span><span class="o">-&gt;</span><span class="n">seq</span><span class="p">,</span> <span class="n">rv_old</span><span class="o">-&gt;</span><span class="n">nodes_count</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rv_old</span><span class="o">-&gt;</span><span class="n">nodes</span><span class="p">);</span>
		<span class="n">kfree</span><span class="p">(</span><span class="n">rv_old</span><span class="p">);</span>
	<span class="p">}</span>

	<span class="n">dlm_recoverd_kick</span><span class="p">(</span><span class="n">ls</span><span class="p">);</span>
	<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

 <span class="nl">fail:</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">rv</span><span class="p">);</span>
	<span class="n">kfree</span><span class="p">(</span><span class="n">nodes</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">error</span><span class="p">;</span>
<span class="p">}</span>

</pre></div></td></tr>

</tbody>
</table>
</div>

</body>
<script>docas={repo:"joekychen/linux",depth:2}</script>
<script>document.write('<script src=' + ('__proto__' in {} ? 'http://cdnjs.cloudflare.com/ajax/libs/zepto/1.0rc1/zepto.min.js' : 'https://ajax.googleapis.com/ajax/libs/jquery/1.7.2/jquery.min.js')+'><\\/script>')</script>
<script src="http://baoshan.github.com/moment/min/moment.min.js"></script>
<script src="../../javascript/docco.min.js"></script>
</html>
